module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd29ya2VyLWxvYWRlci9kaXN0L3dvcmtlcnMvSW5saW5lV29ya2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9ub2RlX21vZHVsZXMvd29ya2VyLWxvYWRlci9kaXN0L3dvcmtlcnMvSW5saW5lV29ya2VyLmpzPzc3ODUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMzQzOTEzL2hvdy10by1jcmVhdGUtYS13ZWItd29ya2VyLWZyb20tYS1zdHJpbmdcblxudmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBibG9iO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBCbG9iQnVpbGRlciA9IERlcHJlY2F0ZWQsIGJ1dCB3aWRlbHkgaW1wbGVtZW50ZWRcbiAgICAgICAgdmFyIEJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XG5cbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuXG4gICAgICAgIGJsb2IuYXBwZW5kKGNvbnRlbnQpO1xuXG4gICAgICAgIGJsb2IgPSBibG9iLmdldEJsb2IoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVGhlIHByb3Bvc2VkIEFQSVxuICAgICAgICBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG5ldyBXb3JrZXIoJ2RhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0lubGluZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgV29ya2VyKHVybCk7XG4gIH1cbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/worker-loader/dist/workers/InlineWorker.js\n");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, description, module, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"imjoy-rpc\\\",\\\"version\\\":\\\"0.1.17\\\",\\\"description\\\":\\\"Remote procedure calls for ImJoy.\\\",\\\"module\\\":\\\"index.js\\\",\\\"scripts\\\":{\\\"build\\\":\\\"rm -rf dist && npm run build-umd && npm run build-module\\\",\\\"build-umd\\\":\\\"webpack --config webpack.config.js --mode development --filename imjoy-rpc.js && webpack --config webpack.config.js --mode production --devtool source-map --filename imjoy-rpc.min.js\\\",\\\"build-module\\\":\\\"webpack --config webpack.config.js --mode development --libraryTarget commonjs2 --filename imjoy-rpc.module.js\\\",\\\"watch\\\":\\\"webpack --watch --progress --config webpack.config.js --mode development --libraryTarget commonjs2 --filename imjoy-rpc.module.js\\\",\\\"serve\\\":\\\"webpack-dev-server --filename imjoy-rpc.js\\\",\\\"stats\\\":\\\"webpack --profile --json > stats.json\\\",\\\"stats-prod\\\":\\\"webpack --profile --json --mode production > stats-prod.json\\\",\\\"analyze\\\":\\\"webpack-bundle-analyzer -p 9999 stats.json\\\",\\\"analyze-prod\\\":\\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\\",\\\"clean\\\":\\\"rimraf dist/*\\\",\\\"deploy\\\":\\\"npm run build && node deploy-site.js\\\",\\\"format\\\":\\\"prettier --write \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"check-format\\\":\\\"prettier --check \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"test\\\":\\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\\"},\\\"keywords\\\":[\\\"imjoy\\\",\\\"rpc\\\"],\\\"author\\\":\\\"imjoy-team <imjoy.team@gmail.com>\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/imjoy-team/imjoy-rpc/issues\\\"},\\\"homepage\\\":\\\"https://github.com/imjoy-team/imjoy-rpc\\\",\\\"dependencies\\\":{},\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.0.0-beta.39\\\",\\\"@babel/plugin-syntax-dynamic-import\\\":\\\"^7.0.0-beta.39\\\",\\\"@babel/polyfill\\\":\\\"^7.0.0-beta.39\\\",\\\"@babel/preset-env\\\":\\\"^7.0.0-beta.39\\\",\\\"@types/requirejs\\\":\\\"^2.1.28\\\",\\\"babel-core\\\":\\\"^6.26.0\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"babel-loader\\\":\\\"8.0.0-beta.2\\\",\\\"babel-runtime\\\":\\\"^6.26.0\\\",\\\"chai\\\":\\\"^4.2.0\\\",\\\"clean-webpack-plugin\\\":\\\"^0.1.19\\\",\\\"copy-webpack-plugin\\\":\\\"^5.0.5\\\",\\\"eslint\\\":\\\"^6.8.0\\\",\\\"eslint-config-prettier\\\":\\\"^4.2.0\\\",\\\"eslint-loader\\\":\\\"^4.0.2\\\",\\\"file-loader\\\":\\\"^0.11.2\\\",\\\"fs-extra\\\":\\\"^0.30.0\\\",\\\"gh-pages\\\":\\\"^2.0.1\\\",\\\"html-loader\\\":\\\"^0.5.5\\\",\\\"html-webpack-plugin\\\":\\\"^3.2.0\\\",\\\"json-loader\\\":\\\"^0.5.4\\\",\\\"karma\\\":\\\"^4.4.1\\\",\\\"karma-chrome-launcher\\\":\\\"^3.1.0\\\",\\\"karma-firefox-launcher\\\":\\\"^1.3.0\\\",\\\"karma-mocha\\\":\\\"^1.3.0\\\",\\\"karma-webpack\\\":\\\"^4.0.2\\\",\\\"lerna\\\":\\\"^3.8.0\\\",\\\"lodash.debounce\\\":\\\"^4.0.8\\\",\\\"mocha\\\":\\\"^7.1.2\\\",\\\"postcss\\\":\\\"^6.0.2\\\",\\\"prettier\\\":\\\"^1.6.1\\\",\\\"rimraf\\\":\\\"^2.6.2\\\",\\\"schema-utils\\\":\\\"^0.4.3\\\",\\\"style-loader\\\":\\\"^0.18.1\\\",\\\"url-loader\\\":\\\"^0.5.9\\\",\\\"webpack\\\":\\\"^4.0.0\\\",\\\"webpack-bundle-analyzer\\\":\\\"^3.3.2\\\",\\\"webpack-cli\\\":\\\"^3.1.2\\\",\\\"webpack-dev-server\\\":\\\"^3.1.1\\\",\\\"webpack-merge\\\":\\\"^4.1.1\\\",\\\"worker-loader\\\":\\\"^2.0.0\\\",\\\"write-file-webpack-plugin\\\":\\\"^4.5.1\\\"},\\\"eslintConfig\\\":{\\\"globals\\\":{\\\"document\\\":true,\\\"window\\\":true}}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWNrYWdlLmpzb24uanMiLCJzb3VyY2VzIjpbXSwibWFwcGluZ3MiOiIiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./package.json\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: RPC, API_VERSION, VERSION, setupBaseFrame, setupRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupBaseFrame\", function() { return setupBaseFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupRPC\", function() { return setupRPC; });\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin.webworker.js */ \"./src/plugin.webworker.js\");\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginIframe.js */ \"./src/pluginIframe.js\");\n/* harmony import */ var _pluginWebPython_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pluginWebPython.js */ \"./src/pluginWebPython.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_4__[\"RPC\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_4__[\"API_VERSION\"]; });\n\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../package.json */ \"./package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ \"./package.json\", 1);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return _package_json__WEBPACK_IMPORTED_MODULE_5__[\"version\"]; });\n\n/**\n * Contains the code executed in the sandboxed frame under web-browser\n *\n * Tries to create a Web-Worker inside the frame and set up the\n * communication between the worker and the parent window. Some\n * browsers restrict creating a worker inside a sandboxed iframe - if\n * this happens, the plugin initialized right inside the frame (in the\n * same thread)\n */\n\n\n\n\n\n\n\nfunction inIframe() {\n  try {\n    return window.self !== window.top;\n  } catch (e) {\n    return true;\n  }\n}\n\nfunction getParamValue(paramName) {\n  const url = window.location.search.substring(1); //get rid of \"?\" in querystring\n\n  const qArray = url.split(\"&\"); //get key-value pairs\n\n  for (let i = 0; i < qArray.length; i++) {\n    const pArr = qArray[i].split(\"=\"); //split key and value\n\n    if (pArr[0] === paramName) return pArr[1]; //return value\n  }\n}\n/**\n * Initializes the plugin inside a web worker. May throw an exception\n * in case this was not permitted by the browser.\n */\n\n\nfunction setupWebWorker(config) {\n  if (!config.allow_execution) throw new Error(\"web-worker plugin can only work with allow_execution=true\");\n  const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a(); // mixed content warning in Chrome silently skips worker\n  // initialization without exception, handling this with timeout\n\n  const fallbackTimeout = setTimeout(function () {\n    worker.terminate();\n    console.warn(`Plugin failed to start as a web-worker, running in an iframe instead.`);\n    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n  }, 2000); // forwarding messages between the worker and parent window\n\n  worker.addEventListener(\"message\", function (e) {\n    let transferables = undefined;\n    const m = e.data;\n\n    if (m.type === \"initialized\") {\n      // send config to the worker\n      worker.postMessage({\n        type: \"connectRPC\",\n        config: config\n      });\n      clearTimeout(fallbackTimeout); // complete the missing fields\n\n      m.config = Object.assign({}, config, m.config);\n    } else if (m.type === \"imjoy_remote_api_ready\") {\n      // if it's a webworker, there will be no api object returned\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: null\n      }));\n    } else if (m.type === \"cacheRequirements\" && typeof cache_requirements === \"function\") {\n      cache_requirements(m.requirements);\n    } else if (m.type === \"disconnect\") {\n      worker.terminate();\n    } else {\n      if (m.__transferables__) {\n        transferables = m.__transferables__;\n        delete m.__transferables__;\n      }\n    }\n\n    parent.postMessage(m, \"*\", transferables);\n  });\n  window.addEventListener(\"message\", function (e) {\n    let transferables = undefined;\n    const m = e.data;\n\n    if (m.__transferables__) {\n      transferables = m.__transferables__;\n      delete m.__transferables__;\n    }\n\n    worker.postMessage(m, transferables);\n  });\n}\n\nasync function setupBaseFrame(config) {\n  config = config || {};\n  config.name = config.name || \"Generic RPC App\";\n  config.type = config.type || getParamValue(\"_plugin_type\") || \"window\";\n  config.allow_execution = config.allow_execution || true;\n  config.enable_service_worker = config.enable_service_worker || true;\n\n  if (config.enable_service_worker) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"setupServiceWorker\"])(config.target_origin, config.cache_requirements);\n  }\n\n  if (config.cache_requirements) {\n    delete config.cache_requirements;\n  }\n\n  config.forwarding_functions = config.forwarding_functions;\n\n  if (config.forwarding_functions === undefined) {\n    config.forwarding_functions = [\"close\", \"on\", \"off\", \"emit\"];\n\n    if ([\"rpc-window\", \"window\", \"web-python-window\"].includes(config.type)) {\n      config.forwarding_functions = config.forwarding_functions.concat([\"resize\", \"show\", \"hide\", \"refresh\"]);\n    }\n  } // expose the api object to window globally.\n  // note: the returned value will be null for webworker\n\n\n  window.api = await imjoyRPC.setupRPC(config);\n  return window.api;\n}\nfunction setupRPC(config) {\n  config = config || {};\n  if (!config.name) throw new Error(\"Please specify a name for your app.\");\n  config.version = config.version || \"0.1.0\";\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"randId\"])();\n  config.allow_execution = config.allow_execution || false;\n  config.token = config.token || Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"randId\"])(); // remove functions\n\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return new Promise((resolve, reject) => {\n    if (inIframe()) {\n      if (config.type === \"web-worker\") {\n        try {\n          setupWebWorker(config);\n        } catch (e) {\n          // fallback to iframe\n          Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n        }\n      } else if (config.type === \"web-python\" || config.type === \"web-python-window\") {\n        Object(_pluginWebPython_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(config);\n      } else if ([\"rpc-window\", \"rpc-worker\", \"iframe\", \"window\"].includes(config.type)) {\n        Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n      } else {\n        console.error(\"Unsupported plugin type: \" + config.type);\n        reject(\"Unsupported plugin type: \" + config.type);\n      }\n\n      try {\n        window.addEventListener(\"imjoy_remote_api_ready\", e => {\n          // imjoy plugin api\n          resolve(e.detail);\n        });\n      } catch (e) {\n        reject(e);\n      }\n    } else {\n      reject(new Error(\"imjoy-rpc should only run inside an iframe.\"));\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDL3NyYy9tYWluLmpzPzJlZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyB0aGUgY29kZSBleGVjdXRlZCBpbiB0aGUgc2FuZGJveGVkIGZyYW1lIHVuZGVyIHdlYi1icm93c2VyXG4gKlxuICogVHJpZXMgdG8gY3JlYXRlIGEgV2ViLVdvcmtlciBpbnNpZGUgdGhlIGZyYW1lIGFuZCBzZXQgdXAgdGhlXG4gKiBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIHdvcmtlciBhbmQgdGhlIHBhcmVudCB3aW5kb3cuIFNvbWVcbiAqIGJyb3dzZXJzIHJlc3RyaWN0IGNyZWF0aW5nIGEgd29ya2VyIGluc2lkZSBhIHNhbmRib3hlZCBpZnJhbWUgLSBpZlxuICogdGhpcyBoYXBwZW5zLCB0aGUgcGx1Z2luIGluaXRpYWxpemVkIHJpZ2h0IGluc2lkZSB0aGUgZnJhbWUgKGluIHRoZVxuICogc2FtZSB0aHJlYWQpXG4gKi9cbmltcG9ydCBQbHVnaW5Xb3JrZXIgZnJvbSBcIi4vcGx1Z2luLndlYndvcmtlci5qc1wiO1xuaW1wb3J0IHNldHVwSWZyYW1lIGZyb20gXCIuL3BsdWdpbklmcmFtZS5qc1wiO1xuaW1wb3J0IHNldHVwV2ViUHl0aG9uIGZyb20gXCIuL3BsdWdpbldlYlB5dGhvbi5qc1wiO1xuaW1wb3J0IHsgc2V0dXBTZXJ2aWNlV29ya2VyLCByYW5kSWQgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuXG5leHBvcnQgeyBSUEMsIEFQSV9WRVJTSU9OIH0gZnJvbSBcIi4vcnBjLmpzXCI7XG5leHBvcnQgeyB2ZXJzaW9uIGFzIFZFUlNJT04gfSBmcm9tIFwiLi4vcGFja2FnZS5qc29uXCI7XG5cbmZ1bmN0aW9uIGluSWZyYW1lKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtVmFsdWUocGFyYW1OYW1lKSB7XG4gIGNvbnN0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpOyAvL2dldCByaWQgb2YgXCI/XCIgaW4gcXVlcnlzdHJpbmdcbiAgY29uc3QgcUFycmF5ID0gdXJsLnNwbGl0KFwiJlwiKTsgLy9nZXQga2V5LXZhbHVlIHBhaXJzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcEFyciA9IHFBcnJheVtpXS5zcGxpdChcIj1cIik7IC8vc3BsaXQga2V5IGFuZCB2YWx1ZVxuICAgIGlmIChwQXJyWzBdID09PSBwYXJhbU5hbWUpIHJldHVybiBwQXJyWzFdOyAvL3JldHVybiB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBpbnNpZGUgYSB3ZWIgd29ya2VyLiBNYXkgdGhyb3cgYW4gZXhjZXB0aW9uXG4gKiBpbiBjYXNlIHRoaXMgd2FzIG5vdCBwZXJtaXR0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gKi9cbmZ1bmN0aW9uIHNldHVwV2ViV29ya2VyKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZy5hbGxvd19leGVjdXRpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJ3ZWItd29ya2VyIHBsdWdpbiBjYW4gb25seSB3b3JrIHdpdGggYWxsb3dfZXhlY3V0aW9uPXRydWVcIlxuICAgICk7XG4gIGNvbnN0IHdvcmtlciA9IG5ldyBQbHVnaW5Xb3JrZXIoKTtcbiAgLy8gbWl4ZWQgY29udGVudCB3YXJuaW5nIGluIENocm9tZSBzaWxlbnRseSBza2lwcyB3b3JrZXJcbiAgLy8gaW5pdGlhbGl6YXRpb24gd2l0aG91dCBleGNlcHRpb24sIGhhbmRsaW5nIHRoaXMgd2l0aCB0aW1lb3V0XG4gIGNvbnN0IGZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBQbHVnaW4gZmFpbGVkIHRvIHN0YXJ0IGFzIGEgd2ViLXdvcmtlciwgcnVubmluZyBpbiBhbiBpZnJhbWUgaW5zdGVhZC5gXG4gICAgKTtcbiAgICBzZXR1cElmcmFtZShjb25maWcpO1xuICB9LCAyMDAwKTtcblxuICAvLyBmb3J3YXJkaW5nIG1lc3NhZ2VzIGJldHdlZW4gdGhlIHdvcmtlciBhbmQgcGFyZW50IHdpbmRvd1xuICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgIGxldCB0cmFuc2ZlcmFibGVzID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG0gPSBlLmRhdGE7XG4gICAgaWYgKG0udHlwZSA9PT0gXCJpbml0aWFsaXplZFwiKSB7XG4gICAgICAvLyBzZW5kIGNvbmZpZyB0byB0aGUgd29ya2VyXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImNvbm5lY3RSUENcIiwgY29uZmlnOiBjb25maWcgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoZmFsbGJhY2tUaW1lb3V0KTtcbiAgICAgIC8vIGNvbXBsZXRlIHRoZSBtaXNzaW5nIGZpZWxkc1xuICAgICAgbS5jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIG0uY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKG0udHlwZSA9PT0gXCJpbWpveV9yZW1vdGVfYXBpX3JlYWR5XCIpIHtcbiAgICAgIC8vIGlmIGl0J3MgYSB3ZWJ3b3JrZXIsIHRoZXJlIHdpbGwgYmUgbm8gYXBpIG9iamVjdCByZXR1cm5lZFxuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudChcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIiwgeyBkZXRhaWw6IG51bGwgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG0udHlwZSA9PT0gXCJjYWNoZVJlcXVpcmVtZW50c1wiICYmXG4gICAgICB0eXBlb2YgY2FjaGVfcmVxdWlyZW1lbnRzID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgIGNhY2hlX3JlcXVpcmVtZW50cyhtLnJlcXVpcmVtZW50cyk7XG4gICAgfSBlbHNlIGlmIChtLnR5cGUgPT09IFwiZGlzY29ubmVjdFwiKSB7XG4gICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtLl9fdHJhbnNmZXJhYmxlc19fKSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZXMgPSBtLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICBkZWxldGUgbS5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgIH1cbiAgICB9XG4gICAgcGFyZW50LnBvc3RNZXNzYWdlKG0sIFwiKlwiLCB0cmFuc2ZlcmFibGVzKTtcbiAgfSk7XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICBsZXQgdHJhbnNmZXJhYmxlcyA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtID0gZS5kYXRhO1xuICAgIGlmIChtLl9fdHJhbnNmZXJhYmxlc19fKSB7XG4gICAgICB0cmFuc2ZlcmFibGVzID0gbS5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgIGRlbGV0ZSBtLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgIH1cbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UobSwgdHJhbnNmZXJhYmxlcyk7XG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBCYXNlRnJhbWUoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgY29uZmlnLm5hbWUgPSBjb25maWcubmFtZSB8fCBcIkdlbmVyaWMgUlBDIEFwcFwiO1xuICBjb25maWcudHlwZSA9IGNvbmZpZy50eXBlIHx8IGdldFBhcmFtVmFsdWUoXCJfcGx1Z2luX3R5cGVcIikgfHwgXCJ3aW5kb3dcIjtcbiAgY29uZmlnLmFsbG93X2V4ZWN1dGlvbiA9IGNvbmZpZy5hbGxvd19leGVjdXRpb24gfHwgdHJ1ZTtcbiAgY29uZmlnLmVuYWJsZV9zZXJ2aWNlX3dvcmtlciA9IGNvbmZpZy5lbmFibGVfc2VydmljZV93b3JrZXIgfHwgdHJ1ZTtcbiAgaWYgKGNvbmZpZy5lbmFibGVfc2VydmljZV93b3JrZXIpIHtcbiAgICBzZXR1cFNlcnZpY2VXb3JrZXIoY29uZmlnLnRhcmdldF9vcmlnaW4sIGNvbmZpZy5jYWNoZV9yZXF1aXJlbWVudHMpO1xuICB9XG4gIGlmIChjb25maWcuY2FjaGVfcmVxdWlyZW1lbnRzKSB7XG4gICAgZGVsZXRlIGNvbmZpZy5jYWNoZV9yZXF1aXJlbWVudHM7XG4gIH1cbiAgY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zID0gY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zO1xuICBpZiAoY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnMgPSBbXCJjbG9zZVwiLCBcIm9uXCIsIFwib2ZmXCIsIFwiZW1pdFwiXTtcbiAgICBpZiAoW1wicnBjLXdpbmRvd1wiLCBcIndpbmRvd1wiLCBcIndlYi1weXRob24td2luZG93XCJdLmluY2x1ZGVzKGNvbmZpZy50eXBlKSkge1xuICAgICAgY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zID0gY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zLmNvbmNhdChbXG4gICAgICAgIFwicmVzaXplXCIsXG4gICAgICAgIFwic2hvd1wiLFxuICAgICAgICBcImhpZGVcIixcbiAgICAgICAgXCJyZWZyZXNoXCJcbiAgICAgIF0pO1xuICAgIH1cbiAgfVxuICAvLyBleHBvc2UgdGhlIGFwaSBvYmplY3QgdG8gd2luZG93IGdsb2JhbGx5LlxuICAvLyBub3RlOiB0aGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBudWxsIGZvciB3ZWJ3b3JrZXJcbiAgd2luZG93LmFwaSA9IGF3YWl0IGltam95UlBDLnNldHVwUlBDKGNvbmZpZyk7XG4gIHJldHVybiB3aW5kb3cuYXBpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBSUEMoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgaWYgKCFjb25maWcubmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgYSBuYW1lIGZvciB5b3VyIGFwcC5cIik7XG4gIGNvbmZpZy52ZXJzaW9uID0gY29uZmlnLnZlcnNpb24gfHwgXCIwLjEuMFwiO1xuICBjb25maWcuZGVzY3JpcHRpb24gPVxuICAgIGNvbmZpZy5kZXNjcmlwdGlvbiB8fCBgW1RPRE86IGFkZCBkZXNjcmlwdGlvbiBmb3IgJHtjb25maWcubmFtZX0gXWA7XG4gIGNvbmZpZy50eXBlID0gY29uZmlnLnR5cGUgfHwgXCJycGMtd2luZG93XCI7XG4gIGNvbmZpZy5pZCA9IGNvbmZpZy5pZCB8fCByYW5kSWQoKTtcbiAgY29uZmlnLmFsbG93X2V4ZWN1dGlvbiA9IGNvbmZpZy5hbGxvd19leGVjdXRpb24gfHwgZmFsc2U7XG4gIGNvbmZpZy50b2tlbiA9IGNvbmZpZy50b2tlbiB8fCByYW5kSWQoKTtcbiAgLy8gcmVtb3ZlIGZ1bmN0aW9uc1xuICBjb25maWcgPSBPYmplY3Qua2V5cyhjb25maWcpLnJlZHVjZSgocCwgYykgPT4ge1xuICAgIGlmICh0eXBlb2YgY29uZmlnW2NdICE9PSBcImZ1bmN0aW9uXCIpIHBbY10gPSBjb25maWdbY107XG4gICAgcmV0dXJuIHA7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoaW5JZnJhbWUoKSkge1xuICAgICAgaWYgKGNvbmZpZy50eXBlID09PSBcIndlYi13b3JrZXJcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldHVwV2ViV29ya2VyKGNvbmZpZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBmYWxsYmFjayB0byBpZnJhbWVcbiAgICAgICAgICBzZXR1cElmcmFtZShjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBjb25maWcudHlwZSA9PT0gXCJ3ZWItcHl0aG9uXCIgfHxcbiAgICAgICAgY29uZmlnLnR5cGUgPT09IFwid2ViLXB5dGhvbi13aW5kb3dcIlxuICAgICAgKSB7XG4gICAgICAgIHNldHVwV2ViUHl0aG9uKGNvbmZpZyk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBbXCJycGMtd2luZG93XCIsIFwicnBjLXdvcmtlclwiLCBcImlmcmFtZVwiLCBcIndpbmRvd1wiXS5pbmNsdWRlcyhjb25maWcudHlwZSlcbiAgICAgICkge1xuICAgICAgICBzZXR1cElmcmFtZShjb25maWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuc3VwcG9ydGVkIHBsdWdpbiB0eXBlOiBcIiArIGNvbmZpZy50eXBlKTtcbiAgICAgICAgcmVqZWN0KFwiVW5zdXBwb3J0ZWQgcGx1Z2luIHR5cGU6IFwiICsgY29uZmlnLnR5cGUpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJpbWpveV9yZW1vdGVfYXBpX3JlYWR5XCIsIGUgPT4ge1xuICAgICAgICAgIC8vIGltam95IHBsdWdpbiBhcGlcbiAgICAgICAgICByZXNvbHZlKGUuZGV0YWlsKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImltam95LXJwYyBzaG91bGQgb25seSBydW4gaW5zaWRlIGFuIGlmcmFtZS5cIikpO1xuICAgIH1cbiAgfSk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./src/plugin.webworker.js":
/*!*********************************!*\
  !*** ./src/plugin.webworker.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function() {\n  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/plugin.webworker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./src/plugin.webworker.js\\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \\\\\\\"./src/pluginCore.js\\\\\\\");\\\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \\\\\\\"./src/rpc.js\\\\\\\");\\\\n/**\\\\n * Contains the routines loaded by the plugin Worker under web-browser.\\\\n *\\\\n * Initializes the web environment version of the platform-dependent\\\\n * connection object for the plugin site\\\\n */\\\\n\\\\n\\\\n\\\\n(function() {\\\\n  // make sure this runs inside a webworker\\\\n  if (\\\\n    typeof WorkerGlobalScope === \\\\\\\"undefined\\\\\\\" ||\\\\n    !self ||\\\\n    !(self instanceof WorkerGlobalScope)\\\\n  ) {\\\\n    throw new Error(\\\\\\\"This script can only loaded in a webworker\\\\\\\");\\\\n  }\\\\n  /**\\\\n   * Executes the given code in a jailed environment. For web\\\\n   * implementation, we're already jailed in the iframe and the\\\\n   * worker, so simply eval()\\\\n   *\\\\n   * @param {String} code code to execute\\\\n   */\\\\n  var execute = function(code) {\\\\n    try {\\\\n      if (code.type === \\\\\\\"requirements\\\\\\\") {\\\\n        try {\\\\n          if (\\\\n            code.requirements &&\\\\n            (Array.isArray(code.requirements) ||\\\\n              typeof code.requirements === \\\\\\\"string\\\\\\\")\\\\n          ) {\\\\n            try {\\\\n              if (!Array.isArray(code.requirements)) {\\\\n                code.requirements = [code.requirements];\\\\n              }\\\\n              for (var i = 0; i < code.requirements.length; i++) {\\\\n                if (\\\\n                  code.requirements[i].toLowerCase().endsWith(\\\\\\\".css\\\\\\\") ||\\\\n                  code.requirements[i].startsWith(\\\\\\\"css:\\\\\\\")\\\\n                ) {\\\\n                  throw \\\\\\\"unable to import css in a webworker\\\\\\\";\\\\n                } else if (\\\\n                  code.requirements[i].toLowerCase().endsWith(\\\\\\\".js\\\\\\\") ||\\\\n                  code.requirements[i].startsWith(\\\\\\\"js:\\\\\\\")\\\\n                ) {\\\\n                  if (code.requirements[i].startsWith(\\\\\\\"js:\\\\\\\")) {\\\\n                    code.requirements[i] = code.requirements[i].slice(3);\\\\n                  }\\\\n                  importScripts(code.requirements[i]);\\\\n                } else if (code.requirements[i].startsWith(\\\\\\\"http\\\\\\\")) {\\\\n                  importScripts(code.requirements[i]);\\\\n                } else if (code.requirements[i].startsWith(\\\\\\\"cache:\\\\\\\")) {\\\\n                  //ignore cache\\\\n                } else {\\\\n                  console.log(\\\\n                    \\\\\\\"Unprocessed requirements url: \\\\\\\" + code.requirements[i]\\\\n                  );\\\\n                }\\\\n              }\\\\n            } catch (e) {\\\\n              throw \\\\\\\"failed to import required scripts: \\\\\\\" +\\\\n                code.requirements.toString();\\\\n            }\\\\n          }\\\\n        } catch (e) {\\\\n          throw e;\\\\n        }\\\\n      } else if (code.type === \\\\\\\"script\\\\\\\") {\\\\n        try {\\\\n          if (\\\\n            code.requirements &&\\\\n            (Array.isArray(code.requirements) ||\\\\n              typeof code.requirements === \\\\\\\"string\\\\\\\")\\\\n          ) {\\\\n            try {\\\\n              if (Array.isArray(code.requirements)) {\\\\n                for (let i = 0; i < code.requirements.length; i++) {\\\\n                  importScripts(code.requirements[i]);\\\\n                }\\\\n              } else {\\\\n                importScripts(code.requirements);\\\\n              }\\\\n            } catch (e) {\\\\n              throw \\\\\\\"failed to import required scripts: \\\\\\\" +\\\\n                code.requirements.toString();\\\\n            }\\\\n          }\\\\n          eval(code.content);\\\\n        } catch (e) {\\\\n          console.error(e.message, e.stack);\\\\n          throw e;\\\\n        }\\\\n      } else {\\\\n        throw \\\\\\\"unsupported code type.\\\\\\\";\\\\n      }\\\\n      self.postMessage({ type: \\\\\\\"executeSuccess\\\\\\\" });\\\\n    } catch (e) {\\\\n      console.error(\\\\\\\"failed to execute scripts: \\\\\\\", code, e);\\\\n      self.postMessage({ type: \\\\\\\"executeFailure\\\\\\\", error: e.stack || String(e) });\\\\n    }\\\\n  };\\\\n\\\\n  /**\\\\n   * Connection object provided to the RPC constructor,\\\\n   * plugin site implementation for the web-based environment.\\\\n   * Global will be then cleared to prevent exposure into the\\\\n   * Worker, so we put this local connection object into a closure\\\\n   */\\\\n  const conn = {\\\\n    disconnect: function() {\\\\n      self.close();\\\\n    },\\\\n    send: function(data, transferables) {\\\\n      data.__transferables__ = transferables;\\\\n      self.postMessage(data, transferables);\\\\n    },\\\\n    onMessage: function(h) {\\\\n      conn._messageHandler = h;\\\\n    },\\\\n    _messageHandler: function() {},\\\\n    onDisconnect: function() {}\\\\n  };\\\\n\\\\n  const config = {\\\\n    type: \\\\\\\"web-worker\\\\\\\",\\\\n    dedicated_thread: true,\\\\n    allow_execution: true,\\\\n    lang: \\\\\\\"javascript\\\\\\\",\\\\n    api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\\\\\\\"API_VERSION\\\\\\\"]\\\\n  };\\\\n\\\\n  /**\\\\n   * Event lisener for the plugin message\\\\n   */\\\\n  self.addEventListener(\\\\\\\"message\\\\\\\", function(e) {\\\\n    const m = e.data;\\\\n    switch (m && m.type) {\\\\n      case \\\\\\\"getConfig\\\\\\\":\\\\n        self.postMessage({\\\\n          type: \\\\\\\"config\\\\\\\",\\\\n          config: config\\\\n        });\\\\n        break;\\\\n      case \\\\\\\"execute\\\\\\\":\\\\n        execute(m.code);\\\\n        if (m.code.type === \\\\\\\"requirements\\\\\\\") {\\\\n          if (!Array.isArray(m.code.requirements)) {\\\\n            m.code.requirements = [m.code.requirements];\\\\n          }\\\\n          self.postMessage({\\\\n            type: \\\\\\\"cacheRequirements\\\\\\\",\\\\n            requirements: m.code.requirements\\\\n          });\\\\n        }\\\\n        break;\\\\n      // for webworker only\\\\n      case \\\\\\\"connectRPC\\\\\\\":\\\\n        Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"connectRPC\\\\\\\"])(conn, m.config);\\\\n        break;\\\\n      default:\\\\n        conn._messageHandler(m);\\\\n    }\\\\n  });\\\\n  self.postMessage({\\\\n    type: \\\\\\\"initialized\\\\\\\",\\\\n    config: config\\\\n  });\\\\n})();\\\\n//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luLndlYndvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanM/OGM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRhaW5zIHRoZSByb3V0aW5lcyBsb2FkZWQgYnkgdGhlIHBsdWdpbiBXb3JrZXIgdW5kZXIgd2ViLWJyb3dzZXIuXG4gKlxuICogSW5pdGlhbGl6ZXMgdGhlIHdlYiBlbnZpcm9ubWVudCB2ZXJzaW9uIG9mIHRoZSBwbGF0Zm9ybS1kZXBlbmRlbnRcbiAqIGNvbm5lY3Rpb24gb2JqZWN0IGZvciB0aGUgcGx1Z2luIHNpdGVcbiAqL1xuaW1wb3J0IHsgY29ubmVjdFJQQyB9IGZyb20gXCIuL3BsdWdpbkNvcmUuanNcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OIH0gZnJvbSBcIi4vcnBjLmpzXCI7XG5cbihmdW5jdGlvbigpIHtcbiAgLy8gbWFrZSBzdXJlIHRoaXMgcnVucyBpbnNpZGUgYSB3ZWJ3b3JrZXJcbiAgaWYgKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICFzZWxmIHx8XG4gICAgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2NyaXB0IGNhbiBvbmx5IGxvYWRlZCBpbiBhIHdlYndvcmtlclwiKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGdpdmVuIGNvZGUgaW4gYSBqYWlsZWQgZW52aXJvbm1lbnQuIEZvciB3ZWJcbiAgICogaW1wbGVtZW50YXRpb24sIHdlJ3JlIGFscmVhZHkgamFpbGVkIGluIHRoZSBpZnJhbWUgYW5kIHRoZVxuICAgKiB3b3JrZXIsIHNvIHNpbXBseSBldmFsKClcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgY29kZSB0byBleGVjdXRlXG4gICAqL1xuICB2YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGNvZGUudHlwZSA9PT0gXCJyZXF1aXJlbWVudHNcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzICYmXG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShjb2RlLnJlcXVpcmVtZW50cykgfHxcbiAgICAgICAgICAgICAgdHlwZW9mIGNvZGUucmVxdWlyZW1lbnRzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzID0gW2NvZGUucmVxdWlyZW1lbnRzXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGUucmVxdWlyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcIi5jc3NcIikgfHxcbiAgICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJjc3M6XCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBcInVuYWJsZSB0byBpbXBvcnQgY3NzIGluIGEgd2Vid29ya2VyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoXCIuanNcIikgfHxcbiAgICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJqczpcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwianM6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldID0gY29kZS5yZXF1aXJlbWVudHNbaV0uc2xpY2UoMyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbXBvcnRTY3JpcHRzKGNvZGUucmVxdWlyZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgICAgICAgICAgICBpbXBvcnRTY3JpcHRzKGNvZGUucmVxdWlyZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJjYWNoZTpcIikpIHtcbiAgICAgICAgICAgICAgICAgIC8vaWdub3JlIGNhY2hlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICBcIlVucHJvY2Vzc2VkIHJlcXVpcmVtZW50cyB1cmw6IFwiICsgY29kZS5yZXF1aXJlbWVudHNbaV1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiZmFpbGVkIHRvIGltcG9ydCByZXF1aXJlZCBzY3JpcHRzOiBcIiArXG4gICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUudHlwZSA9PT0gXCJzY3JpcHRcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzICYmXG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShjb2RlLnJlcXVpcmVtZW50cykgfHxcbiAgICAgICAgICAgICAgdHlwZW9mIGNvZGUucmVxdWlyZW1lbnRzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlLnJlcXVpcmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiZmFpbGVkIHRvIGltcG9ydCByZXF1aXJlZCBzY3JpcHRzOiBcIiArXG4gICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXZhbChjb2RlLmNvbnRlbnQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlLm1lc3NhZ2UsIGUuc3RhY2spO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgY29kZSB0eXBlLlwiO1xuICAgICAgfVxuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXhlY3V0ZVN1Y2Nlc3NcIiB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIGV4ZWN1dGUgc2NyaXB0czogXCIsIGNvZGUsIGUpO1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXhlY3V0ZUZhaWx1cmVcIiwgZXJyb3I6IGUuc3RhY2sgfHwgU3RyaW5nKGUpIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29ubmVjdGlvbiBvYmplY3QgcHJvdmlkZWQgdG8gdGhlIFJQQyBjb25zdHJ1Y3RvcixcbiAgICogcGx1Z2luIHNpdGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSB3ZWItYmFzZWQgZW52aXJvbm1lbnQuXG4gICAqIEdsb2JhbCB3aWxsIGJlIHRoZW4gY2xlYXJlZCB0byBwcmV2ZW50IGV4cG9zdXJlIGludG8gdGhlXG4gICAqIFdvcmtlciwgc28gd2UgcHV0IHRoaXMgbG9jYWwgY29ubmVjdGlvbiBvYmplY3QgaW50byBhIGNsb3N1cmVcbiAgICovXG4gIGNvbnN0IGNvbm4gPSB7XG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSxcbiAgICBzZW5kOiBmdW5jdGlvbihkYXRhLCB0cmFuc2ZlcmFibGVzKSB7XG4gICAgICBkYXRhLl9fdHJhbnNmZXJhYmxlc19fID0gdHJhbnNmZXJhYmxlcztcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJhYmxlcyk7XG4gICAgfSxcbiAgICBvbk1lc3NhZ2U6IGZ1bmN0aW9uKGgpIHtcbiAgICAgIGNvbm4uX21lc3NhZ2VIYW5kbGVyID0gaDtcbiAgICB9LFxuICAgIF9tZXNzYWdlSGFuZGxlcjogZnVuY3Rpb24oKSB7fSxcbiAgICBvbkRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge31cbiAgfTtcblxuICBjb25zdCBjb25maWcgPSB7XG4gICAgdHlwZTogXCJ3ZWItd29ya2VyXCIsXG4gICAgZGVkaWNhdGVkX3RocmVhZDogdHJ1ZSxcbiAgICBhbGxvd19leGVjdXRpb246IHRydWUsXG4gICAgbGFuZzogXCJqYXZhc2NyaXB0XCIsXG4gICAgYXBpX3ZlcnNpb246IEFQSV9WRVJTSU9OXG4gIH07XG5cbiAgLyoqXG4gICAqIEV2ZW50IGxpc2VuZXIgZm9yIHRoZSBwbHVnaW4gbWVzc2FnZVxuICAgKi9cbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgbSA9IGUuZGF0YTtcbiAgICBzd2l0Y2ggKG0gJiYgbS50eXBlKSB7XG4gICAgICBjYXNlIFwiZ2V0Q29uZmlnXCI6XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFwiY29uZmlnXCIsXG4gICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImV4ZWN1dGVcIjpcbiAgICAgICAgZXhlY3V0ZShtLmNvZGUpO1xuICAgICAgICBpZiAobS5jb2RlLnR5cGUgPT09IFwicmVxdWlyZW1lbnRzXCIpIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobS5jb2RlLnJlcXVpcmVtZW50cykpIHtcbiAgICAgICAgICAgIG0uY29kZS5yZXF1aXJlbWVudHMgPSBbbS5jb2RlLnJlcXVpcmVtZW50c107XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJjYWNoZVJlcXVpcmVtZW50c1wiLFxuICAgICAgICAgICAgcmVxdWlyZW1lbnRzOiBtLmNvZGUucmVxdWlyZW1lbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBmb3Igd2Vid29ya2VyIG9ubHlcbiAgICAgIGNhc2UgXCJjb25uZWN0UlBDXCI6XG4gICAgICAgIGNvbm5lY3RSUEMoY29ubiwgbS5jb25maWcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbm4uX21lc3NhZ2VIYW5kbGVyKG0pO1xuICAgIH1cbiAgfSk7XG4gIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgIHR5cGU6IFwiaW5pdGlhbGl6ZWRcIixcbiAgICBjb25maWc6IGNvbmZpZ1xuICB9KTtcbn0pKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\\\n//# sourceURL=webpack-internal:///./src/plugin.webworker.js\\\\n\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/pluginCore.js\\\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"connectRPC\\\\\\\", function() { return connectRPC; });\\\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \\\\\\\"./src/rpc.js\\\\\\\");\\\\n/**\\\\n * Core plugin script loaded into the plugin process/thread.\\\\n *\\\\n * Initializes the plugin-site API global methods.\\\\n */\\\\n\\\\nfunction connectRPC(connection, config) {\\\\n  const application = {};\\\\n  config = config || {};\\\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"RPC\\\\\\\"](connection, config);\\\\n  rpc.onGetInterface(function () {\\\\n    launchConnected();\\\\n  });\\\\n  rpc.onRemoteUpdate(function () {\\\\n    application.remote = rpc.getRemote();\\\\n    if (!application.remote) return;\\\\n    const api = application.remote || {};\\\\n\\\\n    if (api.export) {\\\\n      console.error(\\\\\\\"WARNING: overwriting function 'export'.\\\\\\\");\\\\n    }\\\\n\\\\n    if (api.onload) {\\\\n      console.error(\\\\\\\"WARNING: overwriting function 'onload'.\\\\\\\");\\\\n    }\\\\n\\\\n    if (api.dispose) {\\\\n      console.error(\\\\\\\"WARNING: overwriting function 'dispose'.\\\\\\\");\\\\n    }\\\\n\\\\n    api.export = application.setInterface;\\\\n    api.onLoad = application.whenConnected;\\\\n    api.dispose = application.disconnect;\\\\n\\\\n    if (typeof WorkerGlobalScope !== \\\\\\\"undefined\\\\\\\" && self instanceof WorkerGlobalScope) {\\\\n      self.api = api;\\\\n      self.postMessage({\\\\n        type: \\\\\\\"imjoy_remote_api_ready\\\\\\\"\\\\n      });\\\\n    } else if (typeof window) {\\\\n      window.dispatchEvent(new CustomEvent(\\\\\\\"imjoy_remote_api_ready\\\\\\\", {\\\\n        detail: api\\\\n      }));\\\\n    }\\\\n  });\\\\n  var connected = false;\\\\n  var connectedHandlers = [];\\\\n\\\\n  var launchConnected = function () {\\\\n    if (!connected) {\\\\n      connected = true;\\\\n      var handler;\\\\n\\\\n      while (handler = connectedHandlers.pop()) {\\\\n        handler();\\\\n      }\\\\n    }\\\\n  };\\\\n\\\\n  var checkHandler = function (handler) {\\\\n    var type = typeof handler;\\\\n\\\\n    if (type !== \\\\\\\"function\\\\\\\") {\\\\n      var msg = \\\\\\\"A function may only be subsribed to the event, \\\\\\\" + type + \\\\\\\" was provided instead\\\\\\\";\\\\n      throw new Error(msg);\\\\n    }\\\\n\\\\n    return handler;\\\\n  };\\\\n  /**\\\\n   * Sets a function executed after the connection to the\\\\n   * application is estaplished, and the initial interface-exchange\\\\n   * messaging is completed\\\\n   *\\\\n   * @param {Function} handler to be called upon initialization\\\\n   */\\\\n\\\\n\\\\n  application.whenConnected = function (handler) {\\\\n    handler = checkHandler(handler);\\\\n\\\\n    if (connected) {\\\\n      handler();\\\\n    } else {\\\\n      connectedHandlers.push(handler);\\\\n    }\\\\n  };\\\\n  /**\\\\n   * Sets the plugin interface available to the application\\\\n   *\\\\n   * @param {Object} _interface to set\\\\n   */\\\\n\\\\n\\\\n  application.setInterface = function (_interface) {\\\\n    rpc.setInterface(_interface);\\\\n  };\\\\n  /**\\\\n   * Disconnects the plugin from the application (sending\\\\n   * notification message) and destroys itself\\\\n   */\\\\n\\\\n\\\\n  application.disconnect = function (_interface) {\\\\n    rpc.disconnect();\\\\n  };\\\\n}//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luQ29yZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDL3NyYy9wbHVnaW5Db3JlLmpzP2E0NzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3JlIHBsdWdpbiBzY3JpcHQgbG9hZGVkIGludG8gdGhlIHBsdWdpbiBwcm9jZXNzL3RocmVhZC5cbiAqXG4gKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luLXNpdGUgQVBJIGdsb2JhbCBtZXRob2RzLlxuICovXG5pbXBvcnQgeyBSUEMgfSBmcm9tIFwiLi9ycGMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3RSUEMoY29ubmVjdGlvbiwgY29uZmlnKSB7XG4gIGNvbnN0IGFwcGxpY2F0aW9uID0ge307XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICBjb25zdCBycGMgPSBuZXcgUlBDKGNvbm5lY3Rpb24sIGNvbmZpZyk7XG4gIHJwYy5vbkdldEludGVyZmFjZShmdW5jdGlvbigpIHtcbiAgICBsYXVuY2hDb25uZWN0ZWQoKTtcbiAgfSk7XG5cbiAgcnBjLm9uUmVtb3RlVXBkYXRlKGZ1bmN0aW9uKCkge1xuICAgIGFwcGxpY2F0aW9uLnJlbW90ZSA9IHJwYy5nZXRSZW1vdGUoKTtcbiAgICBpZiAoIWFwcGxpY2F0aW9uLnJlbW90ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGFwaSA9IGFwcGxpY2F0aW9uLnJlbW90ZSB8fCB7fTtcbiAgICBpZiAoYXBpLmV4cG9ydCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIldBUk5JTkc6IG92ZXJ3cml0aW5nIGZ1bmN0aW9uICdleHBvcnQnLlwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5vbmxvYWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJXQVJOSU5HOiBvdmVyd3JpdGluZyBmdW5jdGlvbiAnb25sb2FkJy5cIik7XG4gICAgfVxuICAgIGlmIChhcGkuZGlzcG9zZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIldBUk5JTkc6IG92ZXJ3cml0aW5nIGZ1bmN0aW9uICdkaXNwb3NlJy5cIik7XG4gICAgfVxuICAgIGFwaS5leHBvcnQgPSBhcHBsaWNhdGlvbi5zZXRJbnRlcmZhY2U7XG4gICAgYXBpLm9uTG9hZCA9IGFwcGxpY2F0aW9uLndoZW5Db25uZWN0ZWQ7XG4gICAgYXBpLmRpc3Bvc2UgPSBhcHBsaWNhdGlvbi5kaXNjb25uZWN0O1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlXG4gICAgKSB7XG4gICAgICBzZWxmLmFwaSA9IGFwaTtcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93KSB7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVwiLCB7IGRldGFpbDogYXBpIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGNvbm5lY3RlZCA9IGZhbHNlO1xuICB2YXIgY29ubmVjdGVkSGFuZGxlcnMgPSBbXTtcblxuICB2YXIgbGF1bmNoQ29ubmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgIGNvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgd2hpbGUgKChoYW5kbGVyID0gY29ubmVjdGVkSGFuZGxlcnMucG9wKCkpKSB7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGNoZWNrSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBoYW5kbGVyO1xuICAgIGlmICh0eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhciBtc2cgPVxuICAgICAgICBcIkEgZnVuY3Rpb24gbWF5IG9ubHkgYmUgc3Vic3JpYmVkIHRvIHRoZSBldmVudCwgXCIgK1xuICAgICAgICB0eXBlICtcbiAgICAgICAgXCIgd2FzIHByb3ZpZGVkIGluc3RlYWRcIjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgZnVuY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gdG8gdGhlXG4gICAqIGFwcGxpY2F0aW9uIGlzIGVzdGFwbGlzaGVkLCBhbmQgdGhlIGluaXRpYWwgaW50ZXJmYWNlLWV4Y2hhbmdlXG4gICAqIG1lc3NhZ2luZyBpcyBjb21wbGV0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciB0byBiZSBjYWxsZWQgdXBvbiBpbml0aWFsaXphdGlvblxuICAgKi9cbiAgYXBwbGljYXRpb24ud2hlbkNvbm5lY3RlZCA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyID0gY2hlY2tIYW5kbGVyKGhhbmRsZXIpO1xuICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgIGhhbmRsZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29ubmVjdGVkSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBsdWdpbiBpbnRlcmZhY2UgYXZhaWxhYmxlIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gX2ludGVyZmFjZSB0byBzZXRcbiAgICovXG4gIGFwcGxpY2F0aW9uLnNldEludGVyZmFjZSA9IGZ1bmN0aW9uKF9pbnRlcmZhY2UpIHtcbiAgICBycGMuc2V0SW50ZXJmYWNlKF9pbnRlcmZhY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgcGx1Z2luIGZyb20gdGhlIGFwcGxpY2F0aW9uIChzZW5kaW5nXG4gICAqIG5vdGlmaWNhdGlvbiBtZXNzYWdlKSBhbmQgZGVzdHJveXMgaXRzZWxmXG4gICAqL1xuICBhcHBsaWNhdGlvbi5kaXNjb25uZWN0ID0gZnVuY3Rpb24oX2ludGVyZmFjZSkge1xuICAgIHJwYy5kaXNjb25uZWN0KCk7XG4gIH07XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\\\\n//# sourceURL=webpack-internal:///./src/pluginCore.js\\\\n\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/rpc.js\\\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"API_VERSION\\\\\\\", function() { return API_VERSION; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"RPC\\\\\\\", function() { return RPC; });\\\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \\\\\\\"./src/utils.js\\\\\\\");\\\\n/**\\\\n * Contains the RPC object used both by the application\\\\n * site, and by each plugin\\\\n */\\\\n\\\\nconst API_VERSION = \\\\\\\"0.2.0\\\\\\\";\\\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\\\n\\\\nfunction _appendBuffer(buffer1, buffer2) {\\\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\\\n  tmp.set(new Uint8Array(buffer1), 0);\\\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\\\n  return tmp.buffer;\\\\n}\\\\n\\\\nfunction getKeyByValue(object, value) {\\\\n  return Object.keys(object).find(key => object[key] === value);\\\\n}\\\\n/**\\\\n * RPC object represents a single site in the\\\\n * communication protocol between the application and the plugin\\\\n *\\\\n * @param {Object} connection a special object allowing to send\\\\n * and receive messages from the opposite site (basically it\\\\n * should only provide send() and onMessage() methods)\\\\n */\\\\n\\\\n\\\\nclass RPC {\\\\n  constructor(connection, config) {\\\\n    this._connection = connection;\\\\n    this.config = config || {};\\\\n    this._interface = {};\\\\n    this._plugin_interfaces = {};\\\\n    this._remote = null;\\\\n\\\\n    this._remoteUpdateHandler = function () {};\\\\n\\\\n    this._getInterfaceHandler = function () {};\\\\n\\\\n    this._interfaceSetAsRemoteHandler = null;\\\\n\\\\n    this._disconnectHandler = function () {};\\\\n\\\\n    this._store = new ReferenceStore();\\\\n    this._method_refs = new ReferenceStore();\\\\n    this._connection = connection;\\\\n    let me = this;\\\\n\\\\n    this._connection.onMessage(function (data) {\\\\n      me._processMessage(data);\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Set a handler to be called when the remote site updates its\\\\n   * interface\\\\n   *\\\\n   * @param {Function} handler\\\\n   */\\\\n\\\\n\\\\n  onRemoteUpdate(handler) {\\\\n    this._remoteUpdateHandler = handler;\\\\n  }\\\\n  /**\\\\n   * Set a handler to be called when received a responce from the\\\\n   * remote site reporting that the previously provided interface\\\\n   * has been successfully set as remote for that site\\\\n   *\\\\n   * @param {Function} handler\\\\n   */\\\\n\\\\n\\\\n  onRemoteReady(handler) {\\\\n    this._method_refs.onReady(handler);\\\\n  }\\\\n\\\\n  onRemoteBusy(handler) {\\\\n    this._method_refs.onBusy(handler);\\\\n  }\\\\n\\\\n  getRemoteCallStack() {\\\\n    return this._method_refs.getStack();\\\\n  }\\\\n  /**\\\\n   * Set a handler to be called when the remote site requests to\\\\n   * (re)send the interface. Used to detect an initialzation\\\\n   * completion without sending additional request, since in fact\\\\n   * 'getInterface' request is only sent by application at the last\\\\n   * step of the plugin initialization\\\\n   *\\\\n   * @param {Function} handler\\\\n   */\\\\n\\\\n\\\\n  onGetInterface(handler) {\\\\n    this._getInterfaceHandler = handler;\\\\n  }\\\\n  /**\\\\n   * @returns {Object} set of remote interface methods\\\\n   */\\\\n\\\\n\\\\n  getRemote() {\\\\n    return this._remote;\\\\n  }\\\\n  /**\\\\n   * Sets the interface of this site making it available to the\\\\n   * remote site by sending a message with a set of methods names\\\\n   *\\\\n   * @param {Object} _interface to set\\\\n   */\\\\n\\\\n\\\\n  setInterface(_interface) {\\\\n    if (this.config.forwarding_functions) {\\\\n      for (let func_name of this.config.forwarding_functions) {\\\\n        if (this._remote[func_name]) {\\\\n          if (_interface.constructor === Object) {\\\\n            if (!_interface[func_name]) {\\\\n              _interface[func_name] = (...args) => {\\\\n                this._remote[func_name](...args);\\\\n              };\\\\n            }\\\\n          } else if (_interface.constructor.constructor === Function) {\\\\n            if (!_interface.constructor.prototype[func_name]) {\\\\n              _interface.constructor.prototype[func_name] = (...args) => {\\\\n                this._remote[func_name](...args);\\\\n              };\\\\n            }\\\\n          }\\\\n        }\\\\n      }\\\\n    }\\\\n\\\\n    this._interface = _interface;\\\\n  }\\\\n  /**\\\\n   * Sends the actual interface to the remote site upon it was\\\\n   * updated or by a special request of the remote site\\\\n   */\\\\n\\\\n\\\\n  sendInterface() {\\\\n    return new Promise(resolve => {\\\\n      var names = [];\\\\n\\\\n      if (!this._interface) {\\\\n        throw new Error(\\\\\\\"interface is not set.\\\\\\\");\\\\n      }\\\\n\\\\n      if (this._interface.constructor === Object) {\\\\n        for (var name of Object.keys(this._interface)) {\\\\n          if (name.startsWith(\\\\\\\"_\\\\\\\")) continue;\\\\n\\\\n          if (typeof this._interface[name] === \\\\\\\"function\\\\\\\") {\\\\n            names.push({\\\\n              name: name,\\\\n              data: null,\\\\n              type: \\\\\\\"function\\\\\\\"\\\\n            });\\\\n          } else {\\\\n            var data = this._interface[name];\\\\n\\\\n            if (data !== null && typeof data === \\\\\\\"object\\\\\\\") {\\\\n              var data2 = {};\\\\n\\\\n              for (var k of Object.keys(data)) {\\\\n                if (typeof data[k] === \\\\\\\"function\\\\\\\") {\\\\n                  data2[k] = \\\\\\\"rpc_method::\\\\\\\" + k;\\\\n                } else {\\\\n                  data2[k] = data[k];\\\\n                }\\\\n              }\\\\n\\\\n              names.push({\\\\n                name: name,\\\\n                data: data2,\\\\n                type: \\\\\\\"object\\\\\\\"\\\\n              });\\\\n            } else if (Object(data) !== data) {\\\\n              names.push({\\\\n                name: name,\\\\n                data: data,\\\\n                type: \\\\\\\"data\\\\\\\"\\\\n              });\\\\n            }\\\\n          }\\\\n        }\\\\n      } // a class\\\\n      else if (this._interface.constructor === Function) {\\\\n          throw new Error(\\\\\\\"Please instantiate the class before exportting it.\\\\\\\");\\\\n        } // instance of a class\\\\n        else if (this._interface.constructor.constructor === Function) {\\\\n            var functions = Object.getOwnPropertyNames(Object.getPrototypeOf(this._interface)).concat(Object.keys(this._interface));\\\\n\\\\n            for (var i = 0; i < functions.length; i++) {\\\\n              var name_ = functions[i];\\\\n              if (name_.startsWith(\\\\\\\"_\\\\\\\") || name_ === \\\\\\\"constructor\\\\\\\") continue;\\\\n\\\\n              if (typeof this._interface[name_] === \\\\\\\"function\\\\\\\") {\\\\n                names.push({\\\\n                  name: name_,\\\\n                  data: null\\\\n                });\\\\n              }\\\\n            }\\\\n          } else {\\\\n            throw Error(\\\\\\\"Unsupported interface type\\\\\\\");\\\\n          }\\\\n\\\\n      this._interfaceSetAsRemoteHandler = resolve;\\\\n\\\\n      this._connection.send({\\\\n        type: \\\\\\\"setInterface\\\\\\\",\\\\n        api: names\\\\n      });\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Handles a message from the remote site\\\\n   */\\\\n  // var callback_reg = new RegExp(\\\\\\\"onupdate|run$\\\\\\\")\\\\n\\\\n\\\\n  _processMessage(data) {\\\\n    var resolve, reject, method, args, result;\\\\n\\\\n    switch (data.type) {\\\\n      case \\\\\\\"method\\\\\\\":\\\\n        var _interface = this._interface;\\\\n\\\\n        var _method_context = _interface.__this__ || _interface;\\\\n\\\\n        if (data.pid) {\\\\n          _interface = this._plugin_interfaces[data.pid];\\\\n\\\\n          if (!_interface) {\\\\n            if (data.promise) {\\\\n              [resolve, reject] = this._unwrap(data.promise, false);\\\\n              reject(`plugin api function is not avaialbe in \\\\\\\"${data.pid}\\\\\\\", the plugin maybe terminated.`);\\\\n            } else {\\\\n              console.error(`plugin api function is not avaialbe in ${data.pid}, the plugin maybe terminated.`);\\\\n            }\\\\n\\\\n            return;\\\\n          }\\\\n        }\\\\n\\\\n        if (data.name.indexOf(\\\\\\\".\\\\\\\") !== -1) {\\\\n          var names = data.name.split(\\\\\\\".\\\\\\\");\\\\n          method = _interface[names[0]][names[1]];\\\\n        } else {\\\\n          method = _interface[data.name];\\\\n        }\\\\n\\\\n        args = this._unwrap(data.args, true);\\\\n\\\\n        if (data.promise) {\\\\n          [resolve, reject] = this._unwrap(data.promise, false);\\\\n\\\\n          try {\\\\n            result = method.apply(_method_context, args);\\\\n\\\\n            if (result instanceof Promise || method.constructor && method.constructor.name === \\\\\\\"AsyncFunction\\\\\\\") {\\\\n              result.then(resolve).catch(reject);\\\\n            } else {\\\\n              resolve(result);\\\\n            }\\\\n          } catch (e) {\\\\n            console.error(e, method);\\\\n            reject(e);\\\\n          }\\\\n        } else {\\\\n          try {\\\\n            method.apply(_method_context, args);\\\\n          } catch (e) {\\\\n            console.error(e, method, args);\\\\n          }\\\\n        }\\\\n\\\\n        break;\\\\n\\\\n      case \\\\\\\"callback\\\\\\\":\\\\n        if (data.promise) {\\\\n          [resolve, reject] = this._unwrap(data.promise, false);\\\\n\\\\n          try {\\\\n            method = this._store.fetch(data.num);\\\\n            args = this._unwrap(data.args, true);\\\\n\\\\n            if (!method) {\\\\n              throw \\\\\\\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\\\\\";\\\\n            }\\\\n\\\\n            result = method.apply(null, args);\\\\n\\\\n            if (result instanceof Promise || method.constructor && method.constructor.name === \\\\\\\"AsyncFunction\\\\\\\") {\\\\n              result.then(resolve).catch(reject);\\\\n            } else {\\\\n              resolve(result);\\\\n            }\\\\n          } catch (e) {\\\\n            console.error(e, method);\\\\n            reject(e);\\\\n          }\\\\n        } else {\\\\n          try {\\\\n            method = this._store.fetch(data.num);\\\\n            args = this._unwrap(data.args, true);\\\\n\\\\n            if (!method) {\\\\n              throw \\\\\\\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\\\\\";\\\\n            }\\\\n\\\\n            method.apply(null, args);\\\\n          } catch (e) {\\\\n            console.error(e, method, args);\\\\n          }\\\\n        }\\\\n\\\\n        break;\\\\n\\\\n      case \\\\\\\"setInterface\\\\\\\":\\\\n        this._setRemote(data.api);\\\\n\\\\n        break;\\\\n\\\\n      case \\\\\\\"getInterface\\\\\\\":\\\\n        this.sendInterface();\\\\n\\\\n        this._getInterfaceHandler();\\\\n\\\\n        break;\\\\n\\\\n      case \\\\\\\"interfaceSetAsRemote\\\\\\\":\\\\n        if (typeof this._interfaceSetAsRemoteHandler === \\\\\\\"function\\\\\\\") {\\\\n          this._interfaceSetAsRemoteHandler();\\\\n\\\\n          this._interfaceSetAsRemoteHandler === null;\\\\n        }\\\\n\\\\n        break;\\\\n\\\\n      case \\\\\\\"disconnect\\\\\\\":\\\\n        this._disconnectHandler();\\\\n\\\\n        this._connection.disconnect();\\\\n\\\\n        break;\\\\n    }\\\\n  }\\\\n  /**\\\\n   * Sends a requests to the remote site asking it to provide its\\\\n   * current interface\\\\n   */\\\\n\\\\n\\\\n  requestRemote() {\\\\n    this._connection.send({\\\\n      type: \\\\\\\"getInterface\\\\\\\"\\\\n    });\\\\n  }\\\\n\\\\n  _ndarray(typedArray, shape, dtype) {\\\\n    var _dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"typedArrayToDtype\\\\\\\"][typedArray.constructor.name];\\\\n\\\\n    if (dtype && dtype !== _dtype) {\\\\n      throw \\\\\\\"dtype doesn't match the type of the array: \\\\\\\" + _dtype + \\\\\\\" != \\\\\\\" + dtype;\\\\n    }\\\\n\\\\n    shape = shape || [typedArray.length];\\\\n    return {\\\\n      __jailed_type__: \\\\\\\"ndarray\\\\\\\",\\\\n      __value__: typedArray,\\\\n      __shape__: shape,\\\\n      __dtype__: _dtype\\\\n    };\\\\n  }\\\\n  /**\\\\n   * Sets the new remote interface provided by the other site\\\\n   *\\\\n   * @param {Array} names list of function names\\\\n   */\\\\n\\\\n\\\\n  _setRemote(api) {\\\\n    this._remote = {};\\\\n    var i, name, data, type;\\\\n\\\\n    for (i = 0; i < api.length; i++) {\\\\n      name = api[i].name;\\\\n      data = api[i].data;\\\\n      type = api[i].type;\\\\n\\\\n      if (type === \\\\\\\"data\\\\\\\") {\\\\n        this._remote[name] = data;\\\\n      } else if (data) {\\\\n        if (typeof data === \\\\\\\"object\\\\\\\") {\\\\n          var data2 = {};\\\\n\\\\n          for (var key in data) {\\\\n            if (data.hasOwnProperty(key)) {\\\\n              if (data[key] === \\\\\\\"rpc_method::\\\\\\\" + key) {\\\\n                data2[key] = this._genRemoteMethod(name + \\\\\\\".\\\\\\\" + key);\\\\n              } else {\\\\n                data2[key] = data[key];\\\\n              }\\\\n            }\\\\n          }\\\\n\\\\n          this._remote[name] = data2;\\\\n        } else {\\\\n          this._remote[name] = data;\\\\n        }\\\\n      } else {\\\\n        this._remote[name] = this._genRemoteMethod(name);\\\\n      }\\\\n    }\\\\n\\\\n    this._remoteUpdateHandler();\\\\n\\\\n    this._reportRemoteSet();\\\\n  }\\\\n  /**\\\\n   * Generates the wrapped function corresponding to a single remote\\\\n   * method. When the generated function is called, it will send the\\\\n   * corresponding message to the remote site asking it to execute\\\\n   * the particular method of its interface\\\\n   *\\\\n   * @param {String} name of the remote method\\\\n   *\\\\n   * @returns {Function} wrapped remote method\\\\n   */\\\\n\\\\n\\\\n  _genRemoteMethod(name, plugin_id) {\\\\n    var me = this;\\\\n\\\\n    var remoteMethod = function () {\\\\n      return new Promise((resolve, reject) => {\\\\n        let id = null;\\\\n\\\\n        try {\\\\n          id = me._method_refs.put(plugin_id ? plugin_id + \\\\\\\"/\\\\\\\" + name : name);\\\\n\\\\n          var wrapped_resolve = function () {\\\\n            if (id !== null) me._method_refs.fetch(id);\\\\n            return resolve.apply(this, arguments);\\\\n          };\\\\n\\\\n          var wrapped_reject = function () {\\\\n            if (id !== null) me._method_refs.fetch(id);\\\\n            return reject.apply(this, arguments);\\\\n          };\\\\n\\\\n          wrapped_resolve.__jailed_pairs__ = wrapped_reject;\\\\n          wrapped_reject.__jailed_pairs__ = wrapped_resolve;\\\\n          var args = Array.prototype.slice.call(arguments);\\\\n\\\\n          if (name === \\\\\\\"register\\\\\\\" || name === \\\\\\\"export\\\\\\\" || name === \\\\\\\"on\\\\\\\") {\\\\n            args = me._wrap(args, true);\\\\n          } else {\\\\n            args = me._wrap(args);\\\\n          }\\\\n\\\\n          var transferables = args.args.__transferables__;\\\\n          if (transferables) delete args.args.__transferables__;\\\\n\\\\n          me._connection.send({\\\\n            type: \\\\\\\"method\\\\\\\",\\\\n            name: name,\\\\n            pid: plugin_id,\\\\n            args: args,\\\\n            promise: me._wrap([wrapped_resolve, wrapped_reject])\\\\n          }, transferables);\\\\n        } catch (e) {\\\\n          if (id) me._method_refs.fetch(id);\\\\n          reject(`Failed to exectue remote method (plugin: ${plugin_id || me.id}, method: ${name}), error: ${e}`);\\\\n        }\\\\n      });\\\\n    };\\\\n\\\\n    remoteMethod.__remote_method = true;\\\\n    return remoteMethod;\\\\n  }\\\\n  /**\\\\n   * Sends a responce reporting that interface just provided by the\\\\n   * remote site was successfully set by this site as remote\\\\n   */\\\\n\\\\n\\\\n  _reportRemoteSet() {\\\\n    this._connection.send({\\\\n      type: \\\\\\\"interfaceSetAsRemote\\\\\\\"\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Prepares the provided set of remote method arguments for\\\\n   * sending to the remote site, replaces all the callbacks with\\\\n   * identifiers\\\\n   *\\\\n   * @param {Array} args to wrap\\\\n   *\\\\n   * @returns {Array} wrapped arguments\\\\n   */\\\\n\\\\n\\\\n  _encode_interface(aObject, bObject) {\\\\n    var v, k;\\\\n    const encoded_interface = {};\\\\n    aObject[\\\\\\\"__id__\\\\\\\"] = aObject[\\\\\\\"__id__\\\\\\\"] || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"randId\\\\\\\"])();\\\\n\\\\n    for (k in aObject) {\\\\n      if (k === \\\\\\\"hasOwnProperty\\\\\\\") continue;\\\\n\\\\n      if (aObject.hasOwnProperty(k)) {\\\\n        if (k.startsWith(\\\\\\\"_\\\\\\\")) {\\\\n          continue;\\\\n        }\\\\n\\\\n        v = aObject[k];\\\\n\\\\n        if (typeof v === \\\\\\\"function\\\\\\\") {\\\\n          bObject[k] = {\\\\n            __jailed_type__: \\\\\\\"plugin_interface\\\\\\\",\\\\n            __plugin_id__: aObject[\\\\\\\"__id__\\\\\\\"],\\\\n            __value__: k,\\\\n            num: null\\\\n          };\\\\n          encoded_interface[k] = v;\\\\n        } else if (Object(v) !== v) {\\\\n          bObject[k] = {\\\\n            __jailed_type__: \\\\\\\"argument\\\\\\\",\\\\n            __value__: v\\\\n          };\\\\n          encoded_interface[k] = v;\\\\n        } else if (typeof v === \\\\\\\"object\\\\\\\") {\\\\n          bObject[k] = Array.isArray(v) ? [] : {};\\\\n\\\\n          this._encode_interface(v, bObject[k]);\\\\n        }\\\\n      }\\\\n    }\\\\n\\\\n    this._plugin_interfaces[aObject[\\\\\\\"__id__\\\\\\\"]] = encoded_interface;\\\\n\\\\n    if (aObject.on) {\\\\n      aObject.on(\\\\\\\"close\\\\\\\", () => {\\\\n        delete this._plugin_interfaces[aObject[\\\\\\\"__id__\\\\\\\"]];\\\\n      });\\\\n    }\\\\n  }\\\\n\\\\n  _encode(aObject, as_interface) {\\\\n    var transferables = [];\\\\n\\\\n    if (!aObject) {\\\\n      return aObject;\\\\n    }\\\\n\\\\n    var _transfer = aObject._transfer;\\\\n    var bObject, v, k;\\\\n    var isarray = Array.isArray(aObject);\\\\n    bObject = isarray ? [] : {}; //skip if already encoded\\\\n\\\\n    if (typeof aObject === \\\\\\\"object\\\\\\\" && aObject.__jailed_type__ && aObject.__value__) {\\\\n      return aObject;\\\\n    } //encode interfaces\\\\n\\\\n\\\\n    if (typeof aObject === \\\\\\\"object\\\\\\\" && !Array.isArray(aObject) && (aObject.__as_interface__ || as_interface)) {\\\\n      this._encode_interface(aObject, bObject);\\\\n\\\\n      return bObject;\\\\n    }\\\\n\\\\n    if (as_interface) {\\\\n      aObject[\\\\\\\"__id__\\\\\\\"] = aObject[\\\\\\\"__id__\\\\\\\"] || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"randId\\\\\\\"])();\\\\n      this._plugin_interfaces[aObject[\\\\\\\"__id__\\\\\\\"]] = this._plugin_interfaces[aObject[\\\\\\\"__id__\\\\\\\"]] || {};\\\\n    }\\\\n\\\\n    for (k in aObject) {\\\\n      if (k === \\\\\\\"hasOwnProperty\\\\\\\") continue;\\\\n\\\\n      if (isarray || aObject.hasOwnProperty(k)) {\\\\n        v = aObject[k];\\\\n\\\\n        if (typeof this._interface._rpcEncode === \\\\\\\"function\\\\\\\") {\\\\n          const encoded_obj = this._interface._rpcEncode(v);\\\\n\\\\n          if (encoded_obj && encoded_obj.__rpc_dtype__) {\\\\n            bObject[k] = {\\\\n              __jailed_type__: \\\\\\\"custom_encoding\\\\\\\",\\\\n              __value__: encoded_obj\\\\n            };\\\\n            continue;\\\\n          } // if the returned object does not contain __jailed_type__, assuming the object has been transformed\\\\n          else {\\\\n              v = encoded_obj;\\\\n            }\\\\n        }\\\\n\\\\n        if (typeof v === \\\\\\\"function\\\\\\\") {\\\\n          if (as_interface) {\\\\n            const encoded_interface = this._plugin_interfaces[aObject[\\\\\\\"__id__\\\\\\\"]];\\\\n            bObject[k] = {\\\\n              __jailed_type__: \\\\\\\"plugin_interface\\\\\\\",\\\\n              __plugin_id__: aObject[\\\\\\\"__id__\\\\\\\"],\\\\n              __value__: k,\\\\n              num: null\\\\n            };\\\\n            encoded_interface[k] = v;\\\\n            continue;\\\\n          }\\\\n\\\\n          let interfaceFuncName = null;\\\\n\\\\n          for (var name in this._interface) {\\\\n            if (this._interface.hasOwnProperty(name)) {\\\\n              if (name.startsWith(\\\\\\\"_\\\\\\\")) continue;\\\\n\\\\n              if (this._interface[name] === v) {\\\\n                interfaceFuncName = name;\\\\n                break;\\\\n              }\\\\n            }\\\\n          } // search for prototypes\\\\n\\\\n\\\\n          var functions = Object.getOwnPropertyNames(Object.getPrototypeOf(this._interface));\\\\n\\\\n          for (var i = 0; i < functions.length; i++) {\\\\n            var name_ = functions[i];\\\\n            if (name_.startsWith(\\\\\\\"_\\\\\\\")) continue;\\\\n\\\\n            if (this._interface[name_] === v) {\\\\n              interfaceFuncName = name_;\\\\n              break;\\\\n            }\\\\n          }\\\\n\\\\n          if (!interfaceFuncName) {\\\\n            var id = this._store.put(v);\\\\n\\\\n            bObject[k] = {\\\\n              __jailed_type__: \\\\\\\"callback\\\\\\\",\\\\n              __value__: v.constructor && v.constructor.name || id,\\\\n              num: id\\\\n            };\\\\n          } else {\\\\n            bObject[k] = {\\\\n              __jailed_type__: \\\\\\\"interface\\\\\\\",\\\\n              __value__: interfaceFuncName,\\\\n              num: null\\\\n            };\\\\n          }\\\\n        } else if (\\\\n        /*global tf*/\\\\n        typeof tf !== \\\\\\\"undefined\\\\\\\" && tf.Tensor && v instanceof tf.Tensor) {\\\\n          const v_buffer = v.dataSync();\\\\n\\\\n          if (v._transfer || _transfer) {\\\\n            transferables.push(v_buffer.buffer);\\\\n            delete v._transfer;\\\\n          }\\\\n\\\\n          bObject[k] = {\\\\n            __jailed_type__: \\\\\\\"ndarray\\\\\\\",\\\\n            __value__: v_buffer,\\\\n            __shape__: v.shape,\\\\n            __dtype__: v.dtype\\\\n          };\\\\n        } else if (\\\\n        /*global nj*/\\\\n        typeof nj !== \\\\\\\"undefined\\\\\\\" && nj.NdArray && v instanceof nj.NdArray) {\\\\n          var dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"typedArrayToDtype\\\\\\\"][v.selection.data.constructor.name];\\\\n\\\\n          if (v._transfer || _transfer) {\\\\n            transferables.push(v.selection.data.buffer);\\\\n            delete v._transfer;\\\\n          }\\\\n\\\\n          bObject[k] = {\\\\n            __jailed_type__: \\\\\\\"ndarray\\\\\\\",\\\\n            __value__: v.selection.data,\\\\n            __shape__: v.shape,\\\\n            __dtype__: dtype\\\\n          };\\\\n        } else if (v instanceof Error) {\\\\n          console.error(v);\\\\n          bObject[k] = {\\\\n            __jailed_type__: \\\\\\\"error\\\\\\\",\\\\n            __value__: v.toString()\\\\n          };\\\\n        } else if (typeof File !== \\\\\\\"undefined\\\\\\\" && v instanceof File) {\\\\n          bObject[k] = {\\\\n            __jailed_type__: \\\\\\\"file\\\\\\\",\\\\n            __value__: v,\\\\n            __relative_path__: v.relativePath || v.webkitRelativePath\\\\n          };\\\\n        } // send objects supported by structure clone algorithm\\\\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\\\n        else if (v !== Object(v) || v instanceof Boolean || v instanceof String || v instanceof Date || v instanceof RegExp || v instanceof Blob || v instanceof ImageData || typeof FileList !== \\\\\\\"undefined\\\\\\\" && v instanceof FileList) {\\\\n            bObject[k] = {\\\\n              __jailed_type__: \\\\\\\"argument\\\\\\\",\\\\n              __value__: v\\\\n            };\\\\n          } else if (v instanceof ArrayBuffer) {\\\\n            if (v._transfer || _transfer) {\\\\n              transferables.push(v);\\\\n              delete v._transfer;\\\\n            }\\\\n\\\\n            bObject[k] = {\\\\n              __jailed_type__: \\\\\\\"argument\\\\\\\",\\\\n              __value__: v\\\\n            };\\\\n          } else if (v instanceof ArrayBufferView) {\\\\n            if (v._transfer || _transfer) {\\\\n              transferables.push(v.buffer);\\\\n              delete v._transfer;\\\\n            }\\\\n\\\\n            bObject[k] = {\\\\n              __jailed_type__: \\\\\\\"argument\\\\\\\",\\\\n              __value__: v\\\\n            };\\\\n          } // TODO: support also Map and Set\\\\n          // TODO: avoid object such as DynamicPlugin instance.\\\\n          else if (v.__as_interface__) {\\\\n              bObject[k] = this._encode(v, true);\\\\n            } else if (typeof v === \\\\\\\"object\\\\\\\" || Array.isArray(v)) {\\\\n              bObject[k] = this._encode(v, as_interface); // move transferables to the top level object\\\\n\\\\n              if (bObject[k].__transferables__) {\\\\n                for (var t = 0; t < bObject[k].__transferables__.length; t++) {\\\\n                  transferables.push(bObject[k].__transferables__[t]);\\\\n                }\\\\n\\\\n                delete bObject[k].__transferables__;\\\\n              }\\\\n            } else if (typeof v === \\\\\\\"object\\\\\\\" && v.constructor) {\\\\n              throw \\\\\\\"Unsupported data type for transferring between the plugin and the main app: \\\\\\\" + k + \\\\\\\" : \\\\\\\" + v.constructor.name;\\\\n            } else {\\\\n              throw \\\\\\\"Unsupported data type for transferring between the plugin and the main app: \\\\\\\" + k + \\\\\\\",\\\\\\\" + v;\\\\n            }\\\\n      }\\\\n    }\\\\n\\\\n    if (transferables.length > 0) {\\\\n      bObject.__transferables__ = transferables;\\\\n    }\\\\n\\\\n    return bObject;\\\\n  }\\\\n\\\\n  _decode(aObject, callbackId, withPromise) {\\\\n    if (!aObject) {\\\\n      return aObject;\\\\n    }\\\\n\\\\n    var bObject, v, k;\\\\n\\\\n    if (aObject.hasOwnProperty(\\\\\\\"__jailed_type__\\\\\\\") && aObject.hasOwnProperty(\\\\\\\"__value__\\\\\\\")) {\\\\n      if (aObject.__jailed_type__.startsWith(\\\\\\\"custom_encoding\\\\\\\")) {\\\\n        if (typeof this._interface._rpcDecode === \\\\\\\"function\\\\\\\") {\\\\n          const decodedObj = this._interface._rpcDecode(aObject.__value__);\\\\n\\\\n          bObject = decodedObj;\\\\n        } else {\\\\n          bObject = aObject;\\\\n        }\\\\n      } else if (aObject.__jailed_type__ === \\\\\\\"callback\\\\\\\") {\\\\n        bObject = this._genRemoteCallback(callbackId, aObject.num, withPromise);\\\\n      } else if (aObject.__jailed_type__ === \\\\\\\"interface\\\\\\\") {\\\\n        bObject = this._remote[aObject.__value__] || this._genRemoteMethod(aObject.__value__);\\\\n      } else if (aObject.__jailed_type__ === \\\\\\\"plugin_interface\\\\\\\") {\\\\n        bObject = this._genRemoteMethod(aObject.__value__, aObject.__plugin_id__);\\\\n      } else if (aObject.__jailed_type__ === \\\\\\\"ndarray\\\\\\\") {\\\\n        /*global nj tf*/\\\\n        //create build array/tensor if used in the plugin\\\\n        if (this.id === \\\\\\\"__plugin__\\\\\\\" && typeof nj !== \\\\\\\"undefined\\\\\\\" && nj.array) {\\\\n          if (Array.isArray(aObject.__value__)) {\\\\n            aObject.__value__ = aObject.__value__.reduce(_appendBuffer);\\\\n          }\\\\n\\\\n          bObject = nj.array(aObject.__value__, aObject.__dtype__).reshape(aObject.__shape__);\\\\n        } else if (this.id === \\\\\\\"__plugin__\\\\\\\" && typeof tf !== \\\\\\\"undefined\\\\\\\" && tf.Tensor) {\\\\n          if (Array.isArray(aObject.__value__)) {\\\\n            aObject.__value__ = aObject.__value__.reduce(_appendBuffer);\\\\n          }\\\\n\\\\n          bObject = tf.tensor(aObject.__value__, aObject.__shape__, aObject.__dtype__);\\\\n        } else {\\\\n          //keep it as regular if transfered to the main app\\\\n          bObject = aObject;\\\\n        }\\\\n      } else if (aObject.__jailed_type__ === \\\\\\\"error\\\\\\\") {\\\\n        bObject = new Error(aObject.__value__);\\\\n      } else if (aObject.__jailed_type__ === \\\\\\\"file\\\\\\\") {\\\\n        bObject = aObject.__value__; //patch relativePath\\\\n\\\\n        bObject.relativePath = aObject.__relative_path__;\\\\n      } else if (aObject.__jailed_type__ === \\\\\\\"argument\\\\\\\") {\\\\n        bObject = aObject.__value__;\\\\n      }\\\\n\\\\n      return bObject;\\\\n    } else {\\\\n      var isarray = Array.isArray(aObject);\\\\n      bObject = isarray ? [] : {};\\\\n\\\\n      for (k in aObject) {\\\\n        if (isarray || aObject.hasOwnProperty(k)) {\\\\n          v = aObject[k];\\\\n\\\\n          if (typeof v === \\\\\\\"object\\\\\\\" || Array.isArray(v)) {\\\\n            bObject[k] = this._decode(v, callbackId, withPromise);\\\\n          }\\\\n        }\\\\n      }\\\\n\\\\n      return bObject;\\\\n    }\\\\n  }\\\\n\\\\n  _wrap(args, as_interface) {\\\\n    var wrapped = this._encode(args, as_interface);\\\\n\\\\n    var result = {\\\\n      args: wrapped\\\\n    };\\\\n    return result;\\\\n  }\\\\n  /**\\\\n   * Unwraps the set of arguments delivered from the remote site,\\\\n   * replaces all callback identifiers with a function which will\\\\n   * initiate sending that callback identifier back to other site\\\\n   *\\\\n   * @param {Object} args to unwrap\\\\n   *\\\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\\\n   *\\\\n   * @returns {Array} unwrapped args\\\\n   */\\\\n\\\\n\\\\n  _unwrap(args, withPromise) {\\\\n    // var called = false;\\\\n    // wraps each callback so that the only one could be called\\\\n    // var once(cb) {\\\\n    //     return function() {\\\\n    //         if (!called) {\\\\n    //             called = true;\\\\n    //             return cb.apply(this, arguments);\\\\n    //         } else {\\\\n    //             var msg =\\\\n    //               'A callback from this set has already been executed';\\\\n    //             throw new Error(msg);\\\\n    //         }\\\\n    //     };\\\\n    // }\\\\n    var result = this._decode(args.args, args.callbackId, withPromise);\\\\n\\\\n    return result;\\\\n  }\\\\n  /**\\\\n   * Generates the wrapped function corresponding to a single remote\\\\n   * callback. When the generated function is called, it will send\\\\n   * the corresponding message to the remote site asking it to\\\\n   * execute the particular callback previously saved during a call\\\\n   * by the remote site a method from the interface of this site\\\\n   *\\\\n   * @param {Number} id of the remote callback to execute\\\\n   * @param {Number} argNum argument index of the callback\\\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\\\n   *\\\\n   * @returns {Function} wrapped remote callback\\\\n   */\\\\n\\\\n\\\\n  _genRemoteCallback(id, argNum, withPromise) {\\\\n    var me = this;\\\\n    var remoteCallback;\\\\n\\\\n    if (withPromise) {\\\\n      remoteCallback = function () {\\\\n        return new Promise((resolve, reject) => {\\\\n          var args = me._wrap(Array.prototype.slice.call(arguments));\\\\n\\\\n          var transferables = args.args.__transferables__;\\\\n          if (transferables) delete args.args.__transferables__;\\\\n          resolve.__jailed_pairs__ = reject;\\\\n          reject.__jailed_pairs__ = resolve;\\\\n\\\\n          try {\\\\n            me._connection.send({\\\\n              type: \\\\\\\"callback\\\\\\\",\\\\n              id: id,\\\\n              num: argNum,\\\\n              args: args,\\\\n              // pid :  me.id,\\\\n              promise: me._wrap([resolve, reject])\\\\n            }, transferables);\\\\n          } catch (e) {\\\\n            reject(`Failed to exectue remote callback (id: ${id}, argNum: ${argNum}).`);\\\\n          }\\\\n        });\\\\n      };\\\\n\\\\n      return remoteCallback;\\\\n    } else {\\\\n      remoteCallback = function () {\\\\n        var args = me._wrap(Array.prototype.slice.call(arguments));\\\\n\\\\n        var transferables = args.args.__transferables__;\\\\n        if (transferables) delete args.args.__transferables__;\\\\n        return me._connection.send({\\\\n          type: \\\\\\\"callback\\\\\\\",\\\\n          id: id,\\\\n          num: argNum,\\\\n          args: args // pid :  me.id\\\\n\\\\n        }, transferables);\\\\n      };\\\\n\\\\n      return remoteCallback;\\\\n    }\\\\n  }\\\\n  /**\\\\n   * Sends the notification message and breaks the connection\\\\n   */\\\\n\\\\n\\\\n  disconnect() {\\\\n    this._connection.send({\\\\n      type: \\\\\\\"disconnect\\\\\\\"\\\\n    });\\\\n\\\\n    setTimeout(this._connection.disconnect, 2000);\\\\n  }\\\\n  /**\\\\n   * Set a handler to be called when received a disconnect message\\\\n   * from the remote site\\\\n   *\\\\n   * @param {Function} handler\\\\n   */\\\\n\\\\n\\\\n  onDisconnect(handler) {\\\\n    this._disconnectHandler = handler;\\\\n  }\\\\n\\\\n}\\\\n/**\\\\n * ReferenceStore is a special object which stores other objects\\\\n * and provides the references (number) instead. This reference\\\\n * may then be sent over a json-based communication channel (IPC\\\\n * to another Node.js process or a message to the Worker). Other\\\\n * site may then provide the reference in the responce message\\\\n * implying the given object should be activated.\\\\n *\\\\n * Primary usage for the ReferenceStore is a storage for the\\\\n * callbacks, which therefore makes it possible to initiate a\\\\n * callback execution by the opposite site (which normally cannot\\\\n * directly execute functions over the communication channel).\\\\n *\\\\n * Each stored object can only be fetched once and is not\\\\n * available for the second time. Each stored object must be\\\\n * fetched, since otherwise it will remain stored forever and\\\\n * consume memory.\\\\n *\\\\n * Stored object indeces are simply the numbers, which are however\\\\n * released along with the objects, and are later reused again (in\\\\n * order to postpone the overflow, which should not likely happen,\\\\n * but anyway).\\\\n */\\\\n\\\\nclass ReferenceStore {\\\\n  constructor() {\\\\n    this._store = {}; // stored object\\\\n\\\\n    this._indices = [0]; // smallest available indices\\\\n\\\\n    this._readyHandler = function () {};\\\\n\\\\n    this._busyHandler = function () {};\\\\n\\\\n    this._readyHandler();\\\\n  }\\\\n  /**\\\\n   * call handler when the store is empty\\\\n   *\\\\n   * @param {FUNCTION} id of a handler\\\\n   */\\\\n\\\\n\\\\n  onReady(readyHandler) {\\\\n    this._readyHandler = readyHandler || function () {};\\\\n  }\\\\n  /**\\\\n   * call handler when the store is not empty\\\\n   *\\\\n   * @param {FUNCTION} id of a handler\\\\n   */\\\\n\\\\n\\\\n  onBusy(busyHandler) {\\\\n    this._busyHandler = busyHandler || function () {};\\\\n  }\\\\n  /**\\\\n   * get the length of the store\\\\n   *\\\\n   */\\\\n\\\\n\\\\n  getStack() {\\\\n    return Object.keys(this._store).length;\\\\n  }\\\\n  /**\\\\n   * @function _genId() generates the new reference id\\\\n   *\\\\n   * @returns {Number} smallest available id and reserves it\\\\n   */\\\\n\\\\n\\\\n  _genId() {\\\\n    var id;\\\\n\\\\n    if (this._indices.length === 1) {\\\\n      id = this._indices[0]++;\\\\n    } else {\\\\n      id = this._indices.shift();\\\\n    }\\\\n\\\\n    return id;\\\\n  }\\\\n  /**\\\\n   * Releases the given reference id so that it will be available by\\\\n   * another object stored\\\\n   *\\\\n   * @param {Number} id to release\\\\n   */\\\\n\\\\n\\\\n  _releaseId(id) {\\\\n    for (var i = 0; i < this._indices.length; i++) {\\\\n      if (id < this._indices[i]) {\\\\n        this._indices.splice(i, 0, id);\\\\n\\\\n        break;\\\\n      }\\\\n    } // cleaning-up the sequence tail\\\\n\\\\n\\\\n    for (i = this._indices.length - 1; i >= 0; i--) {\\\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\\\n        this._indices.pop();\\\\n      } else {\\\\n        break;\\\\n      }\\\\n    }\\\\n  }\\\\n  /**\\\\n   * Stores the given object and returns the refernce id instead\\\\n   *\\\\n   * @param {Object} obj to store\\\\n   *\\\\n   * @returns {Number} reference id of the stored object\\\\n   */\\\\n\\\\n\\\\n  put(obj) {\\\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\\\n      this._busyHandler();\\\\n    }\\\\n\\\\n    var id = this._genId();\\\\n\\\\n    this._store[id] = obj;\\\\n    return id;\\\\n  }\\\\n  /**\\\\n   * Retrieves previously stored object and releases its reference\\\\n   *\\\\n   * @param {Number} id of an object to retrieve\\\\n   */\\\\n\\\\n\\\\n  fetch(id) {\\\\n    var obj = this._store[id];\\\\n\\\\n    if (obj && !obj.__remote_method) {\\\\n      delete this._store[id];\\\\n\\\\n      this._releaseId(id);\\\\n\\\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\\\n        this._readyHandler();\\\\n      }\\\\n    }\\\\n\\\\n    if (obj && obj.__jailed_pairs__) {\\\\n      const _id = getKeyByValue(this._store, obj.__jailed_pairs__);\\\\n\\\\n      this.fetch(_id);\\\\n    }\\\\n\\\\n    return obj;\\\\n  }\\\\n  /**\\\\n   * Retrieves previously stored object\\\\n   *\\\\n   * @param {Number} id of an object to retrieve\\\\n   */\\\\n  // retrieve(id) {\\\\n  //     var obj = this._store[id];\\\\n  //     return obj;\\\\n  // }\\\\n\\\\n\\\\n}//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcnBjLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvc3JjL3JwYy5qcz8yM2MyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udGFpbnMgdGhlIFJQQyBvYmplY3QgdXNlZCBib3RoIGJ5IHRoZSBhcHBsaWNhdGlvblxuICogc2l0ZSwgYW5kIGJ5IGVhY2ggcGx1Z2luXG4gKi9cbmltcG9ydCB7IHJhbmRJZCwgdHlwZWRBcnJheVRvRHR5cGUgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuXG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT04gPSBcIjAuMi4wXCI7XG5cbmNvbnN0IEFycmF5QnVmZmVyVmlldyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihcbiAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBVaW50OEFycmF5KCkpXG4pLmNvbnN0cnVjdG9yO1xuXG5mdW5jdGlvbiBfYXBwZW5kQnVmZmVyKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcbiAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcbiAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIxKSwgMCk7XG4gIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMiksIGJ1ZmZlcjEuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB0bXAuYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlCeVZhbHVlKG9iamVjdCwgdmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkuZmluZChrZXkgPT4gb2JqZWN0W2tleV0gPT09IHZhbHVlKTtcbn1cbi8qKlxuICogUlBDIG9iamVjdCByZXByZXNlbnRzIGEgc2luZ2xlIHNpdGUgaW4gdGhlXG4gKiBjb21tdW5pY2F0aW9uIHByb3RvY29sIGJldHdlZW4gdGhlIGFwcGxpY2F0aW9uIGFuZCB0aGUgcGx1Z2luXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb24gYSBzcGVjaWFsIG9iamVjdCBhbGxvd2luZyB0byBzZW5kXG4gKiBhbmQgcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIHRoZSBvcHBvc2l0ZSBzaXRlIChiYXNpY2FsbHkgaXRcbiAqIHNob3VsZCBvbmx5IHByb3ZpZGUgc2VuZCgpIGFuZCBvbk1lc3NhZ2UoKSBtZXRob2RzKVxuICovXG5leHBvcnQgY2xhc3MgUlBDIHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgY29uZmlnKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgdGhpcy5faW50ZXJmYWNlID0ge307XG4gICAgdGhpcy5fcGx1Z2luX2ludGVyZmFjZXMgPSB7fTtcbiAgICB0aGlzLl9yZW1vdGUgPSBudWxsO1xuICAgIHRoaXMuX3JlbW90ZVVwZGF0ZUhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX2dldEludGVyZmFjZUhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX2ludGVyZmFjZVNldEFzUmVtb3RlSGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5fZGlzY29ubmVjdEhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX3N0b3JlID0gbmV3IFJlZmVyZW5jZVN0b3JlKCk7XG4gICAgdGhpcy5fbWV0aG9kX3JlZnMgPSBuZXcgUmVmZXJlbmNlU3RvcmUoKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICBsZXQgbWUgPSB0aGlzO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub25NZXNzYWdlKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIG1lLl9wcm9jZXNzTWVzc2FnZShkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSByZW1vdGUgc2l0ZSB1cGRhdGVzIGl0c1xuICAgKiBpbnRlcmZhY2VcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb25SZW1vdGVVcGRhdGUoaGFuZGxlcikge1xuICAgIHRoaXMuX3JlbW90ZVVwZGF0ZUhhbmRsZXIgPSBoYW5kbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHdoZW4gcmVjZWl2ZWQgYSByZXNwb25jZSBmcm9tIHRoZVxuICAgKiByZW1vdGUgc2l0ZSByZXBvcnRpbmcgdGhhdCB0aGUgcHJldmlvdXNseSBwcm92aWRlZCBpbnRlcmZhY2VcbiAgICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHNldCBhcyByZW1vdGUgZm9yIHRoYXQgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuXG4gIG9uUmVtb3RlUmVhZHkoaGFuZGxlcikge1xuICAgIHRoaXMuX21ldGhvZF9yZWZzLm9uUmVhZHkoaGFuZGxlcik7XG4gIH1cblxuICBvblJlbW90ZUJ1c3koaGFuZGxlcikge1xuICAgIHRoaXMuX21ldGhvZF9yZWZzLm9uQnVzeShoYW5kbGVyKTtcbiAgfVxuXG4gIGdldFJlbW90ZUNhbGxTdGFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0aG9kX3JlZnMuZ2V0U3RhY2soKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgaGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgcmVtb3RlIHNpdGUgcmVxdWVzdHMgdG9cbiAgICogKHJlKXNlbmQgdGhlIGludGVyZmFjZS4gVXNlZCB0byBkZXRlY3QgYW4gaW5pdGlhbHphdGlvblxuICAgKiBjb21wbGV0aW9uIHdpdGhvdXQgc2VuZGluZyBhZGRpdGlvbmFsIHJlcXVlc3QsIHNpbmNlIGluIGZhY3RcbiAgICogJ2dldEludGVyZmFjZScgcmVxdWVzdCBpcyBvbmx5IHNlbnQgYnkgYXBwbGljYXRpb24gYXQgdGhlIGxhc3RcbiAgICogc3RlcCBvZiB0aGUgcGx1Z2luIGluaXRpYWxpemF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9uR2V0SW50ZXJmYWNlKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9nZXRJbnRlcmZhY2VIYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzZXQgb2YgcmVtb3RlIGludGVyZmFjZSBtZXRob2RzXG4gICAqL1xuICBnZXRSZW1vdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW90ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBzaXRlIG1ha2luZyBpdCBhdmFpbGFibGUgdG8gdGhlXG4gICAqIHJlbW90ZSBzaXRlIGJ5IHNlbmRpbmcgYSBtZXNzYWdlIHdpdGggYSBzZXQgb2YgbWV0aG9kcyBuYW1lc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gX2ludGVyZmFjZSB0byBzZXRcbiAgICovXG4gIHNldEludGVyZmFjZShfaW50ZXJmYWNlKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBmdW5jX25hbWUgb2YgdGhpcy5jb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbW90ZVtmdW5jX25hbWVdKSB7XG4gICAgICAgICAgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlW2Z1bmNfbmFtZV0pIHtcbiAgICAgICAgICAgICAgX2ludGVyZmFjZVtmdW5jX25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdGVbZnVuY19uYW1lXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIV9pbnRlcmZhY2UuY29uc3RydWN0b3IucHJvdG90eXBlW2Z1bmNfbmFtZV0pIHtcbiAgICAgICAgICAgICAgX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbZnVuY19uYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3RlW2Z1bmNfbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVyZmFjZSA9IF9pbnRlcmZhY2U7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgdGhlIGFjdHVhbCBpbnRlcmZhY2UgdG8gdGhlIHJlbW90ZSBzaXRlIHVwb24gaXQgd2FzXG4gICAqIHVwZGF0ZWQgb3IgYnkgYSBzcGVjaWFsIHJlcXVlc3Qgb2YgdGhlIHJlbW90ZSBzaXRlXG4gICAqL1xuICBzZW5kSW50ZXJmYWNlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLl9pbnRlcmZhY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJmYWNlIGlzIG5vdCBzZXQuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2ludGVyZmFjZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgb2YgT2JqZWN0LmtleXModGhpcy5faW50ZXJmYWNlKSkge1xuICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfXCIpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ludGVyZmFjZVtuYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKHsgbmFtZTogbmFtZSwgZGF0YTogbnVsbCwgdHlwZTogXCJmdW5jdGlvblwiIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2ludGVyZmFjZVtuYW1lXTtcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSBudWxsICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhMiA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBrIG9mIE9iamVjdC5rZXlzKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2tdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEyW2tdID0gXCJycGNfbWV0aG9kOjpcIiArIGs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEyW2tdID0gZGF0YVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmFtZXMucHVzaCh7IG5hbWU6IG5hbWUsIGRhdGE6IGRhdGEyLCB0eXBlOiBcIm9iamVjdFwiIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QoZGF0YSkgIT09IGRhdGEpIHtcbiAgICAgICAgICAgICAgbmFtZXMucHVzaCh7IG5hbWU6IG5hbWUsIGRhdGE6IGRhdGEsIHR5cGU6IFwiZGF0YVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYSBjbGFzc1xuICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJmYWNlLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgaW5zdGFudGlhdGUgdGhlIGNsYXNzIGJlZm9yZSBleHBvcnR0aW5nIGl0LlwiKTtcbiAgICAgIH1cbiAgICAgIC8vIGluc3RhbmNlIG9mIGEgY2xhc3NcbiAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFxuICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLl9pbnRlcmZhY2UpXG4gICAgICAgICkuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMuX2ludGVyZmFjZSkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuYW1lXyA9IGZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICBpZiAobmFtZV8uc3RhcnRzV2l0aChcIl9cIikgfHwgbmFtZV8gPT09IFwiY29uc3RydWN0b3JcIikgY29udGludWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pbnRlcmZhY2VbbmFtZV9dID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goeyBuYW1lOiBuYW1lXywgZGF0YTogbnVsbCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgaW50ZXJmYWNlIHR5cGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnRlcmZhY2VTZXRBc1JlbW90ZUhhbmRsZXIgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kKHsgdHlwZTogXCJzZXRJbnRlcmZhY2VcIiwgYXBpOiBuYW1lcyB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgbWVzc2FnZSBmcm9tIHRoZSByZW1vdGUgc2l0ZVxuICAgKi9cbiAgLy8gdmFyIGNhbGxiYWNrX3JlZyA9IG5ldyBSZWdFeHAoXCJvbnVwZGF0ZXxydW4kXCIpXG4gIF9wcm9jZXNzTWVzc2FnZShkYXRhKSB7XG4gICAgdmFyIHJlc29sdmUsIHJlamVjdCwgbWV0aG9kLCBhcmdzLCByZXN1bHQ7XG4gICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJtZXRob2RcIjpcbiAgICAgICAgdmFyIF9pbnRlcmZhY2UgPSB0aGlzLl9pbnRlcmZhY2U7XG4gICAgICAgIHZhciBfbWV0aG9kX2NvbnRleHQgPSBfaW50ZXJmYWNlLl9fdGhpc19fIHx8IF9pbnRlcmZhY2U7XG4gICAgICAgIGlmIChkYXRhLnBpZCkge1xuICAgICAgICAgIF9pbnRlcmZhY2UgPSB0aGlzLl9wbHVnaW5faW50ZXJmYWNlc1tkYXRhLnBpZF07XG4gICAgICAgICAgaWYgKCFfaW50ZXJmYWNlKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgICAgICAgIFtyZXNvbHZlLCByZWplY3RdID0gdGhpcy5fdW53cmFwKGRhdGEucHJvbWlzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgYHBsdWdpbiBhcGkgZnVuY3Rpb24gaXMgbm90IGF2YWlhbGJlIGluIFwiJHtkYXRhLnBpZH1cIiwgdGhlIHBsdWdpbiBtYXliZSB0ZXJtaW5hdGVkLmBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgYHBsdWdpbiBhcGkgZnVuY3Rpb24gaXMgbm90IGF2YWlhbGJlIGluICR7ZGF0YS5waWR9LCB0aGUgcGx1Z2luIG1heWJlIHRlcm1pbmF0ZWQuYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5uYW1lLmluZGV4T2YoXCIuXCIpICE9PSAtMSkge1xuICAgICAgICAgIHZhciBuYW1lcyA9IGRhdGEubmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgbWV0aG9kID0gX2ludGVyZmFjZVtuYW1lc1swXV1bbmFtZXNbMV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZCA9IF9pbnRlcmZhY2VbZGF0YS5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzID0gdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcbiAgICAgICAgICBbcmVzb2x2ZSwgcmVqZWN0XSA9IHRoaXMuX3Vud3JhcChkYXRhLnByb21pc2UsIGZhbHNlKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KF9tZXRob2RfY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAgIG1ldGhvZC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFzeW5jRnVuY3Rpb25cIilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgbWV0aG9kKTtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseShfbWV0aG9kX2NvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjYWxsYmFja1wiOlxuICAgICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgICAgW3Jlc29sdmUsIHJlamVjdF0gPSB0aGlzLl91bndyYXAoZGF0YS5wcm9taXNlLCBmYWxzZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1ldGhvZCA9IHRoaXMuX3N0b3JlLmZldGNoKGRhdGEubnVtKTtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiQ2FsbGJhY2sgZnVuY3Rpb24gY2FuIG9ubHkgY2FsbGVkIG9uY2UsIGlmIHlvdSB3YW50IHRvIGNhbGwgYSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgdGltZXMsIHBsZWFzZSBtYWtlIGl0IGFzIGEgcGx1Z2luIGFwaSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vaW1qb3kuaW8vZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlIHx8XG4gICAgICAgICAgICAgIChtZXRob2QuY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIG1ldGhvZCk7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZXRob2QgPSB0aGlzLl9zdG9yZS5mZXRjaChkYXRhLm51bSk7XG4gICAgICAgICAgICBhcmdzID0gdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgICB0aHJvdyBcIlBsZWFzZSBub3RpY2UgdGhhdCBjYWxsYmFjayBmdW5jdGlvbiBjYW4gb25seSBjYWxsZWQgb25jZSwgaWYgeW91IHdhbnQgdG8gY2FsbCBhIGZ1bmN0aW9uIGZvciBtdWx0aXBsZSB0aW1lcywgcGxlYXNlIG1ha2UgaXQgYXMgYSBwbHVnaW4gYXBpIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9pbWpveS5pby9kb2NzIGZvciBtb3JlIGRldGFpbHMuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZXRJbnRlcmZhY2VcIjpcbiAgICAgICAgdGhpcy5fc2V0UmVtb3RlKGRhdGEuYXBpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZ2V0SW50ZXJmYWNlXCI6XG4gICAgICAgIHRoaXMuc2VuZEludGVyZmFjZSgpO1xuICAgICAgICB0aGlzLl9nZXRJbnRlcmZhY2VIYW5kbGVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludGVyZmFjZVNldEFzUmVtb3RlXCI6XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faW50ZXJmYWNlU2V0QXNSZW1vdGVIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLl9pbnRlcmZhY2VTZXRBc1JlbW90ZUhhbmRsZXIoKTtcbiAgICAgICAgICB0aGlzLl9pbnRlcmZhY2VTZXRBc1JlbW90ZUhhbmRsZXIgPT09IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzY29ubmVjdFwiOlxuICAgICAgICB0aGlzLl9kaXNjb25uZWN0SGFuZGxlcigpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdHMgdG8gdGhlIHJlbW90ZSBzaXRlIGFza2luZyBpdCB0byBwcm92aWRlIGl0c1xuICAgKiBjdXJyZW50IGludGVyZmFjZVxuICAgKi9cbiAgcmVxdWVzdFJlbW90ZSgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLnNlbmQoeyB0eXBlOiBcImdldEludGVyZmFjZVwiIH0pO1xuICB9XG5cbiAgX25kYXJyYXkodHlwZWRBcnJheSwgc2hhcGUsIGR0eXBlKSB7XG4gICAgdmFyIF9kdHlwZSA9IHR5cGVkQXJyYXlUb0R0eXBlW3R5cGVkQXJyYXkuY29uc3RydWN0b3IubmFtZV07XG4gICAgaWYgKGR0eXBlICYmIGR0eXBlICE9PSBfZHR5cGUpIHtcbiAgICAgIHRocm93IFwiZHR5cGUgZG9lc24ndCBtYXRjaCB0aGUgdHlwZSBvZiB0aGUgYXJyYXk6IFwiICtcbiAgICAgICAgX2R0eXBlICtcbiAgICAgICAgXCIgIT0gXCIgK1xuICAgICAgICBkdHlwZTtcbiAgICB9XG4gICAgc2hhcGUgPSBzaGFwZSB8fCBbdHlwZWRBcnJheS5sZW5ndGhdO1xuICAgIHJldHVybiB7XG4gICAgICBfX2phaWxlZF90eXBlX186IFwibmRhcnJheVwiLFxuICAgICAgX192YWx1ZV9fOiB0eXBlZEFycmF5LFxuICAgICAgX19zaGFwZV9fOiBzaGFwZSxcbiAgICAgIF9fZHR5cGVfXzogX2R0eXBlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuZXcgcmVtb3RlIGludGVyZmFjZSBwcm92aWRlZCBieSB0aGUgb3RoZXIgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBsaXN0IG9mIGZ1bmN0aW9uIG5hbWVzXG4gICAqL1xuICBfc2V0UmVtb3RlKGFwaSkge1xuICAgIHRoaXMuX3JlbW90ZSA9IHt9O1xuICAgIHZhciBpLCBuYW1lLCBkYXRhLCB0eXBlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcGkubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWUgPSBhcGlbaV0ubmFtZTtcbiAgICAgIGRhdGEgPSBhcGlbaV0uZGF0YTtcbiAgICAgIHR5cGUgPSBhcGlbaV0udHlwZTtcbiAgICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgICB0aGlzLl9yZW1vdGVbbmFtZV0gPSBkYXRhO1xuICAgICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHZhciBkYXRhMiA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhW2tleV0gPT09IFwicnBjX21ldGhvZDo6XCIgKyBrZXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhMltrZXldID0gdGhpcy5fZ2VuUmVtb3RlTWV0aG9kKG5hbWUgKyBcIi5cIiArIGtleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YTJba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZW1vdGVbbmFtZV0gPSBkYXRhMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdGVbbmFtZV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdGVbbmFtZV0gPSB0aGlzLl9nZW5SZW1vdGVNZXRob2QobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcmVtb3RlVXBkYXRlSGFuZGxlcigpO1xuICAgIHRoaXMuX3JlcG9ydFJlbW90ZVNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgd3JhcHBlZCBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIHJlbW90ZVxuICAgKiBtZXRob2QuIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZCB0aGVcbiAgICogY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG8gZXhlY3V0ZVxuICAgKiB0aGUgcGFydGljdWxhciBtZXRob2Qgb2YgaXRzIGludGVyZmFjZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgcmVtb3RlIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgcmVtb3RlIG1ldGhvZFxuICAgKi9cbiAgX2dlblJlbW90ZU1ldGhvZChuYW1lLCBwbHVnaW5faWQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZW1vdGVNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWQgPSBtZS5fbWV0aG9kX3JlZnMucHV0KHBsdWdpbl9pZCA/IHBsdWdpbl9pZCArIFwiL1wiICsgbmFtZSA6IG5hbWUpO1xuICAgICAgICAgIHZhciB3cmFwcGVkX3Jlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gbnVsbCkgbWUuX21ldGhvZF9yZWZzLmZldGNoKGlkKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgd3JhcHBlZF9yZWplY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gbnVsbCkgbWUuX21ldGhvZF9yZWZzLmZldGNoKGlkKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgd3JhcHBlZF9yZXNvbHZlLl9famFpbGVkX3BhaXJzX18gPSB3cmFwcGVkX3JlamVjdDtcbiAgICAgICAgICB3cmFwcGVkX3JlamVjdC5fX2phaWxlZF9wYWlyc19fID0gd3JhcHBlZF9yZXNvbHZlO1xuXG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChuYW1lID09PSBcInJlZ2lzdGVyXCIgfHwgbmFtZSA9PT0gXCJleHBvcnRcIiB8fCBuYW1lID09PSBcIm9uXCIpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBtZS5fd3JhcChhcmdzLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncyA9IG1lLl93cmFwKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICBtZS5fY29ubmVjdGlvbi5zZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcIm1ldGhvZFwiLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBwaWQ6IHBsdWdpbl9pZCxcbiAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgcHJvbWlzZTogbWUuX3dyYXAoW3dyYXBwZWRfcmVzb2x2ZSwgd3JhcHBlZF9yZWplY3RdKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXNcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGlkKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3R1ZSByZW1vdGUgbWV0aG9kIChwbHVnaW46ICR7cGx1Z2luX2lkIHx8XG4gICAgICAgICAgICAgIG1lLmlkfSwgbWV0aG9kOiAke25hbWV9KSwgZXJyb3I6ICR7ZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZW1vdGVNZXRob2QuX19yZW1vdGVfbWV0aG9kID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVtb3RlTWV0aG9kO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVzcG9uY2UgcmVwb3J0aW5nIHRoYXQgaW50ZXJmYWNlIGp1c3QgcHJvdmlkZWQgYnkgdGhlXG4gICAqIHJlbW90ZSBzaXRlIHdhcyBzdWNjZXNzZnVsbHkgc2V0IGJ5IHRoaXMgc2l0ZSBhcyByZW1vdGVcbiAgICovXG4gIF9yZXBvcnRSZW1vdGVTZXQoKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kKHsgdHlwZTogXCJpbnRlcmZhY2VTZXRBc1JlbW90ZVwiIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSBwcm92aWRlZCBzZXQgb2YgcmVtb3RlIG1ldGhvZCBhcmd1bWVudHMgZm9yXG4gICAqIHNlbmRpbmcgdG8gdGhlIHJlbW90ZSBzaXRlLCByZXBsYWNlcyBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoXG4gICAqIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdG8gd3JhcFxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHdyYXBwZWQgYXJndW1lbnRzXG4gICAqL1xuXG4gIF9lbmNvZGVfaW50ZXJmYWNlKGFPYmplY3QsIGJPYmplY3QpIHtcbiAgICB2YXIgdiwgaztcbiAgICBjb25zdCBlbmNvZGVkX2ludGVyZmFjZSA9IHt9O1xuICAgIGFPYmplY3RbXCJfX2lkX19cIl0gPSBhT2JqZWN0W1wiX19pZF9fXCJdIHx8IHJhbmRJZCgpO1xuICAgIGZvciAoayBpbiBhT2JqZWN0KSB7XG4gICAgICBpZiAoayA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiKSBjb250aW51ZTtcbiAgICAgIGlmIChhT2JqZWN0Lmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgIGlmIChrLnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdiA9IGFPYmplY3Rba107XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBiT2JqZWN0W2tdID0ge1xuICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcInBsdWdpbl9pbnRlcmZhY2VcIixcbiAgICAgICAgICAgIF9fcGx1Z2luX2lkX186IGFPYmplY3RbXCJfX2lkX19cIl0sXG4gICAgICAgICAgICBfX3ZhbHVlX186IGssXG4gICAgICAgICAgICBudW06IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVuY29kZWRfaW50ZXJmYWNlW2tdID0gdjtcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QodikgIT09IHYpIHtcbiAgICAgICAgICBiT2JqZWN0W2tdID0geyBfX2phaWxlZF90eXBlX186IFwiYXJndW1lbnRcIiwgX192YWx1ZV9fOiB2IH07XG4gICAgICAgICAgZW5jb2RlZF9pbnRlcmZhY2Vba10gPSB2O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IEFycmF5LmlzQXJyYXkodikgPyBbXSA6IHt9O1xuICAgICAgICAgIHRoaXMuX2VuY29kZV9pbnRlcmZhY2UodiwgYk9iamVjdFtrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcGx1Z2luX2ludGVyZmFjZXNbYU9iamVjdFtcIl9faWRfX1wiXV0gPSBlbmNvZGVkX2ludGVyZmFjZTtcblxuICAgIGlmIChhT2JqZWN0Lm9uKSB7XG4gICAgICBhT2JqZWN0Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fcGx1Z2luX2ludGVyZmFjZXNbYU9iamVjdFtcIl9faWRfX1wiXV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZW5jb2RlKGFPYmplY3QsIGFzX2ludGVyZmFjZSkge1xuICAgIHZhciB0cmFuc2ZlcmFibGVzID0gW107XG4gICAgaWYgKCFhT2JqZWN0KSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG4gICAgdmFyIF90cmFuc2ZlciA9IGFPYmplY3QuX3RyYW5zZmVyO1xuICAgIHZhciBiT2JqZWN0LCB2LCBrO1xuICAgIHZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheShhT2JqZWN0KTtcbiAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgLy9za2lwIGlmIGFscmVhZHkgZW5jb2RlZFxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBhT2JqZWN0ID09PSBcIm9iamVjdFwiICYmXG4gICAgICBhT2JqZWN0Ll9famFpbGVkX3R5cGVfXyAmJlxuICAgICAgYU9iamVjdC5fX3ZhbHVlX19cbiAgICApIHtcbiAgICAgIHJldHVybiBhT2JqZWN0O1xuICAgIH1cblxuICAgIC8vZW5jb2RlIGludGVyZmFjZXNcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgYU9iamVjdCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgIUFycmF5LmlzQXJyYXkoYU9iamVjdCkgJiZcbiAgICAgIChhT2JqZWN0Ll9fYXNfaW50ZXJmYWNlX18gfHwgYXNfaW50ZXJmYWNlKVxuICAgICkge1xuICAgICAgdGhpcy5fZW5jb2RlX2ludGVyZmFjZShhT2JqZWN0LCBiT2JqZWN0KTtcbiAgICAgIHJldHVybiBiT2JqZWN0O1xuICAgIH1cblxuICAgIGlmIChhc19pbnRlcmZhY2UpIHtcbiAgICAgIGFPYmplY3RbXCJfX2lkX19cIl0gPSBhT2JqZWN0W1wiX19pZF9fXCJdIHx8IHJhbmRJZCgpO1xuICAgICAgdGhpcy5fcGx1Z2luX2ludGVyZmFjZXNbYU9iamVjdFtcIl9faWRfX1wiXV0gPVxuICAgICAgICB0aGlzLl9wbHVnaW5faW50ZXJmYWNlc1thT2JqZWN0W1wiX19pZF9fXCJdXSB8fCB7fTtcbiAgICB9XG4gICAgZm9yIChrIGluIGFPYmplY3QpIHtcbiAgICAgIGlmIChrID09PSBcImhhc093blByb3BlcnR5XCIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGlzYXJyYXkgfHwgYU9iamVjdC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICB2ID0gYU9iamVjdFtrXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pbnRlcmZhY2UuX3JwY0VuY29kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZF9vYmogPSB0aGlzLl9pbnRlcmZhY2UuX3JwY0VuY29kZSh2KTtcbiAgICAgICAgICBpZiAoZW5jb2RlZF9vYmogJiYgZW5jb2RlZF9vYmouX19ycGNfZHR5cGVfXykge1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcImN1c3RvbV9lbmNvZGluZ1wiLFxuICAgICAgICAgICAgICBfX3ZhbHVlX186IGVuY29kZWRfb2JqXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHRoZSByZXR1cm5lZCBvYmplY3QgZG9lcyBub3QgY29udGFpbiBfX2phaWxlZF90eXBlX18sIGFzc3VtaW5nIHRoZSBvYmplY3QgaGFzIGJlZW4gdHJhbnNmb3JtZWRcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYgPSBlbmNvZGVkX29iajtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAoYXNfaW50ZXJmYWNlKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkX2ludGVyZmFjZSA9IHRoaXMuX3BsdWdpbl9pbnRlcmZhY2VzW1xuICAgICAgICAgICAgICBhT2JqZWN0W1wiX19pZF9fXCJdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcInBsdWdpbl9pbnRlcmZhY2VcIixcbiAgICAgICAgICAgICAgX19wbHVnaW5faWRfXzogYU9iamVjdFtcIl9faWRfX1wiXSxcbiAgICAgICAgICAgICAgX192YWx1ZV9fOiBrLFxuICAgICAgICAgICAgICBudW06IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbmNvZGVkX2ludGVyZmFjZVtrXSA9IHY7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGludGVyZmFjZUZ1bmNOYW1lID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX2ludGVyZmFjZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiX1wiKSkgY29udGludWU7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcmZhY2VbbmFtZV0gPT09IHYpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmZhY2VGdW5jTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2VhcmNoIGZvciBwcm90b3R5cGVzXG4gICAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuX2ludGVyZmFjZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8gPSBmdW5jdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAobmFtZV8uc3RhcnRzV2l0aChcIl9cIikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVyZmFjZVtuYW1lX10gPT09IHYpIHtcbiAgICAgICAgICAgICAgaW50ZXJmYWNlRnVuY05hbWUgPSBuYW1lXztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaW50ZXJmYWNlRnVuY05hbWUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX3N0b3JlLnB1dCh2KTtcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgICBfX3ZhbHVlX186ICh2LmNvbnN0cnVjdG9yICYmIHYuY29uc3RydWN0b3IubmFtZSkgfHwgaWQsXG4gICAgICAgICAgICAgIG51bTogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJpbnRlcmZhY2VcIixcbiAgICAgICAgICAgICAgX192YWx1ZV9fOiBpbnRlcmZhY2VGdW5jTmFtZSxcbiAgICAgICAgICAgICAgbnVtOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvKmdsb2JhbCB0ZiovXG4gICAgICAgICAgdHlwZW9mIHRmICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgdGYuVGVuc29yICYmXG4gICAgICAgICAgdiBpbnN0YW5jZW9mIHRmLlRlbnNvclxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCB2X2J1ZmZlciA9IHYuZGF0YVN5bmMoKTtcbiAgICAgICAgICBpZiAodi5fdHJhbnNmZXIgfHwgX3RyYW5zZmVyKSB7XG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2godl9idWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB2Ll90cmFuc2ZlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJuZGFycmF5XCIsXG4gICAgICAgICAgICBfX3ZhbHVlX186IHZfYnVmZmVyLFxuICAgICAgICAgICAgX19zaGFwZV9fOiB2LnNoYXBlLFxuICAgICAgICAgICAgX19kdHlwZV9fOiB2LmR0eXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvKmdsb2JhbCBuaiovXG4gICAgICAgICAgdHlwZW9mIG5qICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgbmouTmRBcnJheSAmJlxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBuai5OZEFycmF5XG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBkdHlwZSA9IHR5cGVkQXJyYXlUb0R0eXBlW3Yuc2VsZWN0aW9uLmRhdGEuY29uc3RydWN0b3IubmFtZV07XG4gICAgICAgICAgaWYgKHYuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHYuc2VsZWN0aW9uLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB2Ll90cmFuc2ZlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJuZGFycmF5XCIsXG4gICAgICAgICAgICBfX3ZhbHVlX186IHYuc2VsZWN0aW9uLmRhdGEsXG4gICAgICAgICAgICBfX3NoYXBlX186IHYuc2hhcGUsXG4gICAgICAgICAgICBfX2R0eXBlX186IGR0eXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHYpO1xuICAgICAgICAgIGJPYmplY3Rba10gPSB7IF9famFpbGVkX3R5cGVfXzogXCJlcnJvclwiLCBfX3ZhbHVlX186IHYudG9TdHJpbmcoKSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHYgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJmaWxlXCIsXG4gICAgICAgICAgICBfX3ZhbHVlX186IHYsXG4gICAgICAgICAgICBfX3JlbGF0aXZlX3BhdGhfXzogdi5yZWxhdGl2ZVBhdGggfHwgdi53ZWJraXRSZWxhdGl2ZVBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlbmQgb2JqZWN0cyBzdXBwb3J0ZWQgYnkgc3RydWN0dXJlIGNsb25lIGFsZ29yaXRobVxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1dvcmtlcnNfQVBJL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtXG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIHYgIT09IE9iamVjdCh2KSB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgICAgICAgdiBpbnN0YW5jZW9mIFN0cmluZyB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgdiBpbnN0YW5jZW9mIFJlZ0V4cCB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBCbG9iIHx8XG4gICAgICAgICAgdiBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fFxuICAgICAgICAgICh0eXBlb2YgRmlsZUxpc3QgIT09IFwidW5kZWZpbmVkXCIgJiYgdiBpbnN0YW5jZW9mIEZpbGVMaXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICBiT2JqZWN0W2tdID0geyBfX2phaWxlZF90eXBlX186IFwiYXJndW1lbnRcIiwgX192YWx1ZV9fOiB2IH07XG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgaWYgKHYuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHYpO1xuICAgICAgICAgICAgZGVsZXRlIHYuX3RyYW5zZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiT2JqZWN0W2tdID0geyBfX2phaWxlZF90eXBlX186IFwiYXJndW1lbnRcIiwgX192YWx1ZV9fOiB2IH07XG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyVmlldykge1xuICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh2LmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7IF9famFpbGVkX3R5cGVfXzogXCJhcmd1bWVudFwiLCBfX3ZhbHVlX186IHYgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFsc28gTWFwIGFuZCBTZXRcbiAgICAgICAgLy8gVE9ETzogYXZvaWQgb2JqZWN0IHN1Y2ggYXMgRHluYW1pY1BsdWdpbiBpbnN0YW5jZS5cbiAgICAgICAgZWxzZSBpZiAodi5fX2FzX2ludGVyZmFjZV9fKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHRoaXMuX2VuY29kZSh2LCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHRoaXMuX2VuY29kZSh2LCBhc19pbnRlcmZhY2UpO1xuICAgICAgICAgIC8vIG1vdmUgdHJhbnNmZXJhYmxlcyB0byB0aGUgdG9wIGxldmVsIG9iamVjdFxuICAgICAgICAgIGlmIChiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGJPYmplY3Rba10uX190cmFuc2ZlcmFibGVzX18ubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGJPYmplY3Rba10uX190cmFuc2ZlcmFibGVzX19bdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGJPYmplY3Rba10uX190cmFuc2ZlcmFibGVzX187XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICB0aHJvdyBcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBmb3IgdHJhbnNmZXJyaW5nIGJldHdlZW4gdGhlIHBsdWdpbiBhbmQgdGhlIG1haW4gYXBwOiBcIiArXG4gICAgICAgICAgICBrICtcbiAgICAgICAgICAgIFwiIDogXCIgK1xuICAgICAgICAgICAgdi5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIGZvciB0cmFuc2ZlcnJpbmcgYmV0d2VlbiB0aGUgcGx1Z2luIGFuZCB0aGUgbWFpbiBhcHA6IFwiICtcbiAgICAgICAgICAgIGsgK1xuICAgICAgICAgICAgXCIsXCIgK1xuICAgICAgICAgICAgdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBiT2JqZWN0Ll9fdHJhbnNmZXJhYmxlc19fID0gdHJhbnNmZXJhYmxlcztcbiAgICB9XG4gICAgcmV0dXJuIGJPYmplY3Q7XG4gIH1cblxuICBfZGVjb2RlKGFPYmplY3QsIGNhbGxiYWNrSWQsIHdpdGhQcm9taXNlKSB7XG4gICAgaWYgKCFhT2JqZWN0KSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG4gICAgdmFyIGJPYmplY3QsIHYsIGs7XG5cbiAgICBpZiAoXG4gICAgICBhT2JqZWN0Lmhhc093blByb3BlcnR5KFwiX19qYWlsZWRfdHlwZV9fXCIpICYmXG4gICAgICBhT2JqZWN0Lmhhc093blByb3BlcnR5KFwiX192YWx1ZV9fXCIpXG4gICAgKSB7XG4gICAgICBpZiAoYU9iamVjdC5fX2phaWxlZF90eXBlX18uc3RhcnRzV2l0aChcImN1c3RvbV9lbmNvZGluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ludGVyZmFjZS5fcnBjRGVjb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBkZWNvZGVkT2JqID0gdGhpcy5faW50ZXJmYWNlLl9ycGNEZWNvZGUoYU9iamVjdC5fX3ZhbHVlX18pO1xuICAgICAgICAgIGJPYmplY3QgPSBkZWNvZGVkT2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX19qYWlsZWRfdHlwZV9fID09PSBcImNhbGxiYWNrXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX2dlblJlbW90ZUNhbGxiYWNrKGNhbGxiYWNrSWQsIGFPYmplY3QubnVtLCB3aXRoUHJvbWlzZSk7XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX19qYWlsZWRfdHlwZV9fID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgIGJPYmplY3QgPVxuICAgICAgICAgIHRoaXMuX3JlbW90ZVthT2JqZWN0Ll9fdmFsdWVfX10gfHxcbiAgICAgICAgICB0aGlzLl9nZW5SZW1vdGVNZXRob2QoYU9iamVjdC5fX3ZhbHVlX18pO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9famFpbGVkX3R5cGVfXyA9PT0gXCJwbHVnaW5faW50ZXJmYWNlXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX2dlblJlbW90ZU1ldGhvZChcbiAgICAgICAgICBhT2JqZWN0Ll9fdmFsdWVfXyxcbiAgICAgICAgICBhT2JqZWN0Ll9fcGx1Z2luX2lkX19cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fX2phaWxlZF90eXBlX18gPT09IFwibmRhcnJheVwiKSB7XG4gICAgICAgIC8qZ2xvYmFsIG5qIHRmKi9cbiAgICAgICAgLy9jcmVhdGUgYnVpbGQgYXJyYXkvdGVuc29yIGlmIHVzZWQgaW4gdGhlIHBsdWdpblxuICAgICAgICBpZiAodGhpcy5pZCA9PT0gXCJfX3BsdWdpbl9fXCIgJiYgdHlwZW9mIG5qICE9PSBcInVuZGVmaW5lZFwiICYmIG5qLmFycmF5KSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYU9iamVjdC5fX3ZhbHVlX18pKSB7XG4gICAgICAgICAgICBhT2JqZWN0Ll9fdmFsdWVfXyA9IGFPYmplY3QuX192YWx1ZV9fLnJlZHVjZShfYXBwZW5kQnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYk9iamVjdCA9IG5qXG4gICAgICAgICAgICAuYXJyYXkoYU9iamVjdC5fX3ZhbHVlX18sIGFPYmplY3QuX19kdHlwZV9fKVxuICAgICAgICAgICAgLnJlc2hhcGUoYU9iamVjdC5fX3NoYXBlX18pO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHRoaXMuaWQgPT09IFwiX19wbHVnaW5fX1wiICYmXG4gICAgICAgICAgdHlwZW9mIHRmICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgdGYuVGVuc29yXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFPYmplY3QuX192YWx1ZV9fKSkge1xuICAgICAgICAgICAgYU9iamVjdC5fX3ZhbHVlX18gPSBhT2JqZWN0Ll9fdmFsdWVfXy5yZWR1Y2UoX2FwcGVuZEJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3QgPSB0Zi50ZW5zb3IoXG4gICAgICAgICAgICBhT2JqZWN0Ll9fdmFsdWVfXyxcbiAgICAgICAgICAgIGFPYmplY3QuX19zaGFwZV9fLFxuICAgICAgICAgICAgYU9iamVjdC5fX2R0eXBlX19cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8va2VlcCBpdCBhcyByZWd1bGFyIGlmIHRyYW5zZmVyZWQgdG8gdGhlIG1haW4gYXBwXG4gICAgICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fX2phaWxlZF90eXBlX18gPT09IFwiZXJyb3JcIikge1xuICAgICAgICBiT2JqZWN0ID0gbmV3IEVycm9yKGFPYmplY3QuX192YWx1ZV9fKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fX2phaWxlZF90eXBlX18gPT09IFwiZmlsZVwiKSB7XG4gICAgICAgIGJPYmplY3QgPSBhT2JqZWN0Ll9fdmFsdWVfXztcbiAgICAgICAgLy9wYXRjaCByZWxhdGl2ZVBhdGhcbiAgICAgICAgYk9iamVjdC5yZWxhdGl2ZVBhdGggPSBhT2JqZWN0Ll9fcmVsYXRpdmVfcGF0aF9fO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9famFpbGVkX3R5cGVfXyA9PT0gXCJhcmd1bWVudFwiKSB7XG4gICAgICAgIGJPYmplY3QgPSBhT2JqZWN0Ll9fdmFsdWVfXztcbiAgICAgIH1cbiAgICAgIHJldHVybiBiT2JqZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkoYU9iamVjdCk7XG4gICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgICBmb3IgKGsgaW4gYU9iamVjdCkge1xuICAgICAgICBpZiAoaXNhcnJheSB8fCBhT2JqZWN0Lmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgdiA9IGFPYmplY3Rba107XG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB0aGlzLl9kZWNvZGUodiwgY2FsbGJhY2tJZCwgd2l0aFByb21pc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJPYmplY3Q7XG4gICAgfVxuICB9XG5cbiAgX3dyYXAoYXJncywgYXNfaW50ZXJmYWNlKSB7XG4gICAgdmFyIHdyYXBwZWQgPSB0aGlzLl9lbmNvZGUoYXJncywgYXNfaW50ZXJmYWNlKTtcbiAgICB2YXIgcmVzdWx0ID0geyBhcmdzOiB3cmFwcGVkIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbndyYXBzIHRoZSBzZXQgb2YgYXJndW1lbnRzIGRlbGl2ZXJlZCBmcm9tIHRoZSByZW1vdGUgc2l0ZSxcbiAgICogcmVwbGFjZXMgYWxsIGNhbGxiYWNrIGlkZW50aWZpZXJzIHdpdGggYSBmdW5jdGlvbiB3aGljaCB3aWxsXG4gICAqIGluaXRpYXRlIHNlbmRpbmcgdGhhdCBjYWxsYmFjayBpZGVudGlmaWVyIGJhY2sgdG8gb3RoZXIgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyB0byB1bndyYXBcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aXRoUHJvbWlzZSBpcyB0cnVlIG1lYW5zIHRoaXMgdGhlIGNhbGxiYWNrIHNob3VsZCBjb250YWluIGEgcHJvbWlzZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHVud3JhcHBlZCBhcmdzXG4gICAqL1xuICBfdW53cmFwKGFyZ3MsIHdpdGhQcm9taXNlKSB7XG4gICAgLy8gdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgLy8gd3JhcHMgZWFjaCBjYWxsYmFjayBzbyB0aGF0IHRoZSBvbmx5IG9uZSBjb3VsZCBiZSBjYWxsZWRcbiAgICAvLyB2YXIgb25jZShjYikge1xuICAgIC8vICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgIC8vICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgLy8gICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gICAgICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgICAgIHZhciBtc2cgPVxuICAgIC8vICAgICAgICAgICAgICAgJ0EgY2FsbGJhY2sgZnJvbSB0aGlzIHNldCBoYXMgYWxyZWFkeSBiZWVuIGV4ZWN1dGVkJztcbiAgICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfTtcbiAgICAvLyB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlY29kZShhcmdzLmFyZ3MsIGFyZ3MuY2FsbGJhY2tJZCwgd2l0aFByb21pc2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gYSBzaW5nbGUgcmVtb3RlXG4gICAqIGNhbGxiYWNrLiBXaGVuIHRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgY2FsbGVkLCBpdCB3aWxsIHNlbmRcbiAgICogdGhlIGNvcnJlc3BvbmRpbmcgbWVzc2FnZSB0byB0aGUgcmVtb3RlIHNpdGUgYXNraW5nIGl0IHRvXG4gICAqIGV4ZWN1dGUgdGhlIHBhcnRpY3VsYXIgY2FsbGJhY2sgcHJldmlvdXNseSBzYXZlZCBkdXJpbmcgYSBjYWxsXG4gICAqIGJ5IHRoZSByZW1vdGUgc2l0ZSBhIG1ldGhvZCBmcm9tIHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBzaXRlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBvZiB0aGUgcmVtb3RlIGNhbGxiYWNrIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ051bSBhcmd1bWVudCBpbmRleCBvZiB0aGUgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aXRoUHJvbWlzZSBpcyB0cnVlIG1lYW5zIHRoaXMgdGhlIGNhbGxiYWNrIHNob3VsZCBjb250YWluIGEgcHJvbWlzZVxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgcmVtb3RlIGNhbGxiYWNrXG4gICAqL1xuICBfZ2VuUmVtb3RlQ2FsbGJhY2soaWQsIGFyZ051bSwgd2l0aFByb21pc2UpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZW1vdGVDYWxsYmFjaztcbiAgICBpZiAod2l0aFByb21pc2UpIHtcbiAgICAgIHJlbW90ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBtZS5fd3JhcChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICByZXNvbHZlLl9famFpbGVkX3BhaXJzX18gPSByZWplY3Q7XG4gICAgICAgICAgcmVqZWN0Ll9famFpbGVkX3BhaXJzX18gPSByZXNvbHZlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZS5fY29ubmVjdGlvbi5zZW5kKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBudW06IGFyZ051bSxcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgIC8vIHBpZCA6ICBtZS5pZCxcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBtZS5fd3JhcChbcmVzb2x2ZSwgcmVqZWN0XSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3R1ZSByZW1vdGUgY2FsbGJhY2sgKGlkOiAke2lkfSwgYXJnTnVtOiAke2FyZ051bX0pLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW90ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgcmV0dXJuIG1lLl9jb25uZWN0aW9uLnNlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgbnVtOiBhcmdOdW0sXG4gICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAvLyBwaWQgOiAgbWUuaWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyYW5zZmVyYWJsZXNcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZSBhbmQgYnJlYWtzIHRoZSBjb25uZWN0aW9uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZCh7IHR5cGU6IFwiZGlzY29ubmVjdFwiIH0pO1xuICAgIHNldFRpbWVvdXQodGhpcy5fY29ubmVjdGlvbi5kaXNjb25uZWN0LCAyMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHJlY2VpdmVkIGEgZGlzY29ubmVjdCBtZXNzYWdlXG4gICAqIGZyb20gdGhlIHJlbW90ZSBzaXRlXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9uRGlzY29ubmVjdChoYW5kbGVyKSB7XG4gICAgdGhpcy5fZGlzY29ubmVjdEhhbmRsZXIgPSBoYW5kbGVyO1xuICB9XG59XG5cbi8qKlxuICogUmVmZXJlbmNlU3RvcmUgaXMgYSBzcGVjaWFsIG9iamVjdCB3aGljaCBzdG9yZXMgb3RoZXIgb2JqZWN0c1xuICogYW5kIHByb3ZpZGVzIHRoZSByZWZlcmVuY2VzIChudW1iZXIpIGluc3RlYWQuIFRoaXMgcmVmZXJlbmNlXG4gKiBtYXkgdGhlbiBiZSBzZW50IG92ZXIgYSBqc29uLWJhc2VkIGNvbW11bmljYXRpb24gY2hhbm5lbCAoSVBDXG4gKiB0byBhbm90aGVyIE5vZGUuanMgcHJvY2VzcyBvciBhIG1lc3NhZ2UgdG8gdGhlIFdvcmtlcikuIE90aGVyXG4gKiBzaXRlIG1heSB0aGVuIHByb3ZpZGUgdGhlIHJlZmVyZW5jZSBpbiB0aGUgcmVzcG9uY2UgbWVzc2FnZVxuICogaW1wbHlpbmcgdGhlIGdpdmVuIG9iamVjdCBzaG91bGQgYmUgYWN0aXZhdGVkLlxuICpcbiAqIFByaW1hcnkgdXNhZ2UgZm9yIHRoZSBSZWZlcmVuY2VTdG9yZSBpcyBhIHN0b3JhZ2UgZm9yIHRoZVxuICogY2FsbGJhY2tzLCB3aGljaCB0aGVyZWZvcmUgbWFrZXMgaXQgcG9zc2libGUgdG8gaW5pdGlhdGUgYVxuICogY2FsbGJhY2sgZXhlY3V0aW9uIGJ5IHRoZSBvcHBvc2l0ZSBzaXRlICh3aGljaCBub3JtYWxseSBjYW5ub3RcbiAqIGRpcmVjdGx5IGV4ZWN1dGUgZnVuY3Rpb25zIG92ZXIgdGhlIGNvbW11bmljYXRpb24gY2hhbm5lbCkuXG4gKlxuICogRWFjaCBzdG9yZWQgb2JqZWN0IGNhbiBvbmx5IGJlIGZldGNoZWQgb25jZSBhbmQgaXMgbm90XG4gKiBhdmFpbGFibGUgZm9yIHRoZSBzZWNvbmQgdGltZS4gRWFjaCBzdG9yZWQgb2JqZWN0IG11c3QgYmVcbiAqIGZldGNoZWQsIHNpbmNlIG90aGVyd2lzZSBpdCB3aWxsIHJlbWFpbiBzdG9yZWQgZm9yZXZlciBhbmRcbiAqIGNvbnN1bWUgbWVtb3J5LlxuICpcbiAqIFN0b3JlZCBvYmplY3QgaW5kZWNlcyBhcmUgc2ltcGx5IHRoZSBudW1iZXJzLCB3aGljaCBhcmUgaG93ZXZlclxuICogcmVsZWFzZWQgYWxvbmcgd2l0aCB0aGUgb2JqZWN0cywgYW5kIGFyZSBsYXRlciByZXVzZWQgYWdhaW4gKGluXG4gKiBvcmRlciB0byBwb3N0cG9uZSB0aGUgb3ZlcmZsb3csIHdoaWNoIHNob3VsZCBub3QgbGlrZWx5IGhhcHBlbixcbiAqIGJ1dCBhbnl3YXkpLlxuICovXG5jbGFzcyBSZWZlcmVuY2VTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N0b3JlID0ge307IC8vIHN0b3JlZCBvYmplY3RcbiAgICB0aGlzLl9pbmRpY2VzID0gWzBdOyAvLyBzbWFsbGVzdCBhdmFpbGFibGUgaW5kaWNlc1xuICAgIHRoaXMuX3JlYWR5SGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5fYnVzeUhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX3JlYWR5SGFuZGxlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGwgaGFuZGxlciB3aGVuIHRoZSBzdG9yZSBpcyBlbXB0eVxuICAgKlxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcbiAgICovXG4gIG9uUmVhZHkocmVhZHlIYW5kbGVyKSB7XG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyID0gcmVhZHlIYW5kbGVyIHx8IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICAvKipcbiAgICogY2FsbCBoYW5kbGVyIHdoZW4gdGhlIHN0b3JlIGlzIG5vdCBlbXB0eVxuICAgKlxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcbiAgICovXG4gIG9uQnVzeShidXN5SGFuZGxlcikge1xuICAgIHRoaXMuX2J1c3lIYW5kbGVyID0gYnVzeUhhbmRsZXIgfHwgZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgc3RvcmVcbiAgICpcbiAgICovXG4gIGdldFN0YWNrKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdG9yZSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBfZ2VuSWQoKSBnZW5lcmF0ZXMgdGhlIG5ldyByZWZlcmVuY2UgaWRcbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gc21hbGxlc3QgYXZhaWxhYmxlIGlkIGFuZCByZXNlcnZlcyBpdFxuICAgKi9cbiAgX2dlbklkKCkge1xuICAgIHZhciBpZDtcbiAgICBpZiAodGhpcy5faW5kaWNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlkID0gdGhpcy5faW5kaWNlc1swXSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuX2luZGljZXMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIHJlZmVyZW5jZSBpZCBzbyB0aGF0IGl0IHdpbGwgYmUgYXZhaWxhYmxlIGJ5XG4gICAqIGFub3RoZXIgb2JqZWN0IHN0b3JlZFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgdG8gcmVsZWFzZVxuICAgKi9cbiAgX3JlbGVhc2VJZChpZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlkIDwgdGhpcy5faW5kaWNlc1tpXSkge1xuICAgICAgICB0aGlzLl9pbmRpY2VzLnNwbGljZShpLCAwLCBpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFuaW5nLXVwIHRoZSBzZXF1ZW5jZSB0YWlsXG4gICAgZm9yIChpID0gdGhpcy5faW5kaWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuX2luZGljZXNbaV0gLSAxID09PSB0aGlzLl9pbmRpY2VzW2kgLSAxXSkge1xuICAgICAgICB0aGlzLl9pbmRpY2VzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSByZWZlcm5jZSBpZCBpbnN0ZWFkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdG8gc3RvcmVcbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gcmVmZXJlbmNlIGlkIG9mIHRoZSBzdG9yZWQgb2JqZWN0XG4gICAqL1xuICBwdXQob2JqKSB7XG4gICAgaWYgKHRoaXMuX2J1c3lIYW5kbGVyICYmIE9iamVjdC5rZXlzKHRoaXMuX3N0b3JlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2J1c3lIYW5kbGVyKCk7XG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuX2dlbklkKCk7XG4gICAgdGhpcy5fc3RvcmVbaWRdID0gb2JqO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcHJldmlvdXNseSBzdG9yZWQgb2JqZWN0IGFuZCByZWxlYXNlcyBpdHMgcmVmZXJlbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBvZiBhbiBvYmplY3QgdG8gcmV0cmlldmVcbiAgICovXG4gIGZldGNoKGlkKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMuX3N0b3JlW2lkXTtcbiAgICBpZiAob2JqICYmICFvYmouX19yZW1vdGVfbWV0aG9kKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RvcmVbaWRdO1xuICAgICAgdGhpcy5fcmVsZWFzZUlkKGlkKTtcbiAgICAgIGlmICh0aGlzLl9yZWFkeUhhbmRsZXIgJiYgT2JqZWN0LmtleXModGhpcy5fc3RvcmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZWFkeUhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iaiAmJiBvYmouX19qYWlsZWRfcGFpcnNfXykge1xuICAgICAgY29uc3QgX2lkID0gZ2V0S2V5QnlWYWx1ZSh0aGlzLl9zdG9yZSwgb2JqLl9famFpbGVkX3BhaXJzX18pO1xuICAgICAgdGhpcy5mZXRjaChfaWQpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBwcmV2aW91c2x5IHN0b3JlZCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIG9mIGFuIG9iamVjdCB0byByZXRyaWV2ZVxuICAgKi9cbiAgLy8gcmV0cmlldmUoaWQpIHtcbiAgLy8gICAgIHZhciBvYmogPSB0aGlzLl9zdG9yZVtpZF07XG4gIC8vICAgICByZXR1cm4gb2JqO1xuICAvLyB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBeUJBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUF6R0E7QUEyR0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQVJBO0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFVQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFuMUJBO0FBcTFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExSEEiLCJzb3VyY2VSb290IjoiIn0=\\\\n//# sourceURL=webpack-internal:///./src/rpc.js\\\\n\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/utils.js\\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"randId\\\\\\\", function() { return randId; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"dtypeToTypedArray\\\\\\\", function() { return dtypeToTypedArray; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"typedArrayToDtype\\\\\\\", function() { return typedArrayToDtype; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"cacheRequirements\\\\\\\", function() { return cacheRequirements; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"setupServiceWorker\\\\\\\", function() { return setupServiceWorker; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"urlJoin\\\\\\\", function() { return urlJoin; });\\\\nfunction randId() {\\\\n  return Math.random().toString(36).substr(2, 10);\\\\n}\\\\nconst dtypeToTypedArray = {\\\\n  int8: \\\\\\\"Int8Array\\\\\\\",\\\\n  int16: \\\\\\\"Int16Array\\\\\\\",\\\\n  int32: \\\\\\\"Int32Array\\\\\\\",\\\\n  uint8: \\\\\\\"Uint8Array\\\\\\\",\\\\n  uint16: \\\\\\\"Uint16Array\\\\\\\",\\\\n  uint32: \\\\\\\"Uint32Array\\\\\\\",\\\\n  float32: \\\\\\\"Float32Array\\\\\\\",\\\\n  float64: \\\\\\\"Float64Array\\\\\\\",\\\\n  array: \\\\\\\"Array\\\\\\\"\\\\n};\\\\nconst typedArrayToDtype = {\\\\n  Int8Array: \\\\\\\"int8\\\\\\\",\\\\n  Int16Array: \\\\\\\"int16\\\\\\\",\\\\n  Int32Array: \\\\\\\"int32\\\\\\\",\\\\n  Uint8Array: \\\\\\\"uint8\\\\\\\",\\\\n  Uint16Array: \\\\\\\"uint16\\\\\\\",\\\\n  Uint32Array: \\\\\\\"uint32\\\\\\\",\\\\n  Float32Array: \\\\\\\"float32\\\\\\\",\\\\n  Float64Array: \\\\\\\"float64\\\\\\\",\\\\n  Array: \\\\\\\"array\\\\\\\"\\\\n};\\\\n\\\\nfunction cacheUrlInServiceWorker(url) {\\\\n  return new Promise(function (resolve, reject) {\\\\n    const message = {\\\\n      command: \\\\\\\"add\\\\\\\",\\\\n      url: url\\\\n    };\\\\n\\\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\\\n      reject(\\\\\\\"Service worker is not supported.\\\\\\\");\\\\n      return;\\\\n    }\\\\n\\\\n    const messageChannel = new MessageChannel();\\\\n\\\\n    messageChannel.port1.onmessage = function (event) {\\\\n      if (event.data && event.data.error) {\\\\n        reject(event.data.error);\\\\n      } else {\\\\n        resolve(event.data && event.data.result);\\\\n      }\\\\n    };\\\\n\\\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\\\n    } else {\\\\n      reject(\\\\\\\"Service worker controller is not available\\\\\\\");\\\\n    }\\\\n  });\\\\n}\\\\n\\\\nasync function cacheRequirements(requirements) {\\\\n  if (requirements && requirements.length > 0) {\\\\n    for (let req of requirements) {\\\\n      //remove prefix\\\\n      if (req.startsWith(\\\\\\\"js:\\\\\\\")) req = req.slice(3);\\\\n      if (req.startsWith(\\\\\\\"css:\\\\\\\")) req = req.slice(4);\\\\n      if (req.startsWith(\\\\\\\"cache:\\\\\\\")) req = req.slice(6);\\\\n      if (!req.startsWith(\\\\\\\"http\\\\\\\")) continue;\\\\n      await cacheUrlInServiceWorker(req).catch(e => {\\\\n        console.error(e);\\\\n      });\\\\n    }\\\\n  }\\\\n}\\\\nfunction setupServiceWorker(targetOrigin, cacheCallback) {\\\\n  // register service worker for offline access\\\\n  if (\\\\\\\"serviceWorker\\\\\\\" in navigator) {\\\\n    window.addEventListener(\\\\\\\"load\\\\\\\", function () {\\\\n      navigator.serviceWorker.register(\\\\\\\"/plugin-service-worker.js\\\\\\\").then(function (registration) {\\\\n        // Registration was successful\\\\n        console.log(\\\\\\\"ServiceWorker registration successful with scope: \\\\\\\", registration.scope);\\\\n      }, function (err) {\\\\n        // registration failed :(\\\\n        console.log(\\\\\\\"ServiceWorker registration failed: \\\\\\\", err);\\\\n      });\\\\n      targetOrigin = targetOrigin || \\\\\\\"*\\\\\\\";\\\\n      cacheCallback = cacheCallback || cacheRequirements;\\\\n\\\\n      if (cacheCallback && typeof cacheCallback !== \\\\\\\"function\\\\\\\") {\\\\n        throw new Error(\\\\\\\"config.cache_requirements must be a function\\\\\\\");\\\\n      }\\\\n\\\\n      window.addEventListener(\\\\\\\"message\\\\\\\", function (e) {\\\\n        if (targetOrigin === \\\\\\\"*\\\\\\\" || e.origin === targetOrigin) {\\\\n          const m = e.data;\\\\n\\\\n          if (m.type === \\\\\\\"cacheRequirements\\\\\\\") {\\\\n            cacheCallback(m.requirements);\\\\n          }\\\\n        }\\\\n      });\\\\n    });\\\\n  }\\\\n} //#Source https://bit.ly/2neWfJ2\\\\n\\\\nfunction urlJoin(...args) {\\\\n  return args.join(\\\\\\\"/\\\\\\\").replace(/[\\\\\\\\/]+/g, \\\\\\\"/\\\\\\\").replace(/^(.+):\\\\\\\\//, \\\\\\\"$1://\\\\\\\").replace(/^file:/, \\\\\\\"file:/\\\\\\\").replace(/\\\\\\\\/(\\\\\\\\?|&|#[^!])/g, \\\\\\\"$1\\\\\\\").replace(/\\\\\\\\?/g, \\\\\\\"&\\\\\\\").replace(\\\\\\\"&\\\\\\\", \\\\\\\"?\\\\\\\");\\\\n}//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWpveVJQQy9zcmMvdXRpbHMuanM/YTMwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcmFuZElkKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKVxuICAgIC50b1N0cmluZygzNilcbiAgICAuc3Vic3RyKDIsIDEwKTtcbn1cblxuZXhwb3J0IGNvbnN0IGR0eXBlVG9UeXBlZEFycmF5ID0ge1xuICBpbnQ4OiBcIkludDhBcnJheVwiLFxuICBpbnQxNjogXCJJbnQxNkFycmF5XCIsXG4gIGludDMyOiBcIkludDMyQXJyYXlcIixcbiAgdWludDg6IFwiVWludDhBcnJheVwiLFxuICB1aW50MTY6IFwiVWludDE2QXJyYXlcIixcbiAgdWludDMyOiBcIlVpbnQzMkFycmF5XCIsXG4gIGZsb2F0MzI6IFwiRmxvYXQzMkFycmF5XCIsXG4gIGZsb2F0NjQ6IFwiRmxvYXQ2NEFycmF5XCIsXG4gIGFycmF5OiBcIkFycmF5XCJcbn07XG5leHBvcnQgY29uc3QgdHlwZWRBcnJheVRvRHR5cGUgPSB7XG4gIEludDhBcnJheTogXCJpbnQ4XCIsXG4gIEludDE2QXJyYXk6IFwiaW50MTZcIixcbiAgSW50MzJBcnJheTogXCJpbnQzMlwiLFxuICBVaW50OEFycmF5OiBcInVpbnQ4XCIsXG4gIFVpbnQxNkFycmF5OiBcInVpbnQxNlwiLFxuICBVaW50MzJBcnJheTogXCJ1aW50MzJcIixcbiAgRmxvYXQzMkFycmF5OiBcImZsb2F0MzJcIixcbiAgRmxvYXQ2NEFycmF5OiBcImZsb2F0NjRcIixcbiAgQXJyYXk6IFwiYXJyYXlcIlxufTtcblxuZnVuY3Rpb24gY2FjaGVVcmxJblNlcnZpY2VXb3JrZXIodXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgY29tbWFuZDogXCJhZGRcIixcbiAgICAgIHVybDogdXJsXG4gICAgfTtcbiAgICBpZiAoIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyIHx8ICFuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3Rlcikge1xuICAgICAgcmVqZWN0KFwiU2VydmljZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VDaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgbWVzc2FnZUNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEuZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGV2ZW50LmRhdGEuZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShldmVudC5kYXRhICYmIGV2ZW50LmRhdGEucmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyICYmIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIpIHtcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgW1xuICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MlxuICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdChcIlNlcnZpY2Ugd29ya2VyIGNvbnRyb2xsZXIgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FjaGVSZXF1aXJlbWVudHMocmVxdWlyZW1lbnRzKSB7XG4gIGlmIChyZXF1aXJlbWVudHMgJiYgcmVxdWlyZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGxldCByZXEgb2YgcmVxdWlyZW1lbnRzKSB7XG4gICAgICAvL3JlbW92ZSBwcmVmaXhcbiAgICAgIGlmIChyZXEuc3RhcnRzV2l0aChcImpzOlwiKSkgcmVxID0gcmVxLnNsaWNlKDMpO1xuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFwiY3NzOlwiKSkgcmVxID0gcmVxLnNsaWNlKDQpO1xuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFwiY2FjaGU6XCIpKSByZXEgPSByZXEuc2xpY2UoNik7XG4gICAgICBpZiAoIXJlcS5zdGFydHNXaXRoKFwiaHR0cFwiKSkgY29udGludWU7XG5cbiAgICAgIGF3YWl0IGNhY2hlVXJsSW5TZXJ2aWNlV29ya2VyKHJlcSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwU2VydmljZVdvcmtlcih0YXJnZXRPcmlnaW4sIGNhY2hlQ2FsbGJhY2spIHtcbiAgLy8gcmVnaXN0ZXIgc2VydmljZSB3b3JrZXIgZm9yIG9mZmxpbmUgYWNjZXNzXG4gIGlmIChcInNlcnZpY2VXb3JrZXJcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3RlcihcIi9wbHVnaW4tc2VydmljZS13b3JrZXIuanNcIikudGhlbihcbiAgICAgICAgZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgLy8gUmVnaXN0cmF0aW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwgd2l0aCBzY29wZTogXCIsXG4gICAgICAgICAgICByZWdpc3RyYXRpb24uc2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAvLyByZWdpc3RyYXRpb24gZmFpbGVkIDooXG4gICAgICAgICAgY29uc29sZS5sb2coXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQ6IFwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGFyZ2V0T3JpZ2luID0gdGFyZ2V0T3JpZ2luIHx8IFwiKlwiO1xuICAgICAgY2FjaGVDYWxsYmFjayA9IGNhY2hlQ2FsbGJhY2sgfHwgY2FjaGVSZXF1aXJlbWVudHM7XG4gICAgICBpZiAoY2FjaGVDYWxsYmFjayAmJiB0eXBlb2YgY2FjaGVDYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmZpZy5jYWNoZV9yZXF1aXJlbWVudHMgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRhcmdldE9yaWdpbiA9PT0gXCIqXCIgfHwgZS5vcmlnaW4gPT09IHRhcmdldE9yaWdpbikge1xuICAgICAgICAgIGNvbnN0IG0gPSBlLmRhdGE7XG4gICAgICAgICAgaWYgKG0udHlwZSA9PT0gXCJjYWNoZVJlcXVpcmVtZW50c1wiKSB7XG4gICAgICAgICAgICBjYWNoZUNhbGxiYWNrKG0ucmVxdWlyZW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8vI1NvdXJjZSBodHRwczovL2JpdC5seS8ybmVXZkoyXG5leHBvcnQgZnVuY3Rpb24gdXJsSm9pbiguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzXG4gICAgLmpvaW4oXCIvXCIpXG4gICAgLnJlcGxhY2UoL1tcXC9dKy9nLCBcIi9cIilcbiAgICAucmVwbGFjZSgvXiguKyk6XFwvLywgXCIkMTovL1wiKVxuICAgIC5yZXBsYWNlKC9eZmlsZTovLCBcImZpbGU6L1wiKVxuICAgIC5yZXBsYWNlKC9cXC8oXFw/fCZ8I1teIV0pL2csIFwiJDFcIilcbiAgICAucmVwbGFjZSgvXFw/L2csIFwiJlwiKVxuICAgIC5yZXBsYWNlKFwiJlwiLCBcIj9cIik7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFRQSIsInNvdXJjZVJvb3QiOiIifQ==\\\\n//# sourceURL=webpack-internal:///./src/utils.js\\\\n\\\");\\n\\n/***/ })\\n\\n/******/ });\", null);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luLndlYndvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanM/ZTdlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcmVxdWlyZShcIiEhL1VzZXJzL3dlaS5vdXlhbmcvd29ya3NwYWNlL2ltam95LXJwYy9qYXZhc2NyaXB0L25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3Qvd29ya2Vycy9JbmxpbmVXb3JrZXIuanNcIikoXCIvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0XFx0fVxcbi8qKioqKiovIFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuLyoqKioqKi8gXFx0XFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdGk6IG1vZHVsZUlkLFxcbi8qKioqKiovIFxcdFxcdFxcdGw6IGZhbHNlLFxcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9XFxuLyoqKioqKi8gXFx0XFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdFxcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbi8qKioqKiovIFxcdFxcdG1vZHVsZS5sID0gdHJ1ZTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG4vKioqKioqL1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xcbi8qKioqKiovIFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xcbi8qKioqKiovIFxcdFxcdH1cXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcXG4vKioqKioqLyBcXHRcXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcXG4vKioqKioqLyBcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcXG4vKioqKioqLyBcXHRcXHR9XFxuLyoqKioqKi8gXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcXG4vKioqKioqLyBcXHRcXHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xcbi8qKioqKiovIFxcdFxcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcXG4vKioqKioqLyBcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBucztcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcXG4vKioqKioqLyBcXHRcXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cXG4vKioqKioqLyBcXHRcXHRcXHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxcbi8qKioqKiovIFxcdFxcdFxcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBnZXR0ZXI7XFxuLyoqKioqKi8gXFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXFxcIlxcXCI7XFxuLyoqKioqKi9cXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xcbi8qKioqKiovIFxcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFxcXCIuL3NyYy9wbHVnaW4ud2Vid29ya2VyLmpzXFxcIik7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovICh7XFxuXFxuLyoqKi8gXFxcIi4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy9wbHVnaW4ud2Vid29ya2VyLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbmV2YWwoXFxcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luQ29yZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wbHVnaW5Db3JlLmpzICovIFxcXFxcXFwiLi9zcmMvcGx1Z2luQ29yZS5qc1xcXFxcXFwiKTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcnBjX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JwYy5qcyAqLyBcXFxcXFxcIi4vc3JjL3JwYy5qc1xcXFxcXFwiKTtcXFxcbi8qKlxcXFxuICogQ29udGFpbnMgdGhlIHJvdXRpbmVzIGxvYWRlZCBieSB0aGUgcGx1Z2luIFdvcmtlciB1bmRlciB3ZWItYnJvd3Nlci5cXFxcbiAqXFxcXG4gKiBJbml0aWFsaXplcyB0aGUgd2ViIGVudmlyb25tZW50IHZlcnNpb24gb2YgdGhlIHBsYXRmb3JtLWRlcGVuZGVudFxcXFxuICogY29ubmVjdGlvbiBvYmplY3QgZm9yIHRoZSBwbHVnaW4gc2l0ZVxcXFxuICovXFxcXG5cXFxcblxcXFxuXFxcXG4oZnVuY3Rpb24oKSB7XFxcXG4gIC8vIG1ha2Ugc3VyZSB0aGlzIHJ1bnMgaW5zaWRlIGEgd2Vid29ya2VyXFxcXG4gIGlmIChcXFxcbiAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgfHxcXFxcbiAgICAhc2VsZiB8fFxcXFxuICAgICEoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKVxcXFxuICApIHtcXFxcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJUaGlzIHNjcmlwdCBjYW4gb25seSBsb2FkZWQgaW4gYSB3ZWJ3b3JrZXJcXFxcXFxcIik7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIEV4ZWN1dGVzIHRoZSBnaXZlbiBjb2RlIGluIGEgamFpbGVkIGVudmlyb25tZW50LiBGb3Igd2ViXFxcXG4gICAqIGltcGxlbWVudGF0aW9uLCB3ZSdyZSBhbHJlYWR5IGphaWxlZCBpbiB0aGUgaWZyYW1lIGFuZCB0aGVcXFxcbiAgICogd29ya2VyLCBzbyBzaW1wbHkgZXZhbCgpXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlIGNvZGUgdG8gZXhlY3V0ZVxcXFxuICAgKi9cXFxcbiAgdmFyIGV4ZWN1dGUgPSBmdW5jdGlvbihjb2RlKSB7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgIGlmIChjb2RlLnR5cGUgPT09IFxcXFxcXFwicmVxdWlyZW1lbnRzXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICBpZiAoXFxcXG4gICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cyAmJlxcXFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpIHx8XFxcXG4gICAgICAgICAgICAgIHR5cGVvZiBjb2RlLnJlcXVpcmVtZW50cyA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIilcXFxcbiAgICAgICAgICApIHtcXFxcbiAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb2RlLnJlcXVpcmVtZW50cykpIHtcXFxcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cyA9IFtjb2RlLnJlcXVpcmVtZW50c107XFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlLnJlcXVpcmVtZW50cy5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGlmIChcXFxcbiAgICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoXFxcXFxcXCIuY3NzXFxcXFxcXCIpIHx8XFxcXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFxcXFxcXFwiY3NzOlxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgICkge1xcXFxuICAgICAgICAgICAgICAgICAgdGhyb3cgXFxcXFxcXCJ1bmFibGUgdG8gaW1wb3J0IGNzcyBpbiBhIHdlYndvcmtlclxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXFxcXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFxcXFxcXFwiLmpzXFxcXFxcXCIpIHx8XFxcXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFxcXFxcXFwianM6XFxcXFxcXCIpXFxcXG4gICAgICAgICAgICAgICAgKSB7XFxcXG4gICAgICAgICAgICAgICAgICBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcXFxcXFxcImpzOlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDMpO1xcXFxuICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50c1tpXSk7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFxcXFxcXFwiaHR0cFxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50c1tpXSk7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFxcXFxcXFwiY2FjaGU6XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAvL2lnbm9yZSBjYWNoZVxcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJVbnByb2Nlc3NlZCByZXF1aXJlbWVudHMgdXJsOiBcXFxcXFxcIiArIGNvZGUucmVxdWlyZW1lbnRzW2ldXFxcXG4gICAgICAgICAgICAgICAgICApO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgICB0aHJvdyBcXFxcXFxcImZhaWxlZCB0byBpbXBvcnQgcmVxdWlyZWQgc2NyaXB0czogXFxcXFxcXCIgK1xcXFxuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzLnRvU3RyaW5nKCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgdGhyb3cgZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFxcXFxcXFwic2NyaXB0XFxcXFxcXCIpIHtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICBpZiAoXFxcXG4gICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cyAmJlxcXFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpIHx8XFxcXG4gICAgICAgICAgICAgIHR5cGVvZiBjb2RlLnJlcXVpcmVtZW50cyA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIilcXFxcbiAgICAgICAgICApIHtcXFxcbiAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSkge1xcXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZS5yZXF1aXJlbWVudHMubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICBpbXBvcnRTY3JpcHRzKGNvZGUucmVxdWlyZW1lbnRzKTtcXFxcbiAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgICB0aHJvdyBcXFxcXFxcImZhaWxlZCB0byBpbXBvcnQgcmVxdWlyZWQgc2NyaXB0czogXFxcXFxcXCIgK1xcXFxuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzLnRvU3RyaW5nKCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICAgIGV2YWwoY29kZS5jb250ZW50KTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlLCBlLnN0YWNrKTtcXFxcbiAgICAgICAgICB0aHJvdyBlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICB0aHJvdyBcXFxcXFxcInVuc3VwcG9ydGVkIGNvZGUgdHlwZS5cXFxcXFxcIjtcXFxcbiAgICAgIH1cXFxcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcXFxcXFxcImV4ZWN1dGVTdWNjZXNzXFxcXFxcXCIgfSk7XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgY29uc29sZS5lcnJvcihcXFxcXFxcImZhaWxlZCB0byBleGVjdXRlIHNjcmlwdHM6IFxcXFxcXFwiLCBjb2RlLCBlKTtcXFxcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcXFxcXFxcImV4ZWN1dGVGYWlsdXJlXFxcXFxcXCIsIGVycm9yOiBlLnN0YWNrIHx8IFN0cmluZyhlKSB9KTtcXFxcbiAgICB9XFxcXG4gIH07XFxcXG5cXFxcbiAgLyoqXFxcXG4gICAqIENvbm5lY3Rpb24gb2JqZWN0IHByb3ZpZGVkIHRvIHRoZSBSUEMgY29uc3RydWN0b3IsXFxcXG4gICAqIHBsdWdpbiBzaXRlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgd2ViLWJhc2VkIGVudmlyb25tZW50LlxcXFxuICAgKiBHbG9iYWwgd2lsbCBiZSB0aGVuIGNsZWFyZWQgdG8gcHJldmVudCBleHBvc3VyZSBpbnRvIHRoZVxcXFxuICAgKiBXb3JrZXIsIHNvIHdlIHB1dCB0aGlzIGxvY2FsIGNvbm5lY3Rpb24gb2JqZWN0IGludG8gYSBjbG9zdXJlXFxcXG4gICAqL1xcXFxuICBjb25zdCBjb25uID0ge1xcXFxuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge1xcXFxuICAgICAgc2VsZi5jbG9zZSgpO1xcXFxuICAgIH0sXFxcXG4gICAgc2VuZDogZnVuY3Rpb24oZGF0YSwgdHJhbnNmZXJhYmxlcykge1xcXFxuICAgICAgZGF0YS5fX3RyYW5zZmVyYWJsZXNfXyA9IHRyYW5zZmVyYWJsZXM7XFxcXG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyYWJsZXMpO1xcXFxuICAgIH0sXFxcXG4gICAgb25NZXNzYWdlOiBmdW5jdGlvbihoKSB7XFxcXG4gICAgICBjb25uLl9tZXNzYWdlSGFuZGxlciA9IGg7XFxcXG4gICAgfSxcXFxcbiAgICBfbWVzc2FnZUhhbmRsZXI6IGZ1bmN0aW9uKCkge30sXFxcXG4gICAgb25EaXNjb25uZWN0OiBmdW5jdGlvbigpIHt9XFxcXG4gIH07XFxcXG5cXFxcbiAgY29uc3QgY29uZmlnID0ge1xcXFxuICAgIHR5cGU6IFxcXFxcXFwid2ViLXdvcmtlclxcXFxcXFwiLFxcXFxuICAgIGRlZGljYXRlZF90aHJlYWQ6IHRydWUsXFxcXG4gICAgYWxsb3dfZXhlY3V0aW9uOiB0cnVlLFxcXFxuICAgIGxhbmc6IFxcXFxcXFwiamF2YXNjcmlwdFxcXFxcXFwiLFxcXFxuICAgIGFwaV92ZXJzaW9uOiBfcnBjX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcXFxcXCJBUElfVkVSU0lPTlxcXFxcXFwiXVxcXFxuICB9O1xcXFxuXFxcXG4gIC8qKlxcXFxuICAgKiBFdmVudCBsaXNlbmVyIGZvciB0aGUgcGx1Z2luIG1lc3NhZ2VcXFxcbiAgICovXFxcXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcXFxcXFxcIm1lc3NhZ2VcXFxcXFxcIiwgZnVuY3Rpb24oZSkge1xcXFxuICAgIGNvbnN0IG0gPSBlLmRhdGE7XFxcXG4gICAgc3dpdGNoIChtICYmIG0udHlwZSkge1xcXFxuICAgICAgY2FzZSBcXFxcXFxcImdldENvbmZpZ1xcXFxcXFwiOlxcXFxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcXFxcbiAgICAgICAgICB0eXBlOiBcXFxcXFxcImNvbmZpZ1xcXFxcXFwiLFxcXFxuICAgICAgICAgIGNvbmZpZzogY29uZmlnXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBicmVhaztcXFxcbiAgICAgIGNhc2UgXFxcXFxcXCJleGVjdXRlXFxcXFxcXCI6XFxcXG4gICAgICAgIGV4ZWN1dGUobS5jb2RlKTtcXFxcbiAgICAgICAgaWYgKG0uY29kZS50eXBlID09PSBcXFxcXFxcInJlcXVpcmVtZW50c1xcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG0uY29kZS5yZXF1aXJlbWVudHMpKSB7XFxcXG4gICAgICAgICAgICBtLmNvZGUucmVxdWlyZW1lbnRzID0gW20uY29kZS5yZXF1aXJlbWVudHNdO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcXFxcbiAgICAgICAgICAgIHR5cGU6IFxcXFxcXFwiY2FjaGVSZXF1aXJlbWVudHNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHJlcXVpcmVtZW50czogbS5jb2RlLnJlcXVpcmVtZW50c1xcXFxuICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGJyZWFrO1xcXFxuICAgICAgLy8gZm9yIHdlYndvcmtlciBvbmx5XFxcXG4gICAgICBjYXNlIFxcXFxcXFwiY29ubmVjdFJQQ1xcXFxcXFwiOlxcXFxuICAgICAgICBPYmplY3QoX3BsdWdpbkNvcmVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcImNvbm5lY3RSUENcXFxcXFxcIl0pKGNvbm4sIG0uY29uZmlnKTtcXFxcbiAgICAgICAgYnJlYWs7XFxcXG4gICAgICBkZWZhdWx0OlxcXFxuICAgICAgICBjb25uLl9tZXNzYWdlSGFuZGxlcihtKTtcXFxcbiAgICB9XFxcXG4gIH0pO1xcXFxuICBzZWxmLnBvc3RNZXNzYWdlKHtcXFxcbiAgICB0eXBlOiBcXFxcXFxcImluaXRpYWxpemVkXFxcXFxcXCIsXFxcXG4gICAgY29uZmlnOiBjb25maWdcXFxcbiAgfSk7XFxcXG59KSgpO1xcXFxuLy8jIHNvdXJjZVVSTD1bbW9kdWxlXVxcXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lMaTl6Y21NdmNHeDFaMmx1TG5kbFluZHZjbXRsY2k1cWN5NXFjeUlzSW5OdmRYSmpaWE1pT2xzaWQyVmljR0ZqYXpvdkwybHRhbTk1VWxCREx5NHZjM0pqTDNCc2RXZHBiaTUzWldKM2IzSnJaWEl1YW5NL09HTTFOQ0pkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJdktpcGNiaUFxSUVOdmJuUmhhVzV6SUhSb1pTQnliM1YwYVc1bGN5QnNiMkZrWldRZ1lua2dkR2hsSUhCc2RXZHBiaUJYYjNKclpYSWdkVzVrWlhJZ2QyVmlMV0p5YjNkelpYSXVYRzRnS2x4dUlDb2dTVzVwZEdsaGJHbDZaWE1nZEdobElIZGxZaUJsYm5acGNtOXViV1Z1ZENCMlpYSnphVzl1SUc5bUlIUm9aU0J3YkdGMFptOXliUzFrWlhCbGJtUmxiblJjYmlBcUlHTnZibTVsWTNScGIyNGdiMkpxWldOMElHWnZjaUIwYUdVZ2NHeDFaMmx1SUhOcGRHVmNiaUFxTDF4dWFXMXdiM0owSUhzZ1kyOXVibVZqZEZKUVF5QjlJR1p5YjIwZ1hDSXVMM0JzZFdkcGJrTnZjbVV1YW5OY0lqdGNibWx0Y0c5eWRDQjdJRUZRU1Y5V1JWSlRTVTlPSUgwZ1puSnZiU0JjSWk0dmNuQmpMbXB6WENJN1hHNWNiaWhtZFc1amRHbHZiaWdwSUh0Y2JpQWdMeThnYldGclpTQnpkWEpsSUhSb2FYTWdjblZ1Y3lCcGJuTnBaR1VnWVNCM1pXSjNiM0pyWlhKY2JpQWdhV1lnS0Z4dUlDQWdJSFI1Y0dWdlppQlhiM0pyWlhKSGJHOWlZV3hUWTI5d1pTQTlQVDBnWENKMWJtUmxabWx1WldSY0lpQjhmRnh1SUNBZ0lDRnpaV3htSUh4OFhHNGdJQ0FnSVNoelpXeG1JR2x1YzNSaGJtTmxiMllnVjI5eWEyVnlSMnh2WW1Gc1UyTnZjR1VwWEc0Z0lDa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loY0lsUm9hWE1nYzJOeWFYQjBJR05oYmlCdmJteDVJR3h2WVdSbFpDQnBiaUJoSUhkbFluZHZjbXRsY2x3aUtUdGNiaUFnZlZ4dUlDQXZLaXBjYmlBZ0lDb2dSWGhsWTNWMFpYTWdkR2hsSUdkcGRtVnVJR052WkdVZ2FXNGdZU0JxWVdsc1pXUWdaVzUyYVhKdmJtMWxiblF1SUVadmNpQjNaV0pjYmlBZ0lDb2dhVzF3YkdWdFpXNTBZWFJwYjI0c0lIZGxKM0psSUdGc2NtVmhaSGtnYW1GcGJHVmtJR2x1SUhSb1pTQnBabkpoYldVZ1lXNWtJSFJvWlZ4dUlDQWdLaUIzYjNKclpYSXNJSE52SUhOcGJYQnNlU0JsZG1Gc0tDbGNiaUFnSUNwY2JpQWdJQ29nUUhCaGNtRnRJSHRUZEhKcGJtZDlJR052WkdVZ1kyOWtaU0IwYnlCbGVHVmpkWFJsWEc0Z0lDQXFMMXh1SUNCMllYSWdaWGhsWTNWMFpTQTlJR1oxYm1OMGFXOXVLR052WkdVcElIdGNiaUFnSUNCMGNua2dlMXh1SUNBZ0lDQWdhV1lnS0dOdlpHVXVkSGx3WlNBOVBUMGdYQ0p5WlhGMWFYSmxiV1Z1ZEhOY0lpa2dlMXh1SUNBZ0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQWdJR2xtSUNoY2JpQWdJQ0FnSUNBZ0lDQWdJR052WkdVdWNtVnhkV2x5WlcxbGJuUnpJQ1ltWEc0Z0lDQWdJQ0FnSUNBZ0lDQW9RWEp5WVhrdWFYTkJjbkpoZVNoamIyUmxMbkpsY1hWcGNtVnRaVzUwY3lrZ2ZIeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2RIbHdaVzltSUdOdlpHVXVjbVZ4ZFdseVpXMWxiblJ6SUQwOVBTQmNJbk4wY21sdVoxd2lLVnh1SUNBZ0lDQWdJQ0FnSUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLQ0ZCY25KaGVTNXBjMEZ5Y21GNUtHTnZaR1V1Y21WeGRXbHlaVzFsYm5SektTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052WkdVdWNtVnhkV2x5WlcxbGJuUnpJRDBnVzJOdlpHVXVjbVZ4ZFdseVpXMWxiblJ6WFR0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdOdlpHVXVjbVZ4ZFdseVpXMWxiblJ6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdhV1lnS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhOYmFWMHVkRzlNYjNkbGNrTmhjMlVvS1M1bGJtUnpWMmwwYUNoY0lpNWpjM05jSWlrZ2ZIeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052WkdVdWNtVnhkV2x5WlcxbGJuUnpXMmxkTG5OMFlYSjBjMWRwZEdnb1hDSmpjM002WENJcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUhKdmR5QmNJblZ1WVdKc1pTQjBieUJwYlhCdmNuUWdZM056SUdsdUlHRWdkMlZpZDI5eWEyVnlYQ0k3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZaR1V1Y21WeGRXbHlaVzFsYm5SelcybGRMblJ2VEc5M1pYSkRZWE5sS0NrdVpXNWtjMWRwZEdnb1hDSXVhbk5jSWlrZ2ZIeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052WkdVdWNtVnhkV2x5WlcxbGJuUnpXMmxkTG5OMFlYSjBjMWRwZEdnb1hDSnFjenBjSWlsY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoamIyUmxMbkpsY1hWcGNtVnRaVzUwYzF0cFhTNXpkR0Z5ZEhOWGFYUm9LRndpYW5NNlhDSXBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZaR1V1Y21WeGRXbHlaVzFsYm5SelcybGRJRDBnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE5iYVYwdWMyeHBZMlVvTXlrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwYlhCdmNuUlRZM0pwY0hSektHTnZaR1V1Y21WeGRXbHlaVzFsYm5SelcybGRLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0dOdlpHVXVjbVZ4ZFdseVpXMWxiblJ6VzJsZExuTjBZWEowYzFkcGRHZ29YQ0pvZEhSd1hDSXBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCcGJYQnZjblJUWTNKcGNIUnpLR052WkdVdWNtVnhkV2x5WlcxbGJuUnpXMmxkS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHTnZaR1V1Y21WeGRXbHlaVzFsYm5SelcybGRMbk4wWVhKMGMxZHBkR2dvWENKallXTm9aVHBjSWlrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzh2YVdkdWIzSmxJR05oWTJobFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk52YkdVdWJHOW5LRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCY0lsVnVjSEp2WTJWemMyVmtJSEpsY1hWcGNtVnRaVzUwY3lCMWNtdzZJRndpSUNzZ1kyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhOYmFWMWNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSFJvY205M0lGd2labUZwYkdWa0lIUnZJR2x0Y0c5eWRDQnlaWEYxYVhKbFpDQnpZM0pwY0hSek9pQmNJaUFyWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE11ZEc5VGRISnBibWNvS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMGdZMkYwWTJnZ0tHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNCMGFISnZkeUJsTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHTnZaR1V1ZEhsd1pTQTlQVDBnWENKelkzSnBjSFJjSWlrZ2UxeHVJQ0FnSUNBZ0lDQjBjbmtnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2hjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZaR1V1Y21WeGRXbHlaVzFsYm5SeklDWW1YRzRnSUNBZ0lDQWdJQ0FnSUNBb1FYSnlZWGt1YVhOQmNuSmhlU2hqYjJSbExuSmxjWFZwY21WdFpXNTBjeWtnZkh4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZEhsd1pXOW1JR052WkdVdWNtVnhkV2x5WlcxbGJuUnpJRDA5UFNCY0luTjBjbWx1WjF3aUtWeHVJQ0FnSUNBZ0lDQWdJQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tFRnljbUY1TG1selFYSnlZWGtvWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE1wS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQmpiMlJsTG5KbGNYVnBjbVZ0Wlc1MGN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXMXdiM0owVTJOeWFYQjBjeWhqYjJSbExuSmxjWFZwY21WdFpXNTBjMXRwWFNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsdGNHOXlkRk5qY21sd2RITW9ZMjlrWlM1eVpYRjFhWEpsYldWdWRITXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCOUlHTmhkR05vSUNobEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9jbTkzSUZ3aVptRnBiR1ZrSUhSdklHbHRjRzl5ZENCeVpYRjFhWEpsWkNCelkzSnBjSFJ6T2lCY0lpQXJYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjlrWlM1eVpYRjFhWEpsYldWdWRITXVkRzlUZEhKcGJtY29LVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ1pYWmhiQ2hqYjJSbExtTnZiblJsYm5RcE8xeHVJQ0FnSUNBZ0lDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1kyOXVjMjlzWlM1bGNuSnZjaWhsTG0xbGMzTmhaMlVzSUdVdWMzUmhZMnNwTzF4dUlDQWdJQ0FnSUNBZ0lIUm9jbTkzSUdVN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lIUm9jbTkzSUZ3aWRXNXpkWEJ3YjNKMFpXUWdZMjlrWlNCMGVYQmxMbHdpTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnYzJWc1ppNXdiM04wVFdWemMyRm5aU2g3SUhSNWNHVTZJRndpWlhobFkzVjBaVk4xWTJObGMzTmNJaUI5S1R0Y2JpQWdJQ0I5SUdOaGRHTm9JQ2hsS1NCN1hHNGdJQ0FnSUNCamIyNXpiMnhsTG1WeWNtOXlLRndpWm1GcGJHVmtJSFJ2SUdWNFpXTjFkR1VnYzJOeWFYQjBjem9nWENJc0lHTnZaR1VzSUdVcE8xeHVJQ0FnSUNBZ2MyVnNaaTV3YjNOMFRXVnpjMkZuWlNoN0lIUjVjR1U2SUZ3aVpYaGxZM1YwWlVaaGFXeDFjbVZjSWl3Z1pYSnliM0k2SUdVdWMzUmhZMnNnZkh3Z1UzUnlhVzVuS0dVcElIMHBPMXh1SUNBZ0lIMWNiaUFnZlR0Y2JseHVJQ0F2S2lwY2JpQWdJQ29nUTI5dWJtVmpkR2x2YmlCdlltcGxZM1FnY0hKdmRtbGtaV1FnZEc4Z2RHaGxJRkpRUXlCamIyNXpkSEoxWTNSdmNpeGNiaUFnSUNvZ2NHeDFaMmx1SUhOcGRHVWdhVzF3YkdWdFpXNTBZWFJwYjI0Z1ptOXlJSFJvWlNCM1pXSXRZbUZ6WldRZ1pXNTJhWEp2Ym0xbGJuUXVYRzRnSUNBcUlFZHNiMkpoYkNCM2FXeHNJR0psSUhSb1pXNGdZMnhsWVhKbFpDQjBieUJ3Y21WMlpXNTBJR1Y0Y0c5emRYSmxJR2x1ZEc4Z2RHaGxYRzRnSUNBcUlGZHZjbXRsY2l3Z2MyOGdkMlVnY0hWMElIUm9hWE1nYkc5allXd2dZMjl1Ym1WamRHbHZiaUJ2WW1wbFkzUWdhVzUwYnlCaElHTnNiM04xY21WY2JpQWdJQ292WEc0Z0lHTnZibk4wSUdOdmJtNGdQU0I3WEc0Z0lDQWdaR2x6WTI5dWJtVmpkRG9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCelpXeG1MbU5zYjNObEtDazdYRzRnSUNBZ2ZTeGNiaUFnSUNCelpXNWtPaUJtZFc1amRHbHZiaWhrWVhSaExDQjBjbUZ1YzJabGNtRmliR1Z6S1NCN1hHNGdJQ0FnSUNCa1lYUmhMbDlmZEhKaGJuTm1aWEpoWW14bGMxOWZJRDBnZEhKaGJuTm1aWEpoWW14bGN6dGNiaUFnSUNBZ0lITmxiR1l1Y0c5emRFMWxjM05oWjJVb1pHRjBZU3dnZEhKaGJuTm1aWEpoWW14bGN5azdYRzRnSUNBZ2ZTeGNiaUFnSUNCdmJrMWxjM05oWjJVNklHWjFibU4wYVc5dUtHZ3BJSHRjYmlBZ0lDQWdJR052Ym00dVgyMWxjM05oWjJWSVlXNWtiR1Z5SUQwZ2FEdGNiaUFnSUNCOUxGeHVJQ0FnSUY5dFpYTnpZV2RsU0dGdVpHeGxjam9nWm5WdVkzUnBiMjRvS1NCN2ZTeGNiaUFnSUNCdmJrUnBjMk52Ym01bFkzUTZJR1oxYm1OMGFXOXVLQ2tnZTMxY2JpQWdmVHRjYmx4dUlDQmpiMjV6ZENCamIyNW1hV2NnUFNCN1hHNGdJQ0FnZEhsd1pUb2dYQ0ozWldJdGQyOXlhMlZ5WENJc1hHNGdJQ0FnWkdWa2FXTmhkR1ZrWDNSb2NtVmhaRG9nZEhKMVpTeGNiaUFnSUNCaGJHeHZkMTlsZUdWamRYUnBiMjQ2SUhSeWRXVXNYRzRnSUNBZ2JHRnVaem9nWENKcVlYWmhjMk55YVhCMFhDSXNYRzRnSUNBZ1lYQnBYM1psY25OcGIyNDZJRUZRU1Y5V1JWSlRTVTlPWEc0Z0lIMDdYRzVjYmlBZ0x5b3FYRzRnSUNBcUlFVjJaVzUwSUd4cGMyVnVaWElnWm05eUlIUm9aU0J3YkhWbmFXNGdiV1Z6YzJGblpWeHVJQ0FnS2k5Y2JpQWdjMlZzWmk1aFpHUkZkbVZ1ZEV4cGMzUmxibVZ5S0Z3aWJXVnpjMkZuWlZ3aUxDQm1kVzVqZEdsdmJpaGxLU0I3WEc0Z0lDQWdZMjl1YzNRZ2JTQTlJR1V1WkdGMFlUdGNiaUFnSUNCemQybDBZMmdnS0cwZ0ppWWdiUzUwZVhCbEtTQjdYRzRnSUNBZ0lDQmpZWE5sSUZ3aVoyVjBRMjl1Wm1sblhDSTZYRzRnSUNBZ0lDQWdJSE5sYkdZdWNHOXpkRTFsYzNOaFoyVW9lMXh1SUNBZ0lDQWdJQ0FnSUhSNWNHVTZJRndpWTI5dVptbG5YQ0lzWEc0Z0lDQWdJQ0FnSUNBZ1kyOXVabWxuT2lCamIyNW1hV2RjYmlBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJQ0FnWTJGelpTQmNJbVY0WldOMWRHVmNJanBjYmlBZ0lDQWdJQ0FnWlhobFkzVjBaU2h0TG1OdlpHVXBPMXh1SUNBZ0lDQWdJQ0JwWmlBb2JTNWpiMlJsTG5SNWNHVWdQVDA5SUZ3aWNtVnhkV2x5WlcxbGJuUnpYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvSVVGeWNtRjVMbWx6UVhKeVlYa29iUzVqYjJSbExuSmxjWFZwY21WdFpXNTBjeWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJRzB1WTI5a1pTNXlaWEYxYVhKbGJXVnVkSE1nUFNCYmJTNWpiMlJsTG5KbGNYVnBjbVZ0Wlc1MGMxMDdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lITmxiR1l1Y0c5emRFMWxjM05oWjJVb2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEhsd1pUb2dYQ0pqWVdOb1pWSmxjWFZwY21WdFpXNTBjMXdpTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjbVZ4ZFdseVpXMWxiblJ6T2lCdExtTnZaR1V1Y21WeGRXbHlaVzFsYm5SelhHNGdJQ0FnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ1luSmxZV3M3WEc0Z0lDQWdJQ0F2THlCbWIzSWdkMlZpZDI5eWEyVnlJRzl1YkhsY2JpQWdJQ0FnSUdOaGMyVWdYQ0pqYjI1dVpXTjBVbEJEWENJNlhHNGdJQ0FnSUNBZ0lHTnZibTVsWTNSU1VFTW9ZMjl1Yml3Z2JTNWpiMjVtYVdjcE8xeHVJQ0FnSUNBZ0lDQmljbVZoYXp0Y2JpQWdJQ0FnSUdSbFptRjFiSFE2WEc0Z0lDQWdJQ0FnSUdOdmJtNHVYMjFsYzNOaFoyVklZVzVrYkdWeUtHMHBPMXh1SUNBZ0lIMWNiaUFnZlNrN1hHNGdJSE5sYkdZdWNHOXpkRTFsYzNOaFoyVW9lMXh1SUNBZ0lIUjVjR1U2SUZ3aWFXNXBkR2xoYkdsNlpXUmNJaXhjYmlBZ0lDQmpiMjVtYVdjNklHTnZibVpwWjF4dUlDQjlLVHRjYm4wcEtDazdYRzRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzaUxDSnpiM1Z5WTJWU2IyOTBJam9pSW4wPVxcXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrLWludGVybmFsOi8vLy4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanNcXFxcblxcXCIpO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL3NyYy9wbHVnaW5Db3JlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9zcmMvcGx1Z2luQ29yZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBjb25uZWN0UlBDICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5ldmFsKFxcXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwiY29ubmVjdFJQQ1xcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbm5lY3RSUEM7IH0pO1xcXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ycGNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcnBjLmpzICovIFxcXFxcXFwiLi9zcmMvcnBjLmpzXFxcXFxcXCIpO1xcXFxuLyoqXFxcXG4gKiBDb3JlIHBsdWdpbiBzY3JpcHQgbG9hZGVkIGludG8gdGhlIHBsdWdpbiBwcm9jZXNzL3RocmVhZC5cXFxcbiAqXFxcXG4gKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luLXNpdGUgQVBJIGdsb2JhbCBtZXRob2RzLlxcXFxuICovXFxcXG5cXFxcbmZ1bmN0aW9uIGNvbm5lY3RSUEMoY29ubmVjdGlvbiwgY29uZmlnKSB7XFxcXG4gIGNvbnN0IGFwcGxpY2F0aW9uID0ge307XFxcXG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcXFxcbiAgY29uc3QgcnBjID0gbmV3IF9ycGNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcIlJQQ1xcXFxcXFwiXShjb25uZWN0aW9uLCBjb25maWcpO1xcXFxuICBycGMub25HZXRJbnRlcmZhY2UoZnVuY3Rpb24gKCkge1xcXFxuICAgIGxhdW5jaENvbm5lY3RlZCgpO1xcXFxuICB9KTtcXFxcbiAgcnBjLm9uUmVtb3RlVXBkYXRlKGZ1bmN0aW9uICgpIHtcXFxcbiAgICBhcHBsaWNhdGlvbi5yZW1vdGUgPSBycGMuZ2V0UmVtb3RlKCk7XFxcXG4gICAgaWYgKCFhcHBsaWNhdGlvbi5yZW1vdGUpIHJldHVybjtcXFxcbiAgICBjb25zdCBhcGkgPSBhcHBsaWNhdGlvbi5yZW1vdGUgfHwge307XFxcXG5cXFxcbiAgICBpZiAoYXBpLmV4cG9ydCkge1xcXFxuICAgICAgY29uc29sZS5lcnJvcihcXFxcXFxcIldBUk5JTkc6IG92ZXJ3cml0aW5nIGZ1bmN0aW9uICdleHBvcnQnLlxcXFxcXFwiKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBpZiAoYXBpLm9ubG9hZCkge1xcXFxuICAgICAgY29uc29sZS5lcnJvcihcXFxcXFxcIldBUk5JTkc6IG92ZXJ3cml0aW5nIGZ1bmN0aW9uICdvbmxvYWQnLlxcXFxcXFwiKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBpZiAoYXBpLmRpc3Bvc2UpIHtcXFxcbiAgICAgIGNvbnNvbGUuZXJyb3IoXFxcXFxcXCJXQVJOSU5HOiBvdmVyd3JpdGluZyBmdW5jdGlvbiAnZGlzcG9zZScuXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGFwaS5leHBvcnQgPSBhcHBsaWNhdGlvbi5zZXRJbnRlcmZhY2U7XFxcXG4gICAgYXBpLm9uTG9hZCA9IGFwcGxpY2F0aW9uLndoZW5Db25uZWN0ZWQ7XFxcXG4gICAgYXBpLmRpc3Bvc2UgPSBhcHBsaWNhdGlvbi5kaXNjb25uZWN0O1xcXFxuXFxcXG4gICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcXFxcbiAgICAgIHNlbGYuYXBpID0gYXBpO1xcXFxuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XFxcXG4gICAgICAgIHR5cGU6IFxcXFxcXFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVxcXFxcXFwiXFxcXG4gICAgICB9KTtcXFxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cpIHtcXFxcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcXFxcXFxcImltam95X3JlbW90ZV9hcGlfcmVhZHlcXFxcXFxcIiwge1xcXFxuICAgICAgICBkZXRhaWw6IGFwaVxcXFxuICAgICAgfSkpO1xcXFxuICAgIH1cXFxcbiAgfSk7XFxcXG4gIHZhciBjb25uZWN0ZWQgPSBmYWxzZTtcXFxcbiAgdmFyIGNvbm5lY3RlZEhhbmRsZXJzID0gW107XFxcXG5cXFxcbiAgdmFyIGxhdW5jaENvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcXFxcbiAgICBpZiAoIWNvbm5lY3RlZCkge1xcXFxuICAgICAgY29ubmVjdGVkID0gdHJ1ZTtcXFxcbiAgICAgIHZhciBoYW5kbGVyO1xcXFxuXFxcXG4gICAgICB3aGlsZSAoaGFuZGxlciA9IGNvbm5lY3RlZEhhbmRsZXJzLnBvcCgpKSB7XFxcXG4gICAgICAgIGhhbmRsZXIoKTtcXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG4gIH07XFxcXG5cXFxcbiAgdmFyIGNoZWNrSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XFxcXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaGFuZGxlcjtcXFxcblxcXFxuICAgIGlmICh0eXBlICE9PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgIHZhciBtc2cgPSBcXFxcXFxcIkEgZnVuY3Rpb24gbWF5IG9ubHkgYmUgc3Vic3JpYmVkIHRvIHRoZSBldmVudCwgXFxcXFxcXCIgKyB0eXBlICsgXFxcXFxcXCIgd2FzIHByb3ZpZGVkIGluc3RlYWRcXFxcXFxcIjtcXFxcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHJldHVybiBoYW5kbGVyO1xcXFxuICB9O1xcXFxuICAvKipcXFxcbiAgICogU2V0cyBhIGZ1bmN0aW9uIGV4ZWN1dGVkIGFmdGVyIHRoZSBjb25uZWN0aW9uIHRvIHRoZVxcXFxuICAgKiBhcHBsaWNhdGlvbiBpcyBlc3RhcGxpc2hlZCwgYW5kIHRoZSBpbml0aWFsIGludGVyZmFjZS1leGNoYW5nZVxcXFxuICAgKiBtZXNzYWdpbmcgaXMgY29tcGxldGVkXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgdG8gYmUgY2FsbGVkIHVwb24gaW5pdGlhbGl6YXRpb25cXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBhcHBsaWNhdGlvbi53aGVuQ29ubmVjdGVkID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcXFxcbiAgICBoYW5kbGVyID0gY2hlY2tIYW5kbGVyKGhhbmRsZXIpO1xcXFxuXFxcXG4gICAgaWYgKGNvbm5lY3RlZCkge1xcXFxuICAgICAgaGFuZGxlcigpO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICBjb25uZWN0ZWRIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xcXFxuICAgIH1cXFxcbiAgfTtcXFxcbiAgLyoqXFxcXG4gICAqIFNldHMgdGhlIHBsdWdpbiBpbnRlcmZhY2UgYXZhaWxhYmxlIHRvIHRoZSBhcHBsaWNhdGlvblxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge09iamVjdH0gX2ludGVyZmFjZSB0byBzZXRcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBhcHBsaWNhdGlvbi5zZXRJbnRlcmZhY2UgPSBmdW5jdGlvbiAoX2ludGVyZmFjZSkge1xcXFxuICAgIHJwYy5zZXRJbnRlcmZhY2UoX2ludGVyZmFjZSk7XFxcXG4gIH07XFxcXG4gIC8qKlxcXFxuICAgKiBEaXNjb25uZWN0cyB0aGUgcGx1Z2luIGZyb20gdGhlIGFwcGxpY2F0aW9uIChzZW5kaW5nXFxcXG4gICAqIG5vdGlmaWNhdGlvbiBtZXNzYWdlKSBhbmQgZGVzdHJveXMgaXRzZWxmXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgYXBwbGljYXRpb24uZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChfaW50ZXJmYWNlKSB7XFxcXG4gICAgcnBjLmRpc2Nvbm5lY3QoKTtcXFxcbiAgfTtcXFxcbn0vLyMgc291cmNlVVJMPVttb2R1bGVdXFxcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaUxpOXpjbU12Y0d4MVoybHVRMjl5WlM1cWN5NXFjeUlzSW5OdmRYSmpaWE1pT2xzaWQyVmljR0ZqYXpvdkwybHRhbTk1VWxCREwzTnlZeTl3YkhWbmFXNURiM0psTG1welAyRTBOellpWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5b3FYRzRnS2lCRGIzSmxJSEJzZFdkcGJpQnpZM0pwY0hRZ2JHOWhaR1ZrSUdsdWRHOGdkR2hsSUhCc2RXZHBiaUJ3Y205alpYTnpMM1JvY21WaFpDNWNiaUFxWEc0Z0tpQkpibWwwYVdGc2FYcGxjeUIwYUdVZ2NHeDFaMmx1TFhOcGRHVWdRVkJKSUdkc2IySmhiQ0J0WlhSb2IyUnpMbHh1SUNvdlhHNXBiWEJ2Y25RZ2V5QlNVRU1nZlNCbWNtOXRJRndpTGk5eWNHTXVhbk5jSWp0Y2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHTnZibTVsWTNSU1VFTW9ZMjl1Ym1WamRHbHZiaXdnWTI5dVptbG5LU0I3WEc0Z0lHTnZibk4wSUdGd2NHeHBZMkYwYVc5dUlEMGdlMzA3WEc0Z0lHTnZibVpwWnlBOUlHTnZibVpwWnlCOGZDQjdmVHRjYmx4dUlDQmpiMjV6ZENCeWNHTWdQU0J1WlhjZ1VsQkRLR052Ym01bFkzUnBiMjRzSUdOdmJtWnBaeWs3WEc0Z0lISndZeTV2YmtkbGRFbHVkR1Z5Wm1GalpTaG1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQnNZWFZ1WTJoRGIyNXVaV04wWldRb0tUdGNiaUFnZlNrN1hHNWNiaUFnY25CakxtOXVVbVZ0YjNSbFZYQmtZWFJsS0daMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUdGd2NHeHBZMkYwYVc5dUxuSmxiVzkwWlNBOUlISndZeTVuWlhSU1pXMXZkR1VvS1R0Y2JpQWdJQ0JwWmlBb0lXRndjR3hwWTJGMGFXOXVMbkpsYlc5MFpTa2djbVYwZFhKdU8xeHVJQ0FnSUdOdmJuTjBJR0Z3YVNBOUlHRndjR3hwWTJGMGFXOXVMbkpsYlc5MFpTQjhmQ0I3ZlR0Y2JpQWdJQ0JwWmlBb1lYQnBMbVY0Y0c5eWRDa2dlMXh1SUNBZ0lDQWdZMjl1YzI5c1pTNWxjbkp2Y2loY0lsZEJVazVKVGtjNklHOTJaWEozY21sMGFXNW5JR1oxYm1OMGFXOXVJQ2RsZUhCdmNuUW5MbHdpS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0dGd2FTNXZibXh2WVdRcElIdGNiaUFnSUNBZ0lHTnZibk52YkdVdVpYSnliM0lvWENKWFFWSk9TVTVIT2lCdmRtVnlkM0pwZEdsdVp5Qm1kVzVqZEdsdmJpQW5iMjVzYjJGa0p5NWNJaWs3WEc0Z0lDQWdmVnh1SUNBZ0lHbG1JQ2hoY0drdVpHbHpjRzl6WlNrZ2UxeHVJQ0FnSUNBZ1kyOXVjMjlzWlM1bGNuSnZjaWhjSWxkQlVrNUpUa2M2SUc5MlpYSjNjbWwwYVc1bklHWjFibU4wYVc5dUlDZGthWE53YjNObEp5NWNJaWs3WEc0Z0lDQWdmVnh1SUNBZ0lHRndhUzVsZUhCdmNuUWdQU0JoY0hCc2FXTmhkR2x2Ymk1elpYUkpiblJsY21aaFkyVTdYRzRnSUNBZ1lYQnBMbTl1VEc5aFpDQTlJR0Z3Y0d4cFkyRjBhVzl1TG5kb1pXNURiMjV1WldOMFpXUTdYRzRnSUNBZ1lYQnBMbVJwYzNCdmMyVWdQU0JoY0hCc2FXTmhkR2x2Ymk1a2FYTmpiMjV1WldOME8xeHVJQ0FnSUdsbUlDaGNiaUFnSUNBZ0lIUjVjR1Z2WmlCWGIzSnJaWEpIYkc5aVlXeFRZMjl3WlNBaFBUMGdYQ0oxYm1SbFptbHVaV1JjSWlBbUpseHVJQ0FnSUNBZ2MyVnNaaUJwYm5OMFlXNWpaVzltSUZkdmNtdGxja2RzYjJKaGJGTmpiM0JsWEc0Z0lDQWdLU0I3WEc0Z0lDQWdJQ0J6Wld4bUxtRndhU0E5SUdGd2FUdGNiaUFnSUNBZ0lITmxiR1l1Y0c5emRFMWxjM05oWjJVb2UxeHVJQ0FnSUNBZ0lDQjBlWEJsT2lCY0ltbHRhbTk1WDNKbGJXOTBaVjloY0dsZmNtVmhaSGxjSWx4dUlDQWdJQ0FnZlNrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoMGVYQmxiMllnZDJsdVpHOTNLU0I3WEc0Z0lDQWdJQ0IzYVc1a2IzY3VaR2x6Y0dGMFkyaEZkbVZ1ZENoY2JpQWdJQ0FnSUNBZ2JtVjNJRU4xYzNSdmJVVjJaVzUwS0Z3aWFXMXFiM2xmY21WdGIzUmxYMkZ3YVY5eVpXRmtlVndpTENCN0lHUmxkR0ZwYkRvZ1lYQnBJSDBwWEc0Z0lDQWdJQ0FwTzF4dUlDQWdJSDFjYmlBZ2ZTazdYRzVjYmlBZ2RtRnlJR052Ym01bFkzUmxaQ0E5SUdaaGJITmxPMXh1SUNCMllYSWdZMjl1Ym1WamRHVmtTR0Z1Wkd4bGNuTWdQU0JiWFR0Y2JseHVJQ0IyWVhJZ2JHRjFibU5vUTI5dWJtVmpkR1ZrSUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ2FXWWdLQ0ZqYjI1dVpXTjBaV1FwSUh0Y2JpQWdJQ0FnSUdOdmJtNWxZM1JsWkNBOUlIUnlkV1U3WEc1Y2JpQWdJQ0FnSUhaaGNpQm9ZVzVrYkdWeU8xeHVJQ0FnSUNBZ2QyaHBiR1VnS0Nob1lXNWtiR1Z5SUQwZ1kyOXVibVZqZEdWa1NHRnVaR3hsY25NdWNHOXdLQ2twS1NCN1hHNGdJQ0FnSUNBZ0lHaGhibVJzWlhJb0tUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJSDA3WEc1Y2JpQWdkbUZ5SUdOb1pXTnJTR0Z1Wkd4bGNpQTlJR1oxYm1OMGFXOXVLR2hoYm1Sc1pYSXBJSHRjYmlBZ0lDQjJZWElnZEhsd1pTQTlJSFI1Y0dWdlppQm9ZVzVrYkdWeU8xeHVJQ0FnSUdsbUlDaDBlWEJsSUNFOVBTQmNJbVoxYm1OMGFXOXVYQ0lwSUh0Y2JpQWdJQ0FnSUhaaGNpQnRjMmNnUFZ4dUlDQWdJQ0FnSUNCY0lrRWdablZ1WTNScGIyNGdiV0Y1SUc5dWJIa2dZbVVnYzNWaWMzSnBZbVZrSUhSdklIUm9aU0JsZG1WdWRDd2dYQ0lnSzF4dUlDQWdJQ0FnSUNCMGVYQmxJQ3RjYmlBZ0lDQWdJQ0FnWENJZ2QyRnpJSEJ5YjNacFpHVmtJR2x1YzNSbFlXUmNJanRjYmlBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpaHRjMmNwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSEpsZEhWeWJpQm9ZVzVrYkdWeU8xeHVJQ0I5TzF4dVhHNGdJQzhxS2x4dUlDQWdLaUJUWlhSeklHRWdablZ1WTNScGIyNGdaWGhsWTNWMFpXUWdZV1owWlhJZ2RHaGxJR052Ym01bFkzUnBiMjRnZEc4Z2RHaGxYRzRnSUNBcUlHRndjR3hwWTJGMGFXOXVJR2x6SUdWemRHRndiR2x6YUdWa0xDQmhibVFnZEdobElHbHVhWFJwWVd3Z2FXNTBaWEptWVdObExXVjRZMmhoYm1kbFhHNGdJQ0FxSUcxbGMzTmhaMmx1WnlCcGN5QmpiMjF3YkdWMFpXUmNiaUFnSUNwY2JpQWdJQ29nUUhCaGNtRnRJSHRHZFc1amRHbHZibjBnYUdGdVpHeGxjaUIwYnlCaVpTQmpZV3hzWldRZ2RYQnZiaUJwYm1sMGFXRnNhWHBoZEdsdmJseHVJQ0FnS2k5Y2JpQWdZWEJ3YkdsallYUnBiMjR1ZDJobGJrTnZibTVsWTNSbFpDQTlJR1oxYm1OMGFXOXVLR2hoYm1Sc1pYSXBJSHRjYmlBZ0lDQm9ZVzVrYkdWeUlEMGdZMmhsWTJ0SVlXNWtiR1Z5S0doaGJtUnNaWElwTzF4dUlDQWdJR2xtSUNoamIyNXVaV04wWldRcElIdGNiaUFnSUNBZ0lHaGhibVJzWlhJb0tUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnWTI5dWJtVmpkR1ZrU0dGdVpHeGxjbk11Y0hWemFDaG9ZVzVrYkdWeUtUdGNiaUFnSUNCOVhHNGdJSDA3WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRk5sZEhNZ2RHaGxJSEJzZFdkcGJpQnBiblJsY21aaFkyVWdZWFpoYVd4aFlteGxJSFJ2SUhSb1pTQmhjSEJzYVdOaGRHbHZibHh1SUNBZ0tseHVJQ0FnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnWDJsdWRHVnlabUZqWlNCMGJ5QnpaWFJjYmlBZ0lDb3ZYRzRnSUdGd2NHeHBZMkYwYVc5dUxuTmxkRWx1ZEdWeVptRmpaU0E5SUdaMWJtTjBhVzl1S0Y5cGJuUmxjbVpoWTJVcElIdGNiaUFnSUNCeWNHTXVjMlYwU1c1MFpYSm1ZV05sS0Y5cGJuUmxjbVpoWTJVcE8xeHVJQ0I5TzF4dVhHNGdJQzhxS2x4dUlDQWdLaUJFYVhOamIyNXVaV04wY3lCMGFHVWdjR3gxWjJsdUlHWnliMjBnZEdobElHRndjR3hwWTJGMGFXOXVJQ2h6Wlc1a2FXNW5YRzRnSUNBcUlHNXZkR2xtYVdOaGRHbHZiaUJ0WlhOellXZGxLU0JoYm1RZ1pHVnpkSEp2ZVhNZ2FYUnpaV3htWEc0Z0lDQXFMMXh1SUNCaGNIQnNhV05oZEdsdmJpNWthWE5qYjI1dVpXTjBJRDBnWm5WdVkzUnBiMjRvWDJsdWRHVnlabUZqWlNrZ2UxeHVJQ0FnSUhKd1l5NWthWE5qYjI1dVpXTjBLQ2s3WEc0Z0lIMDdYRzU5WEc0aVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCT3pzN096dEJRVXRCTzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVbEJPMEZCUTBFN1FVRkRRVHRCUVVSQk8wRkJSMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZGUVR0QlFVTkJPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlJVRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkpRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlJVRTdPenM3T3pzN096dEJRVTlCTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVVZCT3pzN096czdPMEZCUzBFN1FVRkRRVHRCUVVOQk8wRkJSVUU3T3pzN096dEJRVWxCTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpYzI5MWNtTmxVbTl2ZENJNklpSjlcXFxcbi8vIyBzb3VyY2VVUkw9d2VicGFjay1pbnRlcm5hbDovLy8uL3NyYy9wbHVnaW5Db3JlLmpzXFxcXG5cXFwiKTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvcnBjLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy9ycGMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBBUElfVkVSU0lPTiwgUlBDICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5ldmFsKFxcXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwiQVBJX1ZFUlNJT05cXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBUElfVkVSU0lPTjsgfSk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwiUlBDXFxcXFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUlBDOyB9KTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMuanMgKi8gXFxcXFxcXCIuL3NyYy91dGlscy5qc1xcXFxcXFwiKTtcXFxcbi8qKlxcXFxuICogQ29udGFpbnMgdGhlIFJQQyBvYmplY3QgdXNlZCBib3RoIGJ5IHRoZSBhcHBsaWNhdGlvblxcXFxuICogc2l0ZSwgYW5kIGJ5IGVhY2ggcGx1Z2luXFxcXG4gKi9cXFxcblxcXFxuY29uc3QgQVBJX1ZFUlNJT04gPSBcXFxcXFxcIjAuMi4wXFxcXFxcXCI7XFxcXG5jb25zdCBBcnJheUJ1ZmZlclZpZXcgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBVaW50OEFycmF5KCkpKS5jb25zdHJ1Y3RvcjtcXFxcblxcXFxuZnVuY3Rpb24gX2FwcGVuZEJ1ZmZlcihidWZmZXIxLCBidWZmZXIyKSB7XFxcXG4gIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcjEuYnl0ZUxlbmd0aCArIGJ1ZmZlcjIuYnl0ZUxlbmd0aCk7XFxcXG4gIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMSksIDApO1xcXFxuICB0bXAuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpLCBidWZmZXIxLmJ5dGVMZW5ndGgpO1xcXFxuICByZXR1cm4gdG1wLmJ1ZmZlcjtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gZ2V0S2V5QnlWYWx1ZShvYmplY3QsIHZhbHVlKSB7XFxcXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLmZpbmQoa2V5ID0+IG9iamVjdFtrZXldID09PSB2YWx1ZSk7XFxcXG59XFxcXG4vKipcXFxcbiAqIFJQQyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbmdsZSBzaXRlIGluIHRoZVxcXFxuICogY29tbXVuaWNhdGlvbiBwcm90b2NvbCBiZXR3ZWVuIHRoZSBhcHBsaWNhdGlvbiBhbmQgdGhlIHBsdWdpblxcXFxuICpcXFxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uIGEgc3BlY2lhbCBvYmplY3QgYWxsb3dpbmcgdG8gc2VuZFxcXFxuICogYW5kIHJlY2VpdmUgbWVzc2FnZXMgZnJvbSB0aGUgb3Bwb3NpdGUgc2l0ZSAoYmFzaWNhbGx5IGl0XFxcXG4gKiBzaG91bGQgb25seSBwcm92aWRlIHNlbmQoKSBhbmQgb25NZXNzYWdlKCkgbWV0aG9kcylcXFxcbiAqL1xcXFxuXFxcXG5cXFxcbmNsYXNzIFJQQyB7XFxcXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGNvbmZpZykge1xcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xcXFxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xcXFxuICAgIHRoaXMuX2ludGVyZmFjZSA9IHt9O1xcXFxuICAgIHRoaXMuX3BsdWdpbl9pbnRlcmZhY2VzID0ge307XFxcXG4gICAgdGhpcy5fcmVtb3RlID0gbnVsbDtcXFxcblxcXFxuICAgIHRoaXMuX3JlbW90ZVVwZGF0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fTtcXFxcblxcXFxuICAgIHRoaXMuX2dldEludGVyZmFjZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fTtcXFxcblxcXFxuICAgIHRoaXMuX2ludGVyZmFjZVNldEFzUmVtb3RlSGFuZGxlciA9IG51bGw7XFxcXG5cXFxcbiAgICB0aGlzLl9kaXNjb25uZWN0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHt9O1xcXFxuXFxcXG4gICAgdGhpcy5fc3RvcmUgPSBuZXcgUmVmZXJlbmNlU3RvcmUoKTtcXFxcbiAgICB0aGlzLl9tZXRob2RfcmVmcyA9IG5ldyBSZWZlcmVuY2VTdG9yZSgpO1xcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xcXFxuICAgIGxldCBtZSA9IHRoaXM7XFxcXG5cXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uTWVzc2FnZShmdW5jdGlvbiAoZGF0YSkge1xcXFxuICAgICAgbWUuX3Byb2Nlc3NNZXNzYWdlKGRhdGEpO1xcXFxuICAgIH0pO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBTZXQgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSByZW1vdGUgc2l0ZSB1cGRhdGVzIGl0c1xcXFxuICAgKiBpbnRlcmZhY2VcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIG9uUmVtb3RlVXBkYXRlKGhhbmRsZXIpIHtcXFxcbiAgICB0aGlzLl9yZW1vdGVVcGRhdGVIYW5kbGVyID0gaGFuZGxlcjtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2V0IGEgaGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbiByZWNlaXZlZCBhIHJlc3BvbmNlIGZyb20gdGhlXFxcXG4gICAqIHJlbW90ZSBzaXRlIHJlcG9ydGluZyB0aGF0IHRoZSBwcmV2aW91c2x5IHByb3ZpZGVkIGludGVyZmFjZVxcXFxuICAgKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2V0IGFzIHJlbW90ZSBmb3IgdGhhdCBzaXRlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBvblJlbW90ZVJlYWR5KGhhbmRsZXIpIHtcXFxcbiAgICB0aGlzLl9tZXRob2RfcmVmcy5vblJlYWR5KGhhbmRsZXIpO1xcXFxuICB9XFxcXG5cXFxcbiAgb25SZW1vdGVCdXN5KGhhbmRsZXIpIHtcXFxcbiAgICB0aGlzLl9tZXRob2RfcmVmcy5vbkJ1c3koaGFuZGxlcik7XFxcXG4gIH1cXFxcblxcXFxuICBnZXRSZW1vdGVDYWxsU3RhY2soKSB7XFxcXG4gICAgcmV0dXJuIHRoaXMuX21ldGhvZF9yZWZzLmdldFN0YWNrKCk7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNldCBhIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHJlbW90ZSBzaXRlIHJlcXVlc3RzIHRvXFxcXG4gICAqIChyZSlzZW5kIHRoZSBpbnRlcmZhY2UuIFVzZWQgdG8gZGV0ZWN0IGFuIGluaXRpYWx6YXRpb25cXFxcbiAgICogY29tcGxldGlvbiB3aXRob3V0IHNlbmRpbmcgYWRkaXRpb25hbCByZXF1ZXN0LCBzaW5jZSBpbiBmYWN0XFxcXG4gICAqICdnZXRJbnRlcmZhY2UnIHJlcXVlc3QgaXMgb25seSBzZW50IGJ5IGFwcGxpY2F0aW9uIGF0IHRoZSBsYXN0XFxcXG4gICAqIHN0ZXAgb2YgdGhlIHBsdWdpbiBpbml0aWFsaXphdGlvblxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgb25HZXRJbnRlcmZhY2UoaGFuZGxlcikge1xcXFxuICAgIHRoaXMuX2dldEludGVyZmFjZUhhbmRsZXIgPSBoYW5kbGVyO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzZXQgb2YgcmVtb3RlIGludGVyZmFjZSBtZXRob2RzXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgZ2V0UmVtb3RlKCkge1xcXFxuICAgIHJldHVybiB0aGlzLl9yZW1vdGU7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNldHMgdGhlIGludGVyZmFjZSBvZiB0aGlzIHNpdGUgbWFraW5nIGl0IGF2YWlsYWJsZSB0byB0aGVcXFxcbiAgICogcmVtb3RlIHNpdGUgYnkgc2VuZGluZyBhIG1lc3NhZ2Ugd2l0aCBhIHNldCBvZiBtZXRob2RzIG5hbWVzXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBfaW50ZXJmYWNlIHRvIHNldFxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIHNldEludGVyZmFjZShfaW50ZXJmYWNlKSB7XFxcXG4gICAgaWYgKHRoaXMuY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zKSB7XFxcXG4gICAgICBmb3IgKGxldCBmdW5jX25hbWUgb2YgdGhpcy5jb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnMpIHtcXFxcbiAgICAgICAgaWYgKHRoaXMuX3JlbW90ZVtmdW5jX25hbWVdKSB7XFxcXG4gICAgICAgICAgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xcXFxuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlW2Z1bmNfbmFtZV0pIHtcXFxcbiAgICAgICAgICAgICAgX2ludGVyZmFjZVtmdW5jX25hbWVdID0gKC4uLmFyZ3MpID0+IHtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdGVbZnVuY19uYW1lXSguLi5hcmdzKTtcXFxcbiAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICB9IGVsc2UgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XFxcXG4gICAgICAgICAgICBpZiAoIV9pbnRlcmZhY2UuY29uc3RydWN0b3IucHJvdG90eXBlW2Z1bmNfbmFtZV0pIHtcXFxcbiAgICAgICAgICAgICAgX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbZnVuY19uYW1lXSA9ICguLi5hcmdzKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3RlW2Z1bmNfbmFtZV0oLi4uYXJncyk7XFxcXG4gICAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICB9XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgdGhpcy5faW50ZXJmYWNlID0gX2ludGVyZmFjZTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2VuZHMgdGhlIGFjdHVhbCBpbnRlcmZhY2UgdG8gdGhlIHJlbW90ZSBzaXRlIHVwb24gaXQgd2FzXFxcXG4gICAqIHVwZGF0ZWQgb3IgYnkgYSBzcGVjaWFsIHJlcXVlc3Qgb2YgdGhlIHJlbW90ZSBzaXRlXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgc2VuZEludGVyZmFjZSgpIHtcXFxcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XFxcXG4gICAgICB2YXIgbmFtZXMgPSBbXTtcXFxcblxcXFxuICAgICAgaWYgKCF0aGlzLl9pbnRlcmZhY2UpIHtcXFxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwiaW50ZXJmYWNlIGlzIG5vdCBzZXQuXFxcXFxcXCIpO1xcXFxuICAgICAgfVxcXFxuXFxcXG4gICAgICBpZiAodGhpcy5faW50ZXJmYWNlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcXFxcbiAgICAgICAgZm9yICh2YXIgbmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLl9pbnRlcmZhY2UpKSB7XFxcXG4gICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcXFxcXFxcIl9cXFxcXFxcIikpIGNvbnRpbnVlO1xcXFxuXFxcXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pbnRlcmZhY2VbbmFtZV0gPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgbmFtZXMucHVzaCh7XFxcXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXFxcXG4gICAgICAgICAgICAgIGRhdGE6IG51bGwsXFxcXG4gICAgICAgICAgICAgIHR5cGU6IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIlxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5faW50ZXJmYWNlW25hbWVdO1xcXFxuXFxcXG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YSA9PT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICB2YXIgZGF0YTIgPSB7fTtcXFxcblxcXFxuICAgICAgICAgICAgICBmb3IgKHZhciBrIG9mIE9iamVjdC5rZXlzKGRhdGEpKSB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2tdID09PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICAgIGRhdGEyW2tdID0gXFxcXFxcXCJycGNfbWV0aG9kOjpcXFxcXFxcIiArIGs7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgIGRhdGEyW2tdID0gZGF0YVtrXTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgICBuYW1lcy5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxcXFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEyLFxcXFxuICAgICAgICAgICAgICAgIHR5cGU6IFxcXFxcXFwib2JqZWN0XFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdChkYXRhKSAhPT0gZGF0YSkge1xcXFxuICAgICAgICAgICAgICBuYW1lcy5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxcXFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXFxcXG4gICAgICAgICAgICAgICAgdHlwZTogXFxcXFxcXCJkYXRhXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICB9IC8vIGEgY2xhc3NcXFxcbiAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVyZmFjZS5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcXFxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJQbGVhc2UgaW5zdGFudGlhdGUgdGhlIGNsYXNzIGJlZm9yZSBleHBvcnR0aW5nIGl0LlxcXFxcXFwiKTtcXFxcbiAgICAgICAgfSAvLyBpbnN0YW5jZSBvZiBhIGNsYXNzXFxcXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcXFxcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5faW50ZXJmYWNlKSkuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMuX2ludGVyZmFjZSkpO1xcXFxuXFxcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICB2YXIgbmFtZV8gPSBmdW5jdGlvbnNbaV07XFxcXG4gICAgICAgICAgICAgIGlmIChuYW1lXy5zdGFydHNXaXRoKFxcXFxcXFwiX1xcXFxcXFwiKSB8fCBuYW1lXyA9PT0gXFxcXFxcXCJjb25zdHJ1Y3RvclxcXFxcXFwiKSBjb250aW51ZTtcXFxcblxcXFxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ludGVyZmFjZVtuYW1lX10gPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZV8sXFxcXG4gICAgICAgICAgICAgICAgICBkYXRhOiBudWxsXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXFxcXFxcXCJVbnN1cHBvcnRlZCBpbnRlcmZhY2UgdHlwZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgIHRoaXMuX2ludGVyZmFjZVNldEFzUmVtb3RlSGFuZGxlciA9IHJlc29sdmU7XFxcXG5cXFxcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZCh7XFxcXG4gICAgICAgIHR5cGU6IFxcXFxcXFwic2V0SW50ZXJmYWNlXFxcXFxcXCIsXFxcXG4gICAgICAgIGFwaTogbmFtZXNcXFxcbiAgICAgIH0pO1xcXFxuICAgIH0pO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBIYW5kbGVzIGEgbWVzc2FnZSBmcm9tIHRoZSByZW1vdGUgc2l0ZVxcXFxuICAgKi9cXFxcbiAgLy8gdmFyIGNhbGxiYWNrX3JlZyA9IG5ldyBSZWdFeHAoXFxcXFxcXCJvbnVwZGF0ZXxydW4kXFxcXFxcXCIpXFxcXG5cXFxcblxcXFxuICBfcHJvY2Vzc01lc3NhZ2UoZGF0YSkge1xcXFxuICAgIHZhciByZXNvbHZlLCByZWplY3QsIG1ldGhvZCwgYXJncywgcmVzdWx0O1xcXFxuXFxcXG4gICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcXFxcbiAgICAgIGNhc2UgXFxcXFxcXCJtZXRob2RcXFxcXFxcIjpcXFxcbiAgICAgICAgdmFyIF9pbnRlcmZhY2UgPSB0aGlzLl9pbnRlcmZhY2U7XFxcXG5cXFxcbiAgICAgICAgdmFyIF9tZXRob2RfY29udGV4dCA9IF9pbnRlcmZhY2UuX190aGlzX18gfHwgX2ludGVyZmFjZTtcXFxcblxcXFxuICAgICAgICBpZiAoZGF0YS5waWQpIHtcXFxcbiAgICAgICAgICBfaW50ZXJmYWNlID0gdGhpcy5fcGx1Z2luX2ludGVyZmFjZXNbZGF0YS5waWRdO1xcXFxuXFxcXG4gICAgICAgICAgaWYgKCFfaW50ZXJmYWNlKSB7XFxcXG4gICAgICAgICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XFxcXG4gICAgICAgICAgICAgIFtyZXNvbHZlLCByZWplY3RdID0gdGhpcy5fdW53cmFwKGRhdGEucHJvbWlzZSwgZmFsc2UpO1xcXFxuICAgICAgICAgICAgICByZWplY3QoYHBsdWdpbiBhcGkgZnVuY3Rpb24gaXMgbm90IGF2YWlhbGJlIGluIFxcXFxcXFwiJHtkYXRhLnBpZH1cXFxcXFxcIiwgdGhlIHBsdWdpbiBtYXliZSB0ZXJtaW5hdGVkLmApO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgcGx1Z2luIGFwaSBmdW5jdGlvbiBpcyBub3QgYXZhaWFsYmUgaW4gJHtkYXRhLnBpZH0sIHRoZSBwbHVnaW4gbWF5YmUgdGVybWluYXRlZC5gKTtcXFxcbiAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgcmV0dXJuO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGlmIChkYXRhLm5hbWUuaW5kZXhPZihcXFxcXFxcIi5cXFxcXFxcIikgIT09IC0xKSB7XFxcXG4gICAgICAgICAgdmFyIG5hbWVzID0gZGF0YS5uYW1lLnNwbGl0KFxcXFxcXFwiLlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICBtZXRob2QgPSBfaW50ZXJmYWNlW25hbWVzWzBdXVtuYW1lc1sxXV07XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgbWV0aG9kID0gX2ludGVyZmFjZVtkYXRhLm5hbWVdO1xcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgYXJncyA9IHRoaXMuX3Vud3JhcChkYXRhLmFyZ3MsIHRydWUpO1xcXFxuXFxcXG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcXFxcbiAgICAgICAgICBbcmVzb2x2ZSwgcmVqZWN0XSA9IHRoaXMuX3Vud3JhcChkYXRhLnByb21pc2UsIGZhbHNlKTtcXFxcblxcXFxuICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkoX21ldGhvZF9jb250ZXh0LCBhcmdzKTtcXFxcblxcXFxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgfHwgbWV0aG9kLmNvbnN0cnVjdG9yICYmIG1ldGhvZC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcXFxcXFxcIkFzeW5jRnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgbWV0aG9kKTtcXFxcbiAgICAgICAgICAgIHJlamVjdChlKTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseShfbWV0aG9kX2NvbnRleHQsIGFyZ3MpO1xcXFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgbWV0aG9kLCBhcmdzKTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICBicmVhaztcXFxcblxcXFxuICAgICAgY2FzZSBcXFxcXFxcImNhbGxiYWNrXFxcXFxcXCI6XFxcXG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcXFxcbiAgICAgICAgICBbcmVzb2x2ZSwgcmVqZWN0XSA9IHRoaXMuX3Vud3JhcChkYXRhLnByb21pc2UsIGZhbHNlKTtcXFxcblxcXFxuICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBtZXRob2QgPSB0aGlzLl9zdG9yZS5mZXRjaChkYXRhLm51bSk7XFxcXG4gICAgICAgICAgICBhcmdzID0gdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XFxcXG5cXFxcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSB7XFxcXG4gICAgICAgICAgICAgIHRocm93IFxcXFxcXFwiQ2FsbGJhY2sgZnVuY3Rpb24gY2FuIG9ubHkgY2FsbGVkIG9uY2UsIGlmIHlvdSB3YW50IHRvIGNhbGwgYSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgdGltZXMsIHBsZWFzZSBtYWtlIGl0IGFzIGEgcGx1Z2luIGFwaSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vaW1qb3kuaW8vZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XFxcXG5cXFxcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlIHx8IG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXFxcXFxcXCJBc3luY0Z1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgcmVzdWx0LnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIG1ldGhvZCk7XFxcXG4gICAgICAgICAgICByZWplY3QoZSk7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBtZXRob2QgPSB0aGlzLl9zdG9yZS5mZXRjaChkYXRhLm51bSk7XFxcXG4gICAgICAgICAgICBhcmdzID0gdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XFxcXG5cXFxcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSB7XFxcXG4gICAgICAgICAgICAgIHRocm93IFxcXFxcXFwiUGxlYXNlIG5vdGljZSB0aGF0IGNhbGxiYWNrIGZ1bmN0aW9uIGNhbiBvbmx5IGNhbGxlZCBvbmNlLCBpZiB5b3Ugd2FudCB0byBjYWxsIGEgZnVuY3Rpb24gZm9yIG11bHRpcGxlIHRpbWVzLCBwbGVhc2UgbWFrZSBpdCBhcyBhIHBsdWdpbiBhcGkgZnVuY3Rpb24uIFNlZSBodHRwczovL2ltam95LmlvL2RvY3MgZm9yIG1vcmUgZGV0YWlscy5cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgbWV0aG9kLmFwcGx5KG51bGwsIGFyZ3MpO1xcXFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgbWV0aG9kLCBhcmdzKTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICBicmVhaztcXFxcblxcXFxuICAgICAgY2FzZSBcXFxcXFxcInNldEludGVyZmFjZVxcXFxcXFwiOlxcXFxuICAgICAgICB0aGlzLl9zZXRSZW1vdGUoZGF0YS5hcGkpO1xcXFxuXFxcXG4gICAgICAgIGJyZWFrO1xcXFxuXFxcXG4gICAgICBjYXNlIFxcXFxcXFwiZ2V0SW50ZXJmYWNlXFxcXFxcXCI6XFxcXG4gICAgICAgIHRoaXMuc2VuZEludGVyZmFjZSgpO1xcXFxuXFxcXG4gICAgICAgIHRoaXMuX2dldEludGVyZmFjZUhhbmRsZXIoKTtcXFxcblxcXFxuICAgICAgICBicmVhaztcXFxcblxcXFxuICAgICAgY2FzZSBcXFxcXFxcImludGVyZmFjZVNldEFzUmVtb3RlXFxcXFxcXCI6XFxcXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faW50ZXJmYWNlU2V0QXNSZW1vdGVIYW5kbGVyID09PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICB0aGlzLl9pbnRlcmZhY2VTZXRBc1JlbW90ZUhhbmRsZXIoKTtcXFxcblxcXFxuICAgICAgICAgIHRoaXMuX2ludGVyZmFjZVNldEFzUmVtb3RlSGFuZGxlciA9PT0gbnVsbDtcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGJyZWFrO1xcXFxuXFxcXG4gICAgICBjYXNlIFxcXFxcXFwiZGlzY29ubmVjdFxcXFxcXFwiOlxcXFxuICAgICAgICB0aGlzLl9kaXNjb25uZWN0SGFuZGxlcigpO1xcXFxuXFxcXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xcXFxuXFxcXG4gICAgICAgIGJyZWFrO1xcXFxuICAgIH1cXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2VuZHMgYSByZXF1ZXN0cyB0byB0aGUgcmVtb3RlIHNpdGUgYXNraW5nIGl0IHRvIHByb3ZpZGUgaXRzXFxcXG4gICAqIGN1cnJlbnQgaW50ZXJmYWNlXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgcmVxdWVzdFJlbW90ZSgpIHtcXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLnNlbmQoe1xcXFxuICAgICAgdHlwZTogXFxcXFxcXCJnZXRJbnRlcmZhY2VcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICB9XFxcXG5cXFxcbiAgX25kYXJyYXkodHlwZWRBcnJheSwgc2hhcGUsIGR0eXBlKSB7XFxcXG4gICAgdmFyIF9kdHlwZSA9IF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXFxcXFwidHlwZWRBcnJheVRvRHR5cGVcXFxcXFxcIl1bdHlwZWRBcnJheS5jb25zdHJ1Y3Rvci5uYW1lXTtcXFxcblxcXFxuICAgIGlmIChkdHlwZSAmJiBkdHlwZSAhPT0gX2R0eXBlKSB7XFxcXG4gICAgICB0aHJvdyBcXFxcXFxcImR0eXBlIGRvZXNuJ3QgbWF0Y2ggdGhlIHR5cGUgb2YgdGhlIGFycmF5OiBcXFxcXFxcIiArIF9kdHlwZSArIFxcXFxcXFwiICE9IFxcXFxcXFwiICsgZHR5cGU7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgc2hhcGUgPSBzaGFwZSB8fCBbdHlwZWRBcnJheS5sZW5ndGhdO1xcXFxuICAgIHJldHVybiB7XFxcXG4gICAgICBfX2phaWxlZF90eXBlX186IFxcXFxcXFwibmRhcnJheVxcXFxcXFwiLFxcXFxuICAgICAgX192YWx1ZV9fOiB0eXBlZEFycmF5LFxcXFxuICAgICAgX19zaGFwZV9fOiBzaGFwZSxcXFxcbiAgICAgIF9fZHR5cGVfXzogX2R0eXBlXFxcXG4gICAgfTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2V0cyB0aGUgbmV3IHJlbW90ZSBpbnRlcmZhY2UgcHJvdmlkZWQgYnkgdGhlIG90aGVyIHNpdGVcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtBcnJheX0gbmFtZXMgbGlzdCBvZiBmdW5jdGlvbiBuYW1lc1xcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIF9zZXRSZW1vdGUoYXBpKSB7XFxcXG4gICAgdGhpcy5fcmVtb3RlID0ge307XFxcXG4gICAgdmFyIGksIG5hbWUsIGRhdGEsIHR5cGU7XFxcXG5cXFxcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXBpLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICBuYW1lID0gYXBpW2ldLm5hbWU7XFxcXG4gICAgICBkYXRhID0gYXBpW2ldLmRhdGE7XFxcXG4gICAgICB0eXBlID0gYXBpW2ldLnR5cGU7XFxcXG5cXFxcbiAgICAgIGlmICh0eXBlID09PSBcXFxcXFxcImRhdGFcXFxcXFxcIikge1xcXFxuICAgICAgICB0aGlzLl9yZW1vdGVbbmFtZV0gPSBkYXRhO1xcXFxuICAgICAgfSBlbHNlIGlmIChkYXRhKSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIikge1xcXFxuICAgICAgICAgIHZhciBkYXRhMiA9IHt9O1xcXFxuXFxcXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcXFxcbiAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcXFxcbiAgICAgICAgICAgICAgaWYgKGRhdGFba2V5XSA9PT0gXFxcXFxcXCJycGNfbWV0aG9kOjpcXFxcXFxcIiArIGtleSkge1xcXFxuICAgICAgICAgICAgICAgIGRhdGEyW2tleV0gPSB0aGlzLl9nZW5SZW1vdGVNZXRob2QobmFtZSArIFxcXFxcXFwiLlxcXFxcXFwiICsga2V5KTtcXFxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICBkYXRhMltrZXldID0gZGF0YVtrZXldO1xcXFxuICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgdGhpcy5fcmVtb3RlW25hbWVdID0gZGF0YTI7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgdGhpcy5fcmVtb3RlW25hbWVdID0gZGF0YTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdGhpcy5fcmVtb3RlW25hbWVdID0gdGhpcy5fZ2VuUmVtb3RlTWV0aG9kKG5hbWUpO1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcblxcXFxuICAgIHRoaXMuX3JlbW90ZVVwZGF0ZUhhbmRsZXIoKTtcXFxcblxcXFxuICAgIHRoaXMuX3JlcG9ydFJlbW90ZVNldCgpO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBHZW5lcmF0ZXMgdGhlIHdyYXBwZWQgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBhIHNpbmdsZSByZW1vdGVcXFxcbiAgICogbWV0aG9kLiBXaGVuIHRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgY2FsbGVkLCBpdCB3aWxsIHNlbmQgdGhlXFxcXG4gICAqIGNvcnJlc3BvbmRpbmcgbWVzc2FnZSB0byB0aGUgcmVtb3RlIHNpdGUgYXNraW5nIGl0IHRvIGV4ZWN1dGVcXFxcbiAgICogdGhlIHBhcnRpY3VsYXIgbWV0aG9kIG9mIGl0cyBpbnRlcmZhY2VcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIHJlbW90ZSBtZXRob2RcXFxcbiAgICpcXFxcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSB3cmFwcGVkIHJlbW90ZSBtZXRob2RcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfZ2VuUmVtb3RlTWV0aG9kKG5hbWUsIHBsdWdpbl9pZCkge1xcXFxuICAgIHZhciBtZSA9IHRoaXM7XFxcXG5cXFxcbiAgICB2YXIgcmVtb3RlTWV0aG9kID0gZnVuY3Rpb24gKCkge1xcXFxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXFxcbiAgICAgICAgbGV0IGlkID0gbnVsbDtcXFxcblxcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgIGlkID0gbWUuX21ldGhvZF9yZWZzLnB1dChwbHVnaW5faWQgPyBwbHVnaW5faWQgKyBcXFxcXFxcIi9cXFxcXFxcIiArIG5hbWUgOiBuYW1lKTtcXFxcblxcXFxuICAgICAgICAgIHZhciB3cmFwcGVkX3Jlc29sdmUgPSBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICAgICAgICBpZiAoaWQgIT09IG51bGwpIG1lLl9tZXRob2RfcmVmcy5mZXRjaChpZCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcXFxuICAgICAgICAgIH07XFxcXG5cXFxcbiAgICAgICAgICB2YXIgd3JhcHBlZF9yZWplY3QgPSBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICAgICAgICBpZiAoaWQgIT09IG51bGwpIG1lLl9tZXRob2RfcmVmcy5mZXRjaChpZCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxcXG4gICAgICAgICAgfTtcXFxcblxcXFxuICAgICAgICAgIHdyYXBwZWRfcmVzb2x2ZS5fX2phaWxlZF9wYWlyc19fID0gd3JhcHBlZF9yZWplY3Q7XFxcXG4gICAgICAgICAgd3JhcHBlZF9yZWplY3QuX19qYWlsZWRfcGFpcnNfXyA9IHdyYXBwZWRfcmVzb2x2ZTtcXFxcbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XFxcXG5cXFxcbiAgICAgICAgICBpZiAobmFtZSA9PT0gXFxcXFxcXCJyZWdpc3RlclxcXFxcXFwiIHx8IG5hbWUgPT09IFxcXFxcXFwiZXhwb3J0XFxcXFxcXCIgfHwgbmFtZSA9PT0gXFxcXFxcXCJvblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBhcmdzID0gbWUuX3dyYXAoYXJncywgdHJ1ZSk7XFxcXG4gICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGFyZ3MgPSBtZS5fd3JhcChhcmdzKTtcXFxcbiAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcXFxcbiAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcXFxcblxcXFxuICAgICAgICAgIG1lLl9jb25uZWN0aW9uLnNlbmQoe1xcXFxuICAgICAgICAgICAgdHlwZTogXFxcXFxcXCJtZXRob2RcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXFxcXG4gICAgICAgICAgICBwaWQ6IHBsdWdpbl9pZCxcXFxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXFxcXG4gICAgICAgICAgICBwcm9taXNlOiBtZS5fd3JhcChbd3JhcHBlZF9yZXNvbHZlLCB3cmFwcGVkX3JlamVjdF0pXFxcXG4gICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyk7XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICBpZiAoaWQpIG1lLl9tZXRob2RfcmVmcy5mZXRjaChpZCk7XFxcXG4gICAgICAgICAgcmVqZWN0KGBGYWlsZWQgdG8gZXhlY3R1ZSByZW1vdGUgbWV0aG9kIChwbHVnaW46ICR7cGx1Z2luX2lkIHx8IG1lLmlkfSwgbWV0aG9kOiAke25hbWV9KSwgZXJyb3I6ICR7ZX1gKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfSk7XFxcXG4gICAgfTtcXFxcblxcXFxuICAgIHJlbW90ZU1ldGhvZC5fX3JlbW90ZV9tZXRob2QgPSB0cnVlO1xcXFxuICAgIHJldHVybiByZW1vdGVNZXRob2Q7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNlbmRzIGEgcmVzcG9uY2UgcmVwb3J0aW5nIHRoYXQgaW50ZXJmYWNlIGp1c3QgcHJvdmlkZWQgYnkgdGhlXFxcXG4gICAqIHJlbW90ZSBzaXRlIHdhcyBzdWNjZXNzZnVsbHkgc2V0IGJ5IHRoaXMgc2l0ZSBhcyByZW1vdGVcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfcmVwb3J0UmVtb3RlU2V0KCkge1xcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZCh7XFxcXG4gICAgICB0eXBlOiBcXFxcXFxcImludGVyZmFjZVNldEFzUmVtb3RlXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogUHJlcGFyZXMgdGhlIHByb3ZpZGVkIHNldCBvZiByZW1vdGUgbWV0aG9kIGFyZ3VtZW50cyBmb3JcXFxcbiAgICogc2VuZGluZyB0byB0aGUgcmVtb3RlIHNpdGUsIHJlcGxhY2VzIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGhcXFxcbiAgICogaWRlbnRpZmllcnNcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyB0byB3cmFwXFxcXG4gICAqXFxcXG4gICAqIEByZXR1cm5zIHtBcnJheX0gd3JhcHBlZCBhcmd1bWVudHNcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfZW5jb2RlX2ludGVyZmFjZShhT2JqZWN0LCBiT2JqZWN0KSB7XFxcXG4gICAgdmFyIHYsIGs7XFxcXG4gICAgY29uc3QgZW5jb2RlZF9pbnRlcmZhY2UgPSB7fTtcXFxcbiAgICBhT2JqZWN0W1xcXFxcXFwiX19pZF9fXFxcXFxcXCJdID0gYU9iamVjdFtcXFxcXFxcIl9faWRfX1xcXFxcXFwiXSB8fCBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcXFxcXCJyYW5kSWRcXFxcXFxcIl0pKCk7XFxcXG5cXFxcbiAgICBmb3IgKGsgaW4gYU9iamVjdCkge1xcXFxuICAgICAgaWYgKGsgPT09IFxcXFxcXFwiaGFzT3duUHJvcGVydHlcXFxcXFxcIikgY29udGludWU7XFxcXG5cXFxcbiAgICAgIGlmIChhT2JqZWN0Lmhhc093blByb3BlcnR5KGspKSB7XFxcXG4gICAgICAgIGlmIChrLnN0YXJ0c1dpdGgoXFxcXFxcXCJfXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICB2ID0gYU9iamVjdFtrXTtcXFxcblxcXFxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICBfX2phaWxlZF90eXBlX186IFxcXFxcXFwicGx1Z2luX2ludGVyZmFjZVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgX19wbHVnaW5faWRfXzogYU9iamVjdFtcXFxcXFxcIl9faWRfX1xcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgIF9fdmFsdWVfXzogayxcXFxcbiAgICAgICAgICAgIG51bTogbnVsbFxcXFxuICAgICAgICAgIH07XFxcXG4gICAgICAgICAgZW5jb2RlZF9pbnRlcmZhY2Vba10gPSB2O1xcXFxuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdCh2KSAhPT0gdikge1xcXFxuICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICBfX2phaWxlZF90eXBlX186IFxcXFxcXFwiYXJndW1lbnRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIF9fdmFsdWVfXzogdlxcXFxuICAgICAgICAgIH07XFxcXG4gICAgICAgICAgZW5jb2RlZF9pbnRlcmZhY2Vba10gPSB2O1xcXFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcXFxcXFxcIm9iamVjdFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgYk9iamVjdFtrXSA9IEFycmF5LmlzQXJyYXkodikgPyBbXSA6IHt9O1xcXFxuXFxcXG4gICAgICAgICAgdGhpcy5fZW5jb2RlX2ludGVyZmFjZSh2LCBiT2JqZWN0W2tdKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcblxcXFxuICAgIHRoaXMuX3BsdWdpbl9pbnRlcmZhY2VzW2FPYmplY3RbXFxcXFxcXCJfX2lkX19cXFxcXFxcIl1dID0gZW5jb2RlZF9pbnRlcmZhY2U7XFxcXG5cXFxcbiAgICBpZiAoYU9iamVjdC5vbikge1xcXFxuICAgICAgYU9iamVjdC5vbihcXFxcXFxcImNsb3NlXFxcXFxcXCIsICgpID0+IHtcXFxcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BsdWdpbl9pbnRlcmZhY2VzW2FPYmplY3RbXFxcXFxcXCJfX2lkX19cXFxcXFxcIl1dO1xcXFxuICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICB9XFxcXG5cXFxcbiAgX2VuY29kZShhT2JqZWN0LCBhc19pbnRlcmZhY2UpIHtcXFxcbiAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IFtdO1xcXFxuXFxcXG4gICAgaWYgKCFhT2JqZWN0KSB7XFxcXG4gICAgICByZXR1cm4gYU9iamVjdDtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICB2YXIgX3RyYW5zZmVyID0gYU9iamVjdC5fdHJhbnNmZXI7XFxcXG4gICAgdmFyIGJPYmplY3QsIHYsIGs7XFxcXG4gICAgdmFyIGlzYXJyYXkgPSBBcnJheS5pc0FycmF5KGFPYmplY3QpO1xcXFxuICAgIGJPYmplY3QgPSBpc2FycmF5ID8gW10gOiB7fTsgLy9za2lwIGlmIGFscmVhZHkgZW5jb2RlZFxcXFxuXFxcXG4gICAgaWYgKHR5cGVvZiBhT2JqZWN0ID09PSBcXFxcXFxcIm9iamVjdFxcXFxcXFwiICYmIGFPYmplY3QuX19qYWlsZWRfdHlwZV9fICYmIGFPYmplY3QuX192YWx1ZV9fKSB7XFxcXG4gICAgICByZXR1cm4gYU9iamVjdDtcXFxcbiAgICB9IC8vZW5jb2RlIGludGVyZmFjZXNcXFxcblxcXFxuXFxcXG4gICAgaWYgKHR5cGVvZiBhT2JqZWN0ID09PSBcXFxcXFxcIm9iamVjdFxcXFxcXFwiICYmICFBcnJheS5pc0FycmF5KGFPYmplY3QpICYmIChhT2JqZWN0Ll9fYXNfaW50ZXJmYWNlX18gfHwgYXNfaW50ZXJmYWNlKSkge1xcXFxuICAgICAgdGhpcy5fZW5jb2RlX2ludGVyZmFjZShhT2JqZWN0LCBiT2JqZWN0KTtcXFxcblxcXFxuICAgICAgcmV0dXJuIGJPYmplY3Q7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgaWYgKGFzX2ludGVyZmFjZSkge1xcXFxuICAgICAgYU9iamVjdFtcXFxcXFxcIl9faWRfX1xcXFxcXFwiXSA9IGFPYmplY3RbXFxcXFxcXCJfX2lkX19cXFxcXFxcIl0gfHwgT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXFxcXFwicmFuZElkXFxcXFxcXCJdKSgpO1xcXFxuICAgICAgdGhpcy5fcGx1Z2luX2ludGVyZmFjZXNbYU9iamVjdFtcXFxcXFxcIl9faWRfX1xcXFxcXFwiXV0gPSB0aGlzLl9wbHVnaW5faW50ZXJmYWNlc1thT2JqZWN0W1xcXFxcXFwiX19pZF9fXFxcXFxcXCJdXSB8fCB7fTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmb3IgKGsgaW4gYU9iamVjdCkge1xcXFxuICAgICAgaWYgKGsgPT09IFxcXFxcXFwiaGFzT3duUHJvcGVydHlcXFxcXFxcIikgY29udGludWU7XFxcXG5cXFxcbiAgICAgIGlmIChpc2FycmF5IHx8IGFPYmplY3QuaGFzT3duUHJvcGVydHkoaykpIHtcXFxcbiAgICAgICAgdiA9IGFPYmplY3Rba107XFxcXG5cXFxcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pbnRlcmZhY2UuX3JwY0VuY29kZSA9PT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgY29uc3QgZW5jb2RlZF9vYmogPSB0aGlzLl9pbnRlcmZhY2UuX3JwY0VuY29kZSh2KTtcXFxcblxcXFxuICAgICAgICAgIGlmIChlbmNvZGVkX29iaiAmJiBlbmNvZGVkX29iai5fX3JwY19kdHlwZV9fKSB7XFxcXG4gICAgICAgICAgICBiT2JqZWN0W2tdID0ge1xcXFxuICAgICAgICAgICAgICBfX2phaWxlZF90eXBlX186IFxcXFxcXFwiY3VzdG9tX2VuY29kaW5nXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgIF9fdmFsdWVfXzogZW5jb2RlZF9vYmpcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICB9IC8vIGlmIHRoZSByZXR1cm5lZCBvYmplY3QgZG9lcyBub3QgY29udGFpbiBfX2phaWxlZF90eXBlX18sIGFzc3VtaW5nIHRoZSBvYmplY3QgaGFzIGJlZW4gdHJhbnNmb3JtZWRcXFxcbiAgICAgICAgICBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgdiA9IGVuY29kZWRfb2JqO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICBpZiAoYXNfaW50ZXJmYWNlKSB7XFxcXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkX2ludGVyZmFjZSA9IHRoaXMuX3BsdWdpbl9pbnRlcmZhY2VzW2FPYmplY3RbXFxcXFxcXCJfX2lkX19cXFxcXFxcIl1dO1xcXFxuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcXFxcbiAgICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcXFxcXFxcInBsdWdpbl9pbnRlcmZhY2VcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgX19wbHVnaW5faWRfXzogYU9iamVjdFtcXFxcXFxcIl9faWRfX1xcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgICAgX192YWx1ZV9fOiBrLFxcXFxuICAgICAgICAgICAgICBudW06IG51bGxcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICBlbmNvZGVkX2ludGVyZmFjZVtrXSA9IHY7XFxcXG4gICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICBsZXQgaW50ZXJmYWNlRnVuY05hbWUgPSBudWxsO1xcXFxuXFxcXG4gICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9pbnRlcmZhY2UpIHtcXFxcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcXFxcbiAgICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcXFxcXFxcIl9cXFxcXFxcIikpIGNvbnRpbnVlO1xcXFxuXFxcXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcmZhY2VbbmFtZV0gPT09IHYpIHtcXFxcbiAgICAgICAgICAgICAgICBpbnRlcmZhY2VGdW5jTmFtZSA9IG5hbWU7XFxcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICB9IC8vIHNlYXJjaCBmb3IgcHJvdG90eXBlc1xcXFxuXFxcXG5cXFxcbiAgICAgICAgICB2YXIgZnVuY3Rpb25zID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuX2ludGVyZmFjZSkpO1xcXFxuXFxcXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgIHZhciBuYW1lXyA9IGZ1bmN0aW9uc1tpXTtcXFxcbiAgICAgICAgICAgIGlmIChuYW1lXy5zdGFydHNXaXRoKFxcXFxcXFwiX1xcXFxcXFwiKSkgY29udGludWU7XFxcXG5cXFxcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcmZhY2VbbmFtZV9dID09PSB2KSB7XFxcXG4gICAgICAgICAgICAgIGludGVyZmFjZUZ1bmNOYW1lID0gbmFtZV87XFxcXG4gICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgIGlmICghaW50ZXJmYWNlRnVuY05hbWUpIHtcXFxcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX3N0b3JlLnB1dCh2KTtcXFxcblxcXFxuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcXFxcbiAgICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcXFxcXFxcImNhbGxiYWNrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgIF9fdmFsdWVfXzogdi5jb25zdHJ1Y3RvciAmJiB2LmNvbnN0cnVjdG9yLm5hbWUgfHwgaWQsXFxcXG4gICAgICAgICAgICAgIG51bTogaWRcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXFxcXFxcXCJpbnRlcmZhY2VcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgX192YWx1ZV9fOiBpbnRlcmZhY2VGdW5jTmFtZSxcXFxcbiAgICAgICAgICAgICAgbnVtOiBudWxsXFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBlbHNlIGlmIChcXFxcbiAgICAgICAgLypnbG9iYWwgdGYqL1xcXFxuICAgICAgICB0eXBlb2YgdGYgIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgdGYuVGVuc29yICYmIHYgaW5zdGFuY2VvZiB0Zi5UZW5zb3IpIHtcXFxcbiAgICAgICAgICBjb25zdCB2X2J1ZmZlciA9IHYuZGF0YVN5bmMoKTtcXFxcblxcXFxuICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcXFxcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh2X2J1ZmZlci5idWZmZXIpO1xcXFxuICAgICAgICAgICAgZGVsZXRlIHYuX3RyYW5zZmVyO1xcXFxuICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICBfX2phaWxlZF90eXBlX186IFxcXFxcXFwibmRhcnJheVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgX192YWx1ZV9fOiB2X2J1ZmZlcixcXFxcbiAgICAgICAgICAgIF9fc2hhcGVfXzogdi5zaGFwZSxcXFxcbiAgICAgICAgICAgIF9fZHR5cGVfXzogdi5kdHlwZVxcXFxuICAgICAgICAgIH07XFxcXG4gICAgICAgIH0gZWxzZSBpZiAoXFxcXG4gICAgICAgIC8qZ2xvYmFsIG5qKi9cXFxcbiAgICAgICAgdHlwZW9mIG5qICE9PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiICYmIG5qLk5kQXJyYXkgJiYgdiBpbnN0YW5jZW9mIG5qLk5kQXJyYXkpIHtcXFxcbiAgICAgICAgICB2YXIgZHR5cGUgPSBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcInR5cGVkQXJyYXlUb0R0eXBlXFxcXFxcXCJdW3Yuc2VsZWN0aW9uLmRhdGEuY29uc3RydWN0b3IubmFtZV07XFxcXG5cXFxcbiAgICAgICAgICBpZiAodi5fdHJhbnNmZXIgfHwgX3RyYW5zZmVyKSB7XFxcXG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2godi5zZWxlY3Rpb24uZGF0YS5idWZmZXIpO1xcXFxuICAgICAgICAgICAgZGVsZXRlIHYuX3RyYW5zZmVyO1xcXFxuICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICBfX2phaWxlZF90eXBlX186IFxcXFxcXFwibmRhcnJheVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgX192YWx1ZV9fOiB2LnNlbGVjdGlvbi5kYXRhLFxcXFxuICAgICAgICAgICAgX19zaGFwZV9fOiB2LnNoYXBlLFxcXFxuICAgICAgICAgICAgX19kdHlwZV9fOiBkdHlwZVxcXFxuICAgICAgICAgIH07XFxcXG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEVycm9yKSB7XFxcXG4gICAgICAgICAgY29uc29sZS5lcnJvcih2KTtcXFxcbiAgICAgICAgICBiT2JqZWN0W2tdID0ge1xcXFxuICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcXFxcXFxcImVycm9yXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBfX3ZhbHVlX186IHYudG9TdHJpbmcoKVxcXFxuICAgICAgICAgIH07XFxcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgdiBpbnN0YW5jZW9mIEZpbGUpIHtcXFxcbiAgICAgICAgICBiT2JqZWN0W2tdID0ge1xcXFxuICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcXFxcXFxcImZpbGVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIF9fdmFsdWVfXzogdixcXFxcbiAgICAgICAgICAgIF9fcmVsYXRpdmVfcGF0aF9fOiB2LnJlbGF0aXZlUGF0aCB8fCB2LndlYmtpdFJlbGF0aXZlUGF0aFxcXFxuICAgICAgICAgIH07XFxcXG4gICAgICAgIH0gLy8gc2VuZCBvYmplY3RzIHN1cHBvcnRlZCBieSBzdHJ1Y3R1cmUgY2xvbmUgYWxnb3JpdGhtXFxcXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfV29ya2Vyc19BUEkvU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG1cXFxcbiAgICAgICAgZWxzZSBpZiAodiAhPT0gT2JqZWN0KHYpIHx8IHYgaW5zdGFuY2VvZiBCb29sZWFuIHx8IHYgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdiBpbnN0YW5jZW9mIERhdGUgfHwgdiBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB2IGluc3RhbmNlb2YgQmxvYiB8fCB2IGluc3RhbmNlb2YgSW1hZ2VEYXRhIHx8IHR5cGVvZiBGaWxlTGlzdCAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiB2IGluc3RhbmNlb2YgRmlsZUxpc3QpIHtcXFxcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXFxcXFxcXCJhcmd1bWVudFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICBfX3ZhbHVlX186IHZcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcXFxcbiAgICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcXFxcbiAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHYpO1xcXFxuICAgICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXFxcXFxcXCJhcmd1bWVudFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICBfX3ZhbHVlX186IHZcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXJWaWV3KSB7XFxcXG4gICAgICAgICAgICBpZiAodi5fdHJhbnNmZXIgfHwgX3RyYW5zZmVyKSB7XFxcXG4gICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh2LmJ1ZmZlcik7XFxcXG4gICAgICAgICAgICAgIGRlbGV0ZSB2Ll90cmFuc2ZlcjtcXFxcbiAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcXFxcbiAgICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcXFxcXFxcImFyZ3VtZW50XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgIF9fdmFsdWVfXzogdlxcXFxuICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICB9IC8vIFRPRE86IHN1cHBvcnQgYWxzbyBNYXAgYW5kIFNldFxcXFxuICAgICAgICAgIC8vIFRPRE86IGF2b2lkIG9iamVjdCBzdWNoIGFzIER5bmFtaWNQbHVnaW4gaW5zdGFuY2UuXFxcXG4gICAgICAgICAgZWxzZSBpZiAodi5fX2FzX2ludGVyZmFjZV9fKSB7XFxcXG4gICAgICAgICAgICAgIGJPYmplY3Rba10gPSB0aGlzLl9lbmNvZGUodiwgdHJ1ZSk7XFxcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcXFxcXFxcIm9iamVjdFxcXFxcXFwiIHx8IEFycmF5LmlzQXJyYXkodikpIHtcXFxcbiAgICAgICAgICAgICAgYk9iamVjdFtrXSA9IHRoaXMuX2VuY29kZSh2LCBhc19pbnRlcmZhY2UpOyAvLyBtb3ZlIHRyYW5zZmVyYWJsZXMgdG8gdGhlIHRvcCBsZXZlbCBvYmplY3RcXFxcblxcXFxuICAgICAgICAgICAgICBpZiAoYk9iamVjdFtrXS5fX3RyYW5zZmVyYWJsZXNfXykge1xcXFxuICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgYk9iamVjdFtrXS5fX3RyYW5zZmVyYWJsZXNfXy5sZW5ndGg7IHQrKykge1xcXFxuICAgICAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGJPYmplY3Rba10uX190cmFuc2ZlcmFibGVzX19bdF0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcXFxcXFxcIm9iamVjdFxcXFxcXFwiICYmIHYuY29uc3RydWN0b3IpIHtcXFxcbiAgICAgICAgICAgICAgdGhyb3cgXFxcXFxcXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUgZm9yIHRyYW5zZmVycmluZyBiZXR3ZWVuIHRoZSBwbHVnaW4gYW5kIHRoZSBtYWluIGFwcDogXFxcXFxcXCIgKyBrICsgXFxcXFxcXCIgOiBcXFxcXFxcIiArIHYuY29uc3RydWN0b3IubmFtZTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgIHRocm93IFxcXFxcXFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIGZvciB0cmFuc2ZlcnJpbmcgYmV0d2VlbiB0aGUgcGx1Z2luIGFuZCB0aGUgbWFpbiBhcHA6IFxcXFxcXFwiICsgayArIFxcXFxcXFwiLFxcXFxcXFwiICsgdjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG5cXFxcbiAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XFxcXG4gICAgICBiT2JqZWN0Ll9fdHJhbnNmZXJhYmxlc19fID0gdHJhbnNmZXJhYmxlcztcXFxcbiAgICB9XFxcXG5cXFxcbiAgICByZXR1cm4gYk9iamVjdDtcXFxcbiAgfVxcXFxuXFxcXG4gIF9kZWNvZGUoYU9iamVjdCwgY2FsbGJhY2tJZCwgd2l0aFByb21pc2UpIHtcXFxcbiAgICBpZiAoIWFPYmplY3QpIHtcXFxcbiAgICAgIHJldHVybiBhT2JqZWN0O1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHZhciBiT2JqZWN0LCB2LCBrO1xcXFxuXFxcXG4gICAgaWYgKGFPYmplY3QuaGFzT3duUHJvcGVydHkoXFxcXFxcXCJfX2phaWxlZF90eXBlX19cXFxcXFxcIikgJiYgYU9iamVjdC5oYXNPd25Qcm9wZXJ0eShcXFxcXFxcIl9fdmFsdWVfX1xcXFxcXFwiKSkge1xcXFxuICAgICAgaWYgKGFPYmplY3QuX19qYWlsZWRfdHlwZV9fLnN0YXJ0c1dpdGgoXFxcXFxcXCJjdXN0b21fZW5jb2RpbmdcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pbnRlcmZhY2UuX3JwY0RlY29kZSA9PT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgY29uc3QgZGVjb2RlZE9iaiA9IHRoaXMuX2ludGVyZmFjZS5fcnBjRGVjb2RlKGFPYmplY3QuX192YWx1ZV9fKTtcXFxcblxcXFxuICAgICAgICAgIGJPYmplY3QgPSBkZWNvZGVkT2JqO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX19qYWlsZWRfdHlwZV9fID09PSBcXFxcXFxcImNhbGxiYWNrXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX2dlblJlbW90ZUNhbGxiYWNrKGNhbGxiYWNrSWQsIGFPYmplY3QubnVtLCB3aXRoUHJvbWlzZSk7XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX19qYWlsZWRfdHlwZV9fID09PSBcXFxcXFxcImludGVyZmFjZVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGJPYmplY3QgPSB0aGlzLl9yZW1vdGVbYU9iamVjdC5fX3ZhbHVlX19dIHx8IHRoaXMuX2dlblJlbW90ZU1ldGhvZChhT2JqZWN0Ll9fdmFsdWVfXyk7XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX19qYWlsZWRfdHlwZV9fID09PSBcXFxcXFxcInBsdWdpbl9pbnRlcmZhY2VcXFxcXFxcIikge1xcXFxuICAgICAgICBiT2JqZWN0ID0gdGhpcy5fZ2VuUmVtb3RlTWV0aG9kKGFPYmplY3QuX192YWx1ZV9fLCBhT2JqZWN0Ll9fcGx1Z2luX2lkX18pO1xcXFxuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9famFpbGVkX3R5cGVfXyA9PT0gXFxcXFxcXCJuZGFycmF5XFxcXFxcXCIpIHtcXFxcbiAgICAgICAgLypnbG9iYWwgbmogdGYqL1xcXFxuICAgICAgICAvL2NyZWF0ZSBidWlsZCBhcnJheS90ZW5zb3IgaWYgdXNlZCBpbiB0aGUgcGx1Z2luXFxcXG4gICAgICAgIGlmICh0aGlzLmlkID09PSBcXFxcXFxcIl9fcGx1Z2luX19cXFxcXFxcIiAmJiB0eXBlb2YgbmogIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgbmouYXJyYXkpIHtcXFxcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhT2JqZWN0Ll9fdmFsdWVfXykpIHtcXFxcbiAgICAgICAgICAgIGFPYmplY3QuX192YWx1ZV9fID0gYU9iamVjdC5fX3ZhbHVlX18ucmVkdWNlKF9hcHBlbmRCdWZmZXIpO1xcXFxuICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgIGJPYmplY3QgPSBuai5hcnJheShhT2JqZWN0Ll9fdmFsdWVfXywgYU9iamVjdC5fX2R0eXBlX18pLnJlc2hhcGUoYU9iamVjdC5fX3NoYXBlX18pO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaWQgPT09IFxcXFxcXFwiX19wbHVnaW5fX1xcXFxcXFwiICYmIHR5cGVvZiB0ZiAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiB0Zi5UZW5zb3IpIHtcXFxcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhT2JqZWN0Ll9fdmFsdWVfXykpIHtcXFxcbiAgICAgICAgICAgIGFPYmplY3QuX192YWx1ZV9fID0gYU9iamVjdC5fX3ZhbHVlX18ucmVkdWNlKF9hcHBlbmRCdWZmZXIpO1xcXFxuICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgIGJPYmplY3QgPSB0Zi50ZW5zb3IoYU9iamVjdC5fX3ZhbHVlX18sIGFPYmplY3QuX19zaGFwZV9fLCBhT2JqZWN0Ll9fZHR5cGVfXyk7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgLy9rZWVwIGl0IGFzIHJlZ3VsYXIgaWYgdHJhbnNmZXJlZCB0byB0aGUgbWFpbiBhcHBcXFxcbiAgICAgICAgICBiT2JqZWN0ID0gYU9iamVjdDtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9famFpbGVkX3R5cGVfXyA9PT0gXFxcXFxcXCJlcnJvclxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGJPYmplY3QgPSBuZXcgRXJyb3IoYU9iamVjdC5fX3ZhbHVlX18pO1xcXFxuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9famFpbGVkX3R5cGVfXyA9PT0gXFxcXFxcXCJmaWxlXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgYk9iamVjdCA9IGFPYmplY3QuX192YWx1ZV9fOyAvL3BhdGNoIHJlbGF0aXZlUGF0aFxcXFxuXFxcXG4gICAgICAgIGJPYmplY3QucmVsYXRpdmVQYXRoID0gYU9iamVjdC5fX3JlbGF0aXZlX3BhdGhfXztcXFxcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fX2phaWxlZF90eXBlX18gPT09IFxcXFxcXFwiYXJndW1lbnRcXFxcXFxcIikge1xcXFxuICAgICAgICBiT2JqZWN0ID0gYU9iamVjdC5fX3ZhbHVlX187XFxcXG4gICAgICB9XFxcXG5cXFxcbiAgICAgIHJldHVybiBiT2JqZWN0O1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICB2YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkoYU9iamVjdCk7XFxcXG4gICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XFxcXG5cXFxcbiAgICAgIGZvciAoayBpbiBhT2JqZWN0KSB7XFxcXG4gICAgICAgIGlmIChpc2FycmF5IHx8IGFPYmplY3QuaGFzT3duUHJvcGVydHkoaykpIHtcXFxcbiAgICAgICAgICB2ID0gYU9iamVjdFtrXTtcXFxcblxcXFxuICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIiB8fCBBcnJheS5pc0FycmF5KHYpKSB7XFxcXG4gICAgICAgICAgICBiT2JqZWN0W2tdID0gdGhpcy5fZGVjb2RlKHYsIGNhbGxiYWNrSWQsIHdpdGhQcm9taXNlKTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH1cXFxcblxcXFxuICAgICAgcmV0dXJuIGJPYmplY3Q7XFxcXG4gICAgfVxcXFxuICB9XFxcXG5cXFxcbiAgX3dyYXAoYXJncywgYXNfaW50ZXJmYWNlKSB7XFxcXG4gICAgdmFyIHdyYXBwZWQgPSB0aGlzLl9lbmNvZGUoYXJncywgYXNfaW50ZXJmYWNlKTtcXFxcblxcXFxuICAgIHZhciByZXN1bHQgPSB7XFxcXG4gICAgICBhcmdzOiB3cmFwcGVkXFxcXG4gICAgfTtcXFxcbiAgICByZXR1cm4gcmVzdWx0O1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBVbndyYXBzIHRoZSBzZXQgb2YgYXJndW1lbnRzIGRlbGl2ZXJlZCBmcm9tIHRoZSByZW1vdGUgc2l0ZSxcXFxcbiAgICogcmVwbGFjZXMgYWxsIGNhbGxiYWNrIGlkZW50aWZpZXJzIHdpdGggYSBmdW5jdGlvbiB3aGljaCB3aWxsXFxcXG4gICAqIGluaXRpYXRlIHNlbmRpbmcgdGhhdCBjYWxsYmFjayBpZGVudGlmaWVyIGJhY2sgdG8gb3RoZXIgc2l0ZVxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyB0byB1bndyYXBcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aXRoUHJvbWlzZSBpcyB0cnVlIG1lYW5zIHRoaXMgdGhlIGNhbGxiYWNrIHNob3VsZCBjb250YWluIGEgcHJvbWlzZVxcXFxuICAgKlxcXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHVud3JhcHBlZCBhcmdzXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgX3Vud3JhcChhcmdzLCB3aXRoUHJvbWlzZSkge1xcXFxuICAgIC8vIHZhciBjYWxsZWQgPSBmYWxzZTtcXFxcbiAgICAvLyB3cmFwcyBlYWNoIGNhbGxiYWNrIHNvIHRoYXQgdGhlIG9ubHkgb25lIGNvdWxkIGJlIGNhbGxlZFxcXFxuICAgIC8vIHZhciBvbmNlKGNiKSB7XFxcXG4gICAgLy8gICAgIHJldHVybiBmdW5jdGlvbigpIHtcXFxcbiAgICAvLyAgICAgICAgIGlmICghY2FsbGVkKSB7XFxcXG4gICAgLy8gICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcXFxcbiAgICAvLyAgICAgICAgICAgICByZXR1cm4gY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXFxcbiAgICAvLyAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgLy8gICAgICAgICAgICAgdmFyIG1zZyA9XFxcXG4gICAgLy8gICAgICAgICAgICAgICAnQSBjYWxsYmFjayBmcm9tIHRoaXMgc2V0IGhhcyBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQnO1xcXFxuICAgIC8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xcXFxuICAgIC8vICAgICAgICAgfVxcXFxuICAgIC8vICAgICB9O1xcXFxuICAgIC8vIH1cXFxcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZGVjb2RlKGFyZ3MuYXJncywgYXJncy5jYWxsYmFja0lkLCB3aXRoUHJvbWlzZSk7XFxcXG5cXFxcbiAgICByZXR1cm4gcmVzdWx0O1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBHZW5lcmF0ZXMgdGhlIHdyYXBwZWQgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBhIHNpbmdsZSByZW1vdGVcXFxcbiAgICogY2FsbGJhY2suIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZFxcXFxuICAgKiB0aGUgY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG9cXFxcbiAgICogZXhlY3V0ZSB0aGUgcGFydGljdWxhciBjYWxsYmFjayBwcmV2aW91c2x5IHNhdmVkIGR1cmluZyBhIGNhbGxcXFxcbiAgICogYnkgdGhlIHJlbW90ZSBzaXRlIGEgbWV0aG9kIGZyb20gdGhlIGludGVyZmFjZSBvZiB0aGlzIHNpdGVcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIG9mIHRoZSByZW1vdGUgY2FsbGJhY2sgdG8gZXhlY3V0ZVxcXFxuICAgKiBAcGFyYW0ge051bWJlcn0gYXJnTnVtIGFyZ3VtZW50IGluZGV4IG9mIHRoZSBjYWxsYmFja1xcXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhQcm9taXNlIGlzIHRydWUgbWVhbnMgdGhpcyB0aGUgY2FsbGJhY2sgc2hvdWxkIGNvbnRhaW4gYSBwcm9taXNlXFxcXG4gICAqXFxcXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCByZW1vdGUgY2FsbGJhY2tcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfZ2VuUmVtb3RlQ2FsbGJhY2soaWQsIGFyZ051bSwgd2l0aFByb21pc2UpIHtcXFxcbiAgICB2YXIgbWUgPSB0aGlzO1xcXFxuICAgIHZhciByZW1vdGVDYWxsYmFjaztcXFxcblxcXFxuICAgIGlmICh3aXRoUHJvbWlzZSkge1xcXFxuICAgICAgcmVtb3RlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxcXG4gICAgICAgICAgdmFyIGFyZ3MgPSBtZS5fd3JhcChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcXFxcblxcXFxuICAgICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgICAgIHJlc29sdmUuX19qYWlsZWRfcGFpcnNfXyA9IHJlamVjdDtcXFxcbiAgICAgICAgICByZWplY3QuX19qYWlsZWRfcGFpcnNfXyA9IHJlc29sdmU7XFxcXG5cXFxcbiAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgbWUuX2Nvbm5lY3Rpb24uc2VuZCh7XFxcXG4gICAgICAgICAgICAgIHR5cGU6IFxcXFxcXFwiY2FsbGJhY2tcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgaWQ6IGlkLFxcXFxuICAgICAgICAgICAgICBudW06IGFyZ051bSxcXFxcbiAgICAgICAgICAgICAgYXJnczogYXJncyxcXFxcbiAgICAgICAgICAgICAgLy8gcGlkIDogIG1lLmlkLFxcXFxuICAgICAgICAgICAgICBwcm9taXNlOiBtZS5fd3JhcChbcmVzb2x2ZSwgcmVqZWN0XSlcXFxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpO1xcXFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGV4ZWN0dWUgcmVtb3RlIGNhbGxiYWNrIChpZDogJHtpZH0sIGFyZ051bTogJHthcmdOdW19KS5gKTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgfTtcXFxcblxcXFxuICAgICAgcmV0dXJuIHJlbW90ZUNhbGxiYWNrO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICByZW1vdGVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcXFxcbiAgICAgICAgdmFyIGFyZ3MgPSBtZS5fd3JhcChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcXFxcblxcXFxuICAgICAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcXFxcbiAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMpIGRlbGV0ZSBhcmdzLmFyZ3MuX190cmFuc2ZlcmFibGVzX187XFxcXG4gICAgICAgIHJldHVybiBtZS5fY29ubmVjdGlvbi5zZW5kKHtcXFxcbiAgICAgICAgICB0eXBlOiBcXFxcXFxcImNhbGxiYWNrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgaWQ6IGlkLFxcXFxuICAgICAgICAgIG51bTogYXJnTnVtLFxcXFxuICAgICAgICAgIGFyZ3M6IGFyZ3MgLy8gcGlkIDogIG1lLmlkXFxcXG5cXFxcbiAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyk7XFxcXG4gICAgICB9O1xcXFxuXFxcXG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XFxcXG4gICAgfVxcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBTZW5kcyB0aGUgbm90aWZpY2F0aW9uIG1lc3NhZ2UgYW5kIGJyZWFrcyB0aGUgY29ubmVjdGlvblxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIGRpc2Nvbm5lY3QoKSB7XFxcXG4gICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kKHtcXFxcbiAgICAgIHR5cGU6IFxcXFxcXFwiZGlzY29ubmVjdFxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICBzZXRUaW1lb3V0KHRoaXMuX2Nvbm5lY3Rpb24uZGlzY29ubmVjdCwgMjAwMCk7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNldCBhIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHdoZW4gcmVjZWl2ZWQgYSBkaXNjb25uZWN0IG1lc3NhZ2VcXFxcbiAgICogZnJvbSB0aGUgcmVtb3RlIHNpdGVcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIG9uRGlzY29ubmVjdChoYW5kbGVyKSB7XFxcXG4gICAgdGhpcy5fZGlzY29ubmVjdEhhbmRsZXIgPSBoYW5kbGVyO1xcXFxuICB9XFxcXG5cXFxcbn1cXFxcbi8qKlxcXFxuICogUmVmZXJlbmNlU3RvcmUgaXMgYSBzcGVjaWFsIG9iamVjdCB3aGljaCBzdG9yZXMgb3RoZXIgb2JqZWN0c1xcXFxuICogYW5kIHByb3ZpZGVzIHRoZSByZWZlcmVuY2VzIChudW1iZXIpIGluc3RlYWQuIFRoaXMgcmVmZXJlbmNlXFxcXG4gKiBtYXkgdGhlbiBiZSBzZW50IG92ZXIgYSBqc29uLWJhc2VkIGNvbW11bmljYXRpb24gY2hhbm5lbCAoSVBDXFxcXG4gKiB0byBhbm90aGVyIE5vZGUuanMgcHJvY2VzcyBvciBhIG1lc3NhZ2UgdG8gdGhlIFdvcmtlcikuIE90aGVyXFxcXG4gKiBzaXRlIG1heSB0aGVuIHByb3ZpZGUgdGhlIHJlZmVyZW5jZSBpbiB0aGUgcmVzcG9uY2UgbWVzc2FnZVxcXFxuICogaW1wbHlpbmcgdGhlIGdpdmVuIG9iamVjdCBzaG91bGQgYmUgYWN0aXZhdGVkLlxcXFxuICpcXFxcbiAqIFByaW1hcnkgdXNhZ2UgZm9yIHRoZSBSZWZlcmVuY2VTdG9yZSBpcyBhIHN0b3JhZ2UgZm9yIHRoZVxcXFxuICogY2FsbGJhY2tzLCB3aGljaCB0aGVyZWZvcmUgbWFrZXMgaXQgcG9zc2libGUgdG8gaW5pdGlhdGUgYVxcXFxuICogY2FsbGJhY2sgZXhlY3V0aW9uIGJ5IHRoZSBvcHBvc2l0ZSBzaXRlICh3aGljaCBub3JtYWxseSBjYW5ub3RcXFxcbiAqIGRpcmVjdGx5IGV4ZWN1dGUgZnVuY3Rpb25zIG92ZXIgdGhlIGNvbW11bmljYXRpb24gY2hhbm5lbCkuXFxcXG4gKlxcXFxuICogRWFjaCBzdG9yZWQgb2JqZWN0IGNhbiBvbmx5IGJlIGZldGNoZWQgb25jZSBhbmQgaXMgbm90XFxcXG4gKiBhdmFpbGFibGUgZm9yIHRoZSBzZWNvbmQgdGltZS4gRWFjaCBzdG9yZWQgb2JqZWN0IG11c3QgYmVcXFxcbiAqIGZldGNoZWQsIHNpbmNlIG90aGVyd2lzZSBpdCB3aWxsIHJlbWFpbiBzdG9yZWQgZm9yZXZlciBhbmRcXFxcbiAqIGNvbnN1bWUgbWVtb3J5LlxcXFxuICpcXFxcbiAqIFN0b3JlZCBvYmplY3QgaW5kZWNlcyBhcmUgc2ltcGx5IHRoZSBudW1iZXJzLCB3aGljaCBhcmUgaG93ZXZlclxcXFxuICogcmVsZWFzZWQgYWxvbmcgd2l0aCB0aGUgb2JqZWN0cywgYW5kIGFyZSBsYXRlciByZXVzZWQgYWdhaW4gKGluXFxcXG4gKiBvcmRlciB0byBwb3N0cG9uZSB0aGUgb3ZlcmZsb3csIHdoaWNoIHNob3VsZCBub3QgbGlrZWx5IGhhcHBlbixcXFxcbiAqIGJ1dCBhbnl3YXkpLlxcXFxuICovXFxcXG5cXFxcbmNsYXNzIFJlZmVyZW5jZVN0b3JlIHtcXFxcbiAgY29uc3RydWN0b3IoKSB7XFxcXG4gICAgdGhpcy5fc3RvcmUgPSB7fTsgLy8gc3RvcmVkIG9iamVjdFxcXFxuXFxcXG4gICAgdGhpcy5faW5kaWNlcyA9IFswXTsgLy8gc21hbGxlc3QgYXZhaWxhYmxlIGluZGljZXNcXFxcblxcXFxuICAgIHRoaXMuX3JlYWR5SGFuZGxlciA9IGZ1bmN0aW9uICgpIHt9O1xcXFxuXFxcXG4gICAgdGhpcy5fYnVzeUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fTtcXFxcblxcXFxuICAgIHRoaXMuX3JlYWR5SGFuZGxlcigpO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBjYWxsIGhhbmRsZXIgd2hlbiB0aGUgc3RvcmUgaXMgZW1wdHlcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtGVU5DVElPTn0gaWQgb2YgYSBoYW5kbGVyXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgb25SZWFkeShyZWFkeUhhbmRsZXIpIHtcXFxcbiAgICB0aGlzLl9yZWFkeUhhbmRsZXIgPSByZWFkeUhhbmRsZXIgfHwgZnVuY3Rpb24gKCkge307XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIGNhbGwgaGFuZGxlciB3aGVuIHRoZSBzdG9yZSBpcyBub3QgZW1wdHlcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtGVU5DVElPTn0gaWQgb2YgYSBoYW5kbGVyXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgb25CdXN5KGJ1c3lIYW5kbGVyKSB7XFxcXG4gICAgdGhpcy5fYnVzeUhhbmRsZXIgPSBidXN5SGFuZGxlciB8fCBmdW5jdGlvbiAoKSB7fTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogZ2V0IHRoZSBsZW5ndGggb2YgdGhlIHN0b3JlXFxcXG4gICAqXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgZ2V0U3RhY2soKSB7XFxcXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3N0b3JlKS5sZW5ndGg7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIEBmdW5jdGlvbiBfZ2VuSWQoKSBnZW5lcmF0ZXMgdGhlIG5ldyByZWZlcmVuY2UgaWRcXFxcbiAgICpcXFxcbiAgICogQHJldHVybnMge051bWJlcn0gc21hbGxlc3QgYXZhaWxhYmxlIGlkIGFuZCByZXNlcnZlcyBpdFxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIF9nZW5JZCgpIHtcXFxcbiAgICB2YXIgaWQ7XFxcXG5cXFxcbiAgICBpZiAodGhpcy5faW5kaWNlcy5sZW5ndGggPT09IDEpIHtcXFxcbiAgICAgIGlkID0gdGhpcy5faW5kaWNlc1swXSsrO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICBpZCA9IHRoaXMuX2luZGljZXMuc2hpZnQoKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICByZXR1cm4gaWQ7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFJlbGVhc2VzIHRoZSBnaXZlbiByZWZlcmVuY2UgaWQgc28gdGhhdCBpdCB3aWxsIGJlIGF2YWlsYWJsZSBieVxcXFxuICAgKiBhbm90aGVyIG9iamVjdCBzdG9yZWRcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIHRvIHJlbGVhc2VcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfcmVsZWFzZUlkKGlkKSB7XFxcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbmRpY2VzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICBpZiAoaWQgPCB0aGlzLl9pbmRpY2VzW2ldKSB7XFxcXG4gICAgICAgIHRoaXMuX2luZGljZXMuc3BsaWNlKGksIDAsIGlkKTtcXFxcblxcXFxuICAgICAgICBicmVhaztcXFxcbiAgICAgIH1cXFxcbiAgICB9IC8vIGNsZWFuaW5nLXVwIHRoZSBzZXF1ZW5jZSB0YWlsXFxcXG5cXFxcblxcXFxuICAgIGZvciAoaSA9IHRoaXMuX2luZGljZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXFxcbiAgICAgIGlmICh0aGlzLl9pbmRpY2VzW2ldIC0gMSA9PT0gdGhpcy5faW5kaWNlc1tpIC0gMV0pIHtcXFxcbiAgICAgICAgdGhpcy5faW5kaWNlcy5wb3AoKTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGJyZWFrO1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU3RvcmVzIHRoZSBnaXZlbiBvYmplY3QgYW5kIHJldHVybnMgdGhlIHJlZmVybmNlIGlkIGluc3RlYWRcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0byBzdG9yZVxcXFxuICAgKlxcXFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSByZWZlcmVuY2UgaWQgb2YgdGhlIHN0b3JlZCBvYmplY3RcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBwdXQob2JqKSB7XFxcXG4gICAgaWYgKHRoaXMuX2J1c3lIYW5kbGVyICYmIE9iamVjdC5rZXlzKHRoaXMuX3N0b3JlKS5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgIHRoaXMuX2J1c3lIYW5kbGVyKCk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgdmFyIGlkID0gdGhpcy5fZ2VuSWQoKTtcXFxcblxcXFxuICAgIHRoaXMuX3N0b3JlW2lkXSA9IG9iajtcXFxcbiAgICByZXR1cm4gaWQ7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFJldHJpZXZlcyBwcmV2aW91c2x5IHN0b3JlZCBvYmplY3QgYW5kIHJlbGVhc2VzIGl0cyByZWZlcmVuY2VcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIG9mIGFuIG9iamVjdCB0byByZXRyaWV2ZVxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIGZldGNoKGlkKSB7XFxcXG4gICAgdmFyIG9iaiA9IHRoaXMuX3N0b3JlW2lkXTtcXFxcblxcXFxuICAgIGlmIChvYmogJiYgIW9iai5fX3JlbW90ZV9tZXRob2QpIHtcXFxcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtpZF07XFxcXG5cXFxcbiAgICAgIHRoaXMuX3JlbGVhc2VJZChpZCk7XFxcXG5cXFxcbiAgICAgIGlmICh0aGlzLl9yZWFkeUhhbmRsZXIgJiYgT2JqZWN0LmtleXModGhpcy5fc3RvcmUpLmxlbmd0aCA9PT0gMCkge1xcXFxuICAgICAgICB0aGlzLl9yZWFkeUhhbmRsZXIoKTtcXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG5cXFxcbiAgICBpZiAob2JqICYmIG9iai5fX2phaWxlZF9wYWlyc19fKSB7XFxcXG4gICAgICBjb25zdCBfaWQgPSBnZXRLZXlCeVZhbHVlKHRoaXMuX3N0b3JlLCBvYmouX19qYWlsZWRfcGFpcnNfXyk7XFxcXG5cXFxcbiAgICAgIHRoaXMuZmV0Y2goX2lkKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICByZXR1cm4gb2JqO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBSZXRyaWV2ZXMgcHJldmlvdXNseSBzdG9yZWQgb2JqZWN0XFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBvZiBhbiBvYmplY3QgdG8gcmV0cmlldmVcXFxcbiAgICovXFxcXG4gIC8vIHJldHJpZXZlKGlkKSB7XFxcXG4gIC8vICAgICB2YXIgb2JqID0gdGhpcy5fc3RvcmVbaWRdO1xcXFxuICAvLyAgICAgcmV0dXJuIG9iajtcXFxcbiAgLy8gfVxcXFxuXFxcXG5cXFxcbn0vLyMgc291cmNlVVJMPVttb2R1bGVdXFxcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaUxpOXpjbU12Y25CakxtcHpMbXB6SWl3aWMyOTFjbU5sY3lJNld5SjNaV0p3WVdOck9pOHZhVzFxYjNsU1VFTXZjM0pqTDNKd1l5NXFjejh5TTJNeUlsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxS2x4dUlDb2dRMjl1ZEdGcGJuTWdkR2hsSUZKUVF5QnZZbXBsWTNRZ2RYTmxaQ0JpYjNSb0lHSjVJSFJvWlNCaGNIQnNhV05oZEdsdmJseHVJQ29nYzJsMFpTd2dZVzVrSUdKNUlHVmhZMmdnY0d4MVoybHVYRzRnS2k5Y2JtbHRjRzl5ZENCN0lISmhibVJKWkN3Z2RIbHdaV1JCY25KaGVWUnZSSFI1Y0dVZ2ZTQm1jbTl0SUZ3aUxpOTFkR2xzY3k1cWMxd2lPMXh1WEc1bGVIQnZjblFnWTI5dWMzUWdRVkJKWDFaRlVsTkpUMDRnUFNCY0lqQXVNaTR3WENJN1hHNWNibU52Ym5OMElFRnljbUY1UW5WbVptVnlWbWxsZHlBOUlFOWlhbVZqZEM1blpYUlFjbTkwYjNSNWNHVlBaaWhjYmlBZ1QySnFaV04wTG1kbGRGQnliM1J2ZEhsd1pVOW1LRzVsZHlCVmFXNTBPRUZ5Y21GNUtDa3BYRzRwTG1OdmJuTjBjblZqZEc5eU8xeHVYRzVtZFc1amRHbHZiaUJmWVhCd1pXNWtRblZtWm1WeUtHSjFabVpsY2pFc0lHSjFabVpsY2pJcElIdGNiaUFnWTI5dWMzUWdkRzF3SUQwZ2JtVjNJRlZwYm5RNFFYSnlZWGtvWW5WbVptVnlNUzVpZVhSbFRHVnVaM1JvSUNzZ1luVm1abVZ5TWk1aWVYUmxUR1Z1WjNSb0tUdGNiaUFnZEcxd0xuTmxkQ2h1WlhjZ1ZXbHVkRGhCY25KaGVTaGlkV1ptWlhJeEtTd2dNQ2s3WEc0Z0lIUnRjQzV6WlhRb2JtVjNJRlZwYm5RNFFYSnlZWGtvWW5WbVptVnlNaWtzSUdKMVptWmxjakV1WW5sMFpVeGxibWQwYUNrN1hHNGdJSEpsZEhWeWJpQjBiWEF1WW5WbVptVnlPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm5aWFJMWlhsQ2VWWmhiSFZsS0c5aWFtVmpkQ3dnZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUU5aWFtVmpkQzVyWlhsektHOWlhbVZqZENrdVptbHVaQ2hyWlhrZ1BUNGdiMkpxWldOMFcydGxlVjBnUFQwOUlIWmhiSFZsS1R0Y2JuMWNiaThxS2x4dUlDb2dVbEJESUc5aWFtVmpkQ0J5WlhCeVpYTmxiblJ6SUdFZ2MybHVaMnhsSUhOcGRHVWdhVzRnZEdobFhHNGdLaUJqYjIxdGRXNXBZMkYwYVc5dUlIQnliM1J2WTI5c0lHSmxkSGRsWlc0Z2RHaGxJR0Z3Y0d4cFkyRjBhVzl1SUdGdVpDQjBhR1VnY0d4MVoybHVYRzRnS2x4dUlDb2dRSEJoY21GdElIdFBZbXBsWTNSOUlHTnZibTVsWTNScGIyNGdZU0J6Y0dWamFXRnNJRzlpYW1WamRDQmhiR3h2ZDJsdVp5QjBieUJ6Wlc1a1hHNGdLaUJoYm1RZ2NtVmpaV2wyWlNCdFpYTnpZV2RsY3lCbWNtOXRJSFJvWlNCdmNIQnZjMmwwWlNCemFYUmxJQ2hpWVhOcFkyRnNiSGtnYVhSY2JpQXFJSE5vYjNWc1pDQnZibXg1SUhCeWIzWnBaR1VnYzJWdVpDZ3BJR0Z1WkNCdmJrMWxjM05oWjJVb0tTQnRaWFJvYjJSektWeHVJQ292WEc1bGVIQnZjblFnWTJ4aGMzTWdVbEJESUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvWTI5dWJtVmpkR2x2Yml3Z1kyOXVabWxuS1NCN1hHNGdJQ0FnZEdocGN5NWZZMjl1Ym1WamRHbHZiaUE5SUdOdmJtNWxZM1JwYjI0N1hHNGdJQ0FnZEdocGN5NWpiMjVtYVdjZ1BTQmpiMjVtYVdjZ2ZId2dlMzA3WEc0Z0lDQWdkR2hwY3k1ZmFXNTBaWEptWVdObElEMGdlMzA3WEc0Z0lDQWdkR2hwY3k1ZmNHeDFaMmx1WDJsdWRHVnlabUZqWlhNZ1BTQjdmVHRjYmlBZ0lDQjBhR2x6TGw5eVpXMXZkR1VnUFNCdWRXeHNPMXh1SUNBZ0lIUm9hWE11WDNKbGJXOTBaVlZ3WkdGMFpVaGhibVJzWlhJZ1BTQm1kVzVqZEdsdmJpZ3BJSHQ5TzF4dUlDQWdJSFJvYVhNdVgyZGxkRWx1ZEdWeVptRmpaVWhoYm1Sc1pYSWdQU0JtZFc1amRHbHZiaWdwSUh0OU8xeHVJQ0FnSUhSb2FYTXVYMmx1ZEdWeVptRmpaVk5sZEVGelVtVnRiM1JsU0dGdVpHeGxjaUE5SUc1MWJHdzdYRzRnSUNBZ2RHaHBjeTVmWkdselkyOXVibVZqZEVoaGJtUnNaWElnUFNCbWRXNWpkR2x2YmlncElIdDlPMXh1SUNBZ0lIUm9hWE11WDNOMGIzSmxJRDBnYm1WM0lGSmxabVZ5Wlc1alpWTjBiM0psS0NrN1hHNGdJQ0FnZEdocGN5NWZiV1YwYUc5a1gzSmxabk1nUFNCdVpYY2dVbVZtWlhKbGJtTmxVM1J2Y21Vb0tUdGNiaUFnSUNCMGFHbHpMbDlqYjI1dVpXTjBhVzl1SUQwZ1kyOXVibVZqZEdsdmJqdGNiaUFnSUNCc1pYUWdiV1VnUFNCMGFHbHpPMXh1SUNBZ0lIUm9hWE11WDJOdmJtNWxZM1JwYjI0dWIyNU5aWE56WVdkbEtHWjFibU4wYVc5dUtHUmhkR0VwSUh0Y2JpQWdJQ0FnSUcxbExsOXdjbTlqWlhOelRXVnpjMkZuWlNoa1lYUmhLVHRjYmlBZ0lDQjlLVHRjYmlBZ2ZWeHVYRzRnSUM4cUtseHVJQ0FnS2lCVFpYUWdZU0JvWVc1a2JHVnlJSFJ2SUdKbElHTmhiR3hsWkNCM2FHVnVJSFJvWlNCeVpXMXZkR1VnYzJsMFpTQjFjR1JoZEdWeklHbDBjMXh1SUNBZ0tpQnBiblJsY21aaFkyVmNiaUFnSUNwY2JpQWdJQ29nUUhCaGNtRnRJSHRHZFc1amRHbHZibjBnYUdGdVpHeGxjbHh1SUNBZ0tpOWNiaUFnYjI1U1pXMXZkR1ZWY0dSaGRHVW9hR0Z1Wkd4bGNpa2dlMXh1SUNBZ0lIUm9hWE11WDNKbGJXOTBaVlZ3WkdGMFpVaGhibVJzWlhJZ1BTQm9ZVzVrYkdWeU8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRk5sZENCaElHaGhibVJzWlhJZ2RHOGdZbVVnWTJGc2JHVmtJSGRvWlc0Z2NtVmpaV2wyWldRZ1lTQnlaWE53YjI1alpTQm1jbTl0SUhSb1pWeHVJQ0FnS2lCeVpXMXZkR1VnYzJsMFpTQnlaWEJ2Y25ScGJtY2dkR2hoZENCMGFHVWdjSEpsZG1sdmRYTnNlU0J3Y205MmFXUmxaQ0JwYm5SbGNtWmhZMlZjYmlBZ0lDb2dhR0Z6SUdKbFpXNGdjM1ZqWTJWemMyWjFiR3g1SUhObGRDQmhjeUJ5WlcxdmRHVWdabTl5SUhSb1lYUWdjMmwwWlZ4dUlDQWdLbHh1SUNBZ0tpQkFjR0Z5WVcwZ2UwWjFibU4wYVc5dWZTQm9ZVzVrYkdWeVhHNGdJQ0FxTDF4dVhHNGdJRzl1VW1WdGIzUmxVbVZoWkhrb2FHRnVaR3hsY2lrZ2UxeHVJQ0FnSUhSb2FYTXVYMjFsZEdodlpGOXlaV1p6TG05dVVtVmhaSGtvYUdGdVpHeGxjaWs3WEc0Z0lIMWNibHh1SUNCdmJsSmxiVzkwWlVKMWMza29hR0Z1Wkd4bGNpa2dlMXh1SUNBZ0lIUm9hWE11WDIxbGRHaHZaRjl5WldaekxtOXVRblZ6ZVNob1lXNWtiR1Z5S1R0Y2JpQWdmVnh1WEc0Z0lHZGxkRkpsYlc5MFpVTmhiR3hUZEdGamF5Z3BJSHRjYmlBZ0lDQnlaWFIxY200Z2RHaHBjeTVmYldWMGFHOWtYM0psWm5NdVoyVjBVM1JoWTJzb0tUdGNiaUFnZlZ4dUlDQXZLaXBjYmlBZ0lDb2dVMlYwSUdFZ2FHRnVaR3hsY2lCMGJ5QmlaU0JqWVd4c1pXUWdkMmhsYmlCMGFHVWdjbVZ0YjNSbElITnBkR1VnY21WeGRXVnpkSE1nZEc5Y2JpQWdJQ29nS0hKbEtYTmxibVFnZEdobElHbHVkR1Z5Wm1GalpTNGdWWE5sWkNCMGJ5QmtaWFJsWTNRZ1lXNGdhVzVwZEdsaGJIcGhkR2x2Ymx4dUlDQWdLaUJqYjIxd2JHVjBhVzl1SUhkcGRHaHZkWFFnYzJWdVpHbHVaeUJoWkdScGRHbHZibUZzSUhKbGNYVmxjM1FzSUhOcGJtTmxJR2x1SUdaaFkzUmNiaUFnSUNvZ0oyZGxkRWx1ZEdWeVptRmpaU2NnY21WeGRXVnpkQ0JwY3lCdmJteDVJSE5sYm5RZ1lua2dZWEJ3YkdsallYUnBiMjRnWVhRZ2RHaGxJR3hoYzNSY2JpQWdJQ29nYzNSbGNDQnZaaUIwYUdVZ2NHeDFaMmx1SUdsdWFYUnBZV3hwZW1GMGFXOXVYRzRnSUNBcVhHNGdJQ0FxSUVCd1lYSmhiU0I3Um5WdVkzUnBiMjU5SUdoaGJtUnNaWEpjYmlBZ0lDb3ZYRzRnSUc5dVIyVjBTVzUwWlhKbVlXTmxLR2hoYm1Sc1pYSXBJSHRjYmlBZ0lDQjBhR2x6TGw5blpYUkpiblJsY21aaFkyVklZVzVrYkdWeUlEMGdhR0Z1Wkd4bGNqdGNiaUFnZlZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJBY21WMGRYSnVjeUI3VDJKcVpXTjBmU0J6WlhRZ2IyWWdjbVZ0YjNSbElHbHVkR1Z5Wm1GalpTQnRaWFJvYjJSelhHNGdJQ0FxTDF4dUlDQm5aWFJTWlcxdmRHVW9LU0I3WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE11WDNKbGJXOTBaVHRjYmlBZ2ZWeHVYRzRnSUM4cUtseHVJQ0FnS2lCVFpYUnpJSFJvWlNCcGJuUmxjbVpoWTJVZ2IyWWdkR2hwY3lCemFYUmxJRzFoYTJsdVp5QnBkQ0JoZG1GcGJHRmliR1VnZEc4Z2RHaGxYRzRnSUNBcUlISmxiVzkwWlNCemFYUmxJR0o1SUhObGJtUnBibWNnWVNCdFpYTnpZV2RsSUhkcGRHZ2dZU0J6WlhRZ2IyWWdiV1YwYUc5a2N5QnVZVzFsYzF4dUlDQWdLbHh1SUNBZ0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ1gybHVkR1Z5Wm1GalpTQjBieUJ6WlhSY2JpQWdJQ292WEc0Z0lITmxkRWx1ZEdWeVptRmpaU2hmYVc1MFpYSm1ZV05sS1NCN1hHNGdJQ0FnYVdZZ0tIUm9hWE11WTI5dVptbG5MbVp2Y25kaGNtUnBibWRmWm5WdVkzUnBiMjV6S1NCN1hHNGdJQ0FnSUNCbWIzSWdLR3hsZENCbWRXNWpYMjVoYldVZ2IyWWdkR2hwY3k1amIyNW1hV2N1Wm05eWQyRnlaR2x1WjE5bWRXNWpkR2x2Ym5NcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0hSb2FYTXVYM0psYlc5MFpWdG1kVzVqWDI1aGJXVmRLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLRjlwYm5SbGNtWmhZMlV1WTI5dWMzUnlkV04wYjNJZ1BUMDlJRTlpYW1WamRDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLQ0ZmYVc1MFpYSm1ZV05sVzJaMWJtTmZibUZ0WlYwcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1gybHVkR1Z5Wm1GalpWdG1kVzVqWDI1aGJXVmRJRDBnS0M0dUxtRnlaM01wSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5eVpXMXZkR1ZiWm5WdVkxOXVZVzFsWFNndUxpNWhjbWR6S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZlR0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tGOXBiblJsY21aaFkyVXVZMjl1YzNSeWRXTjBiM0l1WTI5dWMzUnlkV04wYjNJZ1BUMDlJRVoxYm1OMGFXOXVLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvSVY5cGJuUmxjbVpoWTJVdVkyOXVjM1J5ZFdOMGIzSXVjSEp2ZEc5MGVYQmxXMloxYm1OZmJtRnRaVjBwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWDJsdWRHVnlabUZqWlM1amIyNXpkSEoxWTNSdmNpNXdjbTkwYjNSNWNHVmJablZ1WTE5dVlXMWxYU0E5SUNndUxpNWhjbWR6S1NBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZmNtVnRiM1JsVzJaMWJtTmZibUZ0WlYwb0xpNHVZWEpuY3lrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUgwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0FnSUhSb2FYTXVYMmx1ZEdWeVptRmpaU0E5SUY5cGJuUmxjbVpoWTJVN1hHNGdJSDFjYmx4dUlDQXZLaXBjYmlBZ0lDb2dVMlZ1WkhNZ2RHaGxJR0ZqZEhWaGJDQnBiblJsY21aaFkyVWdkRzhnZEdobElISmxiVzkwWlNCemFYUmxJSFZ3YjI0Z2FYUWdkMkZ6WEc0Z0lDQXFJSFZ3WkdGMFpXUWdiM0lnWW5rZ1lTQnpjR1ZqYVdGc0lISmxjWFZsYzNRZ2IyWWdkR2hsSUhKbGJXOTBaU0J6YVhSbFhHNGdJQ0FxTDF4dUlDQnpaVzVrU1c1MFpYSm1ZV05sS0NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ1WlhjZ1VISnZiV2x6WlNoeVpYTnZiSFpsSUQwK0lIdGNiaUFnSUNBZ0lIWmhjaUJ1WVcxbGN5QTlJRnRkTzF4dUlDQWdJQ0FnYVdZZ0tDRjBhR2x6TGw5cGJuUmxjbVpoWTJVcElIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtGd2lhVzUwWlhKbVlXTmxJR2x6SUc1dmRDQnpaWFF1WENJcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2FXWWdLSFJvYVhNdVgybHVkR1Z5Wm1GalpTNWpiMjV6ZEhKMVkzUnZjaUE5UFQwZ1QySnFaV04wS1NCN1hHNGdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHNWhiV1VnYjJZZ1QySnFaV04wTG10bGVYTW9kR2hwY3k1ZmFXNTBaWEptWVdObEtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHVZVzFsTG5OMFlYSjBjMWRwZEdnb1hDSmZYQ0lwS1NCamIyNTBhVzUxWlR0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZEhsd1pXOW1JSFJvYVhNdVgybHVkR1Z5Wm1GalpWdHVZVzFsWFNBOVBUMGdYQ0ptZFc1amRHbHZibHdpS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J1WVcxbGN5NXdkWE5vS0hzZ2JtRnRaVG9nYm1GdFpTd2daR0YwWVRvZ2JuVnNiQ3dnZEhsd1pUb2dYQ0ptZFc1amRHbHZibHdpSUgwcE8xeHVJQ0FnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMllYSWdaR0YwWVNBOUlIUm9hWE11WDJsdWRHVnlabUZqWlZ0dVlXMWxYVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hrWVhSaElDRTlQU0J1ZFd4c0lDWW1JSFI1Y0dWdlppQmtZWFJoSUQwOVBTQmNJbTlpYW1WamRGd2lLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCa1lYUmhNaUE5SUh0OU8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCcklHOW1JRTlpYW1WamRDNXJaWGx6S0dSaGRHRXBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIUjVjR1Z2WmlCa1lYUmhXMnRkSUQwOVBTQmNJbVoxYm1OMGFXOXVYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHUmhkR0V5VzJ0ZElEMGdYQ0p5Y0dOZmJXVjBhRzlrT2pwY0lpQXJJR3M3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdSaGRHRXlXMnRkSUQwZ1pHRjBZVnRyWFR0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnYm1GdFpYTXVjSFZ6YUNoN0lHNWhiV1U2SUc1aGJXVXNJR1JoZEdFNklHUmhkR0V5TENCMGVYQmxPaUJjSW05aWFtVmpkRndpSUgwcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoUFltcGxZM1FvWkdGMFlTa2dJVDA5SUdSaGRHRXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdibUZ0WlhNdWNIVnphQ2g3SUc1aGJXVTZJRzVoYldVc0lHUmhkR0U2SUdSaGRHRXNJSFI1Y0dVNklGd2laR0YwWVZ3aUlIMHBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnTHk4Z1lTQmpiR0Z6YzF4dUlDQWdJQ0FnWld4elpTQnBaaUFvZEdocGN5NWZhVzUwWlhKbVlXTmxMbU52Ym5OMGNuVmpkRzl5SUQwOVBTQkdkVzVqZEdsdmJpa2dlMXh1SUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9YQ0pRYkdWaGMyVWdhVzV6ZEdGdWRHbGhkR1VnZEdobElHTnNZWE56SUdKbFptOXlaU0JsZUhCdmNuUjBhVzVuSUdsMExsd2lLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJQzh2SUdsdWMzUmhibU5sSUc5bUlHRWdZMnhoYzNOY2JpQWdJQ0FnSUdWc2MyVWdhV1lnS0hSb2FYTXVYMmx1ZEdWeVptRmpaUzVqYjI1emRISjFZM1J2Y2k1amIyNXpkSEoxWTNSdmNpQTlQVDBnUm5WdVkzUnBiMjRwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR1oxYm1OMGFXOXVjeUE5SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0Z4dUlDQWdJQ0FnSUNBZ0lFOWlhbVZqZEM1blpYUlFjbTkwYjNSNWNHVlBaaWgwYUdsekxsOXBiblJsY21aaFkyVXBYRzRnSUNBZ0lDQWdJQ2t1WTI5dVkyRjBLRTlpYW1WamRDNXJaWGx6S0hSb2FYTXVYMmx1ZEdWeVptRmpaU2twTzF4dUlDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHWjFibU4wYVc5dWN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnSUNBZ0lIWmhjaUJ1WVcxbFh5QTlJR1oxYm1OMGFXOXVjMXRwWFR0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvYm1GdFpWOHVjM1JoY25SelYybDBhQ2hjSWw5Y0lpa2dmSHdnYm1GdFpWOGdQVDA5SUZ3aVkyOXVjM1J5ZFdOMGIzSmNJaWtnWTI5dWRHbHVkV1U3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLSFI1Y0dWdlppQjBhR2x6TGw5cGJuUmxjbVpoWTJWYmJtRnRaVjlkSUQwOVBTQmNJbVoxYm1OMGFXOXVYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJRzVoYldWekxuQjFjMmdvZXlCdVlXMWxPaUJ1WVcxbFh5d2daR0YwWVRvZ2JuVnNiQ0I5S1R0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJSFJvY205M0lFVnljbTl5S0Z3aVZXNXpkWEJ3YjNKMFpXUWdhVzUwWlhKbVlXTmxJSFI1Y0dWY0lpazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQjBhR2x6TGw5cGJuUmxjbVpoWTJWVFpYUkJjMUpsYlc5MFpVaGhibVJzWlhJZ1BTQnlaWE52YkhabE8xeHVJQ0FnSUNBZ2RHaHBjeTVmWTI5dWJtVmpkR2x2Ymk1elpXNWtLSHNnZEhsd1pUb2dYQ0p6WlhSSmJuUmxjbVpoWTJWY0lpd2dZWEJwT2lCdVlXMWxjeUI5S1R0Y2JpQWdJQ0I5S1R0Y2JpQWdmVnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQklZVzVrYkdWeklHRWdiV1Z6YzJGblpTQm1jbTl0SUhSb1pTQnlaVzF2ZEdVZ2MybDBaVnh1SUNBZ0tpOWNiaUFnTHk4Z2RtRnlJR05oYkd4aVlXTnJYM0psWnlBOUlHNWxkeUJTWldkRmVIQW9YQ0p2Ym5Wd1pHRjBaWHh5ZFc0a1hDSXBYRzRnSUY5d2NtOWpaWE56VFdWemMyRm5aU2hrWVhSaEtTQjdYRzRnSUNBZ2RtRnlJSEpsYzI5c2RtVXNJSEpsYW1WamRDd2diV1YwYUc5a0xDQmhjbWR6TENCeVpYTjFiSFE3WEc0Z0lDQWdjM2RwZEdOb0lDaGtZWFJoTG5SNWNHVXBJSHRjYmlBZ0lDQWdJR05oYzJVZ1hDSnRaWFJvYjJSY0lqcGNiaUFnSUNBZ0lDQWdkbUZ5SUY5cGJuUmxjbVpoWTJVZ1BTQjBhR2x6TGw5cGJuUmxjbVpoWTJVN1hHNGdJQ0FnSUNBZ0lIWmhjaUJmYldWMGFHOWtYMk52Ym5SbGVIUWdQU0JmYVc1MFpYSm1ZV05sTGw5ZmRHaHBjMTlmSUh4OElGOXBiblJsY21aaFkyVTdYRzRnSUNBZ0lDQWdJR2xtSUNoa1lYUmhMbkJwWkNrZ2UxeHVJQ0FnSUNBZ0lDQWdJRjlwYm5SbGNtWmhZMlVnUFNCMGFHbHpMbDl3YkhWbmFXNWZhVzUwWlhKbVlXTmxjMXRrWVhSaExuQnBaRjA3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLQ0ZmYVc1MFpYSm1ZV05sS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1pHRjBZUzV3Y205dGFYTmxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRnR5WlhOdmJIWmxMQ0J5WldwbFkzUmRJRDBnZEdocGN5NWZkVzUzY21Gd0tHUmhkR0V1Y0hKdmJXbHpaU3dnWm1Gc2MyVXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaV3BsWTNRb1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lIQnNkV2RwYmlCaGNHa2dablZ1WTNScGIyNGdhWE1nYm05MElHRjJZV2xoYkdKbElHbHVJRndpSkh0a1lYUmhMbkJwWkgxY0lpd2dkR2hsSUhCc2RXZHBiaUJ0WVhsaVpTQjBaWEp0YVc1aGRHVmtMbUJjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmJuTnZiR1V1WlhKeWIzSW9YRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZSEJzZFdkcGJpQmhjR2tnWm5WdVkzUnBiMjRnYVhNZ2JtOTBJR0YyWVdsaGJHSmxJR2x1SUNSN1pHRjBZUzV3YVdSOUxDQjBhR1VnY0d4MVoybHVJRzFoZVdKbElIUmxjbTFwYm1GMFpXUXVZRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnBaaUFvWkdGMFlTNXVZVzFsTG1sdVpHVjRUMllvWENJdVhDSXBJQ0U5UFNBdE1Ta2dlMXh1SUNBZ0lDQWdJQ0FnSUhaaGNpQnVZVzFsY3lBOUlHUmhkR0V1Ym1GdFpTNXpjR3hwZENoY0lpNWNJaWs3WEc0Z0lDQWdJQ0FnSUNBZ2JXVjBhRzlrSUQwZ1gybHVkR1Z5Wm1GalpWdHVZVzFsYzFzd1hWMWJibUZ0WlhOYk1WMWRPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUcxbGRHaHZaQ0E5SUY5cGJuUmxjbVpoWTJWYlpHRjBZUzV1WVcxbFhUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JoY21keklEMGdkR2hwY3k1ZmRXNTNjbUZ3S0dSaGRHRXVZWEpuY3l3Z2RISjFaU2s3WEc0Z0lDQWdJQ0FnSUdsbUlDaGtZWFJoTG5CeWIyMXBjMlVwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmJjbVZ6YjJ4MlpTd2djbVZxWldOMFhTQTlJSFJvYVhNdVgzVnVkM0poY0Noa1lYUmhMbkJ5YjIxcGMyVXNJR1poYkhObEtUdGNiaUFnSUNBZ0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WemRXeDBJRDBnYldWMGFHOWtMbUZ3Y0d4NUtGOXRaWFJvYjJSZlkyOXVkR1Y0ZEN3Z1lYSm5jeWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2RDQnBibk4wWVc1alpXOW1JRkJ5YjIxcGMyVWdmSHhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdLRzFsZEdodlpDNWpiMjV6ZEhKMVkzUnZjaUFtSmx4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUcxbGRHaHZaQzVqYjI1emRISjFZM1J2Y2k1dVlXMWxJRDA5UFNCY0lrRnplVzVqUm5WdVkzUnBiMjVjSWlsY2JpQWdJQ0FnSUNBZ0lDQWdJQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUXVkR2hsYmloeVpYTnZiSFpsS1M1allYUmphQ2h5WldwbFkzUXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WemIyeDJaU2h5WlhOMWJIUXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OdmJHVXVaWEp5YjNJb1pTd2diV1YwYUc5a0tUdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGFtVmpkQ2hsS1R0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUcxbGRHaHZaQzVoY0hCc2VTaGZiV1YwYUc5a1gyTnZiblJsZUhRc0lHRnlaM01wTzF4dUlDQWdJQ0FnSUNBZ0lIMGdZMkYwWTJnZ0tHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk52YkdVdVpYSnliM0lvWlN3Z2JXVjBhRzlrTENCaGNtZHpLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0JpY21WaGF6dGNiaUFnSUNBZ0lHTmhjMlVnWENKallXeHNZbUZqYTF3aU9seHVJQ0FnSUNBZ0lDQnBaaUFvWkdGMFlTNXdjbTl0YVhObEtTQjdYRzRnSUNBZ0lDQWdJQ0FnVzNKbGMyOXNkbVVzSUhKbGFtVmpkRjBnUFNCMGFHbHpMbDkxYm5keVlYQW9aR0YwWVM1d2NtOXRhWE5sTENCbVlXeHpaU2s3WEc0Z0lDQWdJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHMWxkR2h2WkNBOUlIUm9hWE11WDNOMGIzSmxMbVpsZEdOb0tHUmhkR0V1Ym5WdEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdGeVozTWdQU0IwYUdsekxsOTFibmR5WVhBb1pHRjBZUzVoY21kekxDQjBjblZsS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNnaGJXVjBhRzlrS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRndpUTJGc2JHSmhZMnNnWm5WdVkzUnBiMjRnWTJGdUlHOXViSGtnWTJGc2JHVmtJRzl1WTJVc0lHbG1JSGx2ZFNCM1lXNTBJSFJ2SUdOaGJHd2dZU0JtZFc1amRHbHZiaUJtYjNJZ2JYVnNkR2x3YkdVZ2RHbHRaWE1zSUhCc1pXRnpaU0J0WVd0bElHbDBJR0Z6SUdFZ2NHeDFaMmx1SUdGd2FTQm1kVzVqZEdsdmJpNGdVMlZsSUdoMGRIQnpPaTh2YVcxcWIza3VhVzh2Wkc5amN5Qm1iM0lnYlc5eVpTQmtaWFJoYVd4ekxsd2lPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WemRXeDBJRDBnYldWMGFHOWtMbUZ3Y0d4NUtHNTFiR3dzSUdGeVozTXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhRZ2FXNXpkR0Z1WTJWdlppQlFjbTl0YVhObElIeDhYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDaHRaWFJvYjJRdVkyOXVjM1J5ZFdOMGIzSWdKaVpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0WlhSb2IyUXVZMjl1YzNSeWRXTjBiM0l1Ym1GdFpTQTlQVDBnWENKQmMzbHVZMFoxYm1OMGFXOXVYQ0lwWEc0Z0lDQWdJQ0FnSUNBZ0lDQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVZ6ZFd4MExuUm9aVzRvY21WemIyeDJaU2t1WTJGMFkyZ29jbVZxWldOMEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYzI5c2RtVW9jbVZ6ZFd4MEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtVnljbTl5S0dVc0lHMWxkR2h2WkNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WldwbFkzUW9aU2s3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J0WlhSb2IyUWdQU0IwYUdsekxsOXpkRzl5WlM1bVpYUmphQ2hrWVhSaExtNTFiU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmhjbWR6SUQwZ2RHaHBjeTVmZFc1M2NtRndLR1JoZEdFdVlYSm5jeXdnZEhKMVpTazdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9JVzFsZEdodlpDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCY0lsQnNaV0Z6WlNCdWIzUnBZMlVnZEdoaGRDQmpZV3hzWW1GamF5Qm1kVzVqZEdsdmJpQmpZVzRnYjI1c2VTQmpZV3hzWldRZ2IyNWpaU3dnYVdZZ2VXOTFJSGRoYm5RZ2RHOGdZMkZzYkNCaElHWjFibU4wYVc5dUlHWnZjaUJ0ZFd4MGFYQnNaU0IwYVcxbGN5d2djR3hsWVhObElHMWhhMlVnYVhRZ1lYTWdZU0J3YkhWbmFXNGdZWEJwSUdaMWJtTjBhVzl1TGlCVFpXVWdhSFIwY0hNNkx5OXBiV3B2ZVM1cGJ5OWtiMk56SUdadmNpQnRiM0psSUdSbGRHRnBiSE11WENJN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnRaWFJvYjJRdVlYQndiSGtvYm5Wc2JDd2dZWEpuY3lrN1hHNGdJQ0FnSUNBZ0lDQWdmU0JqWVhSamFDQW9aU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzI5c1pTNWxjbkp2Y2lobExDQnRaWFJvYjJRc0lHRnlaM01wTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JpY21WaGF6dGNiaUFnSUNBZ0lHTmhjMlVnWENKelpYUkpiblJsY21aaFkyVmNJanBjYmlBZ0lDQWdJQ0FnZEdocGN5NWZjMlYwVW1WdGIzUmxLR1JoZEdFdVlYQnBLVHRjYmlBZ0lDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ0lDQmpZWE5sSUZ3aVoyVjBTVzUwWlhKbVlXTmxYQ0k2WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjMlZ1WkVsdWRHVnlabUZqWlNncE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TGw5blpYUkpiblJsY21aaFkyVklZVzVrYkdWeUtDazdYRzRnSUNBZ0lDQWdJR0p5WldGck8xeHVJQ0FnSUNBZ1kyRnpaU0JjSW1sdWRHVnlabUZqWlZObGRFRnpVbVZ0YjNSbFhDSTZYRzRnSUNBZ0lDQWdJR2xtSUNoMGVYQmxiMllnZEdocGN5NWZhVzUwWlhKbVlXTmxVMlYwUVhOU1pXMXZkR1ZJWVc1a2JHVnlJRDA5UFNCY0ltWjFibU4wYVc5dVhDSXBJSHRjYmlBZ0lDQWdJQ0FnSUNCMGFHbHpMbDlwYm5SbGNtWmhZMlZUWlhSQmMxSmxiVzkwWlVoaGJtUnNaWElvS1R0Y2JpQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5cGJuUmxjbVpoWTJWVFpYUkJjMUpsYlc5MFpVaGhibVJzWlhJZ1BUMDlJRzUxYkd3N1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNCallYTmxJRndpWkdselkyOXVibVZqZEZ3aU9seHVJQ0FnSUNBZ0lDQjBhR2x6TGw5a2FYTmpiMjV1WldOMFNHRnVaR3hsY2lncE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TGw5amIyNXVaV04wYVc5dUxtUnBjMk52Ym01bFkzUW9LVHRjYmlBZ0lDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRk5sYm1SeklHRWdjbVZ4ZFdWemRITWdkRzhnZEdobElISmxiVzkwWlNCemFYUmxJR0Z6YTJsdVp5QnBkQ0IwYnlCd2NtOTJhV1JsSUdsMGMxeHVJQ0FnS2lCamRYSnlaVzUwSUdsdWRHVnlabUZqWlZ4dUlDQWdLaTljYmlBZ2NtVnhkV1Z6ZEZKbGJXOTBaU2dwSUh0Y2JpQWdJQ0IwYUdsekxsOWpiMjV1WldOMGFXOXVMbk5sYm1Rb2V5QjBlWEJsT2lCY0ltZGxkRWx1ZEdWeVptRmpaVndpSUgwcE8xeHVJQ0I5WEc1Y2JpQWdYMjVrWVhKeVlYa29kSGx3WldSQmNuSmhlU3dnYzJoaGNHVXNJR1IwZVhCbEtTQjdYRzRnSUNBZ2RtRnlJRjlrZEhsd1pTQTlJSFI1Y0dWa1FYSnlZWGxVYjBSMGVYQmxXM1I1Y0dWa1FYSnlZWGt1WTI5dWMzUnlkV04wYjNJdWJtRnRaVjA3WEc0Z0lDQWdhV1lnS0dSMGVYQmxJQ1ltSUdSMGVYQmxJQ0U5UFNCZlpIUjVjR1VwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRndpWkhSNWNHVWdaRzlsYzI0bmRDQnRZWFJqYUNCMGFHVWdkSGx3WlNCdlppQjBhR1VnWVhKeVlYazZJRndpSUN0Y2JpQWdJQ0FnSUNBZ1gyUjBlWEJsSUN0Y2JpQWdJQ0FnSUNBZ1hDSWdJVDBnWENJZ0sxeHVJQ0FnSUNBZ0lDQmtkSGx3WlR0Y2JpQWdJQ0I5WEc0Z0lDQWdjMmhoY0dVZ1BTQnphR0Z3WlNCOGZDQmJkSGx3WldSQmNuSmhlUzVzWlc1bmRHaGRPMXh1SUNBZ0lISmxkSFZ5YmlCN1hHNGdJQ0FnSUNCZlgycGhhV3hsWkY5MGVYQmxYMTg2SUZ3aWJtUmhjbkpoZVZ3aUxGeHVJQ0FnSUNBZ1gxOTJZV3gxWlY5Zk9pQjBlWEJsWkVGeWNtRjVMRnh1SUNBZ0lDQWdYMTl6YUdGd1pWOWZPaUJ6YUdGd1pTeGNiaUFnSUNBZ0lGOWZaSFI1Y0dWZlh6b2dYMlIwZVhCbFhHNGdJQ0FnZlR0Y2JpQWdmVnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQlRaWFJ6SUhSb1pTQnVaWGNnY21WdGIzUmxJR2x1ZEdWeVptRmpaU0J3Y205MmFXUmxaQ0JpZVNCMGFHVWdiM1JvWlhJZ2MybDBaVnh1SUNBZ0tseHVJQ0FnS2lCQWNHRnlZVzBnZTBGeWNtRjVmU0J1WVcxbGN5QnNhWE4wSUc5bUlHWjFibU4wYVc5dUlHNWhiV1Z6WEc0Z0lDQXFMMXh1SUNCZmMyVjBVbVZ0YjNSbEtHRndhU2tnZTF4dUlDQWdJSFJvYVhNdVgzSmxiVzkwWlNBOUlIdDlPMXh1SUNBZ0lIWmhjaUJwTENCdVlXMWxMQ0JrWVhSaExDQjBlWEJsTzF4dUlDQWdJR1p2Y2lBb2FTQTlJREE3SUdrZ1BDQmhjR2t1YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lHNWhiV1VnUFNCaGNHbGJhVjB1Ym1GdFpUdGNiaUFnSUNBZ0lHUmhkR0VnUFNCaGNHbGJhVjB1WkdGMFlUdGNiaUFnSUNBZ0lIUjVjR1VnUFNCaGNHbGJhVjB1ZEhsd1pUdGNiaUFnSUNBZ0lHbG1JQ2gwZVhCbElEMDlQU0JjSW1SaGRHRmNJaWtnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbDl5WlcxdmRHVmJibUZ0WlYwZ1BTQmtZWFJoTzF4dUlDQWdJQ0FnZlNCbGJITmxJR2xtSUNoa1lYUmhLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ1pHRjBZU0E5UFQwZ1hDSnZZbXBsWTNSY0lpa2dlMXh1SUNBZ0lDQWdJQ0FnSUhaaGNpQmtZWFJoTWlBOUlIdDlPMXh1SUNBZ0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUd0bGVTQnBiaUJrWVhSaEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9aR0YwWVM1b1lYTlBkMjVRY205d1pYSjBlU2hyWlhrcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hrWVhSaFcydGxlVjBnUFQwOUlGd2ljbkJqWDIxbGRHaHZaRG82WENJZ0t5QnJaWGtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCa1lYUmhNbHRyWlhsZElEMGdkR2hwY3k1ZloyVnVVbVZ0YjNSbFRXVjBhRzlrS0c1aGJXVWdLeUJjSWk1Y0lpQXJJR3RsZVNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWkdGMFlUSmJhMlY1WFNBOUlHUmhkR0ZiYTJWNVhUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0IwYUdsekxsOXlaVzF2ZEdWYmJtRnRaVjBnUFNCa1lYUmhNanRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNCMGFHbHpMbDl5WlcxdmRHVmJibUZ0WlYwZ1BTQmtZWFJoTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbDl5WlcxdmRHVmJibUZ0WlYwZ1BTQjBhR2x6TGw5blpXNVNaVzF2ZEdWTlpYUm9iMlFvYm1GdFpTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2RHaHBjeTVmY21WdGIzUmxWWEJrWVhSbFNHRnVaR3hsY2lncE8xeHVJQ0FnSUhSb2FYTXVYM0psY0c5eWRGSmxiVzkwWlZObGRDZ3BPMXh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUVkbGJtVnlZWFJsY3lCMGFHVWdkM0poY0hCbFpDQm1kVzVqZEdsdmJpQmpiM0p5WlhOd2IyNWthVzVuSUhSdklHRWdjMmx1WjJ4bElISmxiVzkwWlZ4dUlDQWdLaUJ0WlhSb2IyUXVJRmRvWlc0Z2RHaGxJR2RsYm1WeVlYUmxaQ0JtZFc1amRHbHZiaUJwY3lCallXeHNaV1FzSUdsMElIZHBiR3dnYzJWdVpDQjBhR1ZjYmlBZ0lDb2dZMjl5Y21WemNHOXVaR2x1WnlCdFpYTnpZV2RsSUhSdklIUm9aU0J5WlcxdmRHVWdjMmwwWlNCaGMydHBibWNnYVhRZ2RHOGdaWGhsWTNWMFpWeHVJQ0FnS2lCMGFHVWdjR0Z5ZEdsamRXeGhjaUJ0WlhSb2IyUWdiMllnYVhSeklHbHVkR1Z5Wm1GalpWeHVJQ0FnS2x4dUlDQWdLaUJBY0dGeVlXMGdlMU4wY21sdVozMGdibUZ0WlNCdlppQjBhR1VnY21WdGIzUmxJRzFsZEdodlpGeHVJQ0FnS2x4dUlDQWdLaUJBY21WMGRYSnVjeUI3Um5WdVkzUnBiMjU5SUhkeVlYQndaV1FnY21WdGIzUmxJRzFsZEdodlpGeHVJQ0FnS2k5Y2JpQWdYMmRsYmxKbGJXOTBaVTFsZEdodlpDaHVZVzFsTENCd2JIVm5hVzVmYVdRcElIdGNiaUFnSUNCMllYSWdiV1VnUFNCMGFHbHpPMXh1SUNBZ0lIWmhjaUJ5WlcxdmRHVk5aWFJvYjJRZ1BTQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQnVaWGNnVUhKdmJXbHpaU2dvY21WemIyeDJaU3dnY21WcVpXTjBLU0E5UGlCN1hHNGdJQ0FnSUNBZ0lHeGxkQ0JwWkNBOUlHNTFiR3c3WEc0Z0lDQWdJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQWdJQ0FnYVdRZ1BTQnRaUzVmYldWMGFHOWtYM0psWm5NdWNIVjBLSEJzZFdkcGJsOXBaQ0EvSUhCc2RXZHBibDlwWkNBcklGd2lMMXdpSUNzZ2JtRnRaU0E2SUc1aGJXVXBPMXh1SUNBZ0lDQWdJQ0FnSUhaaGNpQjNjbUZ3Y0dWa1gzSmxjMjlzZG1VZ1BTQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hwWkNBaFBUMGdiblZzYkNrZ2JXVXVYMjFsZEdodlpGOXlaV1p6TG1abGRHTm9LR2xrS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnlaWE52YkhabExtRndjR3g1S0hSb2FYTXNJR0Z5WjNWdFpXNTBjeWs3WEc0Z0lDQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lDQWdJQ0IyWVhJZ2QzSmhjSEJsWkY5eVpXcGxZM1FnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaHBaQ0FoUFQwZ2JuVnNiQ2tnYldVdVgyMWxkR2h2WkY5eVpXWnpMbVpsZEdOb0tHbGtLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCeVpXcGxZM1F1WVhCd2JIa29kR2hwY3l3Z1lYSm5kVzFsYm5SektUdGNiaUFnSUNBZ0lDQWdJQ0I5TzF4dVhHNGdJQ0FnSUNBZ0lDQWdkM0poY0hCbFpGOXlaWE52YkhabExsOWZhbUZwYkdWa1gzQmhhWEp6WDE4Z1BTQjNjbUZ3Y0dWa1gzSmxhbVZqZER0Y2JpQWdJQ0FnSUNBZ0lDQjNjbUZ3Y0dWa1gzSmxhbVZqZEM1ZlgycGhhV3hsWkY5d1lXbHljMTlmSUQwZ2QzSmhjSEJsWkY5eVpYTnZiSFpsTzF4dVhHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUdGeVozTWdQU0JCY25KaGVTNXdjbTkwYjNSNWNHVXVjMnhwWTJVdVkyRnNiQ2hoY21kMWJXVnVkSE1wTzF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h1WVcxbElEMDlQU0JjSW5KbFoybHpkR1Z5WENJZ2ZId2dibUZ0WlNBOVBUMGdYQ0psZUhCdmNuUmNJaUI4ZkNCdVlXMWxJRDA5UFNCY0ltOXVYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR0Z5WjNNZ1BTQnRaUzVmZDNKaGNDaGhjbWR6TENCMGNuVmxLVHRjYmlBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZWEpuY3lBOUlHMWxMbDkzY21Gd0tHRnlaM01wTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0IyWVhJZ2RISmhibk5tWlhKaFlteGxjeUE5SUdGeVozTXVZWEpuY3k1ZlgzUnlZVzV6Wm1WeVlXSnNaWE5mWHp0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZEhKaGJuTm1aWEpoWW14bGN5a2daR1ZzWlhSbElHRnlaM011WVhKbmN5NWZYM1J5WVc1elptVnlZV0pzWlhOZlh6dGNiaUFnSUNBZ0lDQWdJQ0J0WlM1ZlkyOXVibVZqZEdsdmJpNXpaVzVrS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQjBlWEJsT2lCY0ltMWxkR2h2WkZ3aUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCdVlXMWxPaUJ1WVcxbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCd2FXUTZJSEJzZFdkcGJsOXBaQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdZWEpuY3pvZ1lYSm5jeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdjSEp2YldselpUb2diV1V1WDNkeVlYQW9XM2R5WVhCd1pXUmZjbVZ6YjJ4MlpTd2dkM0poY0hCbFpGOXlaV3BsWTNSZEtWeHVJQ0FnSUNBZ0lDQWdJQ0FnZlN4Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJ5WVc1elptVnlZV0pzWlhOY2JpQWdJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0I5SUdOaGRHTm9JQ2hsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0dsa0tTQnRaUzVmYldWMGFHOWtYM0psWm5NdVptVjBZMmdvYVdRcE8xeHVJQ0FnSUNBZ0lDQWdJSEpsYW1WamRDaGNiaUFnSUNBZ0lDQWdJQ0FnSUdCR1lXbHNaV1FnZEc4Z1pYaGxZM1IxWlNCeVpXMXZkR1VnYldWMGFHOWtJQ2h3YkhWbmFXNDZJQ1I3Y0d4MVoybHVYMmxrSUh4OFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUcxbExtbGtmU3dnYldWMGFHOWtPaUFrZTI1aGJXVjlLU3dnWlhKeWIzSTZJQ1I3WlgxZ1hHNGdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlNrN1hHNGdJQ0FnZlR0Y2JpQWdJQ0J5WlcxdmRHVk5aWFJvYjJRdVgxOXlaVzF2ZEdWZmJXVjBhRzlrSUQwZ2RISjFaVHRjYmlBZ0lDQnlaWFIxY200Z2NtVnRiM1JsVFdWMGFHOWtPMXh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUZObGJtUnpJR0VnY21WemNHOXVZMlVnY21Wd2IzSjBhVzVuSUhSb1lYUWdhVzUwWlhKbVlXTmxJR3AxYzNRZ2NISnZkbWxrWldRZ1lua2dkR2hsWEc0Z0lDQXFJSEpsYlc5MFpTQnphWFJsSUhkaGN5QnpkV05qWlhOelpuVnNiSGtnYzJWMElHSjVJSFJvYVhNZ2MybDBaU0JoY3lCeVpXMXZkR1ZjYmlBZ0lDb3ZYRzRnSUY5eVpYQnZjblJTWlcxdmRHVlRaWFFvS1NCN1hHNGdJQ0FnZEdocGN5NWZZMjl1Ym1WamRHbHZiaTV6Wlc1a0tIc2dkSGx3WlRvZ1hDSnBiblJsY21aaFkyVlRaWFJCYzFKbGJXOTBaVndpSUgwcE8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRkJ5WlhCaGNtVnpJSFJvWlNCd2NtOTJhV1JsWkNCelpYUWdiMllnY21WdGIzUmxJRzFsZEdodlpDQmhjbWQxYldWdWRITWdabTl5WEc0Z0lDQXFJSE5sYm1ScGJtY2dkRzhnZEdobElISmxiVzkwWlNCemFYUmxMQ0J5WlhCc1lXTmxjeUJoYkd3Z2RHaGxJR05oYkd4aVlXTnJjeUIzYVhSb1hHNGdJQ0FxSUdsa1pXNTBhV1pwWlhKelhHNGdJQ0FxWEc0Z0lDQXFJRUJ3WVhKaGJTQjdRWEp5WVhsOUlHRnlaM01nZEc4Z2QzSmhjRnh1SUNBZ0tseHVJQ0FnS2lCQWNtVjBkWEp1Y3lCN1FYSnlZWGw5SUhkeVlYQndaV1FnWVhKbmRXMWxiblJ6WEc0Z0lDQXFMMXh1WEc0Z0lGOWxibU52WkdWZmFXNTBaWEptWVdObEtHRlBZbXBsWTNRc0lHSlBZbXBsWTNRcElIdGNiaUFnSUNCMllYSWdkaXdnYXp0Y2JpQWdJQ0JqYjI1emRDQmxibU52WkdWa1gybHVkR1Z5Wm1GalpTQTlJSHQ5TzF4dUlDQWdJR0ZQWW1wbFkzUmJYQ0pmWDJsa1gxOWNJbDBnUFNCaFQySnFaV04wVzF3aVgxOXBaRjlmWENKZElIeDhJSEpoYm1SSlpDZ3BPMXh1SUNBZ0lHWnZjaUFvYXlCcGJpQmhUMkpxWldOMEtTQjdYRzRnSUNBZ0lDQnBaaUFvYXlBOVBUMGdYQ0pvWVhOUGQyNVFjbTl3WlhKMGVWd2lLU0JqYjI1MGFXNTFaVHRjYmlBZ0lDQWdJR2xtSUNoaFQySnFaV04wTG1oaGMwOTNibEJ5YjNCbGNuUjVLR3NwS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hyTG5OMFlYSjBjMWRwZEdnb1hDSmZYQ0lwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZGlBOUlHRlBZbXBsWTNSYmExMDdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tIUjVjR1Z2WmlCMklEMDlQU0JjSW1aMWJtTjBhVzl1WENJcElIdGNiaUFnSUNBZ0lDQWdJQ0JpVDJKcVpXTjBXMnRkSUQwZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWDE5cVlXbHNaV1JmZEhsd1pWOWZPaUJjSW5Cc2RXZHBibDlwYm5SbGNtWmhZMlZjSWl4Y2JpQWdJQ0FnSUNBZ0lDQWdJRjlmY0d4MVoybHVYMmxrWDE4NklHRlBZbXBsWTNSYlhDSmZYMmxrWDE5Y0lsMHNYRzRnSUNBZ0lDQWdJQ0FnSUNCZlgzWmhiSFZsWDE4NklHc3NYRzRnSUNBZ0lDQWdJQ0FnSUNCdWRXMDZJRzUxYkd4Y2JpQWdJQ0FnSUNBZ0lDQjlPMXh1SUNBZ0lDQWdJQ0FnSUdWdVkyOWtaV1JmYVc1MFpYSm1ZV05sVzJ0ZElEMGdkanRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoUFltcGxZM1FvZGlrZ0lUMDlJSFlwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmlUMkpxWldOMFcydGRJRDBnZXlCZlgycGhhV3hsWkY5MGVYQmxYMTg2SUZ3aVlYSm5kVzFsYm5SY0lpd2dYMTkyWVd4MVpWOWZPaUIySUgwN1hHNGdJQ0FnSUNBZ0lDQWdaVzVqYjJSbFpGOXBiblJsY21aaFkyVmJhMTBnUFNCMk8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFI1Y0dWdlppQjJJRDA5UFNCY0ltOWlhbVZqZEZ3aUtTQjdYRzRnSUNBZ0lDQWdJQ0FnWWs5aWFtVmpkRnRyWFNBOUlFRnljbUY1TG1selFYSnlZWGtvZGlrZ1B5QmJYU0E2SUh0OU8xeHVJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyVnVZMjlrWlY5cGJuUmxjbVpoWTJVb2Rpd2dZazlpYW1WamRGdHJYU2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lDQWdkR2hwY3k1ZmNHeDFaMmx1WDJsdWRHVnlabUZqWlhOYllVOWlhbVZqZEZ0Y0lsOWZhV1JmWDF3aVhWMGdQU0JsYm1OdlpHVmtYMmx1ZEdWeVptRmpaVHRjYmx4dUlDQWdJR2xtSUNoaFQySnFaV04wTG05dUtTQjdYRzRnSUNBZ0lDQmhUMkpxWldOMExtOXVLRndpWTJ4dmMyVmNJaXdnS0NrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0JrWld4bGRHVWdkR2hwY3k1ZmNHeDFaMmx1WDJsdWRHVnlabUZqWlhOYllVOWlhbVZqZEZ0Y0lsOWZhV1JmWDF3aVhWMDdYRzRnSUNBZ0lDQjlLVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0JmWlc1amIyUmxLR0ZQWW1wbFkzUXNJR0Z6WDJsdWRHVnlabUZqWlNrZ2UxeHVJQ0FnSUhaaGNpQjBjbUZ1YzJabGNtRmliR1Z6SUQwZ1cxMDdYRzRnSUNBZ2FXWWdLQ0ZoVDJKcVpXTjBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdZVTlpYW1WamREdGNiaUFnSUNCOVhHNGdJQ0FnZG1GeUlGOTBjbUZ1YzJabGNpQTlJR0ZQWW1wbFkzUXVYM1J5WVc1elptVnlPMXh1SUNBZ0lIWmhjaUJpVDJKcVpXTjBMQ0IyTENCck8xeHVJQ0FnSUhaaGNpQnBjMkZ5Y21GNUlEMGdRWEp5WVhrdWFYTkJjbkpoZVNoaFQySnFaV04wS1R0Y2JpQWdJQ0JpVDJKcVpXTjBJRDBnYVhOaGNuSmhlU0EvSUZ0ZElEb2dlMzA3WEc0Z0lDQWdMeTl6YTJsd0lHbG1JR0ZzY21WaFpIa2daVzVqYjJSbFpGeHVJQ0FnSUdsbUlDaGNiaUFnSUNBZ0lIUjVjR1Z2WmlCaFQySnFaV04wSUQwOVBTQmNJbTlpYW1WamRGd2lJQ1ltWEc0Z0lDQWdJQ0JoVDJKcVpXTjBMbDlmYW1GcGJHVmtYM1I1Y0dWZlh5QW1KbHh1SUNBZ0lDQWdZVTlpYW1WamRDNWZYM1poYkhWbFgxOWNiaUFnSUNBcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCaFQySnFaV04wTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2Wlc1amIyUmxJR2x1ZEdWeVptRmpaWE5jYmlBZ0lDQnBaaUFvWEc0Z0lDQWdJQ0IwZVhCbGIyWWdZVTlpYW1WamRDQTlQVDBnWENKdlltcGxZM1JjSWlBbUpseHVJQ0FnSUNBZ0lVRnljbUY1TG1selFYSnlZWGtvWVU5aWFtVmpkQ2tnSmlaY2JpQWdJQ0FnSUNoaFQySnFaV04wTGw5ZllYTmZhVzUwWlhKbVlXTmxYMThnZkh3Z1lYTmZhVzUwWlhKbVlXTmxLVnh1SUNBZ0lDa2dlMXh1SUNBZ0lDQWdkR2hwY3k1ZlpXNWpiMlJsWDJsdWRHVnlabUZqWlNoaFQySnFaV04wTENCaVQySnFaV04wS1R0Y2JpQWdJQ0FnSUhKbGRIVnliaUJpVDJKcVpXTjBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2hoYzE5cGJuUmxjbVpoWTJVcElIdGNiaUFnSUNBZ0lHRlBZbXBsWTNSYlhDSmZYMmxrWDE5Y0lsMGdQU0JoVDJKcVpXTjBXMXdpWDE5cFpGOWZYQ0pkSUh4OElISmhibVJKWkNncE8xeHVJQ0FnSUNBZ2RHaHBjeTVmY0d4MVoybHVYMmx1ZEdWeVptRmpaWE5iWVU5aWFtVmpkRnRjSWw5ZmFXUmZYMXdpWFYwZ1BWeHVJQ0FnSUNBZ0lDQjBhR2x6TGw5d2JIVm5hVzVmYVc1MFpYSm1ZV05sYzF0aFQySnFaV04wVzF3aVgxOXBaRjlmWENKZFhTQjhmQ0I3ZlR0Y2JpQWdJQ0I5WEc0Z0lDQWdabTl5SUNocklHbHVJR0ZQWW1wbFkzUXBJSHRjYmlBZ0lDQWdJR2xtSUNocklEMDlQU0JjSW1oaGMwOTNibEJ5YjNCbGNuUjVYQ0lwSUdOdmJuUnBiblZsTzF4dUlDQWdJQ0FnYVdZZ0tHbHpZWEp5WVhrZ2ZId2dZVTlpYW1WamRDNW9ZWE5QZDI1UWNtOXdaWEowZVNocktTa2dlMXh1SUNBZ0lDQWdJQ0IySUQwZ1lVOWlhbVZqZEZ0clhUdGNiaUFnSUNBZ0lDQWdhV1lnS0hSNWNHVnZaaUIwYUdsekxsOXBiblJsY21aaFkyVXVYM0p3WTBWdVkyOWtaU0E5UFQwZ1hDSm1kVzVqZEdsdmJsd2lLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWlc1amIyUmxaRjl2WW1vZ1BTQjBhR2x6TGw5cGJuUmxjbVpoWTJVdVgzSndZMFZ1WTI5a1pTaDJLVHRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9aVzVqYjJSbFpGOXZZbW9nSmlZZ1pXNWpiMlJsWkY5dlltb3VYMTl5Y0dOZlpIUjVjR1ZmWHlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWWs5aWFtVmpkRnRyWFNBOUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1gxOXFZV2xzWldSZmRIbHdaVjlmT2lCY0ltTjFjM1J2YlY5bGJtTnZaR2x1WjF3aUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCZlgzWmhiSFZsWDE4NklHVnVZMjlrWldSZmIySnFYRzRnSUNBZ0lDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWRHbHVkV1U3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQzh2SUdsbUlIUm9aU0J5WlhSMWNtNWxaQ0J2WW1wbFkzUWdaRzlsY3lCdWIzUWdZMjl1ZEdGcGJpQmZYMnBoYVd4bFpGOTBlWEJsWDE4c0lHRnpjM1Z0YVc1bklIUm9aU0J2WW1wbFkzUWdhR0Z6SUdKbFpXNGdkSEpoYm5ObWIzSnRaV1JjYmlBZ0lDQWdJQ0FnSUNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIWWdQU0JsYm1OdlpHVmtYMjlpYWp0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnYVdZZ0tIUjVjR1Z2WmlCMklEMDlQU0JjSW1aMWJtTjBhVzl1WENJcElIdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb1lYTmZhVzUwWlhKbVlXTmxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCbGJtTnZaR1ZrWDJsdWRHVnlabUZqWlNBOUlIUm9hWE11WDNCc2RXZHBibDlwYm5SbGNtWmhZMlZ6VzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JoVDJKcVpXTjBXMXdpWDE5cFpGOWZYQ0pkWEc0Z0lDQWdJQ0FnSUNBZ0lDQmRPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1lrOWlhbVZqZEZ0clhTQTlJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdYMTlxWVdsc1pXUmZkSGx3WlY5Zk9pQmNJbkJzZFdkcGJsOXBiblJsY21aaFkyVmNJaXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdYMTl3YkhWbmFXNWZhV1JmWHpvZ1lVOWlhbVZqZEZ0Y0lsOWZhV1JmWDF3aVhTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1gxOTJZV3gxWlY5Zk9pQnJMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnVkVzA2SUc1MWJHeGNiaUFnSUNBZ0lDQWdJQ0FnSUgwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JsYm1OdlpHVmtYMmx1ZEdWeVptRmpaVnRyWFNBOUlIWTdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNTBhVzUxWlR0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnYkdWMElHbHVkR1Z5Wm1GalpVWjFibU5PWVcxbElEMGdiblZzYkR0Y2JpQWdJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQnVZVzFsSUdsdUlIUm9hWE11WDJsdWRHVnlabUZqWlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIUm9hWE11WDJsdWRHVnlabUZqWlM1b1lYTlBkMjVRY205d1pYSjBlU2h1WVcxbEtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvYm1GdFpTNXpkR0Z5ZEhOWGFYUm9LRndpWDF3aUtTa2dZMjl1ZEdsdWRXVTdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2gwYUdsekxsOXBiblJsY21aaFkyVmJibUZ0WlYwZ1BUMDlJSFlwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCcGJuUmxjbVpoWTJWR2RXNWpUbUZ0WlNBOUlHNWhiV1U3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnTHk4Z2MyVmhjbU5vSUdadmNpQndjbTkwYjNSNWNHVnpYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHWjFibU4wYVc5dWN5QTlJRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVU1aGJXVnpLRnh1SUNBZ0lDQWdJQ0FnSUNBZ1QySnFaV04wTG1kbGRGQnliM1J2ZEhsd1pVOW1LSFJvYVhNdVgybHVkR1Z5Wm1GalpTbGNiaUFnSUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dablZ1WTNScGIyNXpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ2JtRnRaVjhnUFNCbWRXNWpkR2x2Ym5OYmFWMDdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9ibUZ0WlY4dWMzUmhjblJ6VjJsMGFDaGNJbDljSWlrcElHTnZiblJwYm5WbE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIUm9hWE11WDJsdWRHVnlabUZqWlZ0dVlXMWxYMTBnUFQwOUlIWXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdhVzUwWlhKbVlXTmxSblZ1WTA1aGJXVWdQU0J1WVcxbFh6dGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1luSmxZV3M3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2doYVc1MFpYSm1ZV05sUm5WdVkwNWhiV1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCcFpDQTlJSFJvYVhNdVgzTjBiM0psTG5CMWRDaDJLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHSlBZbXBsWTNSYmExMGdQU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRjlmYW1GcGJHVmtYM1I1Y0dWZlh6b2dYQ0pqWVd4c1ltRmphMXdpTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JmWDNaaGJIVmxYMTg2SUNoMkxtTnZibk4wY25WamRHOXlJQ1ltSUhZdVkyOXVjM1J5ZFdOMGIzSXVibUZ0WlNrZ2ZId2dhV1FzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRzUxYlRvZ2FXUmNiaUFnSUNBZ0lDQWdJQ0FnSUgwN1hHNGdJQ0FnSUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdKUFltcGxZM1JiYTEwZ1BTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lGOWZhbUZwYkdWa1gzUjVjR1ZmWHpvZ1hDSnBiblJsY21aaFkyVmNJaXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdYMTkyWVd4MVpWOWZPaUJwYm5SbGNtWmhZMlZHZFc1alRtRnRaU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdiblZ0T2lCdWRXeHNYRzRnSUNBZ0lDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoY2JpQWdJQ0FnSUNBZ0lDQXZLbWRzYjJKaGJDQjBaaW92WEc0Z0lDQWdJQ0FnSUNBZ2RIbHdaVzltSUhSbUlDRTlQU0JjSW5WdVpHVm1hVzVsWkZ3aUlDWW1YRzRnSUNBZ0lDQWdJQ0FnZEdZdVZHVnVjMjl5SUNZbVhHNGdJQ0FnSUNBZ0lDQWdkaUJwYm5OMFlXNWpaVzltSUhSbUxsUmxibk52Y2x4dUlDQWdJQ0FnSUNBcElIdGNiaUFnSUNBZ0lDQWdJQ0JqYjI1emRDQjJYMkoxWm1abGNpQTlJSFl1WkdGMFlWTjVibU1vS1R0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZGk1ZmRISmhibk5tWlhJZ2ZId2dYM1J5WVc1elptVnlLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBjbUZ1YzJabGNtRmliR1Z6TG5CMWMyZ29kbDlpZFdabVpYSXVZblZtWm1WeUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdSbGJHVjBaU0IyTGw5MGNtRnVjMlpsY2p0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnWWs5aWFtVmpkRnRyWFNBOUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUY5ZmFtRnBiR1ZrWDNSNWNHVmZYem9nWENKdVpHRnljbUY1WENJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JmWDNaaGJIVmxYMTg2SUhaZlluVm1abVZ5TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdYMTl6YUdGd1pWOWZPaUIyTG5Ob1lYQmxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1gxOWtkSGx3WlY5Zk9pQjJMbVIwZVhCbFhHNGdJQ0FnSUNBZ0lDQWdmVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoY2JpQWdJQ0FnSUNBZ0lDQXZLbWRzYjJKaGJDQnVhaW92WEc0Z0lDQWdJQ0FnSUNBZ2RIbHdaVzltSUc1cUlDRTlQU0JjSW5WdVpHVm1hVzVsWkZ3aUlDWW1YRzRnSUNBZ0lDQWdJQ0FnYm1vdVRtUkJjbkpoZVNBbUpseHVJQ0FnSUNBZ0lDQWdJSFlnYVc1emRHRnVZMlZ2WmlCdWFpNU9aRUZ5Y21GNVhHNGdJQ0FnSUNBZ0lDa2dlMXh1SUNBZ0lDQWdJQ0FnSUhaaGNpQmtkSGx3WlNBOUlIUjVjR1ZrUVhKeVlYbFViMFIwZVhCbFczWXVjMlZzWldOMGFXOXVMbVJoZEdFdVkyOXVjM1J5ZFdOMGIzSXVibUZ0WlYwN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0hZdVgzUnlZVzV6Wm1WeUlIeDhJRjkwY21GdWMyWmxjaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkSEpoYm5ObVpYSmhZbXhsY3k1d2RYTm9LSFl1YzJWc1pXTjBhVzl1TG1SaGRHRXVZblZtWm1WeUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdSbGJHVjBaU0IyTGw5MGNtRnVjMlpsY2p0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnWWs5aWFtVmpkRnRyWFNBOUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUY5ZmFtRnBiR1ZrWDNSNWNHVmZYem9nWENKdVpHRnljbUY1WENJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JmWDNaaGJIVmxYMTg2SUhZdWMyVnNaV04wYVc5dUxtUmhkR0VzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmZYM05vWVhCbFgxODZJSFl1YzJoaGNHVXNYRzRnSUNBZ0lDQWdJQ0FnSUNCZlgyUjBlWEJsWDE4NklHUjBlWEJsWEc0Z0lDQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2gySUdsdWMzUmhibU5sYjJZZ1JYSnliM0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtVnljbTl5S0hZcE8xeHVJQ0FnSUNBZ0lDQWdJR0pQWW1wbFkzUmJhMTBnUFNCN0lGOWZhbUZwYkdWa1gzUjVjR1ZmWHpvZ1hDSmxjbkp2Y2x3aUxDQmZYM1poYkhWbFgxODZJSFl1ZEc5VGRISnBibWNvS1NCOU8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFI1Y0dWdlppQkdhV3hsSUNFOVBTQmNJblZ1WkdWbWFXNWxaRndpSUNZbUlIWWdhVzV6ZEdGdVkyVnZaaUJHYVd4bEtTQjdYRzRnSUNBZ0lDQWdJQ0FnWWs5aWFtVmpkRnRyWFNBOUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUY5ZmFtRnBiR1ZrWDNSNWNHVmZYem9nWENKbWFXeGxYQ0lzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmZYM1poYkhWbFgxODZJSFlzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmZYM0psYkdGMGFYWmxYM0JoZEdoZlh6b2dkaTV5Wld4aGRHbDJaVkJoZEdnZ2ZId2dkaTUzWldKcmFYUlNaV3hoZEdsMlpWQmhkR2hjYmlBZ0lDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQzh2SUhObGJtUWdiMkpxWldOMGN5QnpkWEJ3YjNKMFpXUWdZbmtnYzNSeWRXTjBkWEpsSUdOc2IyNWxJR0ZzWjI5eWFYUm9iVnh1SUNBZ0lDQWdJQ0F2THlCb2RIUndjem92TDJSbGRtVnNiM0JsY2k1dGIzcHBiR3hoTG05eVp5OWxiaTFWVXk5a2IyTnpMMWRsWWk5QlVFa3ZWMlZpWDFkdmNtdGxjbk5mUVZCSkwxTjBjblZqZEhWeVpXUmZZMnh2Ym1WZllXeG5iM0pwZEdodFhHNGdJQ0FnSUNBZ0lHVnNjMlVnYVdZZ0tGeHVJQ0FnSUNBZ0lDQWdJSFlnSVQwOUlFOWlhbVZqZENoMktTQjhmRnh1SUNBZ0lDQWdJQ0FnSUhZZ2FXNXpkR0Z1WTJWdlppQkNiMjlzWldGdUlIeDhYRzRnSUNBZ0lDQWdJQ0FnZGlCcGJuTjBZVzVqWlc5bUlGTjBjbWx1WnlCOGZGeHVJQ0FnSUNBZ0lDQWdJSFlnYVc1emRHRnVZMlZ2WmlCRVlYUmxJSHg4WEc0Z0lDQWdJQ0FnSUNBZ2RpQnBibk4wWVc1alpXOW1JRkpsWjBWNGNDQjhmRnh1SUNBZ0lDQWdJQ0FnSUhZZ2FXNXpkR0Z1WTJWdlppQkNiRzlpSUh4OFhHNGdJQ0FnSUNBZ0lDQWdkaUJwYm5OMFlXNWpaVzltSUVsdFlXZGxSR0YwWVNCOGZGeHVJQ0FnSUNBZ0lDQWdJQ2gwZVhCbGIyWWdSbWxzWlV4cGMzUWdJVDA5SUZ3aWRXNWtaV1pwYm1Wa1hDSWdKaVlnZGlCcGJuTjBZVzVqWlc5bUlFWnBiR1ZNYVhOMEtWeHVJQ0FnSUNBZ0lDQXBJSHRjYmlBZ0lDQWdJQ0FnSUNCaVQySnFaV04wVzJ0ZElEMGdleUJmWDJwaGFXeGxaRjkwZVhCbFgxODZJRndpWVhKbmRXMWxiblJjSWl3Z1gxOTJZV3gxWlY5Zk9pQjJJSDA3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RpQnBibk4wWVc1alpXOW1JRUZ5Y21GNVFuVm1abVZ5S1NCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0hZdVgzUnlZVzV6Wm1WeUlIeDhJRjkwY21GdWMyWmxjaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkSEpoYm5ObVpYSmhZbXhsY3k1d2RYTm9LSFlwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdaR1ZzWlhSbElIWXVYM1J5WVc1elptVnlPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQmlUMkpxWldOMFcydGRJRDBnZXlCZlgycGhhV3hsWkY5MGVYQmxYMTg2SUZ3aVlYSm5kVzFsYm5SY0lpd2dYMTkyWVd4MVpWOWZPaUIySUgwN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9kaUJwYm5OMFlXNWpaVzltSUVGeWNtRjVRblZtWm1WeVZtbGxkeWtnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2gyTGw5MGNtRnVjMlpsY2lCOGZDQmZkSEpoYm5ObVpYSXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUnlZVzV6Wm1WeVlXSnNaWE11Y0hWemFDaDJMbUoxWm1abGNpazdYRzRnSUNBZ0lDQWdJQ0FnSUNCa1pXeGxkR1VnZGk1ZmRISmhibk5tWlhJN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUdKUFltcGxZM1JiYTEwZ1BTQjdJRjlmYW1GcGJHVmtYM1I1Y0dWZlh6b2dYQ0poY21kMWJXVnVkRndpTENCZlgzWmhiSFZsWDE4NklIWWdmVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBdkx5QlVUMFJQT2lCemRYQndiM0owSUdGc2MyOGdUV0Z3SUdGdVpDQlRaWFJjYmlBZ0lDQWdJQ0FnTHk4Z1ZFOUVUem9nWVhadmFXUWdiMkpxWldOMElITjFZMmdnWVhNZ1JIbHVZVzFwWTFCc2RXZHBiaUJwYm5OMFlXNWpaUzVjYmlBZ0lDQWdJQ0FnWld4elpTQnBaaUFvZGk1ZlgyRnpYMmx1ZEdWeVptRmpaVjlmS1NCN1hHNGdJQ0FnSUNBZ0lDQWdZazlpYW1WamRGdHJYU0E5SUhSb2FYTXVYMlZ1WTI5a1pTaDJMQ0IwY25WbEtUdGNiaUFnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2gwZVhCbGIyWWdkaUE5UFQwZ1hDSnZZbXBsWTNSY0lpQjhmQ0JCY25KaGVTNXBjMEZ5Y21GNUtIWXBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1lrOWlhbVZqZEZ0clhTQTlJSFJvYVhNdVgyVnVZMjlrWlNoMkxDQmhjMTlwYm5SbGNtWmhZMlVwTzF4dUlDQWdJQ0FnSUNBZ0lDOHZJRzF2ZG1VZ2RISmhibk5tWlhKaFlteGxjeUIwYnlCMGFHVWdkRzl3SUd4bGRtVnNJRzlpYW1WamRGeHVJQ0FnSUNBZ0lDQWdJR2xtSUNoaVQySnFaV04wVzJ0ZExsOWZkSEpoYm5ObVpYSmhZbXhsYzE5ZktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCMElEMGdNRHNnZENBOElHSlBZbXBsWTNSYmExMHVYMTkwY21GdWMyWmxjbUZpYkdWelgxOHViR1Z1WjNSb095QjBLeXNwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZEhKaGJuTm1aWEpoWW14bGN5NXdkWE5vS0dKUFltcGxZM1JiYTEwdVgxOTBjbUZ1YzJabGNtRmliR1Z6WDE5YmRGMHBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnWkdWc1pYUmxJR0pQWW1wbFkzUmJhMTB1WDE5MGNtRnVjMlpsY21GaWJHVnpYMTg3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFI1Y0dWdlppQjJJRDA5UFNCY0ltOWlhbVZqZEZ3aUlDWW1JSFl1WTI5dWMzUnlkV04wYjNJcElIdGNiaUFnSUNBZ0lDQWdJQ0IwYUhKdmR5QmNJbFZ1YzNWd2NHOXlkR1ZrSUdSaGRHRWdkSGx3WlNCbWIzSWdkSEpoYm5ObVpYSnlhVzVuSUdKbGRIZGxaVzRnZEdobElIQnNkV2RwYmlCaGJtUWdkR2hsSUcxaGFXNGdZWEJ3T2lCY0lpQXJYRzRnSUNBZ0lDQWdJQ0FnSUNCcklDdGNiaUFnSUNBZ0lDQWdJQ0FnSUZ3aUlEb2dYQ0lnSzF4dUlDQWdJQ0FnSUNBZ0lDQWdkaTVqYjI1emRISjFZM1J2Y2k1dVlXMWxPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRndpVlc1emRYQndiM0owWldRZ1pHRjBZU0IwZVhCbElHWnZjaUIwY21GdWMyWmxjbkpwYm1jZ1ltVjBkMlZsYmlCMGFHVWdjR3gxWjJsdUlHRnVaQ0IwYUdVZ2JXRnBiaUJoY0hBNklGd2lJQ3RjYmlBZ0lDQWdJQ0FnSUNBZ0lHc2dLMXh1SUNBZ0lDQWdJQ0FnSUNBZ1hDSXNYQ0lnSzF4dUlDQWdJQ0FnSUNBZ0lDQWdkanRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvZEhKaGJuTm1aWEpoWW14bGN5NXNaVzVuZEdnZ1BpQXdLU0I3WEc0Z0lDQWdJQ0JpVDJKcVpXTjBMbDlmZEhKaGJuTm1aWEpoWW14bGMxOWZJRDBnZEhKaGJuTm1aWEpoWW14bGN6dGNiaUFnSUNCOVhHNGdJQ0FnY21WMGRYSnVJR0pQWW1wbFkzUTdYRzRnSUgxY2JseHVJQ0JmWkdWamIyUmxLR0ZQWW1wbFkzUXNJR05oYkd4aVlXTnJTV1FzSUhkcGRHaFFjbTl0YVhObEtTQjdYRzRnSUNBZ2FXWWdLQ0ZoVDJKcVpXTjBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdZVTlpYW1WamREdGNiaUFnSUNCOVhHNGdJQ0FnZG1GeUlHSlBZbXBsWTNRc0lIWXNJR3M3WEc1Y2JpQWdJQ0JwWmlBb1hHNGdJQ0FnSUNCaFQySnFaV04wTG1oaGMwOTNibEJ5YjNCbGNuUjVLRndpWDE5cVlXbHNaV1JmZEhsd1pWOWZYQ0lwSUNZbVhHNGdJQ0FnSUNCaFQySnFaV04wTG1oaGMwOTNibEJ5YjNCbGNuUjVLRndpWDE5MllXeDFaVjlmWENJcFhHNGdJQ0FnS1NCN1hHNGdJQ0FnSUNCcFppQW9ZVTlpYW1WamRDNWZYMnBoYVd4bFpGOTBlWEJsWDE4dWMzUmhjblJ6VjJsMGFDaGNJbU4xYzNSdmJWOWxibU52WkdsdVoxd2lLU2tnZTF4dUlDQWdJQ0FnSUNCcFppQW9kSGx3Wlc5bUlIUm9hWE11WDJsdWRHVnlabUZqWlM1ZmNuQmpSR1ZqYjJSbElEMDlQU0JjSW1aMWJtTjBhVzl1WENJcElIdGNiaUFnSUNBZ0lDQWdJQ0JqYjI1emRDQmtaV052WkdWa1QySnFJRDBnZEdocGN5NWZhVzUwWlhKbVlXTmxMbDl5Y0dORVpXTnZaR1VvWVU5aWFtVmpkQzVmWDNaaGJIVmxYMThwTzF4dUlDQWdJQ0FnSUNBZ0lHSlBZbXBsWTNRZ1BTQmtaV052WkdWa1QySnFPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUdKUFltcGxZM1FnUFNCaFQySnFaV04wTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHRlBZbXBsWTNRdVgxOXFZV2xzWldSZmRIbHdaVjlmSUQwOVBTQmNJbU5oYkd4aVlXTnJYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ1lrOWlhbVZqZENBOUlIUm9hWE11WDJkbGJsSmxiVzkwWlVOaGJHeGlZV05yS0dOaGJHeGlZV05yU1dRc0lHRlBZbXBsWTNRdWJuVnRMQ0IzYVhSb1VISnZiV2x6WlNrN1hHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHRlBZbXBsWTNRdVgxOXFZV2xzWldSZmRIbHdaVjlmSUQwOVBTQmNJbWx1ZEdWeVptRmpaVndpS1NCN1hHNGdJQ0FnSUNBZ0lHSlBZbXBsWTNRZ1BWeHVJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgzSmxiVzkwWlZ0aFQySnFaV04wTGw5ZmRtRnNkV1ZmWDEwZ2ZIeGNiaUFnSUNBZ0lDQWdJQ0IwYUdsekxsOW5aVzVTWlcxdmRHVk5aWFJvYjJRb1lVOWlhbVZqZEM1ZlgzWmhiSFZsWDE4cE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaGhUMkpxWldOMExsOWZhbUZwYkdWa1gzUjVjR1ZmWHlBOVBUMGdYQ0p3YkhWbmFXNWZhVzUwWlhKbVlXTmxYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ1lrOWlhbVZqZENBOUlIUm9hWE11WDJkbGJsSmxiVzkwWlUxbGRHaHZaQ2hjYmlBZ0lDQWdJQ0FnSUNCaFQySnFaV04wTGw5ZmRtRnNkV1ZmWHl4Y2JpQWdJQ0FnSUNBZ0lDQmhUMkpxWldOMExsOWZjR3gxWjJsdVgybGtYMTljYmlBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1lVOWlhbVZqZEM1ZlgycGhhV3hsWkY5MGVYQmxYMThnUFQwOUlGd2libVJoY25KaGVWd2lLU0I3WEc0Z0lDQWdJQ0FnSUM4cVoyeHZZbUZzSUc1cUlIUm1LaTljYmlBZ0lDQWdJQ0FnTHk5amNtVmhkR1VnWW5WcGJHUWdZWEp5WVhrdmRHVnVjMjl5SUdsbUlIVnpaV1FnYVc0Z2RHaGxJSEJzZFdkcGJseHVJQ0FnSUNBZ0lDQnBaaUFvZEdocGN5NXBaQ0E5UFQwZ1hDSmZYM0JzZFdkcGJsOWZYQ0lnSmlZZ2RIbHdaVzltSUc1cUlDRTlQU0JjSW5WdVpHVm1hVzVsWkZ3aUlDWW1JRzVxTG1GeWNtRjVLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLRUZ5Y21GNUxtbHpRWEp5WVhrb1lVOWlhbVZqZEM1ZlgzWmhiSFZsWDE4cEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaFQySnFaV04wTGw5ZmRtRnNkV1ZmWHlBOUlHRlBZbXBsWTNRdVgxOTJZV3gxWlY5ZkxuSmxaSFZqWlNoZllYQndaVzVrUW5WbVptVnlLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdZazlpYW1WamRDQTlJRzVxWEc0Z0lDQWdJQ0FnSUNBZ0lDQXVZWEp5WVhrb1lVOWlhbVZqZEM1ZlgzWmhiSFZsWDE4c0lHRlBZbXBsWTNRdVgxOWtkSGx3WlY5ZktWeHVJQ0FnSUNBZ0lDQWdJQ0FnTG5KbGMyaGhjR1VvWVU5aWFtVmpkQzVmWDNOb1lYQmxYMThwTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tGeHVJQ0FnSUNBZ0lDQWdJSFJvYVhNdWFXUWdQVDA5SUZ3aVgxOXdiSFZuYVc1Zlgxd2lJQ1ltWEc0Z0lDQWdJQ0FnSUNBZ2RIbHdaVzltSUhSbUlDRTlQU0JjSW5WdVpHVm1hVzVsWkZ3aUlDWW1YRzRnSUNBZ0lDQWdJQ0FnZEdZdVZHVnVjMjl5WEc0Z0lDQWdJQ0FnSUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJR2xtSUNoQmNuSmhlUzVwYzBGeWNtRjVLR0ZQWW1wbFkzUXVYMTkyWVd4MVpWOWZLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZVTlpYW1WamRDNWZYM1poYkhWbFgxOGdQU0JoVDJKcVpXTjBMbDlmZG1Gc2RXVmZYeTV5WldSMVkyVW9YMkZ3Y0dWdVpFSjFabVpsY2lrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUdKUFltcGxZM1FnUFNCMFppNTBaVzV6YjNJb1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoVDJKcVpXTjBMbDlmZG1Gc2RXVmZYeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lHRlBZbXBsWTNRdVgxOXphR0Z3WlY5ZkxGeHVJQ0FnSUNBZ0lDQWdJQ0FnWVU5aWFtVmpkQzVmWDJSMGVYQmxYMTljYmlBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJQzh2YTJWbGNDQnBkQ0JoY3lCeVpXZDFiR0Z5SUdsbUlIUnlZVzV6Wm1WeVpXUWdkRzhnZEdobElHMWhhVzRnWVhCd1hHNGdJQ0FnSUNBZ0lDQWdZazlpYW1WamRDQTlJR0ZQWW1wbFkzUTdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvWVU5aWFtVmpkQzVmWDJwaGFXeGxaRjkwZVhCbFgxOGdQVDA5SUZ3aVpYSnliM0pjSWlrZ2UxeHVJQ0FnSUNBZ0lDQmlUMkpxWldOMElEMGdibVYzSUVWeWNtOXlLR0ZQWW1wbFkzUXVYMTkyWVd4MVpWOWZLVHRjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvWVU5aWFtVmpkQzVmWDJwaGFXeGxaRjkwZVhCbFgxOGdQVDA5SUZ3aVptbHNaVndpS1NCN1hHNGdJQ0FnSUNBZ0lHSlBZbXBsWTNRZ1BTQmhUMkpxWldOMExsOWZkbUZzZFdWZlh6dGNiaUFnSUNBZ0lDQWdMeTl3WVhSamFDQnlaV3hoZEdsMlpWQmhkR2hjYmlBZ0lDQWdJQ0FnWWs5aWFtVmpkQzV5Wld4aGRHbDJaVkJoZEdnZ1BTQmhUMkpxWldOMExsOWZjbVZzWVhScGRtVmZjR0YwYUY5Zk8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaGhUMkpxWldOMExsOWZhbUZwYkdWa1gzUjVjR1ZmWHlBOVBUMGdYQ0poY21kMWJXVnVkRndpS1NCN1hHNGdJQ0FnSUNBZ0lHSlBZbXBsWTNRZ1BTQmhUMkpxWldOMExsOWZkbUZzZFdWZlh6dGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lISmxkSFZ5YmlCaVQySnFaV04wTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQjJZWElnYVhOaGNuSmhlU0E5SUVGeWNtRjVMbWx6UVhKeVlYa29ZVTlpYW1WamRDazdYRzRnSUNBZ0lDQmlUMkpxWldOMElEMGdhWE5oY25KaGVTQS9JRnRkSURvZ2UzMDdYRzRnSUNBZ0lDQm1iM0lnS0dzZ2FXNGdZVTlpYW1WamRDa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2FYTmhjbkpoZVNCOGZDQmhUMkpxWldOMExtaGhjMDkzYmxCeWIzQmxjblI1S0dzcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnZGlBOUlHRlBZbXBsWTNSYmExMDdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tIUjVjR1Z2WmlCMklEMDlQU0JjSW05aWFtVmpkRndpSUh4OElFRnljbUY1TG1selFYSnlZWGtvZGlrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdKUFltcGxZM1JiYTEwZ1BTQjBhR2x6TGw5a1pXTnZaR1VvZGl3Z1kyRnNiR0poWTJ0SlpDd2dkMmwwYUZCeWIyMXBjMlVwTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdjbVYwZFhKdUlHSlBZbXBsWTNRN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ1gzZHlZWEFvWVhKbmN5d2dZWE5mYVc1MFpYSm1ZV05sS1NCN1hHNGdJQ0FnZG1GeUlIZHlZWEJ3WldRZ1BTQjBhR2x6TGw5bGJtTnZaR1VvWVhKbmN5d2dZWE5mYVc1MFpYSm1ZV05sS1R0Y2JpQWdJQ0IyWVhJZ2NtVnpkV3gwSUQwZ2V5QmhjbWR6T2lCM2NtRndjR1ZrSUgwN1hHNGdJQ0FnY21WMGRYSnVJSEpsYzNWc2REdGNiaUFnZlZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJWYm5keVlYQnpJSFJvWlNCelpYUWdiMllnWVhKbmRXMWxiblJ6SUdSbGJHbDJaWEpsWkNCbWNtOXRJSFJvWlNCeVpXMXZkR1VnYzJsMFpTeGNiaUFnSUNvZ2NtVndiR0ZqWlhNZ1lXeHNJR05oYkd4aVlXTnJJR2xrWlc1MGFXWnBaWEp6SUhkcGRHZ2dZU0JtZFc1amRHbHZiaUIzYUdsamFDQjNhV3hzWEc0Z0lDQXFJR2x1YVhScFlYUmxJSE5sYm1ScGJtY2dkR2hoZENCallXeHNZbUZqYXlCcFpHVnVkR2xtYVdWeUlHSmhZMnNnZEc4Z2IzUm9aWElnYzJsMFpWeHVJQ0FnS2x4dUlDQWdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdZWEpuY3lCMGJ5QjFibmR5WVhCY2JpQWdJQ3BjYmlBZ0lDb2dRSEJoY21GdElIdENiMjlzWldGdWZTQjNhWFJvVUhKdmJXbHpaU0JwY3lCMGNuVmxJRzFsWVc1eklIUm9hWE1nZEdobElHTmhiR3hpWVdOcklITm9iM1ZzWkNCamIyNTBZV2x1SUdFZ2NISnZiV2x6WlZ4dUlDQWdLbHh1SUNBZ0tpQkFjbVYwZFhKdWN5QjdRWEp5WVhsOUlIVnVkM0poY0hCbFpDQmhjbWR6WEc0Z0lDQXFMMXh1SUNCZmRXNTNjbUZ3S0dGeVozTXNJSGRwZEdoUWNtOXRhWE5sS1NCN1hHNGdJQ0FnTHk4Z2RtRnlJR05oYkd4bFpDQTlJR1poYkhObE8xeHVYRzRnSUNBZ0x5OGdkM0poY0hNZ1pXRmphQ0JqWVd4c1ltRmpheUJ6YnlCMGFHRjBJSFJvWlNCdmJteDVJRzl1WlNCamIzVnNaQ0JpWlNCallXeHNaV1JjYmlBZ0lDQXZMeUIyWVhJZ2IyNWpaU2hqWWlrZ2UxeHVJQ0FnSUM4dklDQWdJQ0J5WlhSMWNtNGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdMeThnSUNBZ0lDQWdJQ0JwWmlBb0lXTmhiR3hsWkNrZ2UxeHVJQ0FnSUM4dklDQWdJQ0FnSUNBZ0lDQWdJR05oYkd4bFpDQTlJSFJ5ZFdVN1hHNGdJQ0FnTHk4Z0lDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHTmlMbUZ3Y0d4NUtIUm9hWE1zSUdGeVozVnRaVzUwY3lrN1hHNGdJQ0FnTHk4Z0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQzh2SUNBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUJ0YzJjZ1BWeHVJQ0FnSUM4dklDQWdJQ0FnSUNBZ0lDQWdJQ0FnSjBFZ1kyRnNiR0poWTJzZ1puSnZiU0IwYUdseklITmxkQ0JvWVhNZ1lXeHlaV0ZrZVNCaVpXVnVJR1Y0WldOMWRHVmtKenRjYmlBZ0lDQXZMeUFnSUNBZ0lDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvYlhObktUdGNiaUFnSUNBdkx5QWdJQ0FnSUNBZ0lIMWNiaUFnSUNBdkx5QWdJQ0FnZlR0Y2JpQWdJQ0F2THlCOVhHNGdJQ0FnZG1GeUlISmxjM1ZzZENBOUlIUm9hWE11WDJSbFkyOWtaU2hoY21kekxtRnlaM01zSUdGeVozTXVZMkZzYkdKaFkydEpaQ3dnZDJsMGFGQnliMjFwYzJVcE8xeHVJQ0FnSUhKbGRIVnliaUJ5WlhOMWJIUTdYRzRnSUgxY2JseHVJQ0F2S2lwY2JpQWdJQ29nUjJWdVpYSmhkR1Z6SUhSb1pTQjNjbUZ3Y0dWa0lHWjFibU4wYVc5dUlHTnZjbkpsYzNCdmJtUnBibWNnZEc4Z1lTQnphVzVuYkdVZ2NtVnRiM1JsWEc0Z0lDQXFJR05oYkd4aVlXTnJMaUJYYUdWdUlIUm9aU0JuWlc1bGNtRjBaV1FnWm5WdVkzUnBiMjRnYVhNZ1kyRnNiR1ZrTENCcGRDQjNhV3hzSUhObGJtUmNiaUFnSUNvZ2RHaGxJR052Y25KbGMzQnZibVJwYm1jZ2JXVnpjMkZuWlNCMGJ5QjBhR1VnY21WdGIzUmxJSE5wZEdVZ1lYTnJhVzVuSUdsMElIUnZYRzRnSUNBcUlHVjRaV04xZEdVZ2RHaGxJSEJoY25ScFkzVnNZWElnWTJGc2JHSmhZMnNnY0hKbGRtbHZkWE5zZVNCellYWmxaQ0JrZFhKcGJtY2dZU0JqWVd4c1hHNGdJQ0FxSUdKNUlIUm9aU0J5WlcxdmRHVWdjMmwwWlNCaElHMWxkR2h2WkNCbWNtOXRJSFJvWlNCcGJuUmxjbVpoWTJVZ2IyWWdkR2hwY3lCemFYUmxYRzRnSUNBcVhHNGdJQ0FxSUVCd1lYSmhiU0I3VG5WdFltVnlmU0JwWkNCdlppQjBhR1VnY21WdGIzUmxJR05oYkd4aVlXTnJJSFJ2SUdWNFpXTjFkR1ZjYmlBZ0lDb2dRSEJoY21GdElIdE9kVzFpWlhKOUlHRnlaMDUxYlNCaGNtZDFiV1Z1ZENCcGJtUmxlQ0J2WmlCMGFHVWdZMkZzYkdKaFkydGNiaUFnSUNvZ1FIQmhjbUZ0SUh0Q2IyOXNaV0Z1ZlNCM2FYUm9VSEp2YldselpTQnBjeUIwY25WbElHMWxZVzV6SUhSb2FYTWdkR2hsSUdOaGJHeGlZV05ySUhOb2IzVnNaQ0JqYjI1MFlXbHVJR0VnY0hKdmJXbHpaVnh1SUNBZ0tseHVJQ0FnS2lCQWNtVjBkWEp1Y3lCN1JuVnVZM1JwYjI1OUlIZHlZWEJ3WldRZ2NtVnRiM1JsSUdOaGJHeGlZV05yWEc0Z0lDQXFMMXh1SUNCZloyVnVVbVZ0YjNSbFEyRnNiR0poWTJzb2FXUXNJR0Z5WjA1MWJTd2dkMmwwYUZCeWIyMXBjMlVwSUh0Y2JpQWdJQ0IyWVhJZ2JXVWdQU0IwYUdsek8xeHVJQ0FnSUhaaGNpQnlaVzF2ZEdWRFlXeHNZbUZqYXp0Y2JpQWdJQ0JwWmlBb2QybDBhRkJ5YjIxcGMyVXBJSHRjYmlBZ0lDQWdJSEpsYlc5MFpVTmhiR3hpWVdOcklEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ1WlhjZ1VISnZiV2x6WlNnb2NtVnpiMngyWlN3Z2NtVnFaV04wS1NBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHRnlaM01nUFNCdFpTNWZkM0poY0NoQmNuSmhlUzV3Y205MGIzUjVjR1V1YzJ4cFkyVXVZMkZzYkNoaGNtZDFiV1Z1ZEhNcEtUdGNiaUFnSUNBZ0lDQWdJQ0IyWVhJZ2RISmhibk5tWlhKaFlteGxjeUE5SUdGeVozTXVZWEpuY3k1ZlgzUnlZVzV6Wm1WeVlXSnNaWE5mWHp0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZEhKaGJuTm1aWEpoWW14bGN5a2daR1ZzWlhSbElHRnlaM011WVhKbmN5NWZYM1J5WVc1elptVnlZV0pzWlhOZlh6dGNiaUFnSUNBZ0lDQWdJQ0J5WlhOdmJIWmxMbDlmYW1GcGJHVmtYM0JoYVhKelgxOGdQU0J5WldwbFkzUTdYRzRnSUNBZ0lDQWdJQ0FnY21WcVpXTjBMbDlmYW1GcGJHVmtYM0JoYVhKelgxOGdQU0J5WlhOdmJIWmxPMXh1SUNBZ0lDQWdJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCdFpTNWZZMjl1Ym1WamRHbHZiaTV6Wlc1a0tGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RIbHdaVG9nWENKallXeHNZbUZqYTF3aUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtPaUJwWkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdWRXMDZJR0Z5WjA1MWJTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhjbWR6T2lCaGNtZHpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzh2SUhCcFpDQTZJQ0J0WlM1cFpDeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQndjbTl0YVhObE9pQnRaUzVmZDNKaGNDaGJjbVZ6YjJ4MlpTd2djbVZxWldOMFhTbGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2ZTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2RISmhibk5tWlhKaFlteGxjMXh1SUNBZ0lDQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdJQ0I5SUdOaGRHTm9JQ2hsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WldwbFkzUW9YRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHQkdZV2xzWldRZ2RHOGdaWGhsWTNSMVpTQnlaVzF2ZEdVZ1kyRnNiR0poWTJzZ0tHbGtPaUFrZTJsa2ZTd2dZWEpuVG5WdE9pQWtlMkZ5WjA1MWJYMHBMbUJjYmlBZ0lDQWdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lIMDdYRzRnSUNBZ0lDQnlaWFIxY200Z2NtVnRiM1JsUTJGc2JHSmhZMnM3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lISmxiVzkwWlVOaGJHeGlZV05ySUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCaGNtZHpJRDBnYldVdVgzZHlZWEFvUVhKeVlYa3VjSEp2ZEc5MGVYQmxMbk5zYVdObExtTmhiR3dvWVhKbmRXMWxiblJ6S1NrN1hHNGdJQ0FnSUNBZ0lIWmhjaUIwY21GdWMyWmxjbUZpYkdWeklEMGdZWEpuY3k1aGNtZHpMbDlmZEhKaGJuTm1aWEpoWW14bGMxOWZPMXh1SUNBZ0lDQWdJQ0JwWmlBb2RISmhibk5tWlhKaFlteGxjeWtnWkdWc1pYUmxJR0Z5WjNNdVlYSm5jeTVmWDNSeVlXNXpabVZ5WVdKc1pYTmZYenRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzFsTGw5amIyNXVaV04wYVc5dUxuTmxibVFvWEc0Z0lDQWdJQ0FnSUNBZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEhsd1pUb2dYQ0pqWVd4c1ltRmphMXdpTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdhV1E2SUdsa0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnYm5WdE9pQmhjbWRPZFcwc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JoY21kek9pQmhjbWR6WEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJ3YVdRZ09pQWdiV1V1YVdSY2JpQWdJQ0FnSUNBZ0lDQjlMRnh1SUNBZ0lDQWdJQ0FnSUhSeVlXNXpabVZ5WVdKc1pYTmNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJSDA3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdjbVZ0YjNSbFEyRnNiR0poWTJzN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ0x5b3FYRzRnSUNBcUlGTmxibVJ6SUhSb1pTQnViM1JwWm1sallYUnBiMjRnYldWemMyRm5aU0JoYm1RZ1luSmxZV3R6SUhSb1pTQmpiMjV1WldOMGFXOXVYRzRnSUNBcUwxeHVJQ0JrYVhOamIyNXVaV04wS0NrZ2UxeHVJQ0FnSUhSb2FYTXVYMk52Ym01bFkzUnBiMjR1YzJWdVpDaDdJSFI1Y0dVNklGd2laR2x6WTI5dWJtVmpkRndpSUgwcE8xeHVJQ0FnSUhObGRGUnBiV1Z2ZFhRb2RHaHBjeTVmWTI5dWJtVmpkR2x2Ymk1a2FYTmpiMjV1WldOMExDQXlNREF3S1R0Y2JpQWdmVnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQlRaWFFnWVNCb1lXNWtiR1Z5SUhSdklHSmxJR05oYkd4bFpDQjNhR1Z1SUhKbFkyVnBkbVZrSUdFZ1pHbHpZMjl1Ym1WamRDQnRaWE56WVdkbFhHNGdJQ0FxSUdaeWIyMGdkR2hsSUhKbGJXOTBaU0J6YVhSbFhHNGdJQ0FxWEc0Z0lDQXFJRUJ3WVhKaGJTQjdSblZ1WTNScGIyNTlJR2hoYm1Sc1pYSmNiaUFnSUNvdlhHNGdJRzl1UkdselkyOXVibVZqZENob1lXNWtiR1Z5S1NCN1hHNGdJQ0FnZEdocGN5NWZaR2x6WTI5dWJtVmpkRWhoYm1Sc1pYSWdQU0JvWVc1a2JHVnlPMXh1SUNCOVhHNTlYRzVjYmk4cUtseHVJQ29nVW1WbVpYSmxibU5sVTNSdmNtVWdhWE1nWVNCemNHVmphV0ZzSUc5aWFtVmpkQ0IzYUdsamFDQnpkRzl5WlhNZ2IzUm9aWElnYjJKcVpXTjBjMXh1SUNvZ1lXNWtJSEJ5YjNacFpHVnpJSFJvWlNCeVpXWmxjbVZ1WTJWeklDaHVkVzFpWlhJcElHbHVjM1JsWVdRdUlGUm9hWE1nY21WbVpYSmxibU5sWEc0Z0tpQnRZWGtnZEdobGJpQmlaU0J6Wlc1MElHOTJaWElnWVNCcWMyOXVMV0poYzJWa0lHTnZiVzExYm1sallYUnBiMjRnWTJoaGJtNWxiQ0FvU1ZCRFhHNGdLaUIwYnlCaGJtOTBhR1Z5SUU1dlpHVXVhbk1nY0hKdlkyVnpjeUJ2Y2lCaElHMWxjM05oWjJVZ2RHOGdkR2hsSUZkdmNtdGxjaWt1SUU5MGFHVnlYRzRnS2lCemFYUmxJRzFoZVNCMGFHVnVJSEJ5YjNacFpHVWdkR2hsSUhKbFptVnlaVzVqWlNCcGJpQjBhR1VnY21WemNHOXVZMlVnYldWemMyRm5aVnh1SUNvZ2FXMXdiSGxwYm1jZ2RHaGxJR2RwZG1WdUlHOWlhbVZqZENCemFHOTFiR1FnWW1VZ1lXTjBhWFpoZEdWa0xseHVJQ3BjYmlBcUlGQnlhVzFoY25rZ2RYTmhaMlVnWm05eUlIUm9aU0JTWldabGNtVnVZMlZUZEc5eVpTQnBjeUJoSUhOMGIzSmhaMlVnWm05eUlIUm9aVnh1SUNvZ1kyRnNiR0poWTJ0ekxDQjNhR2xqYUNCMGFHVnlaV1p2Y21VZ2JXRnJaWE1nYVhRZ2NHOXpjMmxpYkdVZ2RHOGdhVzVwZEdsaGRHVWdZVnh1SUNvZ1kyRnNiR0poWTJzZ1pYaGxZM1YwYVc5dUlHSjVJSFJvWlNCdmNIQnZjMmwwWlNCemFYUmxJQ2gzYUdsamFDQnViM0p0WVd4c2VTQmpZVzV1YjNSY2JpQXFJR1JwY21WamRHeDVJR1Y0WldOMWRHVWdablZ1WTNScGIyNXpJRzkyWlhJZ2RHaGxJR052YlcxMWJtbGpZWFJwYjI0Z1kyaGhibTVsYkNrdVhHNGdLbHh1SUNvZ1JXRmphQ0J6ZEc5eVpXUWdiMkpxWldOMElHTmhiaUJ2Ym14NUlHSmxJR1psZEdOb1pXUWdiMjVqWlNCaGJtUWdhWE1nYm05MFhHNGdLaUJoZG1GcGJHRmliR1VnWm05eUlIUm9aU0J6WldOdmJtUWdkR2x0WlM0Z1JXRmphQ0J6ZEc5eVpXUWdiMkpxWldOMElHMTFjM1FnWW1WY2JpQXFJR1psZEdOb1pXUXNJSE5wYm1ObElHOTBhR1Z5ZDJselpTQnBkQ0IzYVd4c0lISmxiV0ZwYmlCemRHOXlaV1FnWm05eVpYWmxjaUJoYm1SY2JpQXFJR052Ym5OMWJXVWdiV1Z0YjNKNUxseHVJQ3BjYmlBcUlGTjBiM0psWkNCdlltcGxZM1FnYVc1a1pXTmxjeUJoY21VZ2MybHRjR3g1SUhSb1pTQnVkVzFpWlhKekxDQjNhR2xqYUNCaGNtVWdhRzkzWlhabGNseHVJQ29nY21Wc1pXRnpaV1FnWVd4dmJtY2dkMmwwYUNCMGFHVWdiMkpxWldOMGN5d2dZVzVrSUdGeVpTQnNZWFJsY2lCeVpYVnpaV1FnWVdkaGFXNGdLR2x1WEc0Z0tpQnZjbVJsY2lCMGJ5QndiM04wY0c5dVpTQjBhR1VnYjNabGNtWnNiM2NzSUhkb2FXTm9JSE5vYjNWc1pDQnViM1FnYkdsclpXeDVJR2hoY0hCbGJpeGNiaUFxSUdKMWRDQmhibmwzWVhrcExseHVJQ292WEc1amJHRnpjeUJTWldabGNtVnVZMlZUZEc5eVpTQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtDa2dlMXh1SUNBZ0lIUm9hWE11WDNOMGIzSmxJRDBnZTMwN0lDOHZJSE4wYjNKbFpDQnZZbXBsWTNSY2JpQWdJQ0IwYUdsekxsOXBibVJwWTJWeklEMGdXekJkT3lBdkx5QnpiV0ZzYkdWemRDQmhkbUZwYkdGaWJHVWdhVzVrYVdObGMxeHVJQ0FnSUhSb2FYTXVYM0psWVdSNVNHRnVaR3hsY2lBOUlHWjFibU4wYVc5dUtDa2dlMzA3WEc0Z0lDQWdkR2hwY3k1ZlluVnplVWhoYm1Sc1pYSWdQU0JtZFc1amRHbHZiaWdwSUh0OU8xeHVJQ0FnSUhSb2FYTXVYM0psWVdSNVNHRnVaR3hsY2lncE8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJR05oYkd3Z2FHRnVaR3hsY2lCM2FHVnVJSFJvWlNCemRHOXlaU0JwY3lCbGJYQjBlVnh1SUNBZ0tseHVJQ0FnS2lCQWNHRnlZVzBnZTBaVlRrTlVTVTlPZlNCcFpDQnZaaUJoSUdoaGJtUnNaWEpjYmlBZ0lDb3ZYRzRnSUc5dVVtVmhaSGtvY21WaFpIbElZVzVrYkdWeUtTQjdYRzRnSUNBZ2RHaHBjeTVmY21WaFpIbElZVzVrYkdWeUlEMGdjbVZoWkhsSVlXNWtiR1Z5SUh4OElHWjFibU4wYVc5dUtDa2dlMzA3WEc0Z0lIMWNibHh1SUNBdktpcGNiaUFnSUNvZ1kyRnNiQ0JvWVc1a2JHVnlJSGRvWlc0Z2RHaGxJSE4wYjNKbElHbHpJRzV2ZENCbGJYQjBlVnh1SUNBZ0tseHVJQ0FnS2lCQWNHRnlZVzBnZTBaVlRrTlVTVTlPZlNCcFpDQnZaaUJoSUdoaGJtUnNaWEpjYmlBZ0lDb3ZYRzRnSUc5dVFuVnplU2hpZFhONVNHRnVaR3hsY2lrZ2UxeHVJQ0FnSUhSb2FYTXVYMkoxYzNsSVlXNWtiR1Z5SUQwZ1luVnplVWhoYm1Sc1pYSWdmSHdnWm5WdVkzUnBiMjRvS1NCN2ZUdGNiaUFnZlZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJuWlhRZ2RHaGxJR3hsYm1kMGFDQnZaaUIwYUdVZ2MzUnZjbVZjYmlBZ0lDcGNiaUFnSUNvdlhHNGdJR2RsZEZOMFlXTnJLQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQlBZbXBsWTNRdWEyVjVjeWgwYUdsekxsOXpkRzl5WlNrdWJHVnVaM1JvTzF4dUlDQjlYRzVjYmlBZ0x5b3FYRzRnSUNBcUlFQm1kVzVqZEdsdmJpQmZaMlZ1U1dRb0tTQm5aVzVsY21GMFpYTWdkR2hsSUc1bGR5QnlaV1psY21WdVkyVWdhV1JjYmlBZ0lDcGNiaUFnSUNvZ1FISmxkSFZ5Ym5NZ2UwNTFiV0psY24wZ2MyMWhiR3hsYzNRZ1lYWmhhV3hoWW14bElHbGtJR0Z1WkNCeVpYTmxjblpsY3lCcGRGeHVJQ0FnS2k5Y2JpQWdYMmRsYmtsa0tDa2dlMXh1SUNBZ0lIWmhjaUJwWkR0Y2JpQWdJQ0JwWmlBb2RHaHBjeTVmYVc1a2FXTmxjeTVzWlc1bmRHZ2dQVDA5SURFcElIdGNiaUFnSUNBZ0lHbGtJRDBnZEdocGN5NWZhVzVrYVdObGMxc3dYU3NyTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnBaQ0E5SUhSb2FYTXVYMmx1WkdsalpYTXVjMmhwWm5Rb0tUdGNiaUFnSUNCOVhHNWNiaUFnSUNCeVpYUjFjbTRnYVdRN1hHNGdJSDFjYmx4dUlDQXZLaXBjYmlBZ0lDb2dVbVZzWldGelpYTWdkR2hsSUdkcGRtVnVJSEpsWm1WeVpXNWpaU0JwWkNCemJ5QjBhR0YwSUdsMElIZHBiR3dnWW1VZ1lYWmhhV3hoWW14bElHSjVYRzRnSUNBcUlHRnViM1JvWlhJZ2IySnFaV04wSUhOMGIzSmxaRnh1SUNBZ0tseHVJQ0FnS2lCQWNHRnlZVzBnZTA1MWJXSmxjbjBnYVdRZ2RHOGdjbVZzWldGelpWeHVJQ0FnS2k5Y2JpQWdYM0psYkdWaGMyVkpaQ2hwWkNrZ2UxeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2RHaHBjeTVmYVc1a2FXTmxjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ2FXWWdLR2xrSUR3Z2RHaHBjeTVmYVc1a2FXTmxjMXRwWFNrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TGw5cGJtUnBZMlZ6TG5Od2JHbGpaU2hwTENBd0xDQnBaQ2s3WEc0Z0lDQWdJQ0FnSUdKeVpXRnJPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJR05zWldGdWFXNW5MWFZ3SUhSb1pTQnpaWEYxWlc1alpTQjBZV2xzWEc0Z0lDQWdabTl5SUNocElEMGdkR2hwY3k1ZmFXNWthV05sY3k1c1pXNW5kR2dnTFNBeE95QnBJRDQ5SURBN0lHa3RMU2tnZTF4dUlDQWdJQ0FnYVdZZ0tIUm9hWE11WDJsdVpHbGpaWE5iYVYwZ0xTQXhJRDA5UFNCMGFHbHpMbDlwYm1ScFkyVnpXMmtnTFNBeFhTa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxsOXBibVJwWTJWekxuQnZjQ2dwTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRk4wYjNKbGN5QjBhR1VnWjJsMlpXNGdiMkpxWldOMElHRnVaQ0J5WlhSMWNtNXpJSFJvWlNCeVpXWmxjbTVqWlNCcFpDQnBibk4wWldGa1hHNGdJQ0FxWEc0Z0lDQXFJRUJ3WVhKaGJTQjdUMkpxWldOMGZTQnZZbW9nZEc4Z2MzUnZjbVZjYmlBZ0lDcGNiaUFnSUNvZ1FISmxkSFZ5Ym5NZ2UwNTFiV0psY24wZ2NtVm1aWEpsYm1ObElHbGtJRzltSUhSb1pTQnpkRzl5WldRZ2IySnFaV04wWEc0Z0lDQXFMMXh1SUNCd2RYUW9iMkpxS1NCN1hHNGdJQ0FnYVdZZ0tIUm9hWE11WDJKMWMzbElZVzVrYkdWeUlDWW1JRTlpYW1WamRDNXJaWGx6S0hSb2FYTXVYM04wYjNKbEtTNXNaVzVuZEdnZ1BUMDlJREFwSUh0Y2JpQWdJQ0FnSUhSb2FYTXVYMkoxYzNsSVlXNWtiR1Z5S0NrN1hHNGdJQ0FnZlZ4dUlDQWdJSFpoY2lCcFpDQTlJSFJvYVhNdVgyZGxia2xrS0NrN1hHNGdJQ0FnZEdocGN5NWZjM1J2Y21WYmFXUmRJRDBnYjJKcU8xeHVJQ0FnSUhKbGRIVnliaUJwWkR0Y2JpQWdmVnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQlNaWFJ5YVdWMlpYTWdjSEpsZG1sdmRYTnNlU0J6ZEc5eVpXUWdiMkpxWldOMElHRnVaQ0J5Wld4bFlYTmxjeUJwZEhNZ2NtVm1aWEpsYm1ObFhHNGdJQ0FxWEc0Z0lDQXFJRUJ3WVhKaGJTQjdUblZ0WW1WeWZTQnBaQ0J2WmlCaGJpQnZZbXBsWTNRZ2RHOGdjbVYwY21sbGRtVmNiaUFnSUNvdlhHNGdJR1psZEdOb0tHbGtLU0I3WEc0Z0lDQWdkbUZ5SUc5aWFpQTlJSFJvYVhNdVgzTjBiM0psVzJsa1hUdGNiaUFnSUNCcFppQW9iMkpxSUNZbUlDRnZZbW91WDE5eVpXMXZkR1ZmYldWMGFHOWtLU0I3WEc0Z0lDQWdJQ0JrWld4bGRHVWdkR2hwY3k1ZmMzUnZjbVZiYVdSZE8xeHVJQ0FnSUNBZ2RHaHBjeTVmY21Wc1pXRnpaVWxrS0dsa0tUdGNiaUFnSUNBZ0lHbG1JQ2gwYUdsekxsOXlaV0ZrZVVoaGJtUnNaWElnSmlZZ1QySnFaV04wTG10bGVYTW9kR2hwY3k1ZmMzUnZjbVVwTG14bGJtZDBhQ0E5UFQwZ01Da2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxsOXlaV0ZrZVVoaGJtUnNaWElvS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0c5aWFpQW1KaUJ2WW1vdVgxOXFZV2xzWldSZmNHRnBjbk5mWHlrZ2UxeHVJQ0FnSUNBZ1kyOXVjM1FnWDJsa0lEMGdaMlYwUzJWNVFubFdZV3gxWlNoMGFHbHpMbDl6ZEc5eVpTd2diMkpxTGw5ZmFtRnBiR1ZrWDNCaGFYSnpYMThwTzF4dUlDQWdJQ0FnZEdocGN5NW1aWFJqYUNoZmFXUXBPMXh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnYjJKcU8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRkpsZEhKcFpYWmxjeUJ3Y21WMmFXOTFjMng1SUhOMGIzSmxaQ0J2WW1wbFkzUmNiaUFnSUNwY2JpQWdJQ29nUUhCaGNtRnRJSHRPZFcxaVpYSjlJR2xrSUc5bUlHRnVJRzlpYW1WamRDQjBieUJ5WlhSeWFXVjJaVnh1SUNBZ0tpOWNiaUFnTHk4Z2NtVjBjbWxsZG1Vb2FXUXBJSHRjYmlBZ0x5OGdJQ0FnSUhaaGNpQnZZbW9nUFNCMGFHbHpMbDl6ZEc5eVpWdHBaRjA3WEc0Z0lDOHZJQ0FnSUNCeVpYUjFjbTRnYjJKcU8xeHVJQ0F2THlCOVhHNTlYRzRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN096czdRVUZKUVR0QlFVVkJPMEZCUlVFN1FVRkRRVHRCUVVkQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3T3pzN096czdPenM3UVVGUlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVWQk96czdPenM3T3p0QlFVMUJPMEZCUTBFN1FVRkRRVHRCUVVWQk96czdPenM3T3pzN1FVRlJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3T3pzN096czdPenM3TzBGQlUwRTdRVUZEUVR0QlFVTkJPMEZCUlVFN096czdPMEZCUjBFN1FVRkRRVHRCUVVOQk8wRkJSVUU3T3pzN096czdPMEZCVFVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVVZCT3pzN096czdRVUZKUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCZEVKQk8wRkJlVUpCTzBGQlEwRTdRVUZHUVR0QlFVdEJPMEZCUTBFN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlJVRTdPenRCUVVkQk8wRkJRMEU3UVVGRFFUdEJRVVJCTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJSMEU3UVVGRFFUdEJRVWRCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUzBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlMwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRVUU3UVVGNlIwRTdRVUV5UjBFN1FVRkZRVHM3T3pzN08wRkJTVUU3UVVGRFFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVWxCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGS1FUdEJRVTFCTzBGQlJVRTdPenM3T3pzN1FVRkxRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJSVUU3T3pzN096czdPenM3T3p0QlFWVkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJSVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVV4Qk8wRkJVMEU3UVVGRFFUdEJRVU5CTzBGQlNVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRlFUczdPenM3TzBGQlNVRTdRVUZEUVR0QlFVRkJPMEZCUVVFN1FVRkRRVHRCUVVWQk96czdPenM3T3pzN096dEJRVlZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVcEJPMEZCVFVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkxRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlMwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVVZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVaQk8wRkJTVUU3UVVGRFFUdEJRVTVCTzBGQlUwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGSFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCU2tFN1FVRk5RVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVoQk8wRkJTMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVaEJPMEZCUzBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGSlFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZLUVR0QlFVMUJPMEZCUTBFN1FVRkRRVHRCUVVsQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVXBCTzBGQlRVRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVaEJPMEZCUzBFN1FVRkZRVHRCUVZKQk8wRkJiVUpCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVOQk8wRkJSVUU3UVVGU1FUdEJRVlZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCU1VFN1FVRkRRVHRCUVVsQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJTVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlIwRTdRVUZEUVR0QlFVbEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVZEJPMEZCUzBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVXRCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkZRVHM3T3pzN096czdPenM3T3p0QlFWZEJPMEZCUTBFN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUlVFN096czdPenM3T3pzN096czdPenRCUVdGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlRrRTdRVUZWUVR0QlFVTkJPMEZCUjBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVeEJPMEZCVTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVVZCT3pzN096dEJRVWRCTzBGQlEwRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJSVUU3T3pzN096czdPMEZCVFVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGdU1VSkJPMEZCY1RGQ1FUczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzBGQmRVSkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVWQk96czdPenM3TzBGQlMwRTdRVUZEUVR0QlFVTkJPMEZCUlVFN096czdPenM3UVVGTFFUdEJRVU5CTzBGQlEwRTdRVUZGUVRzN096czdPMEZCU1VFN1FVRkRRVHRCUVVOQk8wRkJSVUU3T3pzN096czdRVUZMUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUlVFN096czdPenM3TzBGQlRVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlJVRTdPenM3T3pzN096dEJRVTlCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlJVRTdPenM3T3pzN1FVRkxRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRlFUczdPenM3UVVGTFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRXhTRUVpTENKemIzVnlZMlZTYjI5MElqb2lJbjA9XFxcXG4vLyMgc291cmNlVVJMPXdlYnBhY2staW50ZXJuYWw6Ly8vLi9zcmMvcnBjLmpzXFxcXG5cXFwiKTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvdXRpbHMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9zcmMvdXRpbHMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHJhbmRJZCwgZHR5cGVUb1R5cGVkQXJyYXksIHR5cGVkQXJyYXlUb0R0eXBlLCBjYWNoZVJlcXVpcmVtZW50cywgc2V0dXBTZXJ2aWNlV29ya2VyLCB1cmxKb2luICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5ldmFsKFxcXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwicmFuZElkXFxcXFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFuZElkOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJkdHlwZVRvVHlwZWRBcnJheVxcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGR0eXBlVG9UeXBlZEFycmF5OyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJ0eXBlZEFycmF5VG9EdHlwZVxcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHR5cGVkQXJyYXlUb0R0eXBlOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJjYWNoZVJlcXVpcmVtZW50c1xcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhY2hlUmVxdWlyZW1lbnRzOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJzZXR1cFNlcnZpY2VXb3JrZXJcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXR1cFNlcnZpY2VXb3JrZXI7IH0pO1xcXFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFxcXFxcInVybEpvaW5cXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1cmxKb2luOyB9KTtcXFxcbmZ1bmN0aW9uIHJhbmRJZCgpIHtcXFxcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCAxMCk7XFxcXG59XFxcXG5jb25zdCBkdHlwZVRvVHlwZWRBcnJheSA9IHtcXFxcbiAgaW50ODogXFxcXFxcXCJJbnQ4QXJyYXlcXFxcXFxcIixcXFxcbiAgaW50MTY6IFxcXFxcXFwiSW50MTZBcnJheVxcXFxcXFwiLFxcXFxuICBpbnQzMjogXFxcXFxcXCJJbnQzMkFycmF5XFxcXFxcXCIsXFxcXG4gIHVpbnQ4OiBcXFxcXFxcIlVpbnQ4QXJyYXlcXFxcXFxcIixcXFxcbiAgdWludDE2OiBcXFxcXFxcIlVpbnQxNkFycmF5XFxcXFxcXCIsXFxcXG4gIHVpbnQzMjogXFxcXFxcXCJVaW50MzJBcnJheVxcXFxcXFwiLFxcXFxuICBmbG9hdDMyOiBcXFxcXFxcIkZsb2F0MzJBcnJheVxcXFxcXFwiLFxcXFxuICBmbG9hdDY0OiBcXFxcXFxcIkZsb2F0NjRBcnJheVxcXFxcXFwiLFxcXFxuICBhcnJheTogXFxcXFxcXCJBcnJheVxcXFxcXFwiXFxcXG59O1xcXFxuY29uc3QgdHlwZWRBcnJheVRvRHR5cGUgPSB7XFxcXG4gIEludDhBcnJheTogXFxcXFxcXCJpbnQ4XFxcXFxcXCIsXFxcXG4gIEludDE2QXJyYXk6IFxcXFxcXFwiaW50MTZcXFxcXFxcIixcXFxcbiAgSW50MzJBcnJheTogXFxcXFxcXCJpbnQzMlxcXFxcXFwiLFxcXFxuICBVaW50OEFycmF5OiBcXFxcXFxcInVpbnQ4XFxcXFxcXCIsXFxcXG4gIFVpbnQxNkFycmF5OiBcXFxcXFxcInVpbnQxNlxcXFxcXFwiLFxcXFxuICBVaW50MzJBcnJheTogXFxcXFxcXCJ1aW50MzJcXFxcXFxcIixcXFxcbiAgRmxvYXQzMkFycmF5OiBcXFxcXFxcImZsb2F0MzJcXFxcXFxcIixcXFxcbiAgRmxvYXQ2NEFycmF5OiBcXFxcXFxcImZsb2F0NjRcXFxcXFxcIixcXFxcbiAgQXJyYXk6IFxcXFxcXFwiYXJyYXlcXFxcXFxcIlxcXFxufTtcXFxcblxcXFxuZnVuY3Rpb24gY2FjaGVVcmxJblNlcnZpY2VXb3JrZXIodXJsKSB7XFxcXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XFxcXG4gICAgY29uc3QgbWVzc2FnZSA9IHtcXFxcbiAgICAgIGNvbW1hbmQ6IFxcXFxcXFwiYWRkXFxcXFxcXCIsXFxcXG4gICAgICB1cmw6IHVybFxcXFxuICAgIH07XFxcXG5cXFxcbiAgICBpZiAoIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyIHx8ICFuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3Rlcikge1xcXFxuICAgICAgcmVqZWN0KFxcXFxcXFwiU2VydmljZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZC5cXFxcXFxcIik7XFxcXG4gICAgICByZXR1cm47XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcXFxcblxcXFxuICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xcXFxuICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lcnJvcikge1xcXFxuICAgICAgICByZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5yZXN1bHQpO1xcXFxuICAgICAgfVxcXFxuICAgIH07XFxcXG5cXFxcbiAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xcXFxuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlci5wb3N0TWVzc2FnZShtZXNzYWdlLCBbbWVzc2FnZUNoYW5uZWwucG9ydDJdKTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgcmVqZWN0KFxcXFxcXFwiU2VydmljZSB3b3JrZXIgY29udHJvbGxlciBpcyBub3QgYXZhaWxhYmxlXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgfSk7XFxcXG59XFxcXG5cXFxcbmFzeW5jIGZ1bmN0aW9uIGNhY2hlUmVxdWlyZW1lbnRzKHJlcXVpcmVtZW50cykge1xcXFxuICBpZiAocmVxdWlyZW1lbnRzICYmIHJlcXVpcmVtZW50cy5sZW5ndGggPiAwKSB7XFxcXG4gICAgZm9yIChsZXQgcmVxIG9mIHJlcXVpcmVtZW50cykge1xcXFxuICAgICAgLy9yZW1vdmUgcHJlZml4XFxcXG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXFxcXFxcXCJqczpcXFxcXFxcIikpIHJlcSA9IHJlcS5zbGljZSgzKTtcXFxcbiAgICAgIGlmIChyZXEuc3RhcnRzV2l0aChcXFxcXFxcImNzczpcXFxcXFxcIikpIHJlcSA9IHJlcS5zbGljZSg0KTtcXFxcbiAgICAgIGlmIChyZXEuc3RhcnRzV2l0aChcXFxcXFxcImNhY2hlOlxcXFxcXFwiKSkgcmVxID0gcmVxLnNsaWNlKDYpO1xcXFxuICAgICAgaWYgKCFyZXEuc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikpIGNvbnRpbnVlO1xcXFxuICAgICAgYXdhaXQgY2FjaGVVcmxJblNlcnZpY2VXb3JrZXIocmVxKS5jYXRjaChlID0+IHtcXFxcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcXFxcbiAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgfVxcXFxufVxcXFxuZnVuY3Rpb24gc2V0dXBTZXJ2aWNlV29ya2VyKHRhcmdldE9yaWdpbiwgY2FjaGVDYWxsYmFjaykge1xcXFxuICAvLyByZWdpc3RlciBzZXJ2aWNlIHdvcmtlciBmb3Igb2ZmbGluZSBhY2Nlc3NcXFxcbiAgaWYgKFxcXFxcXFwic2VydmljZVdvcmtlclxcXFxcXFwiIGluIG5hdmlnYXRvcikge1xcXFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXFxcXFwibG9hZFxcXFxcXFwiLCBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3RlcihcXFxcXFxcIi9wbHVnaW4tc2VydmljZS13b3JrZXIuanNcXFxcXFxcIikudGhlbihmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XFxcXG4gICAgICAgIC8vIFJlZ2lzdHJhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxcXFxuICAgICAgICBjb25zb2xlLmxvZyhcXFxcXFxcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwgd2l0aCBzY29wZTogXFxcXFxcXCIsIHJlZ2lzdHJhdGlvbi5zY29wZSk7XFxcXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XFxcXG4gICAgICAgIC8vIHJlZ2lzdHJhdGlvbiBmYWlsZWQgOihcXFxcbiAgICAgICAgY29uc29sZS5sb2coXFxcXFxcXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQ6IFxcXFxcXFwiLCBlcnIpO1xcXFxuICAgICAgfSk7XFxcXG4gICAgICB0YXJnZXRPcmlnaW4gPSB0YXJnZXRPcmlnaW4gfHwgXFxcXFxcXCIqXFxcXFxcXCI7XFxcXG4gICAgICBjYWNoZUNhbGxiYWNrID0gY2FjaGVDYWxsYmFjayB8fCBjYWNoZVJlcXVpcmVtZW50cztcXFxcblxcXFxuICAgICAgaWYgKGNhY2hlQ2FsbGJhY2sgJiYgdHlwZW9mIGNhY2hlQ2FsbGJhY2sgIT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJjb25maWcuY2FjaGVfcmVxdWlyZW1lbnRzIG11c3QgYmUgYSBmdW5jdGlvblxcXFxcXFwiKTtcXFxcbiAgICAgIH1cXFxcblxcXFxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXFxcXFxcXCJtZXNzYWdlXFxcXFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxcXG4gICAgICAgIGlmICh0YXJnZXRPcmlnaW4gPT09IFxcXFxcXFwiKlxcXFxcXFwiIHx8IGUub3JpZ2luID09PSB0YXJnZXRPcmlnaW4pIHtcXFxcbiAgICAgICAgICBjb25zdCBtID0gZS5kYXRhO1xcXFxuXFxcXG4gICAgICAgICAgaWYgKG0udHlwZSA9PT0gXFxcXFxcXCJjYWNoZVJlcXVpcmVtZW50c1xcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBjYWNoZUNhbGxiYWNrKG0ucmVxdWlyZW1lbnRzKTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH0pO1xcXFxuICAgIH0pO1xcXFxuICB9XFxcXG59IC8vI1NvdXJjZSBodHRwczovL2JpdC5seS8ybmVXZkoyXFxcXG5cXFxcbmZ1bmN0aW9uIHVybEpvaW4oLi4uYXJncykge1xcXFxuICByZXR1cm4gYXJncy5qb2luKFxcXFxcXFwiL1xcXFxcXFwiKS5yZXBsYWNlKC9bXFxcXFxcXFwvXSsvZywgXFxcXFxcXCIvXFxcXFxcXCIpLnJlcGxhY2UoL14oLispOlxcXFxcXFxcLy8sIFxcXFxcXFwiJDE6Ly9cXFxcXFxcIikucmVwbGFjZSgvXmZpbGU6LywgXFxcXFxcXCJmaWxlOi9cXFxcXFxcIikucmVwbGFjZSgvXFxcXFxcXFwvKFxcXFxcXFxcP3wmfCNbXiFdKS9nLCBcXFxcXFxcIiQxXFxcXFxcXCIpLnJlcGxhY2UoL1xcXFxcXFxcPy9nLCBcXFxcXFxcIiZcXFxcXFxcIikucmVwbGFjZShcXFxcXFxcIiZcXFxcXFxcIiwgXFxcXFxcXCI/XFxcXFxcXCIpO1xcXFxufS8vIyBzb3VyY2VVUkw9W21vZHVsZV1cXFxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pTGk5emNtTXZkWFJwYkhNdWFuTXVhbk1pTENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OXBiV3B2ZVZKUVF5OXpjbU12ZFhScGJITXVhbk0vWVRNd05DSmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpsZUhCdmNuUWdablZ1WTNScGIyNGdjbUZ1WkVsa0tDa2dlMXh1SUNCeVpYUjFjbTRnVFdGMGFDNXlZVzVrYjIwb0tWeHVJQ0FnSUM1MGIxTjBjbWx1Wnlnek5pbGNiaUFnSUNBdWMzVmljM1J5S0RJc0lERXdLVHRjYm4xY2JseHVaWGh3YjNKMElHTnZibk4wSUdSMGVYQmxWRzlVZVhCbFpFRnljbUY1SUQwZ2UxeHVJQ0JwYm5RNE9pQmNJa2x1ZERoQmNuSmhlVndpTEZ4dUlDQnBiblF4TmpvZ1hDSkpiblF4TmtGeWNtRjVYQ0lzWEc0Z0lHbHVkRE15T2lCY0lrbHVkRE15UVhKeVlYbGNJaXhjYmlBZ2RXbHVkRGc2SUZ3aVZXbHVkRGhCY25KaGVWd2lMRnh1SUNCMWFXNTBNVFk2SUZ3aVZXbHVkREUyUVhKeVlYbGNJaXhjYmlBZ2RXbHVkRE15T2lCY0lsVnBiblF6TWtGeWNtRjVYQ0lzWEc0Z0lHWnNiMkYwTXpJNklGd2lSbXh2WVhRek1rRnljbUY1WENJc1hHNGdJR1pzYjJGME5qUTZJRndpUm14dllYUTJORUZ5Y21GNVhDSXNYRzRnSUdGeWNtRjVPaUJjSWtGeWNtRjVYQ0pjYm4wN1hHNWxlSEJ2Y25RZ1kyOXVjM1FnZEhsd1pXUkJjbkpoZVZSdlJIUjVjR1VnUFNCN1hHNGdJRWx1ZERoQmNuSmhlVG9nWENKcGJuUTRYQ0lzWEc0Z0lFbHVkREUyUVhKeVlYazZJRndpYVc1ME1UWmNJaXhjYmlBZ1NXNTBNekpCY25KaGVUb2dYQ0pwYm5Rek1sd2lMRnh1SUNCVmFXNTBPRUZ5Y21GNU9pQmNJblZwYm5RNFhDSXNYRzRnSUZWcGJuUXhOa0Z5Y21GNU9pQmNJblZwYm5ReE5sd2lMRnh1SUNCVmFXNTBNekpCY25KaGVUb2dYQ0oxYVc1ME16SmNJaXhjYmlBZ1JteHZZWFF6TWtGeWNtRjVPaUJjSW1ac2IyRjBNekpjSWl4Y2JpQWdSbXh2WVhRMk5FRnljbUY1T2lCY0ltWnNiMkYwTmpSY0lpeGNiaUFnUVhKeVlYazZJRndpWVhKeVlYbGNJbHh1ZlR0Y2JseHVablZ1WTNScGIyNGdZMkZqYUdWVmNteEpibE5sY25acFkyVlhiM0pyWlhJb2RYSnNLU0I3WEc0Z0lISmxkSFZ5YmlCdVpYY2dVSEp2YldselpTaG1kVzVqZEdsdmJpaHlaWE52YkhabExDQnlaV3BsWTNRcElIdGNiaUFnSUNCamIyNXpkQ0J0WlhOellXZGxJRDBnZTF4dUlDQWdJQ0FnWTI5dGJXRnVaRG9nWENKaFpHUmNJaXhjYmlBZ0lDQWdJSFZ5YkRvZ2RYSnNYRzRnSUNBZ2ZUdGNiaUFnSUNCcFppQW9JVzVoZG1sbllYUnZjaTV6WlhKMmFXTmxWMjl5YTJWeUlIeDhJQ0Z1WVhacFoyRjBiM0l1YzJWeWRtbGpaVmR2Y210bGNpNXlaV2RwYzNSbGNpa2dlMXh1SUNBZ0lDQWdjbVZxWldOMEtGd2lVMlZ5ZG1salpTQjNiM0pyWlhJZ2FYTWdibTkwSUhOMWNIQnZjblJsWkM1Y0lpazdYRzRnSUNBZ0lDQnlaWFIxY200N1hHNGdJQ0FnZlZ4dUlDQWdJR052Ym5OMElHMWxjM05oWjJWRGFHRnVibVZzSUQwZ2JtVjNJRTFsYzNOaFoyVkRhR0Z1Ym1Wc0tDazdYRzRnSUNBZ2JXVnpjMkZuWlVOb1lXNXVaV3d1Y0c5eWRERXViMjV0WlhOellXZGxJRDBnWm5WdVkzUnBiMjRvWlhabGJuUXBJSHRjYmlBZ0lDQWdJR2xtSUNobGRtVnVkQzVrWVhSaElDWW1JR1YyWlc1MExtUmhkR0V1WlhKeWIzSXBJSHRjYmlBZ0lDQWdJQ0FnY21WcVpXTjBLR1YyWlc1MExtUmhkR0V1WlhKeWIzSXBPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdjbVZ6YjJ4MlpTaGxkbVZ1ZEM1a1lYUmhJQ1ltSUdWMlpXNTBMbVJoZEdFdWNtVnpkV3gwS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5TzF4dVhHNGdJQ0FnYVdZZ0tHNWhkbWxuWVhSdmNpNXpaWEoyYVdObFYyOXlhMlZ5SUNZbUlHNWhkbWxuWVhSdmNpNXpaWEoyYVdObFYyOXlhMlZ5TG1OdmJuUnliMnhzWlhJcElIdGNiaUFnSUNBZ0lHNWhkbWxuWVhSdmNpNXpaWEoyYVdObFYyOXlhMlZ5TG1OdmJuUnliMnhzWlhJdWNHOXpkRTFsYzNOaFoyVW9iV1Z6YzJGblpTd2dXMXh1SUNBZ0lDQWdJQ0J0WlhOellXZGxRMmhoYm01bGJDNXdiM0owTWx4dUlDQWdJQ0FnWFNrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSEpsYW1WamRDaGNJbE5sY25acFkyVWdkMjl5YTJWeUlHTnZiblJ5YjJ4c1pYSWdhWE1nYm05MElHRjJZV2xzWVdKc1pWd2lLVHRjYmlBZ0lDQjlYRzRnSUgwcE8xeHVmVnh1WEc1bGVIQnZjblFnWVhONWJtTWdablZ1WTNScGIyNGdZMkZqYUdWU1pYRjFhWEpsYldWdWRITW9jbVZ4ZFdseVpXMWxiblJ6S1NCN1hHNGdJR2xtSUNoeVpYRjFhWEpsYldWdWRITWdKaVlnY21WeGRXbHlaVzFsYm5SekxteGxibWQwYUNBK0lEQXBJSHRjYmlBZ0lDQm1iM0lnS0d4bGRDQnlaWEVnYjJZZ2NtVnhkV2x5WlcxbGJuUnpLU0I3WEc0Z0lDQWdJQ0F2TDNKbGJXOTJaU0J3Y21WbWFYaGNiaUFnSUNBZ0lHbG1JQ2h5WlhFdWMzUmhjblJ6VjJsMGFDaGNJbXB6T2x3aUtTa2djbVZ4SUQwZ2NtVnhMbk5zYVdObEtETXBPMXh1SUNBZ0lDQWdhV1lnS0hKbGNTNXpkR0Z5ZEhOWGFYUm9LRndpWTNOek9sd2lLU2tnY21WeElEMGdjbVZ4TG5Oc2FXTmxLRFFwTzF4dUlDQWdJQ0FnYVdZZ0tISmxjUzV6ZEdGeWRITlhhWFJvS0Z3aVkyRmphR1U2WENJcEtTQnlaWEVnUFNCeVpYRXVjMnhwWTJVb05pazdYRzRnSUNBZ0lDQnBaaUFvSVhKbGNTNXpkR0Z5ZEhOWGFYUm9LRndpYUhSMGNGd2lLU2tnWTI5dWRHbHVkV1U3WEc1Y2JpQWdJQ0FnSUdGM1lXbDBJR05oWTJobFZYSnNTVzVUWlhKMmFXTmxWMjl5YTJWeUtISmxjU2t1WTJGMFkyZ29aU0E5UGlCN1hHNGdJQ0FnSUNBZ0lHTnZibk52YkdVdVpYSnliM0lvWlNrN1hHNGdJQ0FnSUNCOUtUdGNiaUFnSUNCOVhHNGdJSDFjYm4xY2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlITmxkSFZ3VTJWeWRtbGpaVmR2Y210bGNpaDBZWEpuWlhSUGNtbG5hVzRzSUdOaFkyaGxRMkZzYkdKaFkyc3BJSHRjYmlBZ0x5OGdjbVZuYVhOMFpYSWdjMlZ5ZG1salpTQjNiM0pyWlhJZ1ptOXlJRzltWm14cGJtVWdZV05qWlhOelhHNGdJR2xtSUNoY0luTmxjblpwWTJWWGIzSnJaWEpjSWlCcGJpQnVZWFpwWjJGMGIzSXBJSHRjYmlBZ0lDQjNhVzVrYjNjdVlXUmtSWFpsYm5STWFYTjBaVzVsY2loY0lteHZZV1JjSWl3Z1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQnVZWFpwWjJGMGIzSXVjMlZ5ZG1salpWZHZjbXRsY2k1eVpXZHBjM1JsY2loY0lpOXdiSFZuYVc0dGMyVnlkbWxqWlMxM2IzSnJaWEl1YW5OY0lpa3VkR2hsYmloY2JpQWdJQ0FnSUNBZ1puVnVZM1JwYjI0b2NtVm5hWE4wY21GMGFXOXVLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0x5OGdVbVZuYVhOMGNtRjBhVzl1SUhkaGN5QnpkV05qWlhOelpuVnNYRzRnSUNBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVzYjJjb1hHNGdJQ0FnSUNBZ0lDQWdJQ0JjSWxObGNuWnBZMlZYYjNKclpYSWdjbVZuYVhOMGNtRjBhVzl1SUhOMVkyTmxjM05tZFd3Z2QybDBhQ0J6WTI5d1pUb2dYQ0lzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaV2RwYzNSeVlYUnBiMjR1YzJOdmNHVmNiaUFnSUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNBZ0lDQm1kVzVqZEdsdmJpaGxjbklwSUh0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJ5WldkcGMzUnlZWFJwYjI0Z1ptRnBiR1ZrSURvb1hHNGdJQ0FnSUNBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvWENKVFpYSjJhV05sVjI5eWEyVnlJSEpsWjJsemRISmhkR2x2YmlCbVlXbHNaV1E2SUZ3aUxDQmxjbklwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ2RHRnlaMlYwVDNKcFoybHVJRDBnZEdGeVoyVjBUM0pwWjJsdUlIeDhJRndpS2x3aU8xeHVJQ0FnSUNBZ1kyRmphR1ZEWVd4c1ltRmpheUE5SUdOaFkyaGxRMkZzYkdKaFkyc2dmSHdnWTJGamFHVlNaWEYxYVhKbGJXVnVkSE03WEc0Z0lDQWdJQ0JwWmlBb1kyRmphR1ZEWVd4c1ltRmpheUFtSmlCMGVYQmxiMllnWTJGamFHVkRZV3hzWW1GamF5QWhQVDBnWENKbWRXNWpkR2x2Ymx3aUtTQjdYRzRnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpaGNJbU52Ym1acFp5NWpZV05vWlY5eVpYRjFhWEpsYldWdWRITWdiWFZ6ZENCaVpTQmhJR1oxYm1OMGFXOXVYQ0lwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnZDJsdVpHOTNMbUZrWkVWMlpXNTBUR2x6ZEdWdVpYSW9YQ0p0WlhOellXZGxYQ0lzSUdaMWJtTjBhVzl1S0dVcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0hSaGNtZGxkRTl5YVdkcGJpQTlQVDBnWENJcVhDSWdmSHdnWlM1dmNtbG5hVzRnUFQwOUlIUmhjbWRsZEU5eWFXZHBiaWtnZTF4dUlDQWdJQ0FnSUNBZ0lHTnZibk4wSUcwZ1BTQmxMbVJoZEdFN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0cwdWRIbHdaU0E5UFQwZ1hDSmpZV05vWlZKbGNYVnBjbVZ0Wlc1MGMxd2lLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpZV05vWlVOaGJHeGlZV05yS0cwdWNtVnhkV2x5WlcxbGJuUnpLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMHBPMXh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlYRzVjYmk4dkkxTnZkWEpqWlNCb2RIUndjem92TDJKcGRDNXNlUzh5Ym1WWFprb3lYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdkWEpzU205cGJpZ3VMaTVoY21kektTQjdYRzRnSUhKbGRIVnliaUJoY21kelhHNGdJQ0FnTG1wdmFXNG9YQ0l2WENJcFhHNGdJQ0FnTG5KbGNHeGhZMlVvTDF0Y1hDOWRLeTluTENCY0lpOWNJaWxjYmlBZ0lDQXVjbVZ3YkdGalpTZ3ZYaWd1S3lrNlhGd3ZMeXdnWENJa01Ub3ZMMXdpS1Z4dUlDQWdJQzV5WlhCc1lXTmxLQzllWm1sc1pUb3ZMQ0JjSW1acGJHVTZMMXdpS1Z4dUlDQWdJQzV5WlhCc1lXTmxLQzljWEM4b1hGdy9mQ1o4STF0ZUlWMHBMMmNzSUZ3aUpERmNJaWxjYmlBZ0lDQXVjbVZ3YkdGalpTZ3ZYRncvTDJjc0lGd2lKbHdpS1Z4dUlDQWdJQzV5WlhCc1lXTmxLRndpSmx3aUxDQmNJajljSWlrN1hHNTlYRzRpWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGRFFUdEJRVWRCTzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZVUVR0QlFWZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCVkVFN1FVRkRRVHRCUVZkQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZHUVR0QlFVTkJPMEZCUjBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlJVRTdRVUZEUVR0QlFVbEJPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVVZCTzBGQlEwRTdRVUZSUVNJc0luTnZkWEpqWlZKdmIzUWlPaUlpZlE9PVxcXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrLWludGVybmFsOi8vLy4vc3JjL3V0aWxzLmpzXFxcXG5cXFwiKTtcXG5cXG4vKioqLyB9KVxcblxcbi8qKioqKiovIH0pO1wiLCBudWxsKTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/plugin.webworker.js\n");

/***/ }),

/***/ "./src/pluginCore.js":
/*!***************************!*\
  !*** ./src/pluginCore.js ***!
  \***************************/
/*! exports provided: connectRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connectRPC\", function() { return connectRPC; });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/**\n * Core plugin script loaded into the plugin process/thread.\n *\n * Initializes the plugin-site API global methods.\n */\n\nfunction connectRPC(connection, config) {\n  const application = {};\n  config = config || {};\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config);\n  rpc.onGetInterface(function () {\n    launchConnected();\n  });\n  rpc.onRemoteUpdate(function () {\n    application.remote = rpc.getRemote();\n    if (!application.remote) return;\n    const api = application.remote || {};\n\n    if (api.export) {\n      console.error(\"WARNING: overwriting function 'export'.\");\n    }\n\n    if (api.onload) {\n      console.error(\"WARNING: overwriting function 'onload'.\");\n    }\n\n    if (api.dispose) {\n      console.error(\"WARNING: overwriting function 'dispose'.\");\n    }\n\n    api.export = application.setInterface;\n    api.onLoad = application.whenConnected;\n    api.dispose = application.disconnect;\n\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n      self.api = api;\n      self.postMessage({\n        type: \"imjoy_remote_api_ready\"\n      });\n    } else if (typeof window) {\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: api\n      }));\n    }\n  });\n  var connected = false;\n  var connectedHandlers = [];\n\n  var launchConnected = function () {\n    if (!connected) {\n      connected = true;\n      var handler;\n\n      while (handler = connectedHandlers.pop()) {\n        handler();\n      }\n    }\n  };\n\n  var checkHandler = function (handler) {\n    var type = typeof handler;\n\n    if (type !== \"function\") {\n      var msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\n      throw new Error(msg);\n    }\n\n    return handler;\n  };\n  /**\n   * Sets a function executed after the connection to the\n   * application is estaplished, and the initial interface-exchange\n   * messaging is completed\n   *\n   * @param {Function} handler to be called upon initialization\n   */\n\n\n  application.whenConnected = function (handler) {\n    handler = checkHandler(handler);\n\n    if (connected) {\n      handler();\n    } else {\n      connectedHandlers.push(handler);\n    }\n  };\n  /**\n   * Sets the plugin interface available to the application\n   *\n   * @param {Object} _interface to set\n   */\n\n\n  application.setInterface = function (_interface) {\n    rpc.setInterface(_interface);\n  };\n  /**\n   * Disconnects the plugin from the application (sending\n   * notification message) and destroys itself\n   */\n\n\n  application.disconnect = function (_interface) {\n    rpc.disconnect();\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luQ29yZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDL3NyYy9wbHVnaW5Db3JlLmpzP2E0NzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3JlIHBsdWdpbiBzY3JpcHQgbG9hZGVkIGludG8gdGhlIHBsdWdpbiBwcm9jZXNzL3RocmVhZC5cbiAqXG4gKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luLXNpdGUgQVBJIGdsb2JhbCBtZXRob2RzLlxuICovXG5pbXBvcnQgeyBSUEMgfSBmcm9tIFwiLi9ycGMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3RSUEMoY29ubmVjdGlvbiwgY29uZmlnKSB7XG4gIGNvbnN0IGFwcGxpY2F0aW9uID0ge307XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICBjb25zdCBycGMgPSBuZXcgUlBDKGNvbm5lY3Rpb24sIGNvbmZpZyk7XG4gIHJwYy5vbkdldEludGVyZmFjZShmdW5jdGlvbigpIHtcbiAgICBsYXVuY2hDb25uZWN0ZWQoKTtcbiAgfSk7XG5cbiAgcnBjLm9uUmVtb3RlVXBkYXRlKGZ1bmN0aW9uKCkge1xuICAgIGFwcGxpY2F0aW9uLnJlbW90ZSA9IHJwYy5nZXRSZW1vdGUoKTtcbiAgICBpZiAoIWFwcGxpY2F0aW9uLnJlbW90ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGFwaSA9IGFwcGxpY2F0aW9uLnJlbW90ZSB8fCB7fTtcbiAgICBpZiAoYXBpLmV4cG9ydCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIldBUk5JTkc6IG92ZXJ3cml0aW5nIGZ1bmN0aW9uICdleHBvcnQnLlwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5vbmxvYWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJXQVJOSU5HOiBvdmVyd3JpdGluZyBmdW5jdGlvbiAnb25sb2FkJy5cIik7XG4gICAgfVxuICAgIGlmIChhcGkuZGlzcG9zZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIldBUk5JTkc6IG92ZXJ3cml0aW5nIGZ1bmN0aW9uICdkaXNwb3NlJy5cIik7XG4gICAgfVxuICAgIGFwaS5leHBvcnQgPSBhcHBsaWNhdGlvbi5zZXRJbnRlcmZhY2U7XG4gICAgYXBpLm9uTG9hZCA9IGFwcGxpY2F0aW9uLndoZW5Db25uZWN0ZWQ7XG4gICAgYXBpLmRpc3Bvc2UgPSBhcHBsaWNhdGlvbi5kaXNjb25uZWN0O1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlXG4gICAgKSB7XG4gICAgICBzZWxmLmFwaSA9IGFwaTtcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93KSB7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVwiLCB7IGRldGFpbDogYXBpIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGNvbm5lY3RlZCA9IGZhbHNlO1xuICB2YXIgY29ubmVjdGVkSGFuZGxlcnMgPSBbXTtcblxuICB2YXIgbGF1bmNoQ29ubmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgIGNvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgd2hpbGUgKChoYW5kbGVyID0gY29ubmVjdGVkSGFuZGxlcnMucG9wKCkpKSB7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGNoZWNrSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBoYW5kbGVyO1xuICAgIGlmICh0eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhciBtc2cgPVxuICAgICAgICBcIkEgZnVuY3Rpb24gbWF5IG9ubHkgYmUgc3Vic3JpYmVkIHRvIHRoZSBldmVudCwgXCIgK1xuICAgICAgICB0eXBlICtcbiAgICAgICAgXCIgd2FzIHByb3ZpZGVkIGluc3RlYWRcIjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgZnVuY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gdG8gdGhlXG4gICAqIGFwcGxpY2F0aW9uIGlzIGVzdGFwbGlzaGVkLCBhbmQgdGhlIGluaXRpYWwgaW50ZXJmYWNlLWV4Y2hhbmdlXG4gICAqIG1lc3NhZ2luZyBpcyBjb21wbGV0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciB0byBiZSBjYWxsZWQgdXBvbiBpbml0aWFsaXphdGlvblxuICAgKi9cbiAgYXBwbGljYXRpb24ud2hlbkNvbm5lY3RlZCA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyID0gY2hlY2tIYW5kbGVyKGhhbmRsZXIpO1xuICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgIGhhbmRsZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29ubmVjdGVkSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBsdWdpbiBpbnRlcmZhY2UgYXZhaWxhYmxlIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gX2ludGVyZmFjZSB0byBzZXRcbiAgICovXG4gIGFwcGxpY2F0aW9uLnNldEludGVyZmFjZSA9IGZ1bmN0aW9uKF9pbnRlcmZhY2UpIHtcbiAgICBycGMuc2V0SW50ZXJmYWNlKF9pbnRlcmZhY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgcGx1Z2luIGZyb20gdGhlIGFwcGxpY2F0aW9uIChzZW5kaW5nXG4gICAqIG5vdGlmaWNhdGlvbiBtZXNzYWdlKSBhbmQgZGVzdHJveXMgaXRzZWxmXG4gICAqL1xuICBhcHBsaWNhdGlvbi5kaXNjb25uZWN0ID0gZnVuY3Rpb24oX2ludGVyZmFjZSkge1xuICAgIHJwYy5kaXNjb25uZWN0KCk7XG4gIH07XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pluginCore.js\n");

/***/ }),

/***/ "./src/pluginIframe.js":
/*!*****************************!*\
  !*** ./src/pluginIframe.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return setupIframe; });\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/**\n * Contains the routines loaded by the plugin iframe under web-browser\n * in case when worker failed to initialize\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\n\n\nfunction setupIframe(config) {\n  config = config || {};\n  const targetOrigin = config.target_origin || \"*\"; // Create a new, plain <span> element\n\n  function _htmlToElement(html) {\n    var template = document.createElement(\"template\");\n    html = html.trim(); // Never return a text node of whitespace as the result\n\n    template.innerHTML = html;\n    return template.content.firstChild;\n  }\n\n  var _importScript = function (url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.type = \"text/javascript\";\n      scriptTag.onload = resolve;\n\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  }; // support importScripts outside web worker\n\n\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n        len = args.length,\n        i = 0;\n\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  } // evaluates the provided string\n\n\n  var execute = async function (code) {\n    try {\n      if (code.type === \"requirements\") {\n        if (code.requirements && (Array.isArray(code.requirements) || typeof code.requirements === \"string\")) {\n          try {\n            var link_node;\n            code.requirements = typeof code.requirements === \"string\" ? [code.requirements] : code.requirements;\n\n            if (Array.isArray(code.requirements)) {\n              for (var i = 0; i < code.requirements.length; i++) {\n                if (code.requirements[i].toLowerCase().endsWith(\".css\") || code.requirements[i].startsWith(\"css:\")) {\n                  if (code.requirements[i].startsWith(\"css:\")) {\n                    code.requirements[i] = code.requirements[i].slice(4);\n                  }\n\n                  link_node = document.createElement(\"link\");\n                  link_node.rel = \"stylesheet\";\n                  link_node.href = code.requirements[i];\n                  document.head.appendChild(link_node);\n                } else if (code.requirements[i].toLowerCase().endsWith(\".js\") || code.requirements[i].startsWith(\"js:\")) {\n                  if (code.requirements[i].startsWith(\"js:\")) {\n                    code.requirements[i] = code.requirements[i].slice(3);\n                  }\n\n                  await importScripts(code.requirements[i]);\n                } else if (code.requirements[i].startsWith(\"http\")) {\n                  await importScripts(code.requirements[i]);\n                } else if (code.requirements[i].startsWith(\"cache:\")) {//ignore cache\n                } else {\n                  console.log(\"Unprocessed requirements url: \" + code.requirements[i]);\n                }\n              }\n            } else {\n              throw \"unsupported requirements definition\";\n            }\n          } catch (e) {\n            throw \"failed to import required scripts: \" + code.requirements.toString();\n          }\n        }\n      } else if (code.type === \"script\") {\n        if (code.src) {\n          var script_node = document.createElement(\"script\");\n          script_node.setAttribute(\"type\", code.attrs.type);\n          script_node.setAttribute(\"src\", code.src);\n          document.head.appendChild(script_node);\n        } else {\n          if (code.content && (!code.attrs.type || code.attrs.type === \"text/javascript\")) {\n            // document.addEventListener(\"DOMContentLoaded\", function(){\n            eval(code.content); // });\n          } else {\n            var node = document.createElement(\"script\");\n            node.setAttribute(\"type\", code.attrs.type);\n            node.appendChild(document.createTextNode(code.content));\n            document.body.appendChild(node);\n          }\n        }\n      } else if (code.type === \"style\") {\n        var style_node = document.createElement(\"style\");\n\n        if (code.src) {\n          style_node.src = code.src;\n        }\n\n        style_node.innerHTML = code.content;\n        document.head.appendChild(style_node);\n      } else if (code.type === \"link\") {\n        var link_node_ = document.createElement(\"link\");\n\n        if (code.rel) {\n          link_node_.rel = code.rel;\n        }\n\n        if (code.href) {\n          link_node_.href = code.href;\n        }\n\n        if (code.attrs && code.attrs.type) {\n          link_node_.type = code.attrs.type;\n        }\n\n        document.head.appendChild(link_node_);\n      } else if (code.type === \"html\") {\n        document.body.appendChild(_htmlToElement(code.content));\n      } else {\n        throw \"unsupported code type.\";\n      }\n\n      parent.postMessage({\n        type: \"executeSuccess\"\n      }, targetOrigin);\n    } catch (e) {\n      console.error(\"failed to execute scripts: \", code, e);\n      parent.postMessage({\n        type: \"executeFailure\",\n        error: e.stack || String(e)\n      }, targetOrigin);\n    }\n  }; // connection object for the RPC constructor\n\n\n  const conn = {\n    disconnect: function () {},\n    send: function (data, transferables) {\n      parent.postMessage(data, targetOrigin, transferables);\n    },\n    onMessage: function (h) {\n      conn._messageHandler = h;\n    },\n    _messageHandler: function () {},\n    onDisconnect: function () {}\n  };\n  config.dedicated_thread = false;\n  config.lang = \"javascript\";\n  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"]; // event listener for the plugin message\n\n  window.addEventListener(\"message\", function (e) {\n    if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n      const m = e.data;\n\n      switch (m && m.type) {\n        case \"getConfig\":\n          parent.postMessage({\n            type: \"config\",\n            config: config\n          }, targetOrigin);\n          break;\n\n        case \"execute\":\n          if (config.allow_execution) {\n            execute(m.code);\n\n            if (m.code.type === \"requirements\") {\n              if (!Array.isArray(m.code.requirements)) {\n                m.code.requirements = [m.code.requirements];\n              }\n            }\n          } else {\n            console.warn(\"import script is not allowed (allow_execution=false)\");\n          }\n\n          break;\n\n        default:\n          conn._messageHandler(m);\n\n      }\n    }\n  });\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, {\n    forwarding_functions: config.forwarding_functions\n  });\n  parent.postMessage({\n    type: \"initialized\",\n    config: config\n  }, targetOrigin);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luSWZyYW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvc3JjL3BsdWdpbklmcmFtZS5qcz9lNmFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udGFpbnMgdGhlIHJvdXRpbmVzIGxvYWRlZCBieSB0aGUgcGx1Z2luIGlmcmFtZSB1bmRlciB3ZWItYnJvd3NlclxuICogaW4gY2FzZSB3aGVuIHdvcmtlciBmYWlsZWQgdG8gaW5pdGlhbGl6ZVxuICpcbiAqIEluaXRpYWxpemVzIHRoZSB3ZWIgZW52aXJvbm1lbnQgdmVyc2lvbiBvZiB0aGUgcGxhdGZvcm0tZGVwZW5kZW50XG4gKiBjb25uZWN0aW9uIG9iamVjdCBmb3IgdGhlIHBsdWdpbiBzaXRlXG4gKi9cbmltcG9ydCB7IGNvbm5lY3RSUEMgfSBmcm9tIFwiLi9wbHVnaW5Db3JlLmpzXCI7XG5pbXBvcnQgeyBBUElfVkVSU0lPTiB9IGZyb20gXCIuL3JwYy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cElmcmFtZShjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25zdCB0YXJnZXRPcmlnaW4gPSBjb25maWcudGFyZ2V0X29yaWdpbiB8fCBcIipcIjtcbiAgLy8gQ3JlYXRlIGEgbmV3LCBwbGFpbiA8c3Bhbj4gZWxlbWVudFxuICBmdW5jdGlvbiBfaHRtbFRvRWxlbWVudChodG1sKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgIGh0bWwgPSBodG1sLnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIHZhciBfaW1wb3J0U2NyaXB0ID0gZnVuY3Rpb24odXJsKSB7XG4gICAgLy91cmwgaXMgVVJMIG9mIGV4dGVybmFsIGZpbGUsIGltcGxlbWVudGF0aW9uQ29kZSBpcyB0aGUgY29kZVxuICAgIC8vdG8gYmUgY2FsbGVkIGZyb20gdGhlIGZpbGUsIGxvY2F0aW9uIGlzIHRoZSBsb2NhdGlvbiB0b1xuICAgIC8vaW5zZXJ0IHRoZSA8c2NyaXB0PiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHZhciBzY3JpcHRUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgc2NyaXB0VGFnLnNyYyA9IHVybDtcbiAgICAgIHNjcmlwdFRhZy50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcbiAgICAgIHNjcmlwdFRhZy5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgc2NyaXB0VGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBcImxvYWRlZFwiIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2NyaXB0VGFnLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gc3VwcG9ydCBpbXBvcnRTY3JpcHRzIG91dHNpZGUgd2ViIHdvcmtlclxuXG4gIGFzeW5jIGZ1bmN0aW9uIGltcG9ydFNjcmlwdHMoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgbGVuID0gYXJncy5sZW5ndGgsXG4gICAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhd2FpdCBfaW1wb3J0U2NyaXB0KGFyZ3NbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGV2YWx1YXRlcyB0aGUgcHJvdmlkZWQgc3RyaW5nXG4gIHZhciBleGVjdXRlID0gYXN5bmMgZnVuY3Rpb24oY29kZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoY29kZS50eXBlID09PSBcInJlcXVpcmVtZW50c1wiKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cyAmJlxuICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSB8fFxuICAgICAgICAgICAgdHlwZW9mIGNvZGUucmVxdWlyZW1lbnRzID09PSBcInN0cmluZ1wiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGxpbmtfbm9kZTtcbiAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzID1cbiAgICAgICAgICAgICAgdHlwZW9mIGNvZGUucmVxdWlyZW1lbnRzID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBbY29kZS5yZXF1aXJlbWVudHNdXG4gICAgICAgICAgICAgICAgOiBjb2RlLnJlcXVpcmVtZW50cztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGUucmVxdWlyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcIi5jc3NcIikgfHxcbiAgICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJjc3M6XCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImNzczpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0gPSBjb2RlLnJlcXVpcmVtZW50c1tpXS5zbGljZSg0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxpbmtfbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgICAgICAgICAgICAgbGlua19ub2RlLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuICAgICAgICAgICAgICAgICAgbGlua19ub2RlLmhyZWYgPSBjb2RlLnJlcXVpcmVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGlua19ub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcIi5qc1wiKSB8fFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImpzOlwiKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJqczpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0gPSBjb2RlLnJlcXVpcmVtZW50c1tpXS5zbGljZSgzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGF3YWl0IGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImNhY2hlOlwiKSkge1xuICAgICAgICAgICAgICAgICAgLy9pZ25vcmUgY2FjaGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgIFwiVW5wcm9jZXNzZWQgcmVxdWlyZW1lbnRzIHVybDogXCIgKyBjb2RlLnJlcXVpcmVtZW50c1tpXVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgcmVxdWlyZW1lbnRzIGRlZmluaXRpb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBcImZhaWxlZCB0byBpbXBvcnQgcmVxdWlyZWQgc2NyaXB0czogXCIgK1xuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cy50b1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgICAgaWYgKGNvZGUuc3JjKSB7XG4gICAgICAgICAgdmFyIHNjcmlwdF9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICBzY3JpcHRfbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIGNvZGUuYXR0cnMudHlwZSk7XG4gICAgICAgICAgc2NyaXB0X25vZGUuc2V0QXR0cmlidXRlKFwic3JjXCIsIGNvZGUuc3JjKTtcbiAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdF9ub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb2RlLmNvbnRlbnQgJiZcbiAgICAgICAgICAgICghY29kZS5hdHRycy50eXBlIHx8IGNvZGUuYXR0cnMudHlwZSA9PT0gXCJ0ZXh0L2phdmFzY3JpcHRcIilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBldmFsKGNvZGUuY29udGVudCk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIGNvZGUuYXR0cnMudHlwZSk7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvZGUuY29udGVudCkpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZS50eXBlID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgdmFyIHN0eWxlX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIGlmIChjb2RlLnNyYykge1xuICAgICAgICAgIHN0eWxlX25vZGUuc3JjID0gY29kZS5zcmM7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVfbm9kZS5pbm5lckhUTUwgPSBjb2RlLmNvbnRlbnQ7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVfbm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUudHlwZSA9PT0gXCJsaW5rXCIpIHtcbiAgICAgICAgdmFyIGxpbmtfbm9kZV8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgICAgaWYgKGNvZGUucmVsKSB7XG4gICAgICAgICAgbGlua19ub2RlXy5yZWwgPSBjb2RlLnJlbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZS5ocmVmKSB7XG4gICAgICAgICAgbGlua19ub2RlXy5ocmVmID0gY29kZS5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlLmF0dHJzICYmIGNvZGUuYXR0cnMudHlwZSkge1xuICAgICAgICAgIGxpbmtfbm9kZV8udHlwZSA9IGNvZGUuYXR0cnMudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmtfbm9kZV8pO1xuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX2h0bWxUb0VsZW1lbnQoY29kZS5jb250ZW50KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcInVuc3VwcG9ydGVkIGNvZGUgdHlwZS5cIjtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXhlY3V0ZVN1Y2Nlc3NcIiB9LCB0YXJnZXRPcmlnaW4pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJmYWlsZWQgdG8gZXhlY3V0ZSBzY3JpcHRzOiBcIiwgY29kZSwgZSk7XG4gICAgICBwYXJlbnQucG9zdE1lc3NhZ2UoXG4gICAgICAgIHsgdHlwZTogXCJleGVjdXRlRmFpbHVyZVwiLCBlcnJvcjogZS5zdGFjayB8fCBTdHJpbmcoZSkgfSxcbiAgICAgICAgdGFyZ2V0T3JpZ2luXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvLyBjb25uZWN0aW9uIG9iamVjdCBmb3IgdGhlIFJQQyBjb25zdHJ1Y3RvclxuICBjb25zdCBjb25uID0ge1xuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge30sXG4gICAgc2VuZDogZnVuY3Rpb24oZGF0YSwgdHJhbnNmZXJhYmxlcykge1xuICAgICAgcGFyZW50LnBvc3RNZXNzYWdlKGRhdGEsIHRhcmdldE9yaWdpbiwgdHJhbnNmZXJhYmxlcyk7XG4gICAgfSxcbiAgICBvbk1lc3NhZ2U6IGZ1bmN0aW9uKGgpIHtcbiAgICAgIGNvbm4uX21lc3NhZ2VIYW5kbGVyID0gaDtcbiAgICB9LFxuICAgIF9tZXNzYWdlSGFuZGxlcjogZnVuY3Rpb24oKSB7fSxcbiAgICBvbkRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge31cbiAgfTtcblxuICBjb25maWcuZGVkaWNhdGVkX3RocmVhZCA9IGZhbHNlO1xuICBjb25maWcubGFuZyA9IFwiamF2YXNjcmlwdFwiO1xuICBjb25maWcuYXBpX3ZlcnNpb24gPSBBUElfVkVSU0lPTjtcblxuICAvLyBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHBsdWdpbiBtZXNzYWdlXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRhcmdldE9yaWdpbiA9PT0gXCIqXCIgfHwgZS5vcmlnaW4gPT09IHRhcmdldE9yaWdpbikge1xuICAgICAgY29uc3QgbSA9IGUuZGF0YTtcbiAgICAgIHN3aXRjaCAobSAmJiBtLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImdldENvbmZpZ1wiOlxuICAgICAgICAgIHBhcmVudC5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJjb25maWdcIixcbiAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YXJnZXRPcmlnaW5cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXhlY3V0ZVwiOlxuICAgICAgICAgIGlmIChjb25maWcuYWxsb3dfZXhlY3V0aW9uKSB7XG4gICAgICAgICAgICBleGVjdXRlKG0uY29kZSk7XG4gICAgICAgICAgICBpZiAobS5jb2RlLnR5cGUgPT09IFwicmVxdWlyZW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG0uY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgbS5jb2RlLnJlcXVpcmVtZW50cyA9IFttLmNvZGUucmVxdWlyZW1lbnRzXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiaW1wb3J0IHNjcmlwdCBpcyBub3QgYWxsb3dlZCAoYWxsb3dfZXhlY3V0aW9uPWZhbHNlKVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25uLl9tZXNzYWdlSGFuZGxlcihtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbm5lY3RSUEMoY29ubiwge1xuICAgIGZvcndhcmRpbmdfZnVuY3Rpb25zOiBjb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnNcbiAgfSk7XG5cbiAgcGFyZW50LnBvc3RNZXNzYWdlKFxuICAgIHtcbiAgICAgIHR5cGU6IFwiaW5pdGlhbGl6ZWRcIixcbiAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgfSxcbiAgICB0YXJnZXRPcmlnaW5cbiAgKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTFCQTtBQTJCQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBSUE7QUFFQTtBQUNBO0FBRkE7QUFNQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pluginIframe.js\n");

/***/ }),

/***/ "./src/pluginWebPython.js":
/*!********************************!*\
  !*** ./src/pluginWebPython.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return setupWebPython; });\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/**\n * Contains the routines loaded by the plugin iframe under web-browser\n * in case when worker failed to initialize\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\n\n\nfunction setupWebPython(config) {\n  config = config || {}; // Create a new, plain <span> element\n\n  function _htmlToElement(html) {\n    var template = document.createElement(\"template\");\n    html = html.trim(); // Never return a text node of whitespace as the result\n\n    template.innerHTML = html;\n    return template.content.firstChild;\n  }\n\n  var _importScript = function (url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.onload = resolve;\n\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  }; // support importScripts outside web worker\n\n\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n        len = args.length,\n        i = 0;\n\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  }\n\n  var startup_script = `\n  from js import api\n  import sys\n  from types import ModuleType\n  m = ModuleType(\"imjoy\")\n  sys.modules[m.__name__] = m\n  m.__file__ = m.__name__ + \".py\"\n  m.api = api\n  `;\n  var _export_plugin_api = null;\n\n  var execute_python_code = function (code) {\n    try {\n      if (!_export_plugin_api) {\n        _export_plugin_api = window.api.export;\n\n        window.api.export = function (p) {\n          if (typeof p === \"object\") {\n            const _api = {};\n\n            for (let k in p) {\n              if (!k.startsWith(\"_\")) {\n                _api[k] = p[k];\n              }\n            }\n\n            _export_plugin_api(_api);\n          } else if (typeof p === \"function\") {\n            const _api = {};\n            const getattr = window.pyodide.pyimport(\"getattr\");\n            const hasattr = window.pyodide.pyimport(\"hasattr\");\n\n            for (let k of Object.getOwnPropertyNames(p)) {\n              if (!k.startsWith(\"_\") && hasattr(p, k)) {\n                const func = getattr(p, k);\n\n                _api[k] = function () {\n                  return func(...Array.prototype.slice.call(arguments));\n                };\n              }\n            }\n\n            _export_plugin_api(_api);\n          } else {\n            throw \"unsupported api export\";\n          }\n        };\n      }\n\n      window.pyodide.runPython(startup_script);\n      window.pyodide.runPython(code.content);\n    } catch (e) {\n      throw e;\n    }\n  }; // evaluates the provided string\n\n\n  var execute = async function (code) {\n    try {\n      if (code.type === \"requirements\") {\n        if (code.requirements) {\n          code.requirements = typeof code.requirements === \"string\" ? [code.requirements] : code.requirements;\n\n          if (Array.isArray(code.requirements)) {\n            const python_packages = [];\n\n            for (var i = 0; i < code.requirements.length; i++) {\n              if (code.requirements[i].toLowerCase().endsWith(\".css\") || code.requirements[i].startsWith(\"css:\")) {\n                if (code.requirements[i].startsWith(\"css:\")) {\n                  code.requirements[i] = code.requirements[i].slice(4);\n                }\n\n                link_node = document.createElement(\"link\");\n                link_node.rel = \"stylesheet\";\n                link_node.href = code.requirements[i];\n                document.head.appendChild(link_node);\n              } else if ( // code.requirements[i].toLowerCase().endsWith(\".js\") ||\n              code.requirements[i].startsWith(\"js:\")) {\n                if (code.requirements[i].startsWith(\"js:\")) {\n                  code.requirements[i] = code.requirements[i].slice(3);\n                }\n\n                await importScripts(code.requirements[i]);\n              } else if (code.requirements[i].startsWith(\"cache:\")) {//ignore cache\n              } else if (code.requirements[i].toLowerCase().endsWith(\".js\") || code.requirements[i].startsWith(\"package:\")) {\n                if (code.requirements[i].startsWith(\"package:\")) {\n                  code.requirements[i] = code.requirements[i].slice(8);\n                }\n\n                python_packages.push(code.requirements[i]);\n              } else if (code.requirements[i].startsWith(\"http:\") || code.requirements[i].startsWith(\"https:\")) {\n                console.log(\"Unprocessed requirements url: \" + code.requirements[i]);\n              } else {\n                python_packages.push(code.requirements[i]);\n              }\n            }\n\n            await window.pyodide.loadPackage(python_packages);\n          } else {\n            throw \"unsupported requirements definition\";\n          }\n        }\n      } else if (code.type === \"script\") {\n        if (code.src) {\n          var script_node = document.createElement(\"script\");\n          script_node.setAttribute(\"type\", code.attrs.type);\n          script_node.setAttribute(\"src\", code.src);\n          document.head.appendChild(script_node);\n        } else {\n          if (code.content && code.lang === \"python\") {\n            execute_python_code(code);\n          } else if (code.content && code.lang === \"javascript\") {\n            try {\n              eval(code.content);\n            } catch (e) {\n              console.error(e.message, e.stack);\n              throw e;\n            }\n          } else {\n            var node = document.createElement(\"script\");\n            node.setAttribute(\"type\", code.attrs.type);\n            node.appendChild(document.createTextNode(code.content));\n            document.body.appendChild(node);\n          }\n        }\n      } else if (code.type === \"style\") {\n        var style_node = document.createElement(\"style\");\n\n        if (code.src) {\n          style_node.src = code.src;\n        }\n\n        style_node.innerHTML = code.content;\n        document.head.appendChild(style_node);\n      } else if (code.type === \"link\") {\n        var link_node = document.createElement(\"link\");\n\n        if (code.rel) {\n          link_node.rel = code.rel;\n        }\n\n        if (code.href) {\n          link_node.href = code.href;\n        }\n\n        if (code.attrs && code.attrs.type) {\n          link_node.type = code.attrs.type;\n        }\n\n        document.head.appendChild(link_node);\n      } else if (code.type === \"html\") {\n        document.body.appendChild(_htmlToElement(code.content));\n      } else {\n        throw \"unsupported code type.\";\n      }\n\n      parent.postMessage({\n        type: \"executeSuccess\"\n      }, \"*\");\n    } catch (e) {\n      console.error(\"failed to execute scripts: \", code, e);\n      parent.postMessage({\n        type: \"executeFailure\",\n        error: e.stack || String(e)\n      }, \"*\");\n    }\n  };\n\n  const targetOrigin = config.target_origin || \"*\"; // connection object for the RPC constructor\n\n  const conn = {\n    disconnect: function () {},\n    send: function (data, transferables) {\n      parent.postMessage(data, targetOrigin, transferables);\n    },\n    onMessage: function (h) {\n      conn._messageHandler = h;\n    },\n    _messageHandler: function () {},\n    onDisconnect: function () {}\n  };\n  config.dedicated_thread = false;\n  config.lang = \"python\";\n  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"]; // event listener for the plugin message\n\n  window.addEventListener(\"message\", function (e) {\n    if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n      const m = e.data;\n\n      switch (m && m.type) {\n        case \"getConfig\":\n          parent.postMessage({\n            type: \"config\",\n            config: config\n          }, targetOrigin);\n          break;\n\n        case \"execute\":\n          if (config.allow_execution) {\n            execute(m.code);\n\n            if (m.code.type === \"requirements\") {\n              if (!Array.isArray(m.code.requirements)) {\n                m.code.requirements = [m.code.requirements];\n              }\n            }\n          } else {\n            console.warn(\"execute script is not allowed (allow_execution=false)\");\n          }\n\n          break;\n\n        default:\n          conn._messageHandler(m);\n\n      }\n    }\n  });\n  window.languagePluginUrl = \"https://static.imjoy.io/pyodide/\";\n  importScripts(\"https://static.imjoy.io/pyodide/pyodide.js\").then(() => {\n    // hack for matplotlib etc.\n    window.iodide = {\n      output: {\n        element: function element(type) {\n          const div = document.createElement(type);\n          const output = document.getElementById(\"output\") || document.body;\n          output.appendChild(div);\n          return div;\n        }\n      }\n    };\n    window.languagePluginLoader.then(() => {\n      // pyodide is now ready to use...\n      console.log(window.pyodide.runPython(\"import sys\\nsys.version\"));\n      Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, {\n        forwarding_functions: config.forwarding_functions\n      });\n      parent.postMessage({\n        type: \"initialized\",\n        config: config\n      }, targetOrigin);\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luV2ViUHl0aG9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvc3JjL3BsdWdpbldlYlB5dGhvbi5qcz9iZmU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udGFpbnMgdGhlIHJvdXRpbmVzIGxvYWRlZCBieSB0aGUgcGx1Z2luIGlmcmFtZSB1bmRlciB3ZWItYnJvd3NlclxuICogaW4gY2FzZSB3aGVuIHdvcmtlciBmYWlsZWQgdG8gaW5pdGlhbGl6ZVxuICpcbiAqIEluaXRpYWxpemVzIHRoZSB3ZWIgZW52aXJvbm1lbnQgdmVyc2lvbiBvZiB0aGUgcGxhdGZvcm0tZGVwZW5kZW50XG4gKiBjb25uZWN0aW9uIG9iamVjdCBmb3IgdGhlIHBsdWdpbiBzaXRlXG4gKi9cblxuaW1wb3J0IHsgY29ubmVjdFJQQyB9IGZyb20gXCIuL3BsdWdpbkNvcmUuanNcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OIH0gZnJvbSBcIi4vcnBjLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwV2ViUHl0aG9uKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIC8vIENyZWF0ZSBhIG5ldywgcGxhaW4gPHNwYW4+IGVsZW1lbnRcbiAgZnVuY3Rpb24gX2h0bWxUb0VsZW1lbnQoaHRtbCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICBodG1sID0gaHRtbC50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gIH1cblxuICB2YXIgX2ltcG9ydFNjcmlwdCA9IGZ1bmN0aW9uKHVybCkge1xuICAgIC8vdXJsIGlzIFVSTCBvZiBleHRlcm5hbCBmaWxlLCBpbXBsZW1lbnRhdGlvbkNvZGUgaXMgdGhlIGNvZGVcbiAgICAvL3RvIGJlIGNhbGxlZCBmcm9tIHRoZSBmaWxlLCBsb2NhdGlvbiBpcyB0aGUgbG9jYXRpb24gdG9cbiAgICAvL2luc2VydCB0aGUgPHNjcmlwdD4gZWxlbWVudFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgIHNjcmlwdFRhZy5zcmMgPSB1cmw7XG4gICAgICBzY3JpcHRUYWcub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgIHNjcmlwdFRhZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJsb2FkZWRcIiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNjcmlwdFRhZy5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRUYWcpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIHN1cHBvcnQgaW1wb3J0U2NyaXB0cyBvdXRzaWRlIHdlYiB3b3JrZXJcblxuICBhc3luYyBmdW5jdGlvbiBpbXBvcnRTY3JpcHRzKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgIGxlbiA9IGFyZ3MubGVuZ3RoLFxuICAgICAgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXdhaXQgX2ltcG9ydFNjcmlwdChhcmdzW2ldKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhcnR1cF9zY3JpcHQgPSBgXG4gIGZyb20ganMgaW1wb3J0IGFwaVxuICBpbXBvcnQgc3lzXG4gIGZyb20gdHlwZXMgaW1wb3J0IE1vZHVsZVR5cGVcbiAgbSA9IE1vZHVsZVR5cGUoXCJpbWpveVwiKVxuICBzeXMubW9kdWxlc1ttLl9fbmFtZV9fXSA9IG1cbiAgbS5fX2ZpbGVfXyA9IG0uX19uYW1lX18gKyBcIi5weVwiXG4gIG0uYXBpID0gYXBpXG4gIGA7XG4gIHZhciBfZXhwb3J0X3BsdWdpbl9hcGkgPSBudWxsO1xuICB2YXIgZXhlY3V0ZV9weXRob25fY29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfZXhwb3J0X3BsdWdpbl9hcGkpIHtcbiAgICAgICAgX2V4cG9ydF9wbHVnaW5fYXBpID0gd2luZG93LmFwaS5leHBvcnQ7XG4gICAgICAgIHdpbmRvdy5hcGkuZXhwb3J0ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgX2FwaSA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgayBpbiBwKSB7XG4gICAgICAgICAgICAgIGlmICghay5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICAgICAgICAgICAgIF9hcGlba10gPSBwW2tdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZXhwb3J0X3BsdWdpbl9hcGkoX2FwaSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBfYXBpID0ge307XG4gICAgICAgICAgICBjb25zdCBnZXRhdHRyID0gd2luZG93LnB5b2RpZGUucHlpbXBvcnQoXCJnZXRhdHRyXCIpO1xuICAgICAgICAgICAgY29uc3QgaGFzYXR0ciA9IHdpbmRvdy5weW9kaWRlLnB5aW1wb3J0KFwiaGFzYXR0clwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocCkpIHtcbiAgICAgICAgICAgICAgaWYgKCFrLnN0YXJ0c1dpdGgoXCJfXCIpICYmIGhhc2F0dHIocCwgaykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jID0gZ2V0YXR0cihwLCBrKTtcbiAgICAgICAgICAgICAgICBfYXBpW2tdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuYyguLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZXhwb3J0X3BsdWdpbl9hcGkoX2FwaSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgYXBpIGV4cG9ydFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5weW9kaWRlLnJ1blB5dGhvbihzdGFydHVwX3NjcmlwdCk7XG4gICAgICB3aW5kb3cucHlvZGlkZS5ydW5QeXRob24oY29kZS5jb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcblxuICAvLyBldmFsdWF0ZXMgdGhlIHByb3ZpZGVkIHN0cmluZ1xuICB2YXIgZXhlY3V0ZSA9IGFzeW5jIGZ1bmN0aW9uKGNvZGUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGNvZGUudHlwZSA9PT0gXCJyZXF1aXJlbWVudHNcIikge1xuICAgICAgICBpZiAoY29kZS5yZXF1aXJlbWVudHMpIHtcbiAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cyA9XG4gICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgPyBbY29kZS5yZXF1aXJlbWVudHNdXG4gICAgICAgICAgICAgIDogY29kZS5yZXF1aXJlbWVudHM7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgICBjb25zdCBweXRob25fcGFja2FnZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZS5yZXF1aXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoXCIuY3NzXCIpIHx8XG4gICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImNzczpcIilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJjc3M6XCIpKSB7XG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5rX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgICAgICAgICAgICBsaW5rX25vZGUucmVsID0gXCJzdHlsZXNoZWV0XCI7XG4gICAgICAgICAgICAgICAgbGlua19ub2RlLmhyZWYgPSBjb2RlLnJlcXVpcmVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmtfbm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgLy8gY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcIi5qc1wiKSB8fFxuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJqczpcIilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJqczpcIikpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldID0gY29kZS5yZXF1aXJlbWVudHNbaV0uc2xpY2UoMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJjYWNoZTpcIikpIHtcbiAgICAgICAgICAgICAgICAvL2lnbm9yZSBjYWNoZVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoXCIuanNcIikgfHxcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwicGFja2FnZTpcIilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJwYWNrYWdlOlwiKSkge1xuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0gPSBjb2RlLnJlcXVpcmVtZW50c1tpXS5zbGljZSg4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHl0aG9uX3BhY2thZ2VzLnB1c2goY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSB8fFxuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJodHRwczpcIilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICBcIlVucHJvY2Vzc2VkIHJlcXVpcmVtZW50cyB1cmw6IFwiICsgY29kZS5yZXF1aXJlbWVudHNbaV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB5dGhvbl9wYWNrYWdlcy5wdXNoKGNvZGUucmVxdWlyZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgd2luZG93LnB5b2RpZGUubG9hZFBhY2thZ2UocHl0aG9uX3BhY2thZ2VzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCByZXF1aXJlbWVudHMgZGVmaW5pdGlvblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgICAgaWYgKGNvZGUuc3JjKSB7XG4gICAgICAgICAgdmFyIHNjcmlwdF9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICBzY3JpcHRfbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIGNvZGUuYXR0cnMudHlwZSk7XG4gICAgICAgICAgc2NyaXB0X25vZGUuc2V0QXR0cmlidXRlKFwic3JjXCIsIGNvZGUuc3JjKTtcbiAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdF9ub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29kZS5jb250ZW50ICYmIGNvZGUubGFuZyA9PT0gXCJweXRob25cIikge1xuICAgICAgICAgICAgZXhlY3V0ZV9weXRob25fY29kZShjb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUuY29udGVudCAmJiBjb2RlLmxhbmcgPT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBldmFsKGNvZGUuY29udGVudCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlLCBlLnN0YWNrKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIGNvZGUuYXR0cnMudHlwZSk7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvZGUuY29udGVudCkpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZS50eXBlID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgdmFyIHN0eWxlX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIGlmIChjb2RlLnNyYykge1xuICAgICAgICAgIHN0eWxlX25vZGUuc3JjID0gY29kZS5zcmM7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVfbm9kZS5pbm5lckhUTUwgPSBjb2RlLmNvbnRlbnQ7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVfbm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUudHlwZSA9PT0gXCJsaW5rXCIpIHtcbiAgICAgICAgdmFyIGxpbmtfbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgICBpZiAoY29kZS5yZWwpIHtcbiAgICAgICAgICBsaW5rX25vZGUucmVsID0gY29kZS5yZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUuaHJlZikge1xuICAgICAgICAgIGxpbmtfbm9kZS5ocmVmID0gY29kZS5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlLmF0dHJzICYmIGNvZGUuYXR0cnMudHlwZSkge1xuICAgICAgICAgIGxpbmtfbm9kZS50eXBlID0gY29kZS5hdHRycy50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGlua19ub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZS50eXBlID09PSBcImh0bWxcIikge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKF9odG1sVG9FbGVtZW50KGNvZGUuY29udGVudCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBjb2RlIHR5cGUuXCI7XG4gICAgICB9XG4gICAgICBwYXJlbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImV4ZWN1dGVTdWNjZXNzXCIgfSwgXCIqXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJmYWlsZWQgdG8gZXhlY3V0ZSBzY3JpcHRzOiBcIiwgY29kZSwgZSk7XG4gICAgICBwYXJlbnQucG9zdE1lc3NhZ2UoXG4gICAgICAgIHsgdHlwZTogXCJleGVjdXRlRmFpbHVyZVwiLCBlcnJvcjogZS5zdGFjayB8fCBTdHJpbmcoZSkgfSxcbiAgICAgICAgXCIqXCJcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCB0YXJnZXRPcmlnaW4gPSBjb25maWcudGFyZ2V0X29yaWdpbiB8fCBcIipcIjtcbiAgLy8gY29ubmVjdGlvbiBvYmplY3QgZm9yIHRoZSBSUEMgY29uc3RydWN0b3JcbiAgY29uc3QgY29ubiA9IHtcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbigpIHt9LFxuICAgIHNlbmQ6IGZ1bmN0aW9uKGRhdGEsIHRyYW5zZmVyYWJsZXMpIHtcbiAgICAgIHBhcmVudC5wb3N0TWVzc2FnZShkYXRhLCB0YXJnZXRPcmlnaW4sIHRyYW5zZmVyYWJsZXMpO1xuICAgIH0sXG4gICAgb25NZXNzYWdlOiBmdW5jdGlvbihoKSB7XG4gICAgICBjb25uLl9tZXNzYWdlSGFuZGxlciA9IGg7XG4gICAgfSxcbiAgICBfbWVzc2FnZUhhbmRsZXI6IGZ1bmN0aW9uKCkge30sXG4gICAgb25EaXNjb25uZWN0OiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbiAgY29uZmlnLmRlZGljYXRlZF90aHJlYWQgPSBmYWxzZTtcbiAgY29uZmlnLmxhbmcgPSBcInB5dGhvblwiO1xuICBjb25maWcuYXBpX3ZlcnNpb24gPSBBUElfVkVSU0lPTjtcblxuICAvLyBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHBsdWdpbiBtZXNzYWdlXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRhcmdldE9yaWdpbiA9PT0gXCIqXCIgfHwgZS5vcmlnaW4gPT09IHRhcmdldE9yaWdpbikge1xuICAgICAgY29uc3QgbSA9IGUuZGF0YTtcbiAgICAgIHN3aXRjaCAobSAmJiBtLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImdldENvbmZpZ1wiOlxuICAgICAgICAgIHBhcmVudC5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJjb25maWdcIixcbiAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YXJnZXRPcmlnaW5cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXhlY3V0ZVwiOlxuICAgICAgICAgIGlmIChjb25maWcuYWxsb3dfZXhlY3V0aW9uKSB7XG4gICAgICAgICAgICBleGVjdXRlKG0uY29kZSk7XG4gICAgICAgICAgICBpZiAobS5jb2RlLnR5cGUgPT09IFwicmVxdWlyZW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG0uY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgbS5jb2RlLnJlcXVpcmVtZW50cyA9IFttLmNvZGUucmVxdWlyZW1lbnRzXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiZXhlY3V0ZSBzY3JpcHQgaXMgbm90IGFsbG93ZWQgKGFsbG93X2V4ZWN1dGlvbj1mYWxzZSlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29ubi5fbWVzc2FnZUhhbmRsZXIobSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB3aW5kb3cubGFuZ3VhZ2VQbHVnaW5VcmwgPSBcImh0dHBzOi8vc3RhdGljLmltam95LmlvL3B5b2RpZGUvXCI7XG5cbiAgaW1wb3J0U2NyaXB0cyhcImh0dHBzOi8vc3RhdGljLmltam95LmlvL3B5b2RpZGUvcHlvZGlkZS5qc1wiKS50aGVuKCgpID0+IHtcbiAgICAvLyBoYWNrIGZvciBtYXRwbG90bGliIGV0Yy5cbiAgICB3aW5kb3cuaW9kaWRlID0ge1xuICAgICAgb3V0cHV0OiB7XG4gICAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uIGVsZW1lbnQodHlwZSkge1xuICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXRcIikgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICBvdXRwdXQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICByZXR1cm4gZGl2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5sYW5ndWFnZVBsdWdpbkxvYWRlci50aGVuKCgpID0+IHtcbiAgICAgIC8vIHB5b2RpZGUgaXMgbm93IHJlYWR5IHRvIHVzZS4uLlxuICAgICAgY29uc29sZS5sb2cod2luZG93LnB5b2RpZGUucnVuUHl0aG9uKFwiaW1wb3J0IHN5c1xcbnN5cy52ZXJzaW9uXCIpKTtcblxuICAgICAgY29ubmVjdFJQQyhjb25uLCB7XG4gICAgICAgIGZvcndhcmRpbmdfZnVuY3Rpb25zOiBjb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnNcbiAgICAgIH0pO1xuICAgICAgcGFyZW50LnBvc3RNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJpbml0aWFsaXplZFwiLFxuICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgIH0sXG4gICAgICAgIHRhcmdldE9yaWdpblxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBQUE7QUFTQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBMUJBO0FBMkJBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFEQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7QUFDQTtBQUZBO0FBTUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pluginWebPython.js\n");

/***/ }),

/***/ "./src/rpc.js":
/*!********************!*\
  !*** ./src/rpc.js ***!
  \********************/
/*! exports provided: API_VERSION, RPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return RPC; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\nconst API_VERSION = \"0.2.0\";\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction getKeyByValue(object, value) {\n  return Object.keys(object).find(key => object[key] === value);\n}\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\n\n\nclass RPC {\n  constructor(connection, config) {\n    this._connection = connection;\n    this.config = config || {};\n    this._interface = {};\n    this._plugin_interfaces = {};\n    this._remote = null;\n\n    this._remoteUpdateHandler = function () {};\n\n    this._getInterfaceHandler = function () {};\n\n    this._interfaceSetAsRemoteHandler = null;\n\n    this._disconnectHandler = function () {};\n\n    this._store = new ReferenceStore();\n    this._method_refs = new ReferenceStore();\n    this._connection = connection;\n    let me = this;\n\n    this._connection.onMessage(function (data) {\n      me._processMessage(data);\n    });\n  }\n  /**\n   * Set a handler to be called when the remote site updates its\n   * interface\n   *\n   * @param {Function} handler\n   */\n\n\n  onRemoteUpdate(handler) {\n    this._remoteUpdateHandler = handler;\n  }\n  /**\n   * Set a handler to be called when received a responce from the\n   * remote site reporting that the previously provided interface\n   * has been successfully set as remote for that site\n   *\n   * @param {Function} handler\n   */\n\n\n  onRemoteReady(handler) {\n    this._method_refs.onReady(handler);\n  }\n\n  onRemoteBusy(handler) {\n    this._method_refs.onBusy(handler);\n  }\n\n  getRemoteCallStack() {\n    return this._method_refs.getStack();\n  }\n  /**\n   * Set a handler to be called when the remote site requests to\n   * (re)send the interface. Used to detect an initialzation\n   * completion without sending additional request, since in fact\n   * 'getInterface' request is only sent by application at the last\n   * step of the plugin initialization\n   *\n   * @param {Function} handler\n   */\n\n\n  onGetInterface(handler) {\n    this._getInterfaceHandler = handler;\n  }\n  /**\n   * @returns {Object} set of remote interface methods\n   */\n\n\n  getRemote() {\n    return this._remote;\n  }\n  /**\n   * Sets the interface of this site making it available to the\n   * remote site by sending a message with a set of methods names\n   *\n   * @param {Object} _interface to set\n   */\n\n\n  setInterface(_interface) {\n    if (this.config.forwarding_functions) {\n      for (let func_name of this.config.forwarding_functions) {\n        if (this._remote[func_name]) {\n          if (_interface.constructor === Object) {\n            if (!_interface[func_name]) {\n              _interface[func_name] = (...args) => {\n                this._remote[func_name](...args);\n              };\n            }\n          } else if (_interface.constructor.constructor === Function) {\n            if (!_interface.constructor.prototype[func_name]) {\n              _interface.constructor.prototype[func_name] = (...args) => {\n                this._remote[func_name](...args);\n              };\n            }\n          }\n        }\n      }\n    }\n\n    this._interface = _interface;\n  }\n  /**\n   * Sends the actual interface to the remote site upon it was\n   * updated or by a special request of the remote site\n   */\n\n\n  sendInterface() {\n    return new Promise(resolve => {\n      var names = [];\n\n      if (!this._interface) {\n        throw new Error(\"interface is not set.\");\n      }\n\n      if (this._interface.constructor === Object) {\n        for (var name of Object.keys(this._interface)) {\n          if (name.startsWith(\"_\")) continue;\n\n          if (typeof this._interface[name] === \"function\") {\n            names.push({\n              name: name,\n              data: null,\n              type: \"function\"\n            });\n          } else {\n            var data = this._interface[name];\n\n            if (data !== null && typeof data === \"object\") {\n              var data2 = {};\n\n              for (var k of Object.keys(data)) {\n                if (typeof data[k] === \"function\") {\n                  data2[k] = \"rpc_method::\" + k;\n                } else {\n                  data2[k] = data[k];\n                }\n              }\n\n              names.push({\n                name: name,\n                data: data2,\n                type: \"object\"\n              });\n            } else if (Object(data) !== data) {\n              names.push({\n                name: name,\n                data: data,\n                type: \"data\"\n              });\n            }\n          }\n        }\n      } // a class\n      else if (this._interface.constructor === Function) {\n          throw new Error(\"Please instantiate the class before exportting it.\");\n        } // instance of a class\n        else if (this._interface.constructor.constructor === Function) {\n            var functions = Object.getOwnPropertyNames(Object.getPrototypeOf(this._interface)).concat(Object.keys(this._interface));\n\n            for (var i = 0; i < functions.length; i++) {\n              var name_ = functions[i];\n              if (name_.startsWith(\"_\") || name_ === \"constructor\") continue;\n\n              if (typeof this._interface[name_] === \"function\") {\n                names.push({\n                  name: name_,\n                  data: null\n                });\n              }\n            }\n          } else {\n            throw Error(\"Unsupported interface type\");\n          }\n\n      this._interfaceSetAsRemoteHandler = resolve;\n\n      this._connection.send({\n        type: \"setInterface\",\n        api: names\n      });\n    });\n  }\n  /**\n   * Handles a message from the remote site\n   */\n  // var callback_reg = new RegExp(\"onupdate|run$\")\n\n\n  _processMessage(data) {\n    var resolve, reject, method, args, result;\n\n    switch (data.type) {\n      case \"method\":\n        var _interface = this._interface;\n\n        var _method_context = _interface.__this__ || _interface;\n\n        if (data.pid) {\n          _interface = this._plugin_interfaces[data.pid];\n\n          if (!_interface) {\n            if (data.promise) {\n              [resolve, reject] = this._unwrap(data.promise, false);\n              reject(`plugin api function is not avaialbe in \"${data.pid}\", the plugin maybe terminated.`);\n            } else {\n              console.error(`plugin api function is not avaialbe in ${data.pid}, the plugin maybe terminated.`);\n            }\n\n            return;\n          }\n        }\n\n        if (data.name.indexOf(\".\") !== -1) {\n          var names = data.name.split(\".\");\n          method = _interface[names[0]][names[1]];\n        } else {\n          method = _interface[data.name];\n        }\n\n        args = this._unwrap(data.args, true);\n\n        if (data.promise) {\n          [resolve, reject] = this._unwrap(data.promise, false);\n\n          try {\n            result = method.apply(_method_context, args);\n\n            if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n              result.then(resolve).catch(reject);\n            } else {\n              resolve(result);\n            }\n          } catch (e) {\n            console.error(e, method);\n            reject(e);\n          }\n        } else {\n          try {\n            method.apply(_method_context, args);\n          } catch (e) {\n            console.error(e, method, args);\n          }\n        }\n\n        break;\n\n      case \"callback\":\n        if (data.promise) {\n          [resolve, reject] = this._unwrap(data.promise, false);\n\n          try {\n            method = this._store.fetch(data.num);\n            args = this._unwrap(data.args, true);\n\n            if (!method) {\n              throw \"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\";\n            }\n\n            result = method.apply(null, args);\n\n            if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n              result.then(resolve).catch(reject);\n            } else {\n              resolve(result);\n            }\n          } catch (e) {\n            console.error(e, method);\n            reject(e);\n          }\n        } else {\n          try {\n            method = this._store.fetch(data.num);\n            args = this._unwrap(data.args, true);\n\n            if (!method) {\n              throw \"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\";\n            }\n\n            method.apply(null, args);\n          } catch (e) {\n            console.error(e, method, args);\n          }\n        }\n\n        break;\n\n      case \"setInterface\":\n        this._setRemote(data.api);\n\n        break;\n\n      case \"getInterface\":\n        this.sendInterface();\n\n        this._getInterfaceHandler();\n\n        break;\n\n      case \"interfaceSetAsRemote\":\n        if (typeof this._interfaceSetAsRemoteHandler === \"function\") {\n          this._interfaceSetAsRemoteHandler();\n\n          this._interfaceSetAsRemoteHandler === null;\n        }\n\n        break;\n\n      case \"disconnect\":\n        this._disconnectHandler();\n\n        this._connection.disconnect();\n\n        break;\n    }\n  }\n  /**\n   * Sends a requests to the remote site asking it to provide its\n   * current interface\n   */\n\n\n  requestRemote() {\n    this._connection.send({\n      type: \"getInterface\"\n    });\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    var _dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"][typedArray.constructor.name];\n\n    if (dtype && dtype !== _dtype) {\n      throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n    }\n\n    shape = shape || [typedArray.length];\n    return {\n      __jailed_type__: \"ndarray\",\n      __value__: typedArray,\n      __shape__: shape,\n      __dtype__: _dtype\n    };\n  }\n  /**\n   * Sets the new remote interface provided by the other site\n   *\n   * @param {Array} names list of function names\n   */\n\n\n  _setRemote(api) {\n    this._remote = {};\n    var i, name, data, type;\n\n    for (i = 0; i < api.length; i++) {\n      name = api[i].name;\n      data = api[i].data;\n      type = api[i].type;\n\n      if (type === \"data\") {\n        this._remote[name] = data;\n      } else if (data) {\n        if (typeof data === \"object\") {\n          var data2 = {};\n\n          for (var key in data) {\n            if (data.hasOwnProperty(key)) {\n              if (data[key] === \"rpc_method::\" + key) {\n                data2[key] = this._genRemoteMethod(name + \".\" + key);\n              } else {\n                data2[key] = data[key];\n              }\n            }\n          }\n\n          this._remote[name] = data2;\n        } else {\n          this._remote[name] = data;\n        }\n      } else {\n        this._remote[name] = this._genRemoteMethod(name);\n      }\n    }\n\n    this._remoteUpdateHandler();\n\n    this._reportRemoteSet();\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * method. When the generated function is called, it will send the\n   * corresponding message to the remote site asking it to execute\n   * the particular method of its interface\n   *\n   * @param {String} name of the remote method\n   *\n   * @returns {Function} wrapped remote method\n   */\n\n\n  _genRemoteMethod(name, plugin_id) {\n    var me = this;\n\n    var remoteMethod = function () {\n      return new Promise((resolve, reject) => {\n        let id = null;\n\n        try {\n          id = me._method_refs.put(plugin_id ? plugin_id + \"/\" + name : name);\n\n          var wrapped_resolve = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return resolve.apply(this, arguments);\n          };\n\n          var wrapped_reject = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return reject.apply(this, arguments);\n          };\n\n          wrapped_resolve.__jailed_pairs__ = wrapped_reject;\n          wrapped_reject.__jailed_pairs__ = wrapped_resolve;\n          var args = Array.prototype.slice.call(arguments);\n\n          if (name === \"register\" || name === \"export\" || name === \"on\") {\n            args = me._wrap(args, true);\n          } else {\n            args = me._wrap(args);\n          }\n\n          var transferables = args.args.__transferables__;\n          if (transferables) delete args.args.__transferables__;\n\n          me._connection.send({\n            type: \"method\",\n            name: name,\n            pid: plugin_id,\n            args: args,\n            promise: me._wrap([wrapped_resolve, wrapped_reject])\n          }, transferables);\n        } catch (e) {\n          if (id) me._method_refs.fetch(id);\n          reject(`Failed to exectue remote method (plugin: ${plugin_id || me.id}, method: ${name}), error: ${e}`);\n        }\n      });\n    };\n\n    remoteMethod.__remote_method = true;\n    return remoteMethod;\n  }\n  /**\n   * Sends a responce reporting that interface just provided by the\n   * remote site was successfully set by this site as remote\n   */\n\n\n  _reportRemoteSet() {\n    this._connection.send({\n      type: \"interfaceSetAsRemote\"\n    });\n  }\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n\n\n  _encode_interface(aObject, bObject) {\n    var v, k;\n    const encoded_interface = {};\n    aObject[\"__id__\"] = aObject[\"__id__\"] || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n\n    for (k in aObject) {\n      if (k === \"hasOwnProperty\") continue;\n\n      if (aObject.hasOwnProperty(k)) {\n        if (k.startsWith(\"_\")) {\n          continue;\n        }\n\n        v = aObject[k];\n\n        if (typeof v === \"function\") {\n          bObject[k] = {\n            __jailed_type__: \"plugin_interface\",\n            __plugin_id__: aObject[\"__id__\"],\n            __value__: k,\n            num: null\n          };\n          encoded_interface[k] = v;\n        } else if (Object(v) !== v) {\n          bObject[k] = {\n            __jailed_type__: \"argument\",\n            __value__: v\n          };\n          encoded_interface[k] = v;\n        } else if (typeof v === \"object\") {\n          bObject[k] = Array.isArray(v) ? [] : {};\n\n          this._encode_interface(v, bObject[k]);\n        }\n      }\n    }\n\n    this._plugin_interfaces[aObject[\"__id__\"]] = encoded_interface;\n\n    if (aObject.on) {\n      aObject.on(\"close\", () => {\n        delete this._plugin_interfaces[aObject[\"__id__\"]];\n      });\n    }\n  }\n\n  _encode(aObject, as_interface) {\n    var transferables = [];\n\n    if (!aObject) {\n      return aObject;\n    }\n\n    var _transfer = aObject._transfer;\n    var bObject, v, k;\n    var isarray = Array.isArray(aObject);\n    bObject = isarray ? [] : {}; //skip if already encoded\n\n    if (typeof aObject === \"object\" && aObject.__jailed_type__ && aObject.__value__) {\n      return aObject;\n    } //encode interfaces\n\n\n    if (typeof aObject === \"object\" && !Array.isArray(aObject) && (aObject.__as_interface__ || as_interface)) {\n      this._encode_interface(aObject, bObject);\n\n      return bObject;\n    }\n\n    if (as_interface) {\n      aObject[\"__id__\"] = aObject[\"__id__\"] || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n      this._plugin_interfaces[aObject[\"__id__\"]] = this._plugin_interfaces[aObject[\"__id__\"]] || {};\n    }\n\n    for (k in aObject) {\n      if (k === \"hasOwnProperty\") continue;\n\n      if (isarray || aObject.hasOwnProperty(k)) {\n        v = aObject[k];\n\n        if (typeof this._interface._rpcEncode === \"function\") {\n          const encoded_obj = this._interface._rpcEncode(v);\n\n          if (encoded_obj && encoded_obj.__rpc_dtype__) {\n            bObject[k] = {\n              __jailed_type__: \"custom_encoding\",\n              __value__: encoded_obj\n            };\n            continue;\n          } // if the returned object does not contain __jailed_type__, assuming the object has been transformed\n          else {\n              v = encoded_obj;\n            }\n        }\n\n        if (typeof v === \"function\") {\n          if (as_interface) {\n            const encoded_interface = this._plugin_interfaces[aObject[\"__id__\"]];\n            bObject[k] = {\n              __jailed_type__: \"plugin_interface\",\n              __plugin_id__: aObject[\"__id__\"],\n              __value__: k,\n              num: null\n            };\n            encoded_interface[k] = v;\n            continue;\n          }\n\n          let interfaceFuncName = null;\n\n          for (var name in this._interface) {\n            if (this._interface.hasOwnProperty(name)) {\n              if (name.startsWith(\"_\")) continue;\n\n              if (this._interface[name] === v) {\n                interfaceFuncName = name;\n                break;\n              }\n            }\n          } // search for prototypes\n\n\n          var functions = Object.getOwnPropertyNames(Object.getPrototypeOf(this._interface));\n\n          for (var i = 0; i < functions.length; i++) {\n            var name_ = functions[i];\n            if (name_.startsWith(\"_\")) continue;\n\n            if (this._interface[name_] === v) {\n              interfaceFuncName = name_;\n              break;\n            }\n          }\n\n          if (!interfaceFuncName) {\n            var id = this._store.put(v);\n\n            bObject[k] = {\n              __jailed_type__: \"callback\",\n              __value__: v.constructor && v.constructor.name || id,\n              num: id\n            };\n          } else {\n            bObject[k] = {\n              __jailed_type__: \"interface\",\n              __value__: interfaceFuncName,\n              num: null\n            };\n          }\n        } else if (\n        /*global tf*/\n        typeof tf !== \"undefined\" && tf.Tensor && v instanceof tf.Tensor) {\n          const v_buffer = v.dataSync();\n\n          if (v._transfer || _transfer) {\n            transferables.push(v_buffer.buffer);\n            delete v._transfer;\n          }\n\n          bObject[k] = {\n            __jailed_type__: \"ndarray\",\n            __value__: v_buffer,\n            __shape__: v.shape,\n            __dtype__: v.dtype\n          };\n        } else if (\n        /*global nj*/\n        typeof nj !== \"undefined\" && nj.NdArray && v instanceof nj.NdArray) {\n          var dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"][v.selection.data.constructor.name];\n\n          if (v._transfer || _transfer) {\n            transferables.push(v.selection.data.buffer);\n            delete v._transfer;\n          }\n\n          bObject[k] = {\n            __jailed_type__: \"ndarray\",\n            __value__: v.selection.data,\n            __shape__: v.shape,\n            __dtype__: dtype\n          };\n        } else if (v instanceof Error) {\n          console.error(v);\n          bObject[k] = {\n            __jailed_type__: \"error\",\n            __value__: v.toString()\n          };\n        } else if (typeof File !== \"undefined\" && v instanceof File) {\n          bObject[k] = {\n            __jailed_type__: \"file\",\n            __value__: v,\n            __relative_path__: v.relativePath || v.webkitRelativePath\n          };\n        } // send objects supported by structure clone algorithm\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n        else if (v !== Object(v) || v instanceof Boolean || v instanceof String || v instanceof Date || v instanceof RegExp || v instanceof Blob || v instanceof ImageData || typeof FileList !== \"undefined\" && v instanceof FileList) {\n            bObject[k] = {\n              __jailed_type__: \"argument\",\n              __value__: v\n            };\n          } else if (v instanceof ArrayBuffer) {\n            if (v._transfer || _transfer) {\n              transferables.push(v);\n              delete v._transfer;\n            }\n\n            bObject[k] = {\n              __jailed_type__: \"argument\",\n              __value__: v\n            };\n          } else if (v instanceof ArrayBufferView) {\n            if (v._transfer || _transfer) {\n              transferables.push(v.buffer);\n              delete v._transfer;\n            }\n\n            bObject[k] = {\n              __jailed_type__: \"argument\",\n              __value__: v\n            };\n          } // TODO: support also Map and Set\n          // TODO: avoid object such as DynamicPlugin instance.\n          else if (v.__as_interface__) {\n              bObject[k] = this._encode(v, true);\n            } else if (typeof v === \"object\" || Array.isArray(v)) {\n              bObject[k] = this._encode(v, as_interface); // move transferables to the top level object\n\n              if (bObject[k].__transferables__) {\n                for (var t = 0; t < bObject[k].__transferables__.length; t++) {\n                  transferables.push(bObject[k].__transferables__[t]);\n                }\n\n                delete bObject[k].__transferables__;\n              }\n            } else if (typeof v === \"object\" && v.constructor) {\n              throw \"Unsupported data type for transferring between the plugin and the main app: \" + k + \" : \" + v.constructor.name;\n            } else {\n              throw \"Unsupported data type for transferring between the plugin and the main app: \" + k + \",\" + v;\n            }\n      }\n    }\n\n    if (transferables.length > 0) {\n      bObject.__transferables__ = transferables;\n    }\n\n    return bObject;\n  }\n\n  _decode(aObject, callbackId, withPromise) {\n    if (!aObject) {\n      return aObject;\n    }\n\n    var bObject, v, k;\n\n    if (aObject.hasOwnProperty(\"__jailed_type__\") && aObject.hasOwnProperty(\"__value__\")) {\n      if (aObject.__jailed_type__.startsWith(\"custom_encoding\")) {\n        if (typeof this._interface._rpcDecode === \"function\") {\n          const decodedObj = this._interface._rpcDecode(aObject.__value__);\n\n          bObject = decodedObj;\n        } else {\n          bObject = aObject;\n        }\n      } else if (aObject.__jailed_type__ === \"callback\") {\n        bObject = this._genRemoteCallback(callbackId, aObject.num, withPromise);\n      } else if (aObject.__jailed_type__ === \"interface\") {\n        bObject = this._remote[aObject.__value__] || this._genRemoteMethod(aObject.__value__);\n      } else if (aObject.__jailed_type__ === \"plugin_interface\") {\n        bObject = this._genRemoteMethod(aObject.__value__, aObject.__plugin_id__);\n      } else if (aObject.__jailed_type__ === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (this.id === \"__plugin__\" && typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject.__value__)) {\n            aObject.__value__ = aObject.__value__.reduce(_appendBuffer);\n          }\n\n          bObject = nj.array(aObject.__value__, aObject.__dtype__).reshape(aObject.__shape__);\n        } else if (this.id === \"__plugin__\" && typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject.__value__)) {\n            aObject.__value__ = aObject.__value__.reduce(_appendBuffer);\n          }\n\n          bObject = tf.tensor(aObject.__value__, aObject.__shape__, aObject.__dtype__);\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject.__jailed_type__ === \"error\") {\n        bObject = new Error(aObject.__value__);\n      } else if (aObject.__jailed_type__ === \"file\") {\n        bObject = aObject.__value__; //patch relativePath\n\n        bObject.relativePath = aObject.__relative_path__;\n      } else if (aObject.__jailed_type__ === \"argument\") {\n        bObject = aObject.__value__;\n      }\n\n      return bObject;\n    } else {\n      var isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n\n      for (k in aObject) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          v = aObject[k];\n\n          if (typeof v === \"object\" || Array.isArray(v)) {\n            bObject[k] = this._decode(v, callbackId, withPromise);\n          }\n        }\n      }\n\n      return bObject;\n    }\n  }\n\n  _wrap(args, as_interface) {\n    var wrapped = this._encode(args, as_interface);\n\n    var result = {\n      args: wrapped\n    };\n    return result;\n  }\n  /**\n   * Unwraps the set of arguments delivered from the remote site,\n   * replaces all callback identifiers with a function which will\n   * initiate sending that callback identifier back to other site\n   *\n   * @param {Object} args to unwrap\n   *\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Array} unwrapped args\n   */\n\n\n  _unwrap(args, withPromise) {\n    // var called = false;\n    // wraps each callback so that the only one could be called\n    // var once(cb) {\n    //     return function() {\n    //         if (!called) {\n    //             called = true;\n    //             return cb.apply(this, arguments);\n    //         } else {\n    //             var msg =\n    //               'A callback from this set has already been executed';\n    //             throw new Error(msg);\n    //         }\n    //     };\n    // }\n    var result = this._decode(args.args, args.callbackId, withPromise);\n\n    return result;\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * callback. When the generated function is called, it will send\n   * the corresponding message to the remote site asking it to\n   * execute the particular callback previously saved during a call\n   * by the remote site a method from the interface of this site\n   *\n   * @param {Number} id of the remote callback to execute\n   * @param {Number} argNum argument index of the callback\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Function} wrapped remote callback\n   */\n\n\n  _genRemoteCallback(id, argNum, withPromise) {\n    var me = this;\n    var remoteCallback;\n\n    if (withPromise) {\n      remoteCallback = function () {\n        return new Promise((resolve, reject) => {\n          var args = me._wrap(Array.prototype.slice.call(arguments));\n\n          var transferables = args.args.__transferables__;\n          if (transferables) delete args.args.__transferables__;\n          resolve.__jailed_pairs__ = reject;\n          reject.__jailed_pairs__ = resolve;\n\n          try {\n            me._connection.send({\n              type: \"callback\",\n              id: id,\n              num: argNum,\n              args: args,\n              // pid :  me.id,\n              promise: me._wrap([resolve, reject])\n            }, transferables);\n          } catch (e) {\n            reject(`Failed to exectue remote callback (id: ${id}, argNum: ${argNum}).`);\n          }\n        });\n      };\n\n      return remoteCallback;\n    } else {\n      remoteCallback = function () {\n        var args = me._wrap(Array.prototype.slice.call(arguments));\n\n        var transferables = args.args.__transferables__;\n        if (transferables) delete args.args.__transferables__;\n        return me._connection.send({\n          type: \"callback\",\n          id: id,\n          num: argNum,\n          args: args // pid :  me.id\n\n        }, transferables);\n      };\n\n      return remoteCallback;\n    }\n  }\n  /**\n   * Sends the notification message and breaks the connection\n   */\n\n\n  disconnect() {\n    this._connection.send({\n      type: \"disconnect\"\n    });\n\n    setTimeout(this._connection.disconnect, 2000);\n  }\n  /**\n   * Set a handler to be called when received a disconnect message\n   * from the remote site\n   *\n   * @param {Function} handler\n   */\n\n\n  onDisconnect(handler) {\n    this._disconnectHandler = handler;\n  }\n\n}\n/**\n * ReferenceStore is a special object which stores other objects\n * and provides the references (number) instead. This reference\n * may then be sent over a json-based communication channel (IPC\n * to another Node.js process or a message to the Worker). Other\n * site may then provide the reference in the responce message\n * implying the given object should be activated.\n *\n * Primary usage for the ReferenceStore is a storage for the\n * callbacks, which therefore makes it possible to initiate a\n * callback execution by the opposite site (which normally cannot\n * directly execute functions over the communication channel).\n *\n * Each stored object can only be fetched once and is not\n * available for the second time. Each stored object must be\n * fetched, since otherwise it will remain stored forever and\n * consume memory.\n *\n * Stored object indeces are simply the numbers, which are however\n * released along with the objects, and are later reused again (in\n * order to postpone the overflow, which should not likely happen,\n * but anyway).\n */\n\nclass ReferenceStore {\n  constructor() {\n    this._store = {}; // stored object\n\n    this._indices = [0]; // smallest available indices\n\n    this._readyHandler = function () {};\n\n    this._busyHandler = function () {};\n\n    this._readyHandler();\n  }\n  /**\n   * call handler when the store is empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onReady(readyHandler) {\n    this._readyHandler = readyHandler || function () {};\n  }\n  /**\n   * call handler when the store is not empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onBusy(busyHandler) {\n    this._busyHandler = busyHandler || function () {};\n  }\n  /**\n   * get the length of the store\n   *\n   */\n\n\n  getStack() {\n    return Object.keys(this._store).length;\n  }\n  /**\n   * @function _genId() generates the new reference id\n   *\n   * @returns {Number} smallest available id and reserves it\n   */\n\n\n  _genId() {\n    var id;\n\n    if (this._indices.length === 1) {\n      id = this._indices[0]++;\n    } else {\n      id = this._indices.shift();\n    }\n\n    return id;\n  }\n  /**\n   * Releases the given reference id so that it will be available by\n   * another object stored\n   *\n   * @param {Number} id to release\n   */\n\n\n  _releaseId(id) {\n    for (var i = 0; i < this._indices.length; i++) {\n      if (id < this._indices[i]) {\n        this._indices.splice(i, 0, id);\n\n        break;\n      }\n    } // cleaning-up the sequence tail\n\n\n    for (i = this._indices.length - 1; i >= 0; i--) {\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\n        this._indices.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Stores the given object and returns the refernce id instead\n   *\n   * @param {Object} obj to store\n   *\n   * @returns {Number} reference id of the stored object\n   */\n\n\n  put(obj) {\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\n      this._busyHandler();\n    }\n\n    var id = this._genId();\n\n    this._store[id] = obj;\n    return id;\n  }\n  /**\n   * Retrieves previously stored object and releases its reference\n   *\n   * @param {Number} id of an object to retrieve\n   */\n\n\n  fetch(id) {\n    var obj = this._store[id];\n\n    if (obj && !obj.__remote_method) {\n      delete this._store[id];\n\n      this._releaseId(id);\n\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\n        this._readyHandler();\n      }\n    }\n\n    if (obj && obj.__jailed_pairs__) {\n      const _id = getKeyByValue(this._store, obj.__jailed_pairs__);\n\n      this.fetch(_id);\n    }\n\n    return obj;\n  }\n  /**\n   * Retrieves previously stored object\n   *\n   * @param {Number} id of an object to retrieve\n   */\n  // retrieve(id) {\n  //     var obj = this._store[id];\n  //     return obj;\n  // }\n\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcnBjLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvc3JjL3JwYy5qcz8yM2MyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udGFpbnMgdGhlIFJQQyBvYmplY3QgdXNlZCBib3RoIGJ5IHRoZSBhcHBsaWNhdGlvblxuICogc2l0ZSwgYW5kIGJ5IGVhY2ggcGx1Z2luXG4gKi9cbmltcG9ydCB7IHJhbmRJZCwgdHlwZWRBcnJheVRvRHR5cGUgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuXG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT04gPSBcIjAuMi4wXCI7XG5cbmNvbnN0IEFycmF5QnVmZmVyVmlldyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihcbiAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBVaW50OEFycmF5KCkpXG4pLmNvbnN0cnVjdG9yO1xuXG5mdW5jdGlvbiBfYXBwZW5kQnVmZmVyKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcbiAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcbiAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIxKSwgMCk7XG4gIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMiksIGJ1ZmZlcjEuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB0bXAuYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlCeVZhbHVlKG9iamVjdCwgdmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkuZmluZChrZXkgPT4gb2JqZWN0W2tleV0gPT09IHZhbHVlKTtcbn1cbi8qKlxuICogUlBDIG9iamVjdCByZXByZXNlbnRzIGEgc2luZ2xlIHNpdGUgaW4gdGhlXG4gKiBjb21tdW5pY2F0aW9uIHByb3RvY29sIGJldHdlZW4gdGhlIGFwcGxpY2F0aW9uIGFuZCB0aGUgcGx1Z2luXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb24gYSBzcGVjaWFsIG9iamVjdCBhbGxvd2luZyB0byBzZW5kXG4gKiBhbmQgcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIHRoZSBvcHBvc2l0ZSBzaXRlIChiYXNpY2FsbHkgaXRcbiAqIHNob3VsZCBvbmx5IHByb3ZpZGUgc2VuZCgpIGFuZCBvbk1lc3NhZ2UoKSBtZXRob2RzKVxuICovXG5leHBvcnQgY2xhc3MgUlBDIHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgY29uZmlnKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgdGhpcy5faW50ZXJmYWNlID0ge307XG4gICAgdGhpcy5fcGx1Z2luX2ludGVyZmFjZXMgPSB7fTtcbiAgICB0aGlzLl9yZW1vdGUgPSBudWxsO1xuICAgIHRoaXMuX3JlbW90ZVVwZGF0ZUhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX2dldEludGVyZmFjZUhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX2ludGVyZmFjZVNldEFzUmVtb3RlSGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5fZGlzY29ubmVjdEhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX3N0b3JlID0gbmV3IFJlZmVyZW5jZVN0b3JlKCk7XG4gICAgdGhpcy5fbWV0aG9kX3JlZnMgPSBuZXcgUmVmZXJlbmNlU3RvcmUoKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICBsZXQgbWUgPSB0aGlzO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub25NZXNzYWdlKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIG1lLl9wcm9jZXNzTWVzc2FnZShkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSByZW1vdGUgc2l0ZSB1cGRhdGVzIGl0c1xuICAgKiBpbnRlcmZhY2VcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb25SZW1vdGVVcGRhdGUoaGFuZGxlcikge1xuICAgIHRoaXMuX3JlbW90ZVVwZGF0ZUhhbmRsZXIgPSBoYW5kbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHdoZW4gcmVjZWl2ZWQgYSByZXNwb25jZSBmcm9tIHRoZVxuICAgKiByZW1vdGUgc2l0ZSByZXBvcnRpbmcgdGhhdCB0aGUgcHJldmlvdXNseSBwcm92aWRlZCBpbnRlcmZhY2VcbiAgICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHNldCBhcyByZW1vdGUgZm9yIHRoYXQgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuXG4gIG9uUmVtb3RlUmVhZHkoaGFuZGxlcikge1xuICAgIHRoaXMuX21ldGhvZF9yZWZzLm9uUmVhZHkoaGFuZGxlcik7XG4gIH1cblxuICBvblJlbW90ZUJ1c3koaGFuZGxlcikge1xuICAgIHRoaXMuX21ldGhvZF9yZWZzLm9uQnVzeShoYW5kbGVyKTtcbiAgfVxuXG4gIGdldFJlbW90ZUNhbGxTdGFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0aG9kX3JlZnMuZ2V0U3RhY2soKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgaGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgcmVtb3RlIHNpdGUgcmVxdWVzdHMgdG9cbiAgICogKHJlKXNlbmQgdGhlIGludGVyZmFjZS4gVXNlZCB0byBkZXRlY3QgYW4gaW5pdGlhbHphdGlvblxuICAgKiBjb21wbGV0aW9uIHdpdGhvdXQgc2VuZGluZyBhZGRpdGlvbmFsIHJlcXVlc3QsIHNpbmNlIGluIGZhY3RcbiAgICogJ2dldEludGVyZmFjZScgcmVxdWVzdCBpcyBvbmx5IHNlbnQgYnkgYXBwbGljYXRpb24gYXQgdGhlIGxhc3RcbiAgICogc3RlcCBvZiB0aGUgcGx1Z2luIGluaXRpYWxpemF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9uR2V0SW50ZXJmYWNlKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9nZXRJbnRlcmZhY2VIYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzZXQgb2YgcmVtb3RlIGludGVyZmFjZSBtZXRob2RzXG4gICAqL1xuICBnZXRSZW1vdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW90ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBzaXRlIG1ha2luZyBpdCBhdmFpbGFibGUgdG8gdGhlXG4gICAqIHJlbW90ZSBzaXRlIGJ5IHNlbmRpbmcgYSBtZXNzYWdlIHdpdGggYSBzZXQgb2YgbWV0aG9kcyBuYW1lc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gX2ludGVyZmFjZSB0byBzZXRcbiAgICovXG4gIHNldEludGVyZmFjZShfaW50ZXJmYWNlKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBmdW5jX25hbWUgb2YgdGhpcy5jb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbW90ZVtmdW5jX25hbWVdKSB7XG4gICAgICAgICAgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlW2Z1bmNfbmFtZV0pIHtcbiAgICAgICAgICAgICAgX2ludGVyZmFjZVtmdW5jX25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdGVbZnVuY19uYW1lXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIV9pbnRlcmZhY2UuY29uc3RydWN0b3IucHJvdG90eXBlW2Z1bmNfbmFtZV0pIHtcbiAgICAgICAgICAgICAgX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbZnVuY19uYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3RlW2Z1bmNfbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVyZmFjZSA9IF9pbnRlcmZhY2U7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgdGhlIGFjdHVhbCBpbnRlcmZhY2UgdG8gdGhlIHJlbW90ZSBzaXRlIHVwb24gaXQgd2FzXG4gICAqIHVwZGF0ZWQgb3IgYnkgYSBzcGVjaWFsIHJlcXVlc3Qgb2YgdGhlIHJlbW90ZSBzaXRlXG4gICAqL1xuICBzZW5kSW50ZXJmYWNlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLl9pbnRlcmZhY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJmYWNlIGlzIG5vdCBzZXQuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2ludGVyZmFjZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgb2YgT2JqZWN0LmtleXModGhpcy5faW50ZXJmYWNlKSkge1xuICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfXCIpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ludGVyZmFjZVtuYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKHsgbmFtZTogbmFtZSwgZGF0YTogbnVsbCwgdHlwZTogXCJmdW5jdGlvblwiIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2ludGVyZmFjZVtuYW1lXTtcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSBudWxsICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhMiA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBrIG9mIE9iamVjdC5rZXlzKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2tdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEyW2tdID0gXCJycGNfbWV0aG9kOjpcIiArIGs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEyW2tdID0gZGF0YVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmFtZXMucHVzaCh7IG5hbWU6IG5hbWUsIGRhdGE6IGRhdGEyLCB0eXBlOiBcIm9iamVjdFwiIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QoZGF0YSkgIT09IGRhdGEpIHtcbiAgICAgICAgICAgICAgbmFtZXMucHVzaCh7IG5hbWU6IG5hbWUsIGRhdGE6IGRhdGEsIHR5cGU6IFwiZGF0YVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYSBjbGFzc1xuICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJmYWNlLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgaW5zdGFudGlhdGUgdGhlIGNsYXNzIGJlZm9yZSBleHBvcnR0aW5nIGl0LlwiKTtcbiAgICAgIH1cbiAgICAgIC8vIGluc3RhbmNlIG9mIGEgY2xhc3NcbiAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFxuICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLl9pbnRlcmZhY2UpXG4gICAgICAgICkuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMuX2ludGVyZmFjZSkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuYW1lXyA9IGZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICBpZiAobmFtZV8uc3RhcnRzV2l0aChcIl9cIikgfHwgbmFtZV8gPT09IFwiY29uc3RydWN0b3JcIikgY29udGludWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pbnRlcmZhY2VbbmFtZV9dID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goeyBuYW1lOiBuYW1lXywgZGF0YTogbnVsbCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgaW50ZXJmYWNlIHR5cGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnRlcmZhY2VTZXRBc1JlbW90ZUhhbmRsZXIgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kKHsgdHlwZTogXCJzZXRJbnRlcmZhY2VcIiwgYXBpOiBuYW1lcyB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgbWVzc2FnZSBmcm9tIHRoZSByZW1vdGUgc2l0ZVxuICAgKi9cbiAgLy8gdmFyIGNhbGxiYWNrX3JlZyA9IG5ldyBSZWdFeHAoXCJvbnVwZGF0ZXxydW4kXCIpXG4gIF9wcm9jZXNzTWVzc2FnZShkYXRhKSB7XG4gICAgdmFyIHJlc29sdmUsIHJlamVjdCwgbWV0aG9kLCBhcmdzLCByZXN1bHQ7XG4gICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJtZXRob2RcIjpcbiAgICAgICAgdmFyIF9pbnRlcmZhY2UgPSB0aGlzLl9pbnRlcmZhY2U7XG4gICAgICAgIHZhciBfbWV0aG9kX2NvbnRleHQgPSBfaW50ZXJmYWNlLl9fdGhpc19fIHx8IF9pbnRlcmZhY2U7XG4gICAgICAgIGlmIChkYXRhLnBpZCkge1xuICAgICAgICAgIF9pbnRlcmZhY2UgPSB0aGlzLl9wbHVnaW5faW50ZXJmYWNlc1tkYXRhLnBpZF07XG4gICAgICAgICAgaWYgKCFfaW50ZXJmYWNlKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgICAgICAgIFtyZXNvbHZlLCByZWplY3RdID0gdGhpcy5fdW53cmFwKGRhdGEucHJvbWlzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgYHBsdWdpbiBhcGkgZnVuY3Rpb24gaXMgbm90IGF2YWlhbGJlIGluIFwiJHtkYXRhLnBpZH1cIiwgdGhlIHBsdWdpbiBtYXliZSB0ZXJtaW5hdGVkLmBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgYHBsdWdpbiBhcGkgZnVuY3Rpb24gaXMgbm90IGF2YWlhbGJlIGluICR7ZGF0YS5waWR9LCB0aGUgcGx1Z2luIG1heWJlIHRlcm1pbmF0ZWQuYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5uYW1lLmluZGV4T2YoXCIuXCIpICE9PSAtMSkge1xuICAgICAgICAgIHZhciBuYW1lcyA9IGRhdGEubmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgbWV0aG9kID0gX2ludGVyZmFjZVtuYW1lc1swXV1bbmFtZXNbMV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZCA9IF9pbnRlcmZhY2VbZGF0YS5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzID0gdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcbiAgICAgICAgICBbcmVzb2x2ZSwgcmVqZWN0XSA9IHRoaXMuX3Vud3JhcChkYXRhLnByb21pc2UsIGZhbHNlKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KF9tZXRob2RfY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAgIG1ldGhvZC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFzeW5jRnVuY3Rpb25cIilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgbWV0aG9kKTtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseShfbWV0aG9kX2NvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjYWxsYmFja1wiOlxuICAgICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgICAgW3Jlc29sdmUsIHJlamVjdF0gPSB0aGlzLl91bndyYXAoZGF0YS5wcm9taXNlLCBmYWxzZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1ldGhvZCA9IHRoaXMuX3N0b3JlLmZldGNoKGRhdGEubnVtKTtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiQ2FsbGJhY2sgZnVuY3Rpb24gY2FuIG9ubHkgY2FsbGVkIG9uY2UsIGlmIHlvdSB3YW50IHRvIGNhbGwgYSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgdGltZXMsIHBsZWFzZSBtYWtlIGl0IGFzIGEgcGx1Z2luIGFwaSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vaW1qb3kuaW8vZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlIHx8XG4gICAgICAgICAgICAgIChtZXRob2QuY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIG1ldGhvZCk7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZXRob2QgPSB0aGlzLl9zdG9yZS5mZXRjaChkYXRhLm51bSk7XG4gICAgICAgICAgICBhcmdzID0gdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgICB0aHJvdyBcIlBsZWFzZSBub3RpY2UgdGhhdCBjYWxsYmFjayBmdW5jdGlvbiBjYW4gb25seSBjYWxsZWQgb25jZSwgaWYgeW91IHdhbnQgdG8gY2FsbCBhIGZ1bmN0aW9uIGZvciBtdWx0aXBsZSB0aW1lcywgcGxlYXNlIG1ha2UgaXQgYXMgYSBwbHVnaW4gYXBpIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9pbWpveS5pby9kb2NzIGZvciBtb3JlIGRldGFpbHMuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZXRJbnRlcmZhY2VcIjpcbiAgICAgICAgdGhpcy5fc2V0UmVtb3RlKGRhdGEuYXBpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZ2V0SW50ZXJmYWNlXCI6XG4gICAgICAgIHRoaXMuc2VuZEludGVyZmFjZSgpO1xuICAgICAgICB0aGlzLl9nZXRJbnRlcmZhY2VIYW5kbGVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludGVyZmFjZVNldEFzUmVtb3RlXCI6XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faW50ZXJmYWNlU2V0QXNSZW1vdGVIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLl9pbnRlcmZhY2VTZXRBc1JlbW90ZUhhbmRsZXIoKTtcbiAgICAgICAgICB0aGlzLl9pbnRlcmZhY2VTZXRBc1JlbW90ZUhhbmRsZXIgPT09IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzY29ubmVjdFwiOlxuICAgICAgICB0aGlzLl9kaXNjb25uZWN0SGFuZGxlcigpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdHMgdG8gdGhlIHJlbW90ZSBzaXRlIGFza2luZyBpdCB0byBwcm92aWRlIGl0c1xuICAgKiBjdXJyZW50IGludGVyZmFjZVxuICAgKi9cbiAgcmVxdWVzdFJlbW90ZSgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLnNlbmQoeyB0eXBlOiBcImdldEludGVyZmFjZVwiIH0pO1xuICB9XG5cbiAgX25kYXJyYXkodHlwZWRBcnJheSwgc2hhcGUsIGR0eXBlKSB7XG4gICAgdmFyIF9kdHlwZSA9IHR5cGVkQXJyYXlUb0R0eXBlW3R5cGVkQXJyYXkuY29uc3RydWN0b3IubmFtZV07XG4gICAgaWYgKGR0eXBlICYmIGR0eXBlICE9PSBfZHR5cGUpIHtcbiAgICAgIHRocm93IFwiZHR5cGUgZG9lc24ndCBtYXRjaCB0aGUgdHlwZSBvZiB0aGUgYXJyYXk6IFwiICtcbiAgICAgICAgX2R0eXBlICtcbiAgICAgICAgXCIgIT0gXCIgK1xuICAgICAgICBkdHlwZTtcbiAgICB9XG4gICAgc2hhcGUgPSBzaGFwZSB8fCBbdHlwZWRBcnJheS5sZW5ndGhdO1xuICAgIHJldHVybiB7XG4gICAgICBfX2phaWxlZF90eXBlX186IFwibmRhcnJheVwiLFxuICAgICAgX192YWx1ZV9fOiB0eXBlZEFycmF5LFxuICAgICAgX19zaGFwZV9fOiBzaGFwZSxcbiAgICAgIF9fZHR5cGVfXzogX2R0eXBlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuZXcgcmVtb3RlIGludGVyZmFjZSBwcm92aWRlZCBieSB0aGUgb3RoZXIgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBsaXN0IG9mIGZ1bmN0aW9uIG5hbWVzXG4gICAqL1xuICBfc2V0UmVtb3RlKGFwaSkge1xuICAgIHRoaXMuX3JlbW90ZSA9IHt9O1xuICAgIHZhciBpLCBuYW1lLCBkYXRhLCB0eXBlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcGkubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWUgPSBhcGlbaV0ubmFtZTtcbiAgICAgIGRhdGEgPSBhcGlbaV0uZGF0YTtcbiAgICAgIHR5cGUgPSBhcGlbaV0udHlwZTtcbiAgICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgICB0aGlzLl9yZW1vdGVbbmFtZV0gPSBkYXRhO1xuICAgICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHZhciBkYXRhMiA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhW2tleV0gPT09IFwicnBjX21ldGhvZDo6XCIgKyBrZXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhMltrZXldID0gdGhpcy5fZ2VuUmVtb3RlTWV0aG9kKG5hbWUgKyBcIi5cIiArIGtleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YTJba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZW1vdGVbbmFtZV0gPSBkYXRhMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdGVbbmFtZV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdGVbbmFtZV0gPSB0aGlzLl9nZW5SZW1vdGVNZXRob2QobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcmVtb3RlVXBkYXRlSGFuZGxlcigpO1xuICAgIHRoaXMuX3JlcG9ydFJlbW90ZVNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgd3JhcHBlZCBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIHJlbW90ZVxuICAgKiBtZXRob2QuIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZCB0aGVcbiAgICogY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG8gZXhlY3V0ZVxuICAgKiB0aGUgcGFydGljdWxhciBtZXRob2Qgb2YgaXRzIGludGVyZmFjZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgcmVtb3RlIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgcmVtb3RlIG1ldGhvZFxuICAgKi9cbiAgX2dlblJlbW90ZU1ldGhvZChuYW1lLCBwbHVnaW5faWQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZW1vdGVNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWQgPSBtZS5fbWV0aG9kX3JlZnMucHV0KHBsdWdpbl9pZCA/IHBsdWdpbl9pZCArIFwiL1wiICsgbmFtZSA6IG5hbWUpO1xuICAgICAgICAgIHZhciB3cmFwcGVkX3Jlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gbnVsbCkgbWUuX21ldGhvZF9yZWZzLmZldGNoKGlkKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgd3JhcHBlZF9yZWplY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gbnVsbCkgbWUuX21ldGhvZF9yZWZzLmZldGNoKGlkKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgd3JhcHBlZF9yZXNvbHZlLl9famFpbGVkX3BhaXJzX18gPSB3cmFwcGVkX3JlamVjdDtcbiAgICAgICAgICB3cmFwcGVkX3JlamVjdC5fX2phaWxlZF9wYWlyc19fID0gd3JhcHBlZF9yZXNvbHZlO1xuXG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChuYW1lID09PSBcInJlZ2lzdGVyXCIgfHwgbmFtZSA9PT0gXCJleHBvcnRcIiB8fCBuYW1lID09PSBcIm9uXCIpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBtZS5fd3JhcChhcmdzLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncyA9IG1lLl93cmFwKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICBtZS5fY29ubmVjdGlvbi5zZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcIm1ldGhvZFwiLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBwaWQ6IHBsdWdpbl9pZCxcbiAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgcHJvbWlzZTogbWUuX3dyYXAoW3dyYXBwZWRfcmVzb2x2ZSwgd3JhcHBlZF9yZWplY3RdKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXNcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGlkKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3R1ZSByZW1vdGUgbWV0aG9kIChwbHVnaW46ICR7cGx1Z2luX2lkIHx8XG4gICAgICAgICAgICAgIG1lLmlkfSwgbWV0aG9kOiAke25hbWV9KSwgZXJyb3I6ICR7ZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZW1vdGVNZXRob2QuX19yZW1vdGVfbWV0aG9kID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVtb3RlTWV0aG9kO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVzcG9uY2UgcmVwb3J0aW5nIHRoYXQgaW50ZXJmYWNlIGp1c3QgcHJvdmlkZWQgYnkgdGhlXG4gICAqIHJlbW90ZSBzaXRlIHdhcyBzdWNjZXNzZnVsbHkgc2V0IGJ5IHRoaXMgc2l0ZSBhcyByZW1vdGVcbiAgICovXG4gIF9yZXBvcnRSZW1vdGVTZXQoKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kKHsgdHlwZTogXCJpbnRlcmZhY2VTZXRBc1JlbW90ZVwiIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSBwcm92aWRlZCBzZXQgb2YgcmVtb3RlIG1ldGhvZCBhcmd1bWVudHMgZm9yXG4gICAqIHNlbmRpbmcgdG8gdGhlIHJlbW90ZSBzaXRlLCByZXBsYWNlcyBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoXG4gICAqIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdG8gd3JhcFxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHdyYXBwZWQgYXJndW1lbnRzXG4gICAqL1xuXG4gIF9lbmNvZGVfaW50ZXJmYWNlKGFPYmplY3QsIGJPYmplY3QpIHtcbiAgICB2YXIgdiwgaztcbiAgICBjb25zdCBlbmNvZGVkX2ludGVyZmFjZSA9IHt9O1xuICAgIGFPYmplY3RbXCJfX2lkX19cIl0gPSBhT2JqZWN0W1wiX19pZF9fXCJdIHx8IHJhbmRJZCgpO1xuICAgIGZvciAoayBpbiBhT2JqZWN0KSB7XG4gICAgICBpZiAoayA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiKSBjb250aW51ZTtcbiAgICAgIGlmIChhT2JqZWN0Lmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgIGlmIChrLnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdiA9IGFPYmplY3Rba107XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBiT2JqZWN0W2tdID0ge1xuICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcInBsdWdpbl9pbnRlcmZhY2VcIixcbiAgICAgICAgICAgIF9fcGx1Z2luX2lkX186IGFPYmplY3RbXCJfX2lkX19cIl0sXG4gICAgICAgICAgICBfX3ZhbHVlX186IGssXG4gICAgICAgICAgICBudW06IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVuY29kZWRfaW50ZXJmYWNlW2tdID0gdjtcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QodikgIT09IHYpIHtcbiAgICAgICAgICBiT2JqZWN0W2tdID0geyBfX2phaWxlZF90eXBlX186IFwiYXJndW1lbnRcIiwgX192YWx1ZV9fOiB2IH07XG4gICAgICAgICAgZW5jb2RlZF9pbnRlcmZhY2Vba10gPSB2O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IEFycmF5LmlzQXJyYXkodikgPyBbXSA6IHt9O1xuICAgICAgICAgIHRoaXMuX2VuY29kZV9pbnRlcmZhY2UodiwgYk9iamVjdFtrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcGx1Z2luX2ludGVyZmFjZXNbYU9iamVjdFtcIl9faWRfX1wiXV0gPSBlbmNvZGVkX2ludGVyZmFjZTtcblxuICAgIGlmIChhT2JqZWN0Lm9uKSB7XG4gICAgICBhT2JqZWN0Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fcGx1Z2luX2ludGVyZmFjZXNbYU9iamVjdFtcIl9faWRfX1wiXV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZW5jb2RlKGFPYmplY3QsIGFzX2ludGVyZmFjZSkge1xuICAgIHZhciB0cmFuc2ZlcmFibGVzID0gW107XG4gICAgaWYgKCFhT2JqZWN0KSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG4gICAgdmFyIF90cmFuc2ZlciA9IGFPYmplY3QuX3RyYW5zZmVyO1xuICAgIHZhciBiT2JqZWN0LCB2LCBrO1xuICAgIHZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheShhT2JqZWN0KTtcbiAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgLy9za2lwIGlmIGFscmVhZHkgZW5jb2RlZFxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBhT2JqZWN0ID09PSBcIm9iamVjdFwiICYmXG4gICAgICBhT2JqZWN0Ll9famFpbGVkX3R5cGVfXyAmJlxuICAgICAgYU9iamVjdC5fX3ZhbHVlX19cbiAgICApIHtcbiAgICAgIHJldHVybiBhT2JqZWN0O1xuICAgIH1cblxuICAgIC8vZW5jb2RlIGludGVyZmFjZXNcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgYU9iamVjdCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgIUFycmF5LmlzQXJyYXkoYU9iamVjdCkgJiZcbiAgICAgIChhT2JqZWN0Ll9fYXNfaW50ZXJmYWNlX18gfHwgYXNfaW50ZXJmYWNlKVxuICAgICkge1xuICAgICAgdGhpcy5fZW5jb2RlX2ludGVyZmFjZShhT2JqZWN0LCBiT2JqZWN0KTtcbiAgICAgIHJldHVybiBiT2JqZWN0O1xuICAgIH1cblxuICAgIGlmIChhc19pbnRlcmZhY2UpIHtcbiAgICAgIGFPYmplY3RbXCJfX2lkX19cIl0gPSBhT2JqZWN0W1wiX19pZF9fXCJdIHx8IHJhbmRJZCgpO1xuICAgICAgdGhpcy5fcGx1Z2luX2ludGVyZmFjZXNbYU9iamVjdFtcIl9faWRfX1wiXV0gPVxuICAgICAgICB0aGlzLl9wbHVnaW5faW50ZXJmYWNlc1thT2JqZWN0W1wiX19pZF9fXCJdXSB8fCB7fTtcbiAgICB9XG4gICAgZm9yIChrIGluIGFPYmplY3QpIHtcbiAgICAgIGlmIChrID09PSBcImhhc093blByb3BlcnR5XCIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGlzYXJyYXkgfHwgYU9iamVjdC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICB2ID0gYU9iamVjdFtrXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pbnRlcmZhY2UuX3JwY0VuY29kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZF9vYmogPSB0aGlzLl9pbnRlcmZhY2UuX3JwY0VuY29kZSh2KTtcbiAgICAgICAgICBpZiAoZW5jb2RlZF9vYmogJiYgZW5jb2RlZF9vYmouX19ycGNfZHR5cGVfXykge1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcImN1c3RvbV9lbmNvZGluZ1wiLFxuICAgICAgICAgICAgICBfX3ZhbHVlX186IGVuY29kZWRfb2JqXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHRoZSByZXR1cm5lZCBvYmplY3QgZG9lcyBub3QgY29udGFpbiBfX2phaWxlZF90eXBlX18sIGFzc3VtaW5nIHRoZSBvYmplY3QgaGFzIGJlZW4gdHJhbnNmb3JtZWRcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYgPSBlbmNvZGVkX29iajtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAoYXNfaW50ZXJmYWNlKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkX2ludGVyZmFjZSA9IHRoaXMuX3BsdWdpbl9pbnRlcmZhY2VzW1xuICAgICAgICAgICAgICBhT2JqZWN0W1wiX19pZF9fXCJdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgICAgX19qYWlsZWRfdHlwZV9fOiBcInBsdWdpbl9pbnRlcmZhY2VcIixcbiAgICAgICAgICAgICAgX19wbHVnaW5faWRfXzogYU9iamVjdFtcIl9faWRfX1wiXSxcbiAgICAgICAgICAgICAgX192YWx1ZV9fOiBrLFxuICAgICAgICAgICAgICBudW06IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbmNvZGVkX2ludGVyZmFjZVtrXSA9IHY7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGludGVyZmFjZUZ1bmNOYW1lID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX2ludGVyZmFjZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiX1wiKSkgY29udGludWU7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcmZhY2VbbmFtZV0gPT09IHYpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmZhY2VGdW5jTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2VhcmNoIGZvciBwcm90b3R5cGVzXG4gICAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuX2ludGVyZmFjZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8gPSBmdW5jdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAobmFtZV8uc3RhcnRzV2l0aChcIl9cIikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVyZmFjZVtuYW1lX10gPT09IHYpIHtcbiAgICAgICAgICAgICAgaW50ZXJmYWNlRnVuY05hbWUgPSBuYW1lXztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaW50ZXJmYWNlRnVuY05hbWUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX3N0b3JlLnB1dCh2KTtcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgICBfX3ZhbHVlX186ICh2LmNvbnN0cnVjdG9yICYmIHYuY29uc3RydWN0b3IubmFtZSkgfHwgaWQsXG4gICAgICAgICAgICAgIG51bTogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJpbnRlcmZhY2VcIixcbiAgICAgICAgICAgICAgX192YWx1ZV9fOiBpbnRlcmZhY2VGdW5jTmFtZSxcbiAgICAgICAgICAgICAgbnVtOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvKmdsb2JhbCB0ZiovXG4gICAgICAgICAgdHlwZW9mIHRmICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgdGYuVGVuc29yICYmXG4gICAgICAgICAgdiBpbnN0YW5jZW9mIHRmLlRlbnNvclxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCB2X2J1ZmZlciA9IHYuZGF0YVN5bmMoKTtcbiAgICAgICAgICBpZiAodi5fdHJhbnNmZXIgfHwgX3RyYW5zZmVyKSB7XG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2godl9idWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB2Ll90cmFuc2ZlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJuZGFycmF5XCIsXG4gICAgICAgICAgICBfX3ZhbHVlX186IHZfYnVmZmVyLFxuICAgICAgICAgICAgX19zaGFwZV9fOiB2LnNoYXBlLFxuICAgICAgICAgICAgX19kdHlwZV9fOiB2LmR0eXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvKmdsb2JhbCBuaiovXG4gICAgICAgICAgdHlwZW9mIG5qICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgbmouTmRBcnJheSAmJlxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBuai5OZEFycmF5XG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBkdHlwZSA9IHR5cGVkQXJyYXlUb0R0eXBlW3Yuc2VsZWN0aW9uLmRhdGEuY29uc3RydWN0b3IubmFtZV07XG4gICAgICAgICAgaWYgKHYuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHYuc2VsZWN0aW9uLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB2Ll90cmFuc2ZlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJuZGFycmF5XCIsXG4gICAgICAgICAgICBfX3ZhbHVlX186IHYuc2VsZWN0aW9uLmRhdGEsXG4gICAgICAgICAgICBfX3NoYXBlX186IHYuc2hhcGUsXG4gICAgICAgICAgICBfX2R0eXBlX186IGR0eXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHYpO1xuICAgICAgICAgIGJPYmplY3Rba10gPSB7IF9famFpbGVkX3R5cGVfXzogXCJlcnJvclwiLCBfX3ZhbHVlX186IHYudG9TdHJpbmcoKSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHYgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgIF9famFpbGVkX3R5cGVfXzogXCJmaWxlXCIsXG4gICAgICAgICAgICBfX3ZhbHVlX186IHYsXG4gICAgICAgICAgICBfX3JlbGF0aXZlX3BhdGhfXzogdi5yZWxhdGl2ZVBhdGggfHwgdi53ZWJraXRSZWxhdGl2ZVBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlbmQgb2JqZWN0cyBzdXBwb3J0ZWQgYnkgc3RydWN0dXJlIGNsb25lIGFsZ29yaXRobVxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1dvcmtlcnNfQVBJL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtXG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIHYgIT09IE9iamVjdCh2KSB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgICAgICAgdiBpbnN0YW5jZW9mIFN0cmluZyB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgdiBpbnN0YW5jZW9mIFJlZ0V4cCB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBCbG9iIHx8XG4gICAgICAgICAgdiBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fFxuICAgICAgICAgICh0eXBlb2YgRmlsZUxpc3QgIT09IFwidW5kZWZpbmVkXCIgJiYgdiBpbnN0YW5jZW9mIEZpbGVMaXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICBiT2JqZWN0W2tdID0geyBfX2phaWxlZF90eXBlX186IFwiYXJndW1lbnRcIiwgX192YWx1ZV9fOiB2IH07XG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgaWYgKHYuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHYpO1xuICAgICAgICAgICAgZGVsZXRlIHYuX3RyYW5zZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiT2JqZWN0W2tdID0geyBfX2phaWxlZF90eXBlX186IFwiYXJndW1lbnRcIiwgX192YWx1ZV9fOiB2IH07XG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyVmlldykge1xuICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh2LmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7IF9famFpbGVkX3R5cGVfXzogXCJhcmd1bWVudFwiLCBfX3ZhbHVlX186IHYgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFsc28gTWFwIGFuZCBTZXRcbiAgICAgICAgLy8gVE9ETzogYXZvaWQgb2JqZWN0IHN1Y2ggYXMgRHluYW1pY1BsdWdpbiBpbnN0YW5jZS5cbiAgICAgICAgZWxzZSBpZiAodi5fX2FzX2ludGVyZmFjZV9fKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHRoaXMuX2VuY29kZSh2LCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHRoaXMuX2VuY29kZSh2LCBhc19pbnRlcmZhY2UpO1xuICAgICAgICAgIC8vIG1vdmUgdHJhbnNmZXJhYmxlcyB0byB0aGUgdG9wIGxldmVsIG9iamVjdFxuICAgICAgICAgIGlmIChiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGJPYmplY3Rba10uX190cmFuc2ZlcmFibGVzX18ubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGJPYmplY3Rba10uX190cmFuc2ZlcmFibGVzX19bdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGJPYmplY3Rba10uX190cmFuc2ZlcmFibGVzX187XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICB0aHJvdyBcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBmb3IgdHJhbnNmZXJyaW5nIGJldHdlZW4gdGhlIHBsdWdpbiBhbmQgdGhlIG1haW4gYXBwOiBcIiArXG4gICAgICAgICAgICBrICtcbiAgICAgICAgICAgIFwiIDogXCIgK1xuICAgICAgICAgICAgdi5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIGZvciB0cmFuc2ZlcnJpbmcgYmV0d2VlbiB0aGUgcGx1Z2luIGFuZCB0aGUgbWFpbiBhcHA6IFwiICtcbiAgICAgICAgICAgIGsgK1xuICAgICAgICAgICAgXCIsXCIgK1xuICAgICAgICAgICAgdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBiT2JqZWN0Ll9fdHJhbnNmZXJhYmxlc19fID0gdHJhbnNmZXJhYmxlcztcbiAgICB9XG4gICAgcmV0dXJuIGJPYmplY3Q7XG4gIH1cblxuICBfZGVjb2RlKGFPYmplY3QsIGNhbGxiYWNrSWQsIHdpdGhQcm9taXNlKSB7XG4gICAgaWYgKCFhT2JqZWN0KSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG4gICAgdmFyIGJPYmplY3QsIHYsIGs7XG5cbiAgICBpZiAoXG4gICAgICBhT2JqZWN0Lmhhc093blByb3BlcnR5KFwiX19qYWlsZWRfdHlwZV9fXCIpICYmXG4gICAgICBhT2JqZWN0Lmhhc093blByb3BlcnR5KFwiX192YWx1ZV9fXCIpXG4gICAgKSB7XG4gICAgICBpZiAoYU9iamVjdC5fX2phaWxlZF90eXBlX18uc3RhcnRzV2l0aChcImN1c3RvbV9lbmNvZGluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ludGVyZmFjZS5fcnBjRGVjb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBkZWNvZGVkT2JqID0gdGhpcy5faW50ZXJmYWNlLl9ycGNEZWNvZGUoYU9iamVjdC5fX3ZhbHVlX18pO1xuICAgICAgICAgIGJPYmplY3QgPSBkZWNvZGVkT2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX19qYWlsZWRfdHlwZV9fID09PSBcImNhbGxiYWNrXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX2dlblJlbW90ZUNhbGxiYWNrKGNhbGxiYWNrSWQsIGFPYmplY3QubnVtLCB3aXRoUHJvbWlzZSk7XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX19qYWlsZWRfdHlwZV9fID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgIGJPYmplY3QgPVxuICAgICAgICAgIHRoaXMuX3JlbW90ZVthT2JqZWN0Ll9fdmFsdWVfX10gfHxcbiAgICAgICAgICB0aGlzLl9nZW5SZW1vdGVNZXRob2QoYU9iamVjdC5fX3ZhbHVlX18pO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9famFpbGVkX3R5cGVfXyA9PT0gXCJwbHVnaW5faW50ZXJmYWNlXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX2dlblJlbW90ZU1ldGhvZChcbiAgICAgICAgICBhT2JqZWN0Ll9fdmFsdWVfXyxcbiAgICAgICAgICBhT2JqZWN0Ll9fcGx1Z2luX2lkX19cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fX2phaWxlZF90eXBlX18gPT09IFwibmRhcnJheVwiKSB7XG4gICAgICAgIC8qZ2xvYmFsIG5qIHRmKi9cbiAgICAgICAgLy9jcmVhdGUgYnVpbGQgYXJyYXkvdGVuc29yIGlmIHVzZWQgaW4gdGhlIHBsdWdpblxuICAgICAgICBpZiAodGhpcy5pZCA9PT0gXCJfX3BsdWdpbl9fXCIgJiYgdHlwZW9mIG5qICE9PSBcInVuZGVmaW5lZFwiICYmIG5qLmFycmF5KSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYU9iamVjdC5fX3ZhbHVlX18pKSB7XG4gICAgICAgICAgICBhT2JqZWN0Ll9fdmFsdWVfXyA9IGFPYmplY3QuX192YWx1ZV9fLnJlZHVjZShfYXBwZW5kQnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYk9iamVjdCA9IG5qXG4gICAgICAgICAgICAuYXJyYXkoYU9iamVjdC5fX3ZhbHVlX18sIGFPYmplY3QuX19kdHlwZV9fKVxuICAgICAgICAgICAgLnJlc2hhcGUoYU9iamVjdC5fX3NoYXBlX18pO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHRoaXMuaWQgPT09IFwiX19wbHVnaW5fX1wiICYmXG4gICAgICAgICAgdHlwZW9mIHRmICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgdGYuVGVuc29yXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFPYmplY3QuX192YWx1ZV9fKSkge1xuICAgICAgICAgICAgYU9iamVjdC5fX3ZhbHVlX18gPSBhT2JqZWN0Ll9fdmFsdWVfXy5yZWR1Y2UoX2FwcGVuZEJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3QgPSB0Zi50ZW5zb3IoXG4gICAgICAgICAgICBhT2JqZWN0Ll9fdmFsdWVfXyxcbiAgICAgICAgICAgIGFPYmplY3QuX19zaGFwZV9fLFxuICAgICAgICAgICAgYU9iamVjdC5fX2R0eXBlX19cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8va2VlcCBpdCBhcyByZWd1bGFyIGlmIHRyYW5zZmVyZWQgdG8gdGhlIG1haW4gYXBwXG4gICAgICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fX2phaWxlZF90eXBlX18gPT09IFwiZXJyb3JcIikge1xuICAgICAgICBiT2JqZWN0ID0gbmV3IEVycm9yKGFPYmplY3QuX192YWx1ZV9fKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fX2phaWxlZF90eXBlX18gPT09IFwiZmlsZVwiKSB7XG4gICAgICAgIGJPYmplY3QgPSBhT2JqZWN0Ll9fdmFsdWVfXztcbiAgICAgICAgLy9wYXRjaCByZWxhdGl2ZVBhdGhcbiAgICAgICAgYk9iamVjdC5yZWxhdGl2ZVBhdGggPSBhT2JqZWN0Ll9fcmVsYXRpdmVfcGF0aF9fO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9famFpbGVkX3R5cGVfXyA9PT0gXCJhcmd1bWVudFwiKSB7XG4gICAgICAgIGJPYmplY3QgPSBhT2JqZWN0Ll9fdmFsdWVfXztcbiAgICAgIH1cbiAgICAgIHJldHVybiBiT2JqZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkoYU9iamVjdCk7XG4gICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgICBmb3IgKGsgaW4gYU9iamVjdCkge1xuICAgICAgICBpZiAoaXNhcnJheSB8fCBhT2JqZWN0Lmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgdiA9IGFPYmplY3Rba107XG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB0aGlzLl9kZWNvZGUodiwgY2FsbGJhY2tJZCwgd2l0aFByb21pc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJPYmplY3Q7XG4gICAgfVxuICB9XG5cbiAgX3dyYXAoYXJncywgYXNfaW50ZXJmYWNlKSB7XG4gICAgdmFyIHdyYXBwZWQgPSB0aGlzLl9lbmNvZGUoYXJncywgYXNfaW50ZXJmYWNlKTtcbiAgICB2YXIgcmVzdWx0ID0geyBhcmdzOiB3cmFwcGVkIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbndyYXBzIHRoZSBzZXQgb2YgYXJndW1lbnRzIGRlbGl2ZXJlZCBmcm9tIHRoZSByZW1vdGUgc2l0ZSxcbiAgICogcmVwbGFjZXMgYWxsIGNhbGxiYWNrIGlkZW50aWZpZXJzIHdpdGggYSBmdW5jdGlvbiB3aGljaCB3aWxsXG4gICAqIGluaXRpYXRlIHNlbmRpbmcgdGhhdCBjYWxsYmFjayBpZGVudGlmaWVyIGJhY2sgdG8gb3RoZXIgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyB0byB1bndyYXBcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aXRoUHJvbWlzZSBpcyB0cnVlIG1lYW5zIHRoaXMgdGhlIGNhbGxiYWNrIHNob3VsZCBjb250YWluIGEgcHJvbWlzZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHVud3JhcHBlZCBhcmdzXG4gICAqL1xuICBfdW53cmFwKGFyZ3MsIHdpdGhQcm9taXNlKSB7XG4gICAgLy8gdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgLy8gd3JhcHMgZWFjaCBjYWxsYmFjayBzbyB0aGF0IHRoZSBvbmx5IG9uZSBjb3VsZCBiZSBjYWxsZWRcbiAgICAvLyB2YXIgb25jZShjYikge1xuICAgIC8vICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgIC8vICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgLy8gICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gICAgICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgICAgIHZhciBtc2cgPVxuICAgIC8vICAgICAgICAgICAgICAgJ0EgY2FsbGJhY2sgZnJvbSB0aGlzIHNldCBoYXMgYWxyZWFkeSBiZWVuIGV4ZWN1dGVkJztcbiAgICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfTtcbiAgICAvLyB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlY29kZShhcmdzLmFyZ3MsIGFyZ3MuY2FsbGJhY2tJZCwgd2l0aFByb21pc2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gYSBzaW5nbGUgcmVtb3RlXG4gICAqIGNhbGxiYWNrLiBXaGVuIHRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgY2FsbGVkLCBpdCB3aWxsIHNlbmRcbiAgICogdGhlIGNvcnJlc3BvbmRpbmcgbWVzc2FnZSB0byB0aGUgcmVtb3RlIHNpdGUgYXNraW5nIGl0IHRvXG4gICAqIGV4ZWN1dGUgdGhlIHBhcnRpY3VsYXIgY2FsbGJhY2sgcHJldmlvdXNseSBzYXZlZCBkdXJpbmcgYSBjYWxsXG4gICAqIGJ5IHRoZSByZW1vdGUgc2l0ZSBhIG1ldGhvZCBmcm9tIHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBzaXRlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBvZiB0aGUgcmVtb3RlIGNhbGxiYWNrIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ051bSBhcmd1bWVudCBpbmRleCBvZiB0aGUgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aXRoUHJvbWlzZSBpcyB0cnVlIG1lYW5zIHRoaXMgdGhlIGNhbGxiYWNrIHNob3VsZCBjb250YWluIGEgcHJvbWlzZVxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgcmVtb3RlIGNhbGxiYWNrXG4gICAqL1xuICBfZ2VuUmVtb3RlQ2FsbGJhY2soaWQsIGFyZ051bSwgd2l0aFByb21pc2UpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZW1vdGVDYWxsYmFjaztcbiAgICBpZiAod2l0aFByb21pc2UpIHtcbiAgICAgIHJlbW90ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBtZS5fd3JhcChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICByZXNvbHZlLl9famFpbGVkX3BhaXJzX18gPSByZWplY3Q7XG4gICAgICAgICAgcmVqZWN0Ll9famFpbGVkX3BhaXJzX18gPSByZXNvbHZlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZS5fY29ubmVjdGlvbi5zZW5kKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBudW06IGFyZ051bSxcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgIC8vIHBpZCA6ICBtZS5pZCxcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBtZS5fd3JhcChbcmVzb2x2ZSwgcmVqZWN0XSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3R1ZSByZW1vdGUgY2FsbGJhY2sgKGlkOiAke2lkfSwgYXJnTnVtOiAke2FyZ051bX0pLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW90ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgcmV0dXJuIG1lLl9jb25uZWN0aW9uLnNlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgbnVtOiBhcmdOdW0sXG4gICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAvLyBwaWQgOiAgbWUuaWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyYW5zZmVyYWJsZXNcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZSBhbmQgYnJlYWtzIHRoZSBjb25uZWN0aW9uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZCh7IHR5cGU6IFwiZGlzY29ubmVjdFwiIH0pO1xuICAgIHNldFRpbWVvdXQodGhpcy5fY29ubmVjdGlvbi5kaXNjb25uZWN0LCAyMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHJlY2VpdmVkIGEgZGlzY29ubmVjdCBtZXNzYWdlXG4gICAqIGZyb20gdGhlIHJlbW90ZSBzaXRlXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9uRGlzY29ubmVjdChoYW5kbGVyKSB7XG4gICAgdGhpcy5fZGlzY29ubmVjdEhhbmRsZXIgPSBoYW5kbGVyO1xuICB9XG59XG5cbi8qKlxuICogUmVmZXJlbmNlU3RvcmUgaXMgYSBzcGVjaWFsIG9iamVjdCB3aGljaCBzdG9yZXMgb3RoZXIgb2JqZWN0c1xuICogYW5kIHByb3ZpZGVzIHRoZSByZWZlcmVuY2VzIChudW1iZXIpIGluc3RlYWQuIFRoaXMgcmVmZXJlbmNlXG4gKiBtYXkgdGhlbiBiZSBzZW50IG92ZXIgYSBqc29uLWJhc2VkIGNvbW11bmljYXRpb24gY2hhbm5lbCAoSVBDXG4gKiB0byBhbm90aGVyIE5vZGUuanMgcHJvY2VzcyBvciBhIG1lc3NhZ2UgdG8gdGhlIFdvcmtlcikuIE90aGVyXG4gKiBzaXRlIG1heSB0aGVuIHByb3ZpZGUgdGhlIHJlZmVyZW5jZSBpbiB0aGUgcmVzcG9uY2UgbWVzc2FnZVxuICogaW1wbHlpbmcgdGhlIGdpdmVuIG9iamVjdCBzaG91bGQgYmUgYWN0aXZhdGVkLlxuICpcbiAqIFByaW1hcnkgdXNhZ2UgZm9yIHRoZSBSZWZlcmVuY2VTdG9yZSBpcyBhIHN0b3JhZ2UgZm9yIHRoZVxuICogY2FsbGJhY2tzLCB3aGljaCB0aGVyZWZvcmUgbWFrZXMgaXQgcG9zc2libGUgdG8gaW5pdGlhdGUgYVxuICogY2FsbGJhY2sgZXhlY3V0aW9uIGJ5IHRoZSBvcHBvc2l0ZSBzaXRlICh3aGljaCBub3JtYWxseSBjYW5ub3RcbiAqIGRpcmVjdGx5IGV4ZWN1dGUgZnVuY3Rpb25zIG92ZXIgdGhlIGNvbW11bmljYXRpb24gY2hhbm5lbCkuXG4gKlxuICogRWFjaCBzdG9yZWQgb2JqZWN0IGNhbiBvbmx5IGJlIGZldGNoZWQgb25jZSBhbmQgaXMgbm90XG4gKiBhdmFpbGFibGUgZm9yIHRoZSBzZWNvbmQgdGltZS4gRWFjaCBzdG9yZWQgb2JqZWN0IG11c3QgYmVcbiAqIGZldGNoZWQsIHNpbmNlIG90aGVyd2lzZSBpdCB3aWxsIHJlbWFpbiBzdG9yZWQgZm9yZXZlciBhbmRcbiAqIGNvbnN1bWUgbWVtb3J5LlxuICpcbiAqIFN0b3JlZCBvYmplY3QgaW5kZWNlcyBhcmUgc2ltcGx5IHRoZSBudW1iZXJzLCB3aGljaCBhcmUgaG93ZXZlclxuICogcmVsZWFzZWQgYWxvbmcgd2l0aCB0aGUgb2JqZWN0cywgYW5kIGFyZSBsYXRlciByZXVzZWQgYWdhaW4gKGluXG4gKiBvcmRlciB0byBwb3N0cG9uZSB0aGUgb3ZlcmZsb3csIHdoaWNoIHNob3VsZCBub3QgbGlrZWx5IGhhcHBlbixcbiAqIGJ1dCBhbnl3YXkpLlxuICovXG5jbGFzcyBSZWZlcmVuY2VTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N0b3JlID0ge307IC8vIHN0b3JlZCBvYmplY3RcbiAgICB0aGlzLl9pbmRpY2VzID0gWzBdOyAvLyBzbWFsbGVzdCBhdmFpbGFibGUgaW5kaWNlc1xuICAgIHRoaXMuX3JlYWR5SGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5fYnVzeUhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX3JlYWR5SGFuZGxlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGwgaGFuZGxlciB3aGVuIHRoZSBzdG9yZSBpcyBlbXB0eVxuICAgKlxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcbiAgICovXG4gIG9uUmVhZHkocmVhZHlIYW5kbGVyKSB7XG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyID0gcmVhZHlIYW5kbGVyIHx8IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICAvKipcbiAgICogY2FsbCBoYW5kbGVyIHdoZW4gdGhlIHN0b3JlIGlzIG5vdCBlbXB0eVxuICAgKlxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcbiAgICovXG4gIG9uQnVzeShidXN5SGFuZGxlcikge1xuICAgIHRoaXMuX2J1c3lIYW5kbGVyID0gYnVzeUhhbmRsZXIgfHwgZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgc3RvcmVcbiAgICpcbiAgICovXG4gIGdldFN0YWNrKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdG9yZSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBfZ2VuSWQoKSBnZW5lcmF0ZXMgdGhlIG5ldyByZWZlcmVuY2UgaWRcbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gc21hbGxlc3QgYXZhaWxhYmxlIGlkIGFuZCByZXNlcnZlcyBpdFxuICAgKi9cbiAgX2dlbklkKCkge1xuICAgIHZhciBpZDtcbiAgICBpZiAodGhpcy5faW5kaWNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlkID0gdGhpcy5faW5kaWNlc1swXSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuX2luZGljZXMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIHJlZmVyZW5jZSBpZCBzbyB0aGF0IGl0IHdpbGwgYmUgYXZhaWxhYmxlIGJ5XG4gICAqIGFub3RoZXIgb2JqZWN0IHN0b3JlZFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgdG8gcmVsZWFzZVxuICAgKi9cbiAgX3JlbGVhc2VJZChpZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlkIDwgdGhpcy5faW5kaWNlc1tpXSkge1xuICAgICAgICB0aGlzLl9pbmRpY2VzLnNwbGljZShpLCAwLCBpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFuaW5nLXVwIHRoZSBzZXF1ZW5jZSB0YWlsXG4gICAgZm9yIChpID0gdGhpcy5faW5kaWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuX2luZGljZXNbaV0gLSAxID09PSB0aGlzLl9pbmRpY2VzW2kgLSAxXSkge1xuICAgICAgICB0aGlzLl9pbmRpY2VzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSByZWZlcm5jZSBpZCBpbnN0ZWFkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdG8gc3RvcmVcbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gcmVmZXJlbmNlIGlkIG9mIHRoZSBzdG9yZWQgb2JqZWN0XG4gICAqL1xuICBwdXQob2JqKSB7XG4gICAgaWYgKHRoaXMuX2J1c3lIYW5kbGVyICYmIE9iamVjdC5rZXlzKHRoaXMuX3N0b3JlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2J1c3lIYW5kbGVyKCk7XG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuX2dlbklkKCk7XG4gICAgdGhpcy5fc3RvcmVbaWRdID0gb2JqO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcHJldmlvdXNseSBzdG9yZWQgb2JqZWN0IGFuZCByZWxlYXNlcyBpdHMgcmVmZXJlbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBvZiBhbiBvYmplY3QgdG8gcmV0cmlldmVcbiAgICovXG4gIGZldGNoKGlkKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMuX3N0b3JlW2lkXTtcbiAgICBpZiAob2JqICYmICFvYmouX19yZW1vdGVfbWV0aG9kKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RvcmVbaWRdO1xuICAgICAgdGhpcy5fcmVsZWFzZUlkKGlkKTtcbiAgICAgIGlmICh0aGlzLl9yZWFkeUhhbmRsZXIgJiYgT2JqZWN0LmtleXModGhpcy5fc3RvcmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZWFkeUhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iaiAmJiBvYmouX19qYWlsZWRfcGFpcnNfXykge1xuICAgICAgY29uc3QgX2lkID0gZ2V0S2V5QnlWYWx1ZSh0aGlzLl9zdG9yZSwgb2JqLl9famFpbGVkX3BhaXJzX18pO1xuICAgICAgdGhpcy5mZXRjaChfaWQpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBwcmV2aW91c2x5IHN0b3JlZCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIG9mIGFuIG9iamVjdCB0byByZXRyaWV2ZVxuICAgKi9cbiAgLy8gcmV0cmlldmUoaWQpIHtcbiAgLy8gICAgIHZhciBvYmogPSB0aGlzLl9zdG9yZVtpZF07XG4gIC8vICAgICByZXR1cm4gb2JqO1xuICAvLyB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBeUJBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUF6R0E7QUEyR0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQVJBO0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFVQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFuMUJBO0FBcTFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExSEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/rpc.js\n");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: randId, dtypeToTypedArray, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randId\", function() { return randId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"urlJoin\", function() { return urlJoin; });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10);\n}\nconst dtypeToTypedArray = {\n  int8: \"Int8Array\",\n  int16: \"Int16Array\",\n  int32: \"Int32Array\",\n  uint8: \"Uint8Array\",\n  uint16: \"Uint16Array\",\n  uint32: \"Uint32Array\",\n  float32: \"Float32Array\",\n  float64: \"Float64Array\",\n  array: \"Array\"\n};\nconst typedArrayToDtype = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\"\n};\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url\n    };\n\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n\n    const messageChannel = new MessageChannel();\n\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  if (requirements && requirements.length > 0) {\n    for (let req of requirements) {\n      //remove prefix\n      if (req.startsWith(\"js:\")) req = req.slice(3);\n      if (req.startsWith(\"css:\")) req = req.slice(4);\n      if (req.startsWith(\"cache:\")) req = req.slice(6);\n      if (!req.startsWith(\"http\")) continue;\n      await cacheUrlInServiceWorker(req).catch(e => {\n        console.error(e);\n      });\n    }\n  }\n}\nfunction setupServiceWorker(targetOrigin, cacheCallback) {\n  // register service worker for offline access\n  if (\"serviceWorker\" in navigator) {\n    window.addEventListener(\"load\", function () {\n      navigator.serviceWorker.register(\"/plugin-service-worker.js\").then(function (registration) {\n        // Registration was successful\n        console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n      }, function (err) {\n        // registration failed :(\n        console.log(\"ServiceWorker registration failed: \", err);\n      });\n      targetOrigin = targetOrigin || \"*\";\n      cacheCallback = cacheCallback || cacheRequirements;\n\n      if (cacheCallback && typeof cacheCallback !== \"function\") {\n        throw new Error(\"config.cache_requirements must be a function\");\n      }\n\n      window.addEventListener(\"message\", function (e) {\n        if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n          const m = e.data;\n\n          if (m.type === \"cacheRequirements\") {\n            cacheCallback(m.requirements);\n          }\n        }\n      });\n    });\n  }\n} //#Source https://bit.ly/2neWfJ2\n\nfunction urlJoin(...args) {\n  return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWpveVJQQy9zcmMvdXRpbHMuanM/YTMwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcmFuZElkKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKVxuICAgIC50b1N0cmluZygzNilcbiAgICAuc3Vic3RyKDIsIDEwKTtcbn1cblxuZXhwb3J0IGNvbnN0IGR0eXBlVG9UeXBlZEFycmF5ID0ge1xuICBpbnQ4OiBcIkludDhBcnJheVwiLFxuICBpbnQxNjogXCJJbnQxNkFycmF5XCIsXG4gIGludDMyOiBcIkludDMyQXJyYXlcIixcbiAgdWludDg6IFwiVWludDhBcnJheVwiLFxuICB1aW50MTY6IFwiVWludDE2QXJyYXlcIixcbiAgdWludDMyOiBcIlVpbnQzMkFycmF5XCIsXG4gIGZsb2F0MzI6IFwiRmxvYXQzMkFycmF5XCIsXG4gIGZsb2F0NjQ6IFwiRmxvYXQ2NEFycmF5XCIsXG4gIGFycmF5OiBcIkFycmF5XCJcbn07XG5leHBvcnQgY29uc3QgdHlwZWRBcnJheVRvRHR5cGUgPSB7XG4gIEludDhBcnJheTogXCJpbnQ4XCIsXG4gIEludDE2QXJyYXk6IFwiaW50MTZcIixcbiAgSW50MzJBcnJheTogXCJpbnQzMlwiLFxuICBVaW50OEFycmF5OiBcInVpbnQ4XCIsXG4gIFVpbnQxNkFycmF5OiBcInVpbnQxNlwiLFxuICBVaW50MzJBcnJheTogXCJ1aW50MzJcIixcbiAgRmxvYXQzMkFycmF5OiBcImZsb2F0MzJcIixcbiAgRmxvYXQ2NEFycmF5OiBcImZsb2F0NjRcIixcbiAgQXJyYXk6IFwiYXJyYXlcIlxufTtcblxuZnVuY3Rpb24gY2FjaGVVcmxJblNlcnZpY2VXb3JrZXIodXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgY29tbWFuZDogXCJhZGRcIixcbiAgICAgIHVybDogdXJsXG4gICAgfTtcbiAgICBpZiAoIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyIHx8ICFuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3Rlcikge1xuICAgICAgcmVqZWN0KFwiU2VydmljZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VDaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgbWVzc2FnZUNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEuZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGV2ZW50LmRhdGEuZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShldmVudC5kYXRhICYmIGV2ZW50LmRhdGEucmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyICYmIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIpIHtcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgW1xuICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MlxuICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdChcIlNlcnZpY2Ugd29ya2VyIGNvbnRyb2xsZXIgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FjaGVSZXF1aXJlbWVudHMocmVxdWlyZW1lbnRzKSB7XG4gIGlmIChyZXF1aXJlbWVudHMgJiYgcmVxdWlyZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGxldCByZXEgb2YgcmVxdWlyZW1lbnRzKSB7XG4gICAgICAvL3JlbW92ZSBwcmVmaXhcbiAgICAgIGlmIChyZXEuc3RhcnRzV2l0aChcImpzOlwiKSkgcmVxID0gcmVxLnNsaWNlKDMpO1xuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFwiY3NzOlwiKSkgcmVxID0gcmVxLnNsaWNlKDQpO1xuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFwiY2FjaGU6XCIpKSByZXEgPSByZXEuc2xpY2UoNik7XG4gICAgICBpZiAoIXJlcS5zdGFydHNXaXRoKFwiaHR0cFwiKSkgY29udGludWU7XG5cbiAgICAgIGF3YWl0IGNhY2hlVXJsSW5TZXJ2aWNlV29ya2VyKHJlcSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwU2VydmljZVdvcmtlcih0YXJnZXRPcmlnaW4sIGNhY2hlQ2FsbGJhY2spIHtcbiAgLy8gcmVnaXN0ZXIgc2VydmljZSB3b3JrZXIgZm9yIG9mZmxpbmUgYWNjZXNzXG4gIGlmIChcInNlcnZpY2VXb3JrZXJcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3RlcihcIi9wbHVnaW4tc2VydmljZS13b3JrZXIuanNcIikudGhlbihcbiAgICAgICAgZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgLy8gUmVnaXN0cmF0aW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwgd2l0aCBzY29wZTogXCIsXG4gICAgICAgICAgICByZWdpc3RyYXRpb24uc2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAvLyByZWdpc3RyYXRpb24gZmFpbGVkIDooXG4gICAgICAgICAgY29uc29sZS5sb2coXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQ6IFwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGFyZ2V0T3JpZ2luID0gdGFyZ2V0T3JpZ2luIHx8IFwiKlwiO1xuICAgICAgY2FjaGVDYWxsYmFjayA9IGNhY2hlQ2FsbGJhY2sgfHwgY2FjaGVSZXF1aXJlbWVudHM7XG4gICAgICBpZiAoY2FjaGVDYWxsYmFjayAmJiB0eXBlb2YgY2FjaGVDYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmZpZy5jYWNoZV9yZXF1aXJlbWVudHMgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRhcmdldE9yaWdpbiA9PT0gXCIqXCIgfHwgZS5vcmlnaW4gPT09IHRhcmdldE9yaWdpbikge1xuICAgICAgICAgIGNvbnN0IG0gPSBlLmRhdGE7XG4gICAgICAgICAgaWYgKG0udHlwZSA9PT0gXCJjYWNoZVJlcXVpcmVtZW50c1wiKSB7XG4gICAgICAgICAgICBjYWNoZUNhbGxiYWNrKG0ucmVxdWlyZW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8vI1NvdXJjZSBodHRwczovL2JpdC5seS8ybmVXZkoyXG5leHBvcnQgZnVuY3Rpb24gdXJsSm9pbiguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzXG4gICAgLmpvaW4oXCIvXCIpXG4gICAgLnJlcGxhY2UoL1tcXC9dKy9nLCBcIi9cIilcbiAgICAucmVwbGFjZSgvXiguKyk6XFwvLywgXCIkMTovL1wiKVxuICAgIC5yZXBsYWNlKC9eZmlsZTovLCBcImZpbGU6L1wiKVxuICAgIC5yZXBsYWNlKC9cXC8oXFw/fCZ8I1teIV0pL2csIFwiJDFcIilcbiAgICAucmVwbGFjZSgvXFw/L2csIFwiJlwiKVxuICAgIC5yZXBsYWNlKFwiJlwiLCBcIj9cIik7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFRQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils.js\n");

/***/ })

/******/ });