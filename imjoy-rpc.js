(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("imjoyRPC", [], factory);
	else if(typeof exports === 'object')
		exports["imjoyRPC"] = factory();
	else
		root["imjoyRPC"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd29ya2VyLWxvYWRlci9kaXN0L3dvcmtlcnMvSW5saW5lV29ya2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9ub2RlX21vZHVsZXMvd29ya2VyLWxvYWRlci9kaXN0L3dvcmtlcnMvSW5saW5lV29ya2VyLmpzPzc3ODUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMzQzOTEzL2hvdy10by1jcmVhdGUtYS13ZWItd29ya2VyLWZyb20tYS1zdHJpbmdcblxudmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBibG9iO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBCbG9iQnVpbGRlciA9IERlcHJlY2F0ZWQsIGJ1dCB3aWRlbHkgaW1wbGVtZW50ZWRcbiAgICAgICAgdmFyIEJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XG5cbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuXG4gICAgICAgIGJsb2IuYXBwZW5kKGNvbnRlbnQpO1xuXG4gICAgICAgIGJsb2IgPSBibG9iLmdldEJsb2IoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVGhlIHByb3Bvc2VkIEFQSVxuICAgICAgICBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG5ldyBXb3JrZXIoJ2RhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0lubGluZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgV29ya2VyKHVybCk7XG4gIH1cbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/worker-loader/dist/workers/InlineWorker.js\n");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, description, module, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"imjoy-rpc\\\",\\\"version\\\":\\\"0.2.3\\\",\\\"description\\\":\\\"Remote procedure calls for ImJoy.\\\",\\\"module\\\":\\\"index.js\\\",\\\"scripts\\\":{\\\"build\\\":\\\"rm -rf dist && npm run build-umd\\\",\\\"build-umd\\\":\\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\\",\\\"watch\\\":\\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\\",\\\"serve\\\":\\\"webpack-dev-server\\\",\\\"stats\\\":\\\"webpack --profile --json > stats.json\\\",\\\"stats-prod\\\":\\\"webpack --profile --json --mode production > stats-prod.json\\\",\\\"analyze\\\":\\\"webpack-bundle-analyzer -p 9999 stats.json\\\",\\\"analyze-prod\\\":\\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\\",\\\"clean\\\":\\\"rimraf dist/*\\\",\\\"deploy\\\":\\\"npm run build && node deploy-site.js\\\",\\\"format\\\":\\\"prettier --write \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"check-format\\\":\\\"prettier --check \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"test\\\":\\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\\",\\\"test-watch\\\":\\\"karma start --auto-watch --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\\"},\\\"keywords\\\":[\\\"imjoy\\\",\\\"rpc\\\"],\\\"author\\\":\\\"imjoy-team <imjoy.team@gmail.com>\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/imjoy-team/imjoy-rpc/issues\\\"},\\\"homepage\\\":\\\"https://github.com/imjoy-team/imjoy-rpc\\\",\\\"dependencies\\\":{},\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.0.0-beta.39\\\",\\\"@babel/plugin-syntax-dynamic-import\\\":\\\"^7.0.0-beta.39\\\",\\\"@babel/polyfill\\\":\\\"^7.0.0-beta.39\\\",\\\"@babel/preset-env\\\":\\\"^7.0.0-beta.39\\\",\\\"@types/requirejs\\\":\\\"^2.1.28\\\",\\\"babel-core\\\":\\\"^6.26.0\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"babel-loader\\\":\\\"^8.1.0\\\",\\\"babel-runtime\\\":\\\"^6.26.0\\\",\\\"chai\\\":\\\"^4.2.0\\\",\\\"clean-webpack-plugin\\\":\\\"^0.1.19\\\",\\\"copy-webpack-plugin\\\":\\\"^5.0.5\\\",\\\"eslint\\\":\\\"^6.8.0\\\",\\\"eslint-config-prettier\\\":\\\"^4.2.0\\\",\\\"eslint-loader\\\":\\\"^4.0.2\\\",\\\"file-loader\\\":\\\"^0.11.2\\\",\\\"fs-extra\\\":\\\"^0.30.0\\\",\\\"gh-pages\\\":\\\"^2.0.1\\\",\\\"html-loader\\\":\\\"^0.5.5\\\",\\\"html-webpack-plugin\\\":\\\"^3.2.0\\\",\\\"json-loader\\\":\\\"^0.5.4\\\",\\\"karma\\\":\\\"^4.4.1\\\",\\\"karma-chrome-launcher\\\":\\\"^3.1.0\\\",\\\"karma-firefox-launcher\\\":\\\"^1.3.0\\\",\\\"karma-mocha\\\":\\\"^1.3.0\\\",\\\"karma-spec-reporter\\\":\\\"0.0.32\\\",\\\"karma-webpack\\\":\\\"^4.0.2\\\",\\\"lerna\\\":\\\"^3.8.0\\\",\\\"lodash.debounce\\\":\\\"^4.0.8\\\",\\\"mocha\\\":\\\"^7.1.2\\\",\\\"postcss\\\":\\\"^6.0.2\\\",\\\"prettier\\\":\\\"^1.6.1\\\",\\\"rimraf\\\":\\\"^2.6.2\\\",\\\"schema-utils\\\":\\\"^0.4.3\\\",\\\"socket.io-client\\\":\\\"^2.3.0\\\",\\\"style-loader\\\":\\\"^0.18.1\\\",\\\"url-loader\\\":\\\"^0.5.9\\\",\\\"webpack\\\":\\\"^4.0.0\\\",\\\"webpack-bundle-analyzer\\\":\\\"^3.3.2\\\",\\\"webpack-cli\\\":\\\"^3.1.2\\\",\\\"webpack-dev-server\\\":\\\"^3.1.1\\\",\\\"webpack-merge\\\":\\\"^4.1.1\\\",\\\"workbox-webpack-plugin\\\":\\\"^4.3.1\\\",\\\"worker-loader\\\":\\\"^2.0.0\\\",\\\"write-file-webpack-plugin\\\":\\\"^4.5.1\\\"},\\\"eslintConfig\\\":{\\\"globals\\\":{\\\"document\\\":true,\\\"window\\\":true}}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWNrYWdlLmpzb24uanMiLCJzb3VyY2VzIjpbXSwibWFwcGluZ3MiOiIiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./package.json\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: RPC, API_VERSION, VERSION, waitForInitialization, setupRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"waitForInitialization\", function() { return waitForInitialization; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupRPC\", function() { return setupRPC; });\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin.webworker.js */ \"./src/plugin.webworker.js\");\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginIframe.js */ \"./src/pluginIframe.js\");\n/* harmony import */ var _pluginWebPython_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pluginWebPython.js */ \"./src/pluginWebPython.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_4__[\"RPC\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_4__[\"API_VERSION\"]; });\n\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../package.json */ \"./package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ \"./package.json\", 1);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return _package_json__WEBPACK_IMPORTED_MODULE_5__[\"version\"]; });\n\n/**\n * Contains the code executed in the sandboxed frame under web-browser\n *\n * Tries to create a Web-Worker inside the frame and set up the\n * communication between the worker and the parent window. Some\n * browsers restrict creating a worker inside a sandboxed iframe - if\n * this happens, the plugin initialized right inside the frame (in the\n * same thread)\n */\n\n\n\n\n\n\n\nfunction _inIframe() {\n  try {\n    return window.self !== window.top;\n  } catch (e) {\n    return true;\n  }\n}\n/**\n * Initializes the plugin inside a web worker. May throw an exception\n * in case this was not permitted by the browser.\n */\n\n\nfunction setupWebWorker(config) {\n  if (!config.allow_execution) throw new Error(\"web-worker plugin can only work with allow_execution=true\");\n  const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a(); // mixed content warning in Chrome silently skips worker\n  // initialization without exception, handling this with timeout\n\n  const fallbackTimeout = setTimeout(function () {\n    worker.terminate();\n    console.warn(`Plugin failed to start as a web-worker, running in an iframe instead.`);\n    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n  }, 2000);\n  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"randId\"])(); // forwarding messages between the worker and parent window\n\n  worker.addEventListener(\"message\", function (e) {\n    let transferables = undefined;\n    const m = e.data;\n\n    if (m.type === \"worker-ready\") {\n      // send config to the worker\n      worker.postMessage({\n        type: \"connectRPC\",\n        config: config\n      });\n      clearTimeout(fallbackTimeout);\n      return;\n    } else if (m.type === \"initialized\") {\n      // complete the missing fields\n      m.config = Object.assign({}, config, m.config);\n      m.origin = window.location.origin;\n      m.peer_id = peer_id;\n    } else if (m.type === \"imjoy_remote_api_ready\") {\n      // if it's a webworker, there will be no api object returned\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: null\n      }));\n    } else if (m.type === \"cacheRequirements\" && typeof cache_requirements === \"function\") {\n      cache_requirements(m.requirements);\n    } else if (m.type === \"disconnect\") {\n      worker.terminate();\n    } else {\n      if (m.__transferables__) {\n        transferables = m.__transferables__;\n        delete m.__transferables__;\n      }\n    }\n\n    parent.postMessage(m, config.target_origin || \"*\", transferables);\n  });\n  window.addEventListener(\"message\", function (e) {\n    let transferables = undefined;\n    const m = e.data;\n\n    if (m.__transferables__) {\n      transferables = m.__transferables__;\n      delete m.__transferables__;\n    }\n\n    if (m.peer_id === peer_id) {\n      worker.postMessage(m, transferables);\n    } else if (config.debug) {\n      console.log(`connection peer id mismatch ${m.peer_id} !== ${peer_id}`);\n    }\n  });\n}\n\nfunction waitForInitialization(config) {\n  config = config || {};\n  const targetOrigin = config.target_origin || \"*\";\n\n  if (config.credential_required && typeof config.verify_credential !== \"function\") {\n    throw new Error(\"Please also provide the `verify_credential` function with `credential_required`.\");\n  }\n\n  if (config.credential_required && targetOrigin === \"*\") {\n    throw new Error(\"`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.\");\n  }\n\n  const done = () => {\n    window.removeEventListener(\"message\", handleEvent);\n  };\n\n  const handleEvent = e => {\n    if (e.type === \"message\" && (targetOrigin === \"*\" || e.origin === targetOrigin)) {\n      if (e.data.type === \"initialize\") {\n        done();\n        const cfg = e.data.config; // override the target_origin setting if it's configured by the rpc client\n        // otherwise take the setting from the core\n\n        if (targetOrigin !== \"*\") {\n          cfg.target_origin = targetOrigin;\n        }\n\n        if (config.credential_required) {\n          config.verify_credential(cfg.credential).then(result => {\n            if (result && result.auth && !result.error) {\n              // pass the authentication information with tokens\n              cfg.auth = result.auth;\n              setupRPC(cfg).then(() => {\n                console.log(\"ImJoy RPC loaded successfully!\");\n              });\n            } else {\n              throw new Error(\"Failed to verify the credentail:\" + (result && result.error));\n            }\n          });\n        } else {\n          setupRPC(cfg).then(() => {\n            console.log(\"ImJoy RPC loaded successfully!\");\n          });\n        }\n      } else {\n        throw new Error(`invalid command: ${e.data.cmd}`);\n      }\n    }\n  };\n\n  window.addEventListener(\"message\", handleEvent);\n  parent.postMessage({\n    type: \"imjoyRPCReady\",\n    config: config\n  }, \"*\");\n}\nfunction setupRPC(config) {\n  config = config || {};\n  if (!config.name) throw new Error(\"Please specify a name for your app.\");\n  config.version = config.version || \"0.1.0\";\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"randId\"])();\n  config.allow_execution = config.allow_execution || false;\n\n  if (config.enable_service_worker) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"setupServiceWorker\"])(config.target_origin, config.cache_requirements);\n  }\n\n  if (config.cache_requirements) {\n    delete config.cache_requirements;\n  } // remove functions\n\n\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return new Promise((resolve, reject) => {\n    if (_inIframe()) {\n      if (config.type === \"web-worker\") {\n        try {\n          setupWebWorker(config);\n        } catch (e) {\n          // fallback to iframe\n          Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n        }\n      } else if (config.type === \"web-python\" || config.type === \"web-python-window\") {\n        Object(_pluginWebPython_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(config);\n      } else if ([\"rpc-window\", \"rpc-worker\", \"iframe\", \"window\"].includes(config.type)) {\n        Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n      } else {\n        console.error(\"Unsupported plugin type: \" + config.type);\n        reject(\"Unsupported plugin type: \" + config.type);\n      }\n\n      try {\n        const handleEvent = e => {\n          const api = e.detail;\n\n          if (config.expose_api_globally) {\n            window.api = api;\n          } // imjoy plugin api\n\n\n          resolve(api);\n          window.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n        };\n\n        window.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n      } catch (e) {\n        reject(e);\n      }\n    } else {\n      reject(new Error(\"imjoy-rpc should only run inside an iframe.\"));\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL21haW4uanM/NTZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRhaW5zIHRoZSBjb2RlIGV4ZWN1dGVkIGluIHRoZSBzYW5kYm94ZWQgZnJhbWUgdW5kZXIgd2ViLWJyb3dzZXJcbiAqXG4gKiBUcmllcyB0byBjcmVhdGUgYSBXZWItV29ya2VyIGluc2lkZSB0aGUgZnJhbWUgYW5kIHNldCB1cCB0aGVcbiAqIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgd29ya2VyIGFuZCB0aGUgcGFyZW50IHdpbmRvdy4gU29tZVxuICogYnJvd3NlcnMgcmVzdHJpY3QgY3JlYXRpbmcgYSB3b3JrZXIgaW5zaWRlIGEgc2FuZGJveGVkIGlmcmFtZSAtIGlmXG4gKiB0aGlzIGhhcHBlbnMsIHRoZSBwbHVnaW4gaW5pdGlhbGl6ZWQgcmlnaHQgaW5zaWRlIHRoZSBmcmFtZSAoaW4gdGhlXG4gKiBzYW1lIHRocmVhZClcbiAqL1xuaW1wb3J0IFBsdWdpbldvcmtlciBmcm9tIFwiLi9wbHVnaW4ud2Vid29ya2VyLmpzXCI7XG5pbXBvcnQgc2V0dXBJZnJhbWUgZnJvbSBcIi4vcGx1Z2luSWZyYW1lLmpzXCI7XG5pbXBvcnQgc2V0dXBXZWJQeXRob24gZnJvbSBcIi4vcGx1Z2luV2ViUHl0aG9uLmpzXCI7XG5pbXBvcnQgeyBzZXR1cFNlcnZpY2VXb3JrZXIsIHJhbmRJZCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cbmV4cG9ydCB7IFJQQywgQVBJX1ZFUlNJT04gfSBmcm9tIFwiLi9ycGMuanNcIjtcbmV4cG9ydCB7IHZlcnNpb24gYXMgVkVSU0lPTiB9IGZyb20gXCIuLi9wYWNrYWdlLmpzb25cIjtcblxuZnVuY3Rpb24gX2luSWZyYW1lKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBpbnNpZGUgYSB3ZWIgd29ya2VyLiBNYXkgdGhyb3cgYW4gZXhjZXB0aW9uXG4gKiBpbiBjYXNlIHRoaXMgd2FzIG5vdCBwZXJtaXR0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gKi9cbmZ1bmN0aW9uIHNldHVwV2ViV29ya2VyKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZy5hbGxvd19leGVjdXRpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJ3ZWItd29ya2VyIHBsdWdpbiBjYW4gb25seSB3b3JrIHdpdGggYWxsb3dfZXhlY3V0aW9uPXRydWVcIlxuICAgICk7XG4gIGNvbnN0IHdvcmtlciA9IG5ldyBQbHVnaW5Xb3JrZXIoKTtcbiAgLy8gbWl4ZWQgY29udGVudCB3YXJuaW5nIGluIENocm9tZSBzaWxlbnRseSBza2lwcyB3b3JrZXJcbiAgLy8gaW5pdGlhbGl6YXRpb24gd2l0aG91dCBleGNlcHRpb24sIGhhbmRsaW5nIHRoaXMgd2l0aCB0aW1lb3V0XG4gIGNvbnN0IGZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBQbHVnaW4gZmFpbGVkIHRvIHN0YXJ0IGFzIGEgd2ViLXdvcmtlciwgcnVubmluZyBpbiBhbiBpZnJhbWUgaW5zdGVhZC5gXG4gICAgKTtcbiAgICBzZXR1cElmcmFtZShjb25maWcpO1xuICB9LCAyMDAwKTtcbiAgY29uc3QgcGVlcl9pZCA9IHJhbmRJZCgpO1xuXG4gIC8vIGZvcndhcmRpbmcgbWVzc2FnZXMgYmV0d2VlbiB0aGUgd29ya2VyIGFuZCBwYXJlbnQgd2luZG93XG4gIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgbGV0IHRyYW5zZmVyYWJsZXMgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgbSA9IGUuZGF0YTtcbiAgICBpZiAobS50eXBlID09PSBcIndvcmtlci1yZWFkeVwiKSB7XG4gICAgICAvLyBzZW5kIGNvbmZpZyB0byB0aGUgd29ya2VyXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImNvbm5lY3RSUENcIiwgY29uZmlnOiBjb25maWcgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoZmFsbGJhY2tUaW1lb3V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKG0udHlwZSA9PT0gXCJpbml0aWFsaXplZFwiKSB7XG4gICAgICAvLyBjb21wbGV0ZSB0aGUgbWlzc2luZyBmaWVsZHNcbiAgICAgIG0uY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCBtLmNvbmZpZyk7XG4gICAgICBtLm9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICBtLnBlZXJfaWQgPSBwZWVyX2lkO1xuICAgIH0gZWxzZSBpZiAobS50eXBlID09PSBcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIikge1xuICAgICAgLy8gaWYgaXQncyBhIHdlYndvcmtlciwgdGhlcmUgd2lsbCBiZSBubyBhcGkgb2JqZWN0IHJldHVybmVkXG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVwiLCB7IGRldGFpbDogbnVsbCB9KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgbS50eXBlID09PSBcImNhY2hlUmVxdWlyZW1lbnRzXCIgJiZcbiAgICAgIHR5cGVvZiBjYWNoZV9yZXF1aXJlbWVudHMgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgY2FjaGVfcmVxdWlyZW1lbnRzKG0ucmVxdWlyZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG0udHlwZSA9PT0gXCJkaXNjb25uZWN0XCIpIHtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG0uX190cmFuc2ZlcmFibGVzX18pIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcyA9IG0uX190cmFuc2ZlcmFibGVzX187XG4gICAgICAgIGRlbGV0ZSBtLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJlbnQucG9zdE1lc3NhZ2UobSwgY29uZmlnLnRhcmdldF9vcmlnaW4gfHwgXCIqXCIsIHRyYW5zZmVyYWJsZXMpO1xuICB9KTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgIGxldCB0cmFuc2ZlcmFibGVzID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG0gPSBlLmRhdGE7XG4gICAgaWYgKG0uX190cmFuc2ZlcmFibGVzX18pIHtcbiAgICAgIHRyYW5zZmVyYWJsZXMgPSBtLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgZGVsZXRlIG0uX190cmFuc2ZlcmFibGVzX187XG4gICAgfVxuICAgIGlmIChtLnBlZXJfaWQgPT09IHBlZXJfaWQpIHtcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShtLCB0cmFuc2ZlcmFibGVzKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYGNvbm5lY3Rpb24gcGVlciBpZCBtaXNtYXRjaCAke20ucGVlcl9pZH0gIT09ICR7cGVlcl9pZH1gKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FpdEZvckluaXRpYWxpemF0aW9uKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbnN0IHRhcmdldE9yaWdpbiA9IGNvbmZpZy50YXJnZXRfb3JpZ2luIHx8IFwiKlwiO1xuICBpZiAoXG4gICAgY29uZmlnLmNyZWRlbnRpYWxfcmVxdWlyZWQgJiZcbiAgICB0eXBlb2YgY29uZmlnLnZlcmlmeV9jcmVkZW50aWFsICE9PSBcImZ1bmN0aW9uXCJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJQbGVhc2UgYWxzbyBwcm92aWRlIHRoZSBgdmVyaWZ5X2NyZWRlbnRpYWxgIGZ1bmN0aW9uIHdpdGggYGNyZWRlbnRpYWxfcmVxdWlyZWRgLlwiXG4gICAgKTtcbiAgfVxuICBpZiAoY29uZmlnLmNyZWRlbnRpYWxfcmVxdWlyZWQgJiYgdGFyZ2V0T3JpZ2luID09PSBcIipcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYHRhcmdldF9vcmlnaW5gIHdhcyBzZXQgdG8gYCpgIHdpdGggYGNyZWRlbnRpYWxfcmVxdWlyZWQ9dHJ1ZWAsIHRoZXJlIGlzIGEgc2VjdXJpdHkgcmlzayB0aGF0IHlvdSBtYXkgbGVhayB0aGUgY3JlZGVudGlhbCB0byB3ZWJzaXRlIGZyb20gb3RoZXIgb3JpZ2luLiBQbGVhc2Ugc3BlY2lmeSB0aGUgYHRhcmdldF9vcmlnaW5gIGV4cGxpY2l0bHkuXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZUV2ZW50KTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlRXZlbnQgPSBlID0+IHtcbiAgICBpZiAoXG4gICAgICBlLnR5cGUgPT09IFwibWVzc2FnZVwiICYmXG4gICAgICAodGFyZ2V0T3JpZ2luID09PSBcIipcIiB8fCBlLm9yaWdpbiA9PT0gdGFyZ2V0T3JpZ2luKVxuICAgICkge1xuICAgICAgaWYgKGUuZGF0YS50eXBlID09PSBcImluaXRpYWxpemVcIikge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNvbnN0IGNmZyA9IGUuZGF0YS5jb25maWc7XG4gICAgICAgIC8vIG92ZXJyaWRlIHRoZSB0YXJnZXRfb3JpZ2luIHNldHRpbmcgaWYgaXQncyBjb25maWd1cmVkIGJ5IHRoZSBycGMgY2xpZW50XG4gICAgICAgIC8vIG90aGVyd2lzZSB0YWtlIHRoZSBzZXR0aW5nIGZyb20gdGhlIGNvcmVcbiAgICAgICAgaWYgKHRhcmdldE9yaWdpbiAhPT0gXCIqXCIpIHtcbiAgICAgICAgICBjZmcudGFyZ2V0X29yaWdpbiA9IHRhcmdldE9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmNyZWRlbnRpYWxfcmVxdWlyZWQpIHtcbiAgICAgICAgICBjb25maWcudmVyaWZ5X2NyZWRlbnRpYWwoY2ZnLmNyZWRlbnRpYWwpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmF1dGggJiYgIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAvLyBwYXNzIHRoZSBhdXRoZW50aWNhdGlvbiBpbmZvcm1hdGlvbiB3aXRoIHRva2Vuc1xuICAgICAgICAgICAgICBjZmcuYXV0aCA9IHJlc3VsdC5hdXRoO1xuICAgICAgICAgICAgICBzZXR1cFJQQyhjZmcpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW1Kb3kgUlBDIGxvYWRlZCBzdWNjZXNzZnVsbHkhXCIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkZhaWxlZCB0byB2ZXJpZnkgdGhlIGNyZWRlbnRhaWw6XCIgKyAocmVzdWx0ICYmIHJlc3VsdC5lcnJvcilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR1cFJQQyhjZmcpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbUpveSBSUEMgbG9hZGVkIHN1Y2Nlc3NmdWxseSFcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjb21tYW5kOiAke2UuZGF0YS5jbWR9YCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlRXZlbnQpO1xuICBwYXJlbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImltam95UlBDUmVhZHlcIiwgY29uZmlnOiBjb25maWcgfSwgXCIqXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBSUEMoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgaWYgKCFjb25maWcubmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgYSBuYW1lIGZvciB5b3VyIGFwcC5cIik7XG4gIGNvbmZpZy52ZXJzaW9uID0gY29uZmlnLnZlcnNpb24gfHwgXCIwLjEuMFwiO1xuICBjb25maWcuZGVzY3JpcHRpb24gPVxuICAgIGNvbmZpZy5kZXNjcmlwdGlvbiB8fCBgW1RPRE86IGFkZCBkZXNjcmlwdGlvbiBmb3IgJHtjb25maWcubmFtZX0gXWA7XG4gIGNvbmZpZy50eXBlID0gY29uZmlnLnR5cGUgfHwgXCJycGMtd2luZG93XCI7XG4gIGNvbmZpZy5pZCA9IGNvbmZpZy5pZCB8fCByYW5kSWQoKTtcbiAgY29uZmlnLmFsbG93X2V4ZWN1dGlvbiA9IGNvbmZpZy5hbGxvd19leGVjdXRpb24gfHwgZmFsc2U7XG4gIGlmIChjb25maWcuZW5hYmxlX3NlcnZpY2Vfd29ya2VyKSB7XG4gICAgc2V0dXBTZXJ2aWNlV29ya2VyKGNvbmZpZy50YXJnZXRfb3JpZ2luLCBjb25maWcuY2FjaGVfcmVxdWlyZW1lbnRzKTtcbiAgfVxuICBpZiAoY29uZmlnLmNhY2hlX3JlcXVpcmVtZW50cykge1xuICAgIGRlbGV0ZSBjb25maWcuY2FjaGVfcmVxdWlyZW1lbnRzO1xuICB9XG4gIC8vIHJlbW92ZSBmdW5jdGlvbnNcbiAgY29uZmlnID0gT2JqZWN0LmtleXMoY29uZmlnKS5yZWR1Y2UoKHAsIGMpID0+IHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZ1tjXSAhPT0gXCJmdW5jdGlvblwiKSBwW2NdID0gY29uZmlnW2NdO1xuICAgIHJldHVybiBwO1xuICB9LCB7fSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKF9pbklmcmFtZSgpKSB7XG4gICAgICBpZiAoY29uZmlnLnR5cGUgPT09IFwid2ViLXdvcmtlclwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0dXBXZWJXb3JrZXIoY29uZmlnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIGlmcmFtZVxuICAgICAgICAgIHNldHVwSWZyYW1lKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGNvbmZpZy50eXBlID09PSBcIndlYi1weXRob25cIiB8fFxuICAgICAgICBjb25maWcudHlwZSA9PT0gXCJ3ZWItcHl0aG9uLXdpbmRvd1wiXG4gICAgICApIHtcbiAgICAgICAgc2V0dXBXZWJQeXRob24oY29uZmlnKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIFtcInJwYy13aW5kb3dcIiwgXCJycGMtd29ya2VyXCIsIFwiaWZyYW1lXCIsIFwid2luZG93XCJdLmluY2x1ZGVzKGNvbmZpZy50eXBlKVxuICAgICAgKSB7XG4gICAgICAgIHNldHVwSWZyYW1lKGNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5zdXBwb3J0ZWQgcGx1Z2luIHR5cGU6IFwiICsgY29uZmlnLnR5cGUpO1xuICAgICAgICByZWplY3QoXCJVbnN1cHBvcnRlZCBwbHVnaW4gdHlwZTogXCIgKyBjb25maWcudHlwZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoYW5kbGVFdmVudCA9IGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGFwaSA9IGUuZGV0YWlsO1xuICAgICAgICAgIGlmIChjb25maWcuZXhwb3NlX2FwaV9nbG9iYWxseSkge1xuICAgICAgICAgICAgd2luZG93LmFwaSA9IGFwaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaW1qb3kgcGx1Z2luIGFwaVxuICAgICAgICAgIHJlc29sdmUoYXBpKTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIiwgaGFuZGxlRXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIiwgaGFuZGxlRXZlbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJpbWpveS1ycGMgc2hvdWxkIG9ubHkgcnVuIGluc2lkZSBhbiBpZnJhbWUuXCIpKTtcbiAgICB9XG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./src/plugin.webworker.js":
/*!*********************************!*\
  !*** ./src/plugin.webworker.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function() {\n  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/plugin.webworker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./src/plugin.webworker.js\\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \\\\\\\"./src/pluginCore.js\\\\\\\");\\\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \\\\\\\"./src/rpc.js\\\\\\\");\\\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \\\\\\\"./src/utils.js\\\\\\\");\\\\n/**\\\\n * Contains the routines loaded by the plugin Worker under web-browser.\\\\n *\\\\n * Initializes the web environment version of the platform-dependent\\\\n * connection object for the plugin site\\\\n */\\\\n\\\\n\\\\n\\\\n\\\\n(function() {\\\\n  // make sure this runs inside a webworker\\\\n  if (\\\\n    typeof WorkerGlobalScope === \\\\\\\"undefined\\\\\\\" ||\\\\n    !self ||\\\\n    !(self instanceof WorkerGlobalScope)\\\\n  ) {\\\\n    throw new Error(\\\\\\\"This script can only loaded in a webworker\\\\\\\");\\\\n  }\\\\n  /**\\\\n   * Connection object provided to the RPC constructor,\\\\n   * plugin site implementation for the web-based environment.\\\\n   * Global will be then cleared to prevent exposure into the\\\\n   * Worker, so we put this local connection object into a closure\\\\n   */\\\\n  class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\\\\\\\"MessageEmitter\\\\\\\"] {\\\\n    constructor(config) {\\\\n      super(config && config.debug);\\\\n      this.config = config || {};\\\\n    }\\\\n    connect() {\\\\n      self.addEventListener(\\\\\\\"message\\\\\\\", e => {\\\\n        this._fire(e.data.type, e.data);\\\\n      });\\\\n      this.emit({\\\\n        type: \\\\\\\"initialized\\\\\\\",\\\\n        config: this.config\\\\n      });\\\\n    }\\\\n    disconnect() {\\\\n      this._fire(\\\\\\\"beforeDisconnect\\\\\\\");\\\\n      self.close();\\\\n      this._fire(\\\\\\\"disconnected\\\\\\\");\\\\n    }\\\\n    emit(data) {\\\\n      let transferables = undefined;\\\\n      if (data.__transferables__) {\\\\n        transferables = data.__transferables__;\\\\n        delete data.__transferables__;\\\\n      }\\\\n      self.postMessage(data, transferables);\\\\n    }\\\\n    async execute(code) {\\\\n      if (code.type === \\\\\\\"requirements\\\\\\\") {\\\\n        try {\\\\n          if (\\\\n            code.requirements &&\\\\n            (Array.isArray(code.requirements) ||\\\\n              typeof code.requirements === \\\\\\\"string\\\\\\\")\\\\n          ) {\\\\n            try {\\\\n              if (!Array.isArray(code.requirements)) {\\\\n                code.requirements = [code.requirements];\\\\n              }\\\\n              for (var i = 0; i < code.requirements.length; i++) {\\\\n                if (\\\\n                  code.requirements[i].toLowerCase().endsWith(\\\\\\\".css\\\\\\\") ||\\\\n                  code.requirements[i].startsWith(\\\\\\\"css:\\\\\\\")\\\\n                ) {\\\\n                  throw \\\\\\\"unable to import css in a webworker\\\\\\\";\\\\n                } else if (\\\\n                  code.requirements[i].toLowerCase().endsWith(\\\\\\\".js\\\\\\\") ||\\\\n                  code.requirements[i].startsWith(\\\\\\\"js:\\\\\\\")\\\\n                ) {\\\\n                  if (code.requirements[i].startsWith(\\\\\\\"js:\\\\\\\")) {\\\\n                    code.requirements[i] = code.requirements[i].slice(3);\\\\n                  }\\\\n                  importScripts(code.requirements[i]);\\\\n                } else if (code.requirements[i].startsWith(\\\\\\\"http\\\\\\\")) {\\\\n                  importScripts(code.requirements[i]);\\\\n                } else if (code.requirements[i].startsWith(\\\\\\\"cache:\\\\\\\")) {\\\\n                  //ignore cache\\\\n                } else {\\\\n                  console.log(\\\\n                    \\\\\\\"Unprocessed requirements url: \\\\\\\" + code.requirements[i]\\\\n                  );\\\\n                }\\\\n              }\\\\n            } catch (e) {\\\\n              throw \\\\\\\"failed to import required scripts: \\\\\\\" +\\\\n                code.requirements.toString();\\\\n            }\\\\n          }\\\\n        } catch (e) {\\\\n          throw e;\\\\n        }\\\\n      } else if (code.type === \\\\\\\"script\\\\\\\") {\\\\n        try {\\\\n          if (\\\\n            code.requirements &&\\\\n            (Array.isArray(code.requirements) ||\\\\n              typeof code.requirements === \\\\\\\"string\\\\\\\")\\\\n          ) {\\\\n            try {\\\\n              if (Array.isArray(code.requirements)) {\\\\n                for (let i = 0; i < code.requirements.length; i++) {\\\\n                  importScripts(code.requirements[i]);\\\\n                }\\\\n              } else {\\\\n                importScripts(code.requirements);\\\\n              }\\\\n            } catch (e) {\\\\n              throw \\\\\\\"failed to import required scripts: \\\\\\\" +\\\\n                code.requirements.toString();\\\\n            }\\\\n          }\\\\n          eval(code.content);\\\\n        } catch (e) {\\\\n          console.error(e.message, e.stack);\\\\n          throw e;\\\\n        }\\\\n      } else {\\\\n        throw \\\\\\\"unsupported code type.\\\\\\\";\\\\n      }\\\\n      if (code.type === \\\\\\\"requirements\\\\\\\") {\\\\n        self.postMessage({\\\\n          type: \\\\\\\"cacheRequirements\\\\\\\",\\\\n          requirements: code.requirements\\\\n        });\\\\n      }\\\\n    }\\\\n  }\\\\n  const config = {\\\\n    type: \\\\\\\"web-worker\\\\\\\",\\\\n    dedicated_thread: true,\\\\n    allow_execution: true,\\\\n    lang: \\\\\\\"javascript\\\\\\\",\\\\n    api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\\\\\\\"API_VERSION\\\\\\\"]\\\\n  };\\\\n  const conn = new Connection(config);\\\\n  conn.on(\\\\\\\"connectRPC\\\\\\\", data => {\\\\n    Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"connectRPC\\\\\\\"])(conn, Object.assign(data.config, config));\\\\n  });\\\\n  conn.connect();\\\\n  self.postMessage({\\\\n    type: \\\\\\\"worker-ready\\\\\\\"\\\\n  });\\\\n})();\\\\n//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luLndlYndvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanM/OGM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRhaW5zIHRoZSByb3V0aW5lcyBsb2FkZWQgYnkgdGhlIHBsdWdpbiBXb3JrZXIgdW5kZXIgd2ViLWJyb3dzZXIuXG4gKlxuICogSW5pdGlhbGl6ZXMgdGhlIHdlYiBlbnZpcm9ubWVudCB2ZXJzaW9uIG9mIHRoZSBwbGF0Zm9ybS1kZXBlbmRlbnRcbiAqIGNvbm5lY3Rpb24gb2JqZWN0IGZvciB0aGUgcGx1Z2luIHNpdGVcbiAqL1xuaW1wb3J0IHsgY29ubmVjdFJQQyB9IGZyb20gXCIuL3BsdWdpbkNvcmUuanNcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OIH0gZnJvbSBcIi4vcnBjLmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlRW1pdHRlciwgcmFuZElkIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBtYWtlIHN1cmUgdGhpcyBydW5zIGluc2lkZSBhIHdlYndvcmtlclxuICBpZiAoXG4gICAgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSBcInVuZGVmaW5lZFwiIHx8XG4gICAgIXNlbGYgfHxcbiAgICAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzY3JpcHQgY2FuIG9ubHkgbG9hZGVkIGluIGEgd2Vid29ya2VyXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0aW9uIG9iamVjdCBwcm92aWRlZCB0byB0aGUgUlBDIGNvbnN0cnVjdG9yLFxuICAgKiBwbHVnaW4gc2l0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHdlYi1iYXNlZCBlbnZpcm9ubWVudC5cbiAgICogR2xvYmFsIHdpbGwgYmUgdGhlbiBjbGVhcmVkIHRvIHByZXZlbnQgZXhwb3N1cmUgaW50byB0aGVcbiAgICogV29ya2VyLCBzbyB3ZSBwdXQgdGhpcyBsb2NhbCBjb25uZWN0aW9uIG9iamVjdCBpbnRvIGEgY2xvc3VyZVxuICAgKi9cbiAgY2xhc3MgQ29ubmVjdGlvbiBleHRlbmRzIE1lc3NhZ2VFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgIHN1cGVyKGNvbmZpZyAmJiBjb25maWcuZGVidWcpO1xuICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGUgPT4ge1xuICAgICAgICB0aGlzLl9maXJlKGUuZGF0YS50eXBlLCBlLmRhdGEpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoe1xuICAgICAgICB0eXBlOiBcImluaXRpYWxpemVkXCIsXG4gICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgdGhpcy5fZmlyZShcImJlZm9yZURpc2Nvbm5lY3RcIik7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB0aGlzLl9maXJlKFwiZGlzY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBlbWl0KGRhdGEpIHtcbiAgICAgIGxldCB0cmFuc2ZlcmFibGVzID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGRhdGEuX190cmFuc2ZlcmFibGVzX18pIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcyA9IGRhdGEuX190cmFuc2ZlcmFibGVzX187XG4gICAgICAgIGRlbGV0ZSBkYXRhLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgfVxuICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2ZlcmFibGVzKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZShjb2RlKSB7XG4gICAgICBpZiAoY29kZS50eXBlID09PSBcInJlcXVpcmVtZW50c1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgJiZcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSB8fFxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgPSBbY29kZS5yZXF1aXJlbWVudHNdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZS5yZXF1aXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmNzc1wiKSB8fFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImNzczpcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IFwidW5hYmxlIHRvIGltcG9ydCBjc3MgaW4gYSB3ZWJ3b3JrZXJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcIi5qc1wiKSB8fFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImpzOlwiKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJqczpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0gPSBjb2RlLnJlcXVpcmVtZW50c1tpXS5zbGljZSgzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImNhY2hlOlwiKSkge1xuICAgICAgICAgICAgICAgICAgLy9pZ25vcmUgY2FjaGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgIFwiVW5wcm9jZXNzZWQgcmVxdWlyZW1lbnRzIHVybDogXCIgKyBjb2RlLnJlcXVpcmVtZW50c1tpXVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJmYWlsZWQgdG8gaW1wb3J0IHJlcXVpcmVkIHNjcmlwdHM6IFwiICtcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZS50eXBlID09PSBcInNjcmlwdFwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgJiZcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSB8fFxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2RlLnJlcXVpcmVtZW50cykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUucmVxdWlyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpbXBvcnRTY3JpcHRzKGNvZGUucmVxdWlyZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJmYWlsZWQgdG8gaW1wb3J0IHJlcXVpcmVkIHNjcmlwdHM6IFwiICtcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBldmFsKGNvZGUuY29udGVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSwgZS5zdGFjayk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBjb2RlIHR5cGUuXCI7XG4gICAgICB9XG4gICAgICBpZiAoY29kZS50eXBlID09PSBcInJlcXVpcmVtZW50c1wiKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFwiY2FjaGVSZXF1aXJlbWVudHNcIixcbiAgICAgICAgICByZXF1aXJlbWVudHM6IGNvZGUucmVxdWlyZW1lbnRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBjb25maWcgPSB7XG4gICAgdHlwZTogXCJ3ZWItd29ya2VyXCIsXG4gICAgZGVkaWNhdGVkX3RocmVhZDogdHJ1ZSxcbiAgICBhbGxvd19leGVjdXRpb246IHRydWUsXG4gICAgbGFuZzogXCJqYXZhc2NyaXB0XCIsXG4gICAgYXBpX3ZlcnNpb246IEFQSV9WRVJTSU9OXG4gIH07XG4gIGNvbnN0IGNvbm4gPSBuZXcgQ29ubmVjdGlvbihjb25maWcpO1xuICBjb25uLm9uKFwiY29ubmVjdFJQQ1wiLCBkYXRhID0+IHtcbiAgICBjb25uZWN0UlBDKGNvbm4sIE9iamVjdC5hc3NpZ24oZGF0YS5jb25maWcsIGNvbmZpZykpO1xuICB9KTtcbiAgY29ubi5jb25uZWN0KCk7XG4gIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgIHR5cGU6IFwid29ya2VyLXJlYWR5XCJcbiAgfSk7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\\\n//# sourceURL=webpack-internal:///./src/plugin.webworker.js\\\\n\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/pluginCore.js\\\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"connectRPC\\\\\\\", function() { return connectRPC; });\\\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \\\\\\\"./src/rpc.js\\\\\\\");\\\\n/**\\\\n * Core plugin script loaded into the plugin process/thread.\\\\n *\\\\n * Initializes the plugin-site API global methods.\\\\n */\\\\n\\\\nfunction connectRPC(connection, config) {\\\\n  config = config || {};\\\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"RPC\\\\\\\"](connection, config);\\\\n  rpc.on(\\\\\\\"getInterface\\\\\\\", function () {\\\\n    launchConnected();\\\\n  });\\\\n  rpc.on(\\\\\\\"remoteReady\\\\\\\", function () {\\\\n    const api = rpc.getRemote() || {};\\\\n\\\\n    if (api.export) {\\\\n      throw new Error(\\\\\\\"`export` is a reserved function name\\\\\\\");\\\\n    }\\\\n\\\\n    if (api.onload) {\\\\n      throw new Error(\\\\\\\"`onload` is a reserved function name\\\\\\\");\\\\n    }\\\\n\\\\n    if (api.dispose) {\\\\n      throw new Error(\\\\\\\"`dispose` is a reserved function name\\\\\\\");\\\\n    }\\\\n\\\\n    api.export = function (_interface) {\\\\n      rpc.setInterface(_interface);\\\\n    };\\\\n\\\\n    api.onLoad = function (handler) {\\\\n      handler = checkHandler(handler);\\\\n\\\\n      if (connected) {\\\\n        handler();\\\\n      } else {\\\\n        connectedHandlers.push(handler);\\\\n      }\\\\n    };\\\\n\\\\n    api.dispose = function (_interface) {\\\\n      rpc.disconnect();\\\\n    };\\\\n\\\\n    if (typeof WorkerGlobalScope !== \\\\\\\"undefined\\\\\\\" && self instanceof WorkerGlobalScope) {\\\\n      self.api = api;\\\\n      self.postMessage({\\\\n        type: \\\\\\\"imjoy_remote_api_ready\\\\\\\"\\\\n      });\\\\n    } else if (typeof window) {\\\\n      window.dispatchEvent(new CustomEvent(\\\\\\\"imjoy_remote_api_ready\\\\\\\", {\\\\n        detail: api\\\\n      }));\\\\n    }\\\\n  });\\\\n  let connected = false;\\\\n  const connectedHandlers = [];\\\\n\\\\n  const launchConnected = function () {\\\\n    if (!connected) {\\\\n      connected = true;\\\\n      let handler;\\\\n\\\\n      while (handler = connectedHandlers.pop()) {\\\\n        handler();\\\\n      }\\\\n    }\\\\n  };\\\\n\\\\n  const checkHandler = function (handler) {\\\\n    const type = typeof handler;\\\\n\\\\n    if (type !== \\\\\\\"function\\\\\\\") {\\\\n      const msg = \\\\\\\"A function may only be subsribed to the event, \\\\\\\" + type + \\\\\\\" was provided instead\\\\\\\";\\\\n      throw new Error(msg);\\\\n    }\\\\n\\\\n    return handler;\\\\n  };\\\\n\\\\n  return rpc;\\\\n}//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luQ29yZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbkNvcmUuanM/YTgxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcmUgcGx1Z2luIHNjcmlwdCBsb2FkZWQgaW50byB0aGUgcGx1Z2luIHByb2Nlc3MvdGhyZWFkLlxuICpcbiAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4tc2l0ZSBBUEkgZ2xvYmFsIG1ldGhvZHMuXG4gKi9cbmltcG9ydCB7IFJQQyB9IGZyb20gXCIuL3JwYy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdFJQQyhjb25uZWN0aW9uLCBjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gIGNvbnN0IHJwYyA9IG5ldyBSUEMoY29ubmVjdGlvbiwgY29uZmlnKTtcbiAgcnBjLm9uKFwiZ2V0SW50ZXJmYWNlXCIsIGZ1bmN0aW9uKCkge1xuICAgIGxhdW5jaENvbm5lY3RlZCgpO1xuICB9KTtcblxuICBycGMub24oXCJyZW1vdGVSZWFkeVwiLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBhcGkgPSBycGMuZ2V0UmVtb3RlKCkgfHwge307XG4gICAgaWYgKGFwaS5leHBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBleHBvcnRgIGlzIGEgcmVzZXJ2ZWQgZnVuY3Rpb24gbmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5vbmxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBvbmxvYWRgIGlzIGEgcmVzZXJ2ZWQgZnVuY3Rpb24gbmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5kaXNwb3NlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGlzcG9zZWAgaXMgYSByZXNlcnZlZCBmdW5jdGlvbiBuYW1lXCIpO1xuICAgIH1cbiAgICBhcGkuZXhwb3J0ID0gZnVuY3Rpb24oX2ludGVyZmFjZSkge1xuICAgICAgcnBjLnNldEludGVyZmFjZShfaW50ZXJmYWNlKTtcbiAgICB9O1xuICAgIGFwaS5vbkxvYWQgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyID0gY2hlY2tIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICBoYW5kbGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25uZWN0ZWRIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgYXBpLmRpc3Bvc2UgPSBmdW5jdGlvbihfaW50ZXJmYWNlKSB7XG4gICAgICBycGMuZGlzY29ubmVjdCgpO1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZVxuICAgICkge1xuICAgICAgc2VsZi5hcGkgPSBhcGk7XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJpbWpveV9yZW1vdGVfYXBpX3JlYWR5XCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdykge1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudChcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIiwgeyBkZXRhaWw6IGFwaSB9KVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxldCBjb25uZWN0ZWQgPSBmYWxzZTtcbiAgY29uc3QgY29ubmVjdGVkSGFuZGxlcnMgPSBbXTtcblxuICBjb25zdCBsYXVuY2hDb25uZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWNvbm5lY3RlZCkge1xuICAgICAgY29ubmVjdGVkID0gdHJ1ZTtcblxuICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICB3aGlsZSAoKGhhbmRsZXIgPSBjb25uZWN0ZWRIYW5kbGVycy5wb3AoKSkpIHtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBjaGVja0hhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBoYW5kbGVyO1xuICAgIGlmICh0eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IG1zZyA9XG4gICAgICAgIFwiQSBmdW5jdGlvbiBtYXkgb25seSBiZSBzdWJzcmliZWQgdG8gdGhlIGV2ZW50LCBcIiArXG4gICAgICAgIHR5cGUgK1xuICAgICAgICBcIiB3YXMgcHJvdmlkZWQgaW5zdGVhZFwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyO1xuICB9O1xuXG4gIHJldHVybiBycGM7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\\\\n//# sourceURL=webpack-internal:///./src/pluginCore.js\\\\n\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/rpc.js\\\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"API_VERSION\\\\\\\", function() { return API_VERSION; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"RPC\\\\\\\", function() { return RPC; });\\\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \\\\\\\"./src/utils.js\\\\\\\");\\\\n/**\\\\n * Contains the RPC object used both by the application\\\\n * site, and by each plugin\\\\n */\\\\n\\\\nconst API_VERSION = \\\\\\\"0.2.1\\\\\\\";\\\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\\\n\\\\nfunction _appendBuffer(buffer1, buffer2) {\\\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\\\n  tmp.set(new Uint8Array(buffer1), 0);\\\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\\\n  return tmp.buffer;\\\\n}\\\\n\\\\nfunction getKeyByValue(object, value) {\\\\n  return Object.keys(object).find(key => object[key] === value);\\\\n}\\\\n/**\\\\n * RPC object represents a single site in the\\\\n * communication protocol between the application and the plugin\\\\n *\\\\n * @param {Object} connection a special object allowing to send\\\\n * and receive messages from the opposite site (basically it\\\\n * should only provide send() and onMessage() methods)\\\\n */\\\\n\\\\n\\\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"MessageEmitter\\\\\\\"] {\\\\n  constructor(connection, config) {\\\\n    super(config && config.debug);\\\\n    this._connection = connection;\\\\n    this.config = config || {};\\\\n    this._interface_store = {};\\\\n    this._local_api = null; // make sure there is an execute function\\\\n\\\\n    const name = this.config.name;\\\\n\\\\n    this._connection.execute = this._connection.execute || function () {\\\\n      throw new Error(`connection.execute not implemented (in \\\\\\\"${name}\\\\\\\")`);\\\\n    };\\\\n\\\\n    this._store = new ReferenceStore();\\\\n    this._method_refs = new ReferenceStore();\\\\n\\\\n    this._method_refs.onReady(() => {\\\\n      this._fire(\\\\\\\"remoteIdle\\\\\\\");\\\\n    });\\\\n\\\\n    this._method_refs.onBusy(() => {\\\\n      this._fire(\\\\\\\"remoteBusy\\\\\\\");\\\\n    });\\\\n\\\\n    this._setupMessageHanlders();\\\\n  }\\\\n\\\\n  init() {\\\\n    this._connection.emit({\\\\n      type: \\\\\\\"initialized\\\\\\\",\\\\n      config: this.config,\\\\n      peer_id: this._connection.peer_id\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Set a handler to be called when received a responce from the\\\\n   * remote site reporting that the previously provided interface\\\\n   * has been successfully set as remote for that site\\\\n   *\\\\n   * @param {Function} handler\\\\n   */\\\\n\\\\n\\\\n  getRemoteCallStack() {\\\\n    return this._method_refs.getStack();\\\\n  }\\\\n  /**\\\\n   * @returns {Object} set of remote interface methods\\\\n   */\\\\n\\\\n\\\\n  getRemote() {\\\\n    return this._interface_store[\\\\\\\"_rremote\\\\\\\"];\\\\n  }\\\\n  /**\\\\n   * Sets the interface of this site making it available to the\\\\n   * remote site by sending a message with a set of methods names\\\\n   *\\\\n   * @param {Object} _interface to set\\\\n   */\\\\n\\\\n\\\\n  setInterface(_interface) {\\\\n    if (this.config.forwarding_functions) {\\\\n      for (let func_name of this.config.forwarding_functions) {\\\\n        const _remote = this._interface_store[\\\\\\\"_rremote\\\\\\\"];\\\\n\\\\n        if (_remote[func_name]) {\\\\n          if (_interface.constructor === Object) {\\\\n            if (!_interface[func_name]) {\\\\n              _interface[func_name] = (...args) => {\\\\n                _remote[func_name](...args);\\\\n              };\\\\n            }\\\\n          } else if (_interface.constructor.constructor === Function) {\\\\n            if (!_interface.constructor.prototype[func_name]) {\\\\n              _interface.constructor.prototype[func_name] = (...args) => {\\\\n                _remote[func_name](...args);\\\\n              };\\\\n            }\\\\n          }\\\\n        }\\\\n      }\\\\n    }\\\\n\\\\n    this._local_api = _interface;\\\\n\\\\n    this._fire(\\\\\\\"interfaceAvailable\\\\\\\");\\\\n  }\\\\n  /**\\\\n   * Sends the actual interface to the remote site upon it was\\\\n   * updated or by a special request of the remote site\\\\n   */\\\\n\\\\n\\\\n  sendInterface() {\\\\n    if (!this._local_api) {\\\\n      throw new Error(\\\\\\\"interface is not set.\\\\\\\");\\\\n    }\\\\n\\\\n    this._local_api._rid = \\\\\\\"_rlocal\\\\\\\";\\\\n\\\\n    const api = this._encode(this._local_api, true);\\\\n\\\\n    this._connection.emit({\\\\n      type: \\\\\\\"setInterface\\\\\\\",\\\\n      api: api\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Handles a message from the remote site\\\\n   */\\\\n  // var callback_reg = new RegExp(\\\\\\\"onupdate|run$\\\\\\\")\\\\n\\\\n\\\\n  _setupMessageHanlders() {\\\\n    this._connection.on(\\\\\\\"init\\\\\\\", this.init);\\\\n\\\\n    this._connection.on(\\\\\\\"execute\\\\\\\", data => {\\\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\\\n        this._connection.emit({\\\\n          type: \\\\\\\"executed\\\\\\\"\\\\n        });\\\\n      }).catch(e => {\\\\n        console.error(e);\\\\n\\\\n        this._connection.emit({\\\\n          type: \\\\\\\"executed\\\\\\\",\\\\n          error: e\\\\n        });\\\\n      });\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"method\\\\\\\", data => {\\\\n      let resolve, reject, method, args, result;\\\\n      let _interface = this._interface_store[data.pid];\\\\n\\\\n      const _method_context = _interface.__this__ || _interface;\\\\n\\\\n      if (!_interface) {\\\\n        if (data.promise) {\\\\n          [resolve, reject] = this._unwrap(data.promise, false);\\\\n          reject(`plugin api function is not avaialbe in \\\\\\\"${data.pid}\\\\\\\", the plugin maybe terminated.`);\\\\n        } else {\\\\n          console.error(`plugin api function is not avaialbe in ${data.pid}, the plugin maybe terminated.`);\\\\n        }\\\\n\\\\n        return;\\\\n      }\\\\n\\\\n      method = _interface[data.name];\\\\n      args = this._unwrap(data.args, true);\\\\n\\\\n      if (data.promise) {\\\\n        [resolve, reject] = this._unwrap(data.promise, false);\\\\n\\\\n        try {\\\\n          result = method.apply(_method_context, args);\\\\n\\\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\\\\\\"AsyncFunction\\\\\\\") {\\\\n            result.then(resolve).catch(reject);\\\\n          } else {\\\\n            resolve(result);\\\\n          }\\\\n        } catch (e) {\\\\n          console.error(this.config.name, e, method);\\\\n          reject(e);\\\\n        }\\\\n      } else {\\\\n        try {\\\\n          method.apply(_method_context, args);\\\\n        } catch (e) {\\\\n          console.error(this.config.name, e, method, args);\\\\n        }\\\\n      }\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"callback\\\\\\\", data => {\\\\n      let resolve, reject, method, args, result;\\\\n\\\\n      if (data.promise) {\\\\n        [resolve, reject] = this._unwrap(data.promise, false);\\\\n\\\\n        try {\\\\n          method = this._store.fetch(data._rindex);\\\\n          args = this._unwrap(data.args, true);\\\\n\\\\n          if (!method) {\\\\n            throw new Error(\\\\\\\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\\\\\");\\\\n          }\\\\n\\\\n          result = method.apply(null, args);\\\\n\\\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\\\\\\"AsyncFunction\\\\\\\") {\\\\n            result.then(resolve).catch(reject);\\\\n          } else {\\\\n            resolve(result);\\\\n          }\\\\n        } catch (e) {\\\\n          console.error(this.config.name, e, method);\\\\n          reject(e);\\\\n        }\\\\n      } else {\\\\n        try {\\\\n          method = this._store.fetch(data._rindex);\\\\n          args = this._unwrap(data.args, true);\\\\n\\\\n          if (!method) {\\\\n            throw new Error(\\\\\\\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\\\\\");\\\\n          }\\\\n\\\\n          method.apply(null, args);\\\\n        } catch (e) {\\\\n          console.error(this.config.name, e, method, args);\\\\n        }\\\\n      }\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"setInterface\\\\\\\", data => {\\\\n      this._setRemoteInterface(data.api);\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"getInterface\\\\\\\", () => {\\\\n      this._fire(\\\\\\\"getInterface\\\\\\\");\\\\n\\\\n      if (this._local_api) {\\\\n        this.sendInterface();\\\\n      } else {\\\\n        this.once(\\\\\\\"interfaceAvailable\\\\\\\", () => {\\\\n          this.sendInterface();\\\\n        });\\\\n      }\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"interfaceSetAsRemote\\\\\\\", () => {\\\\n      this._fire(\\\\\\\"interfaceSetAsRemote\\\\\\\");\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"disconnect\\\\\\\", () => {\\\\n      this._fire(\\\\\\\"beforeDisconnect\\\\\\\");\\\\n\\\\n      this._connection.disconnect();\\\\n\\\\n      this._fire(\\\\\\\"disconnected\\\\\\\");\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Sends a requests to the remote site asking it to provide its\\\\n   * current interface\\\\n   */\\\\n\\\\n\\\\n  requestRemote() {\\\\n    this._connection.emit({\\\\n      type: \\\\\\\"getInterface\\\\\\\"\\\\n    });\\\\n  }\\\\n\\\\n  _ndarray(typedArray, shape, dtype) {\\\\n    var _dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"typedArrayToDtype\\\\\\\"][typedArray.constructor.name];\\\\n\\\\n    if (dtype && dtype !== _dtype) {\\\\n      throw \\\\\\\"dtype doesn't match the type of the array: \\\\\\\" + _dtype + \\\\\\\" != \\\\\\\" + dtype;\\\\n    }\\\\n\\\\n    shape = shape || [typedArray.length];\\\\n    return {\\\\n      _rtype: \\\\\\\"ndarray\\\\\\\",\\\\n      _rvalue: typedArray,\\\\n      _rshape: shape,\\\\n      _rdtype: _dtype\\\\n    };\\\\n  }\\\\n  /**\\\\n   * Sets the new remote interface provided by the other site\\\\n   *\\\\n   * @param {Array} names list of function names\\\\n   */\\\\n\\\\n\\\\n  _setRemoteInterface(api) {\\\\n    this._interface_store[\\\\\\\"_rremote\\\\\\\"] = this._decode(api);\\\\n\\\\n    this._fire(\\\\\\\"remoteReady\\\\\\\");\\\\n\\\\n    this._reportRemoteSet();\\\\n  }\\\\n  /**\\\\n   * Generates the wrapped function corresponding to a single remote\\\\n   * method. When the generated function is called, it will send the\\\\n   * corresponding message to the remote site asking it to execute\\\\n   * the particular method of its interface\\\\n   *\\\\n   * @param {String} name of the remote method\\\\n   *\\\\n   * @returns {Function} wrapped remote method\\\\n   */\\\\n\\\\n\\\\n  _genRemoteMethod(name, interface_id) {\\\\n    var me = this;\\\\n\\\\n    var remoteMethod = function () {\\\\n      return new Promise((resolve, reject) => {\\\\n        let id = null;\\\\n\\\\n        try {\\\\n          id = me._method_refs.put(interface_id ? interface_id + \\\\\\\"/\\\\\\\" + name : name);\\\\n\\\\n          var wrapped_resolve = function () {\\\\n            if (id !== null) me._method_refs.fetch(id);\\\\n            return resolve.apply(this, arguments);\\\\n          };\\\\n\\\\n          var wrapped_reject = function () {\\\\n            if (id !== null) me._method_refs.fetch(id);\\\\n            return reject.apply(this, arguments);\\\\n          };\\\\n\\\\n          wrapped_resolve.__jailed_pairs__ = wrapped_reject;\\\\n          wrapped_reject.__jailed_pairs__ = wrapped_resolve;\\\\n          var args = Array.prototype.slice.call(arguments);\\\\n\\\\n          if (name === \\\\\\\"register\\\\\\\" || name === \\\\\\\"export\\\\\\\" || name === \\\\\\\"on\\\\\\\") {\\\\n            args = me._wrap(args, true);\\\\n          } else {\\\\n            args = me._wrap(args);\\\\n          }\\\\n\\\\n          var transferables = args.args.__transferables__;\\\\n          if (transferables) delete args.args.__transferables__;\\\\n\\\\n          me._connection.emit({\\\\n            type: \\\\\\\"method\\\\\\\",\\\\n            name: name,\\\\n            pid: interface_id,\\\\n            args: args,\\\\n            promise: me._wrap([wrapped_resolve, wrapped_reject])\\\\n          }, transferables);\\\\n        } catch (e) {\\\\n          if (id) me._method_refs.fetch(id);\\\\n          reject(`Failed to exectue remote method (interface: ${interface_id || me.id}, method: ${name}), error: ${e}`);\\\\n        }\\\\n      });\\\\n    };\\\\n\\\\n    remoteMethod.__remote_method = true;\\\\n    return remoteMethod;\\\\n  }\\\\n  /**\\\\n   * Sends a responce reporting that interface just provided by the\\\\n   * remote site was successfully set by this site as remote\\\\n   */\\\\n\\\\n\\\\n  _reportRemoteSet() {\\\\n    this._connection.emit({\\\\n      type: \\\\\\\"interfaceSetAsRemote\\\\\\\"\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Prepares the provided set of remote method arguments for\\\\n   * sending to the remote site, replaces all the callbacks with\\\\n   * identifiers\\\\n   *\\\\n   * @param {Array} args to wrap\\\\n   *\\\\n   * @returns {Array} wrapped arguments\\\\n   */\\\\n\\\\n\\\\n  _encodeInterface(aObject) {\\\\n    let v, k, keys;\\\\n    const encoded_interface = {};\\\\n    aObject[\\\\\\\"_rid\\\\\\\"] = aObject[\\\\\\\"_rid\\\\\\\"] || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"randId\\\\\\\"])(); // an object/array\\\\n\\\\n    if (aObject.constructor === Object || Array.isArray(aObject)) {\\\\n      keys = Object.keys(aObject);\\\\n    } // a class\\\\n    else if (aObject.constructor === Function) {\\\\n        throw new Error(\\\\\\\"Please instantiate the class before exportting it.\\\\\\\");\\\\n      } // instance of a class\\\\n      else if (aObject.constructor.constructor === Function) {\\\\n          keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\\\n        } else {\\\\n          throw Error(\\\\\\\"Unsupported interface type\\\\\\\");\\\\n        }\\\\n\\\\n    const bObject = Array.isArray(aObject) ? [] : {};\\\\n\\\\n    for (k of keys) {\\\\n      if ([\\\\\\\"hasOwnProperty\\\\\\\", \\\\\\\"constructor\\\\\\\"].includes(k)) continue;\\\\n\\\\n      if (k.startsWith(\\\\\\\"_\\\\\\\")) {\\\\n        continue;\\\\n      }\\\\n\\\\n      v = aObject[k];\\\\n\\\\n      if (typeof v === \\\\\\\"function\\\\\\\") {\\\\n        bObject[k] = {\\\\n          _rtype: \\\\\\\"interface\\\\\\\",\\\\n          _rid: aObject[\\\\\\\"_rid\\\\\\\"],\\\\n          _rvalue: k\\\\n        };\\\\n        encoded_interface[k] = v;\\\\n      } else if (Object(v) !== v) {\\\\n        bObject[k] = {\\\\n          _rtype: \\\\\\\"argument\\\\\\\",\\\\n          _rvalue: v\\\\n        };\\\\n        encoded_interface[k] = v;\\\\n      } else if (typeof v === \\\\\\\"object\\\\\\\") {\\\\n        bObject[k] = this._encodeInterface(v);\\\\n      }\\\\n    }\\\\n\\\\n    this._interface_store[aObject[\\\\\\\"_rid\\\\\\\"]] = encoded_interface; // remove interface when closed\\\\n\\\\n    if (aObject.on && typeof aObject.on === \\\\\\\"function\\\\\\\") {\\\\n      aObject.on(\\\\\\\"close\\\\\\\", () => {\\\\n        delete this._interface_store[aObject[\\\\\\\"_rid\\\\\\\"]];\\\\n      });\\\\n    }\\\\n\\\\n    return bObject;\\\\n  }\\\\n\\\\n  _encode(aObject, as_interface) {\\\\n    const transferables = [];\\\\n\\\\n    if (!aObject) {\\\\n      return aObject;\\\\n    }\\\\n\\\\n    const _transfer = aObject._transfer;\\\\n    let bObject, v, k;\\\\n    const isarray = Array.isArray(aObject); //skip if already encoded\\\\n\\\\n    if (typeof aObject === \\\\\\\"object\\\\\\\" && aObject._rtype && aObject._rvalue) {\\\\n      return aObject;\\\\n    } //encode interfaces\\\\n\\\\n\\\\n    if (typeof aObject === \\\\\\\"object\\\\\\\" && !Array.isArray(aObject) && (aObject._rintf || as_interface)) {\\\\n      return this._encodeInterface(aObject);\\\\n    }\\\\n\\\\n    if (as_interface) {\\\\n      aObject[\\\\\\\"_rid\\\\\\\"] = aObject[\\\\\\\"_rid\\\\\\\"] || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"randId\\\\\\\"])();\\\\n      this._interface_store[aObject[\\\\\\\"_rid\\\\\\\"]] = this._interface_store[aObject[\\\\\\\"_rid\\\\\\\"]] || (isarray ? [] : {});\\\\n    }\\\\n\\\\n    bObject = isarray ? [] : {};\\\\n\\\\n    for (k in aObject) {\\\\n      if ([\\\\\\\"hasOwnProperty\\\\\\\", \\\\\\\"constructor\\\\\\\"].includes(k)) continue;\\\\n\\\\n      if (isarray || aObject.hasOwnProperty(k)) {\\\\n        v = aObject[k];\\\\n\\\\n        if (v && typeof this._local_api._rpc_encode === \\\\\\\"function\\\\\\\") {\\\\n          const encoded_obj = this._local_api._rpc_encode(v);\\\\n\\\\n          if (encoded_obj && encoded_obj._ctype) {\\\\n            bObject[k] = {\\\\n              _rtype: \\\\\\\"custom\\\\\\\",\\\\n              _rvalue: encoded_obj,\\\\n              _rid: aObject[\\\\\\\"_rid\\\\\\\"]\\\\n            };\\\\n            continue;\\\\n          } // if the returned object does not contain _rtype, assuming the object has been transformed\\\\n          else if (encoded_obj !== undefined) {\\\\n              v = encoded_obj;\\\\n            }\\\\n        }\\\\n\\\\n        if (typeof v === \\\\\\\"function\\\\\\\") {\\\\n          if (as_interface) {\\\\n            const encoded_interface = this._interface_store[aObject[\\\\\\\"_rid\\\\\\\"]];\\\\n            bObject[k] = {\\\\n              _rtype: \\\\\\\"interface\\\\\\\",\\\\n              _rid: aObject[\\\\\\\"_rid\\\\\\\"],\\\\n              _rvalue: k\\\\n            };\\\\n            encoded_interface[k] = v;\\\\n            continue;\\\\n          }\\\\n\\\\n          let interfaceFuncName = null;\\\\n\\\\n          for (var name in this._local_api) {\\\\n            if (this._local_api.hasOwnProperty(name)) {\\\\n              if (name.startsWith(\\\\\\\"_\\\\\\\")) continue;\\\\n\\\\n              if (this._local_api[name] === v) {\\\\n                interfaceFuncName = name;\\\\n                break;\\\\n              }\\\\n            }\\\\n          } // search for prototypes\\\\n\\\\n\\\\n          var functions = Object.getOwnPropertyNames(Object.getPrototypeOf(this._local_api));\\\\n\\\\n          for (var i = 0; i < functions.length; i++) {\\\\n            var name_ = functions[i];\\\\n            if (name_.startsWith(\\\\\\\"_\\\\\\\")) continue;\\\\n\\\\n            if (this._local_api[name_] === v) {\\\\n              interfaceFuncName = name_;\\\\n              break;\\\\n            }\\\\n          }\\\\n\\\\n          if (!interfaceFuncName) {\\\\n            var id = this._store.put(v);\\\\n\\\\n            bObject[k] = {\\\\n              _rtype: \\\\\\\"callback\\\\\\\",\\\\n              _rvalue: v.constructor && v.constructor.name || id,\\\\n              _rindex: id\\\\n            };\\\\n          } else {\\\\n            bObject[k] = {\\\\n              _rtype: \\\\\\\"interface\\\\\\\",\\\\n              _rvalue: interfaceFuncName,\\\\n              _rid: \\\\\\\"_rlocal\\\\\\\"\\\\n            };\\\\n          }\\\\n        } else if (\\\\n        /*global tf*/\\\\n        typeof tf !== \\\\\\\"undefined\\\\\\\" && tf.Tensor && v instanceof tf.Tensor) {\\\\n          const v_buffer = v.dataSync();\\\\n\\\\n          if (v._transfer || _transfer) {\\\\n            transferables.push(v_buffer.buffer);\\\\n            delete v._transfer;\\\\n          }\\\\n\\\\n          bObject[k] = {\\\\n            _rtype: \\\\\\\"ndarray\\\\\\\",\\\\n            _rvalue: v_buffer,\\\\n            _rshape: v.shape,\\\\n            _rdtype: v.dtype\\\\n          };\\\\n        } else if (\\\\n        /*global nj*/\\\\n        typeof nj !== \\\\\\\"undefined\\\\\\\" && nj.NdArray && v instanceof nj.NdArray) {\\\\n          var dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"typedArrayToDtype\\\\\\\"][v.selection.data.constructor.name];\\\\n\\\\n          if (v._transfer || _transfer) {\\\\n            transferables.push(v.selection.data.buffer);\\\\n            delete v._transfer;\\\\n          }\\\\n\\\\n          bObject[k] = {\\\\n            _rtype: \\\\\\\"ndarray\\\\\\\",\\\\n            _rvalue: v.selection.data,\\\\n            _rshape: v.shape,\\\\n            _rdtype: dtype\\\\n          };\\\\n        } else if (v instanceof Error) {\\\\n          console.error(v);\\\\n          bObject[k] = {\\\\n            _rtype: \\\\\\\"error\\\\\\\",\\\\n            _rvalue: v.toString()\\\\n          };\\\\n        } else if (typeof File !== \\\\\\\"undefined\\\\\\\" && v instanceof File) {\\\\n          bObject[k] = {\\\\n            _rtype: \\\\\\\"file\\\\\\\",\\\\n            _rvalue: v,\\\\n            _rrelative_path: v.relativePath || v.webkitRelativePath\\\\n          };\\\\n        } // send objects supported by structure clone algorithm\\\\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\\\n        else if (v !== Object(v) || v instanceof Boolean || v instanceof String || v instanceof Date || v instanceof RegExp || v instanceof Blob || v instanceof ImageData || typeof FileList !== \\\\\\\"undefined\\\\\\\" && v instanceof FileList) {\\\\n            bObject[k] = {\\\\n              _rtype: \\\\\\\"argument\\\\\\\",\\\\n              _rvalue: v\\\\n            };\\\\n          } else if (v instanceof ArrayBuffer) {\\\\n            if (v._transfer || _transfer) {\\\\n              transferables.push(v);\\\\n              delete v._transfer;\\\\n            }\\\\n\\\\n            bObject[k] = {\\\\n              _rtype: \\\\\\\"argument\\\\\\\",\\\\n              _rvalue: v\\\\n            };\\\\n          } else if (v instanceof ArrayBufferView) {\\\\n            if (v._transfer || _transfer) {\\\\n              transferables.push(v.buffer);\\\\n              delete v._transfer;\\\\n            }\\\\n\\\\n            bObject[k] = {\\\\n              _rtype: \\\\\\\"argument\\\\\\\",\\\\n              _rvalue: v\\\\n            };\\\\n          } // TODO: support also Map and Set\\\\n          // TODO: avoid object such as DynamicPlugin instance.\\\\n          else if (v._rintf) {\\\\n              bObject[k] = this._encode(v, true);\\\\n            } else if (typeof v === \\\\\\\"object\\\\\\\") {\\\\n              bObject[k] = this._encode(v, as_interface); // move transferables to the top level object\\\\n\\\\n              if (bObject[k].__transferables__) {\\\\n                for (var t = 0; t < bObject[k].__transferables__.length; t++) {\\\\n                  transferables.push(bObject[k].__transferables__[t]);\\\\n                }\\\\n\\\\n                delete bObject[k].__transferables__;\\\\n              }\\\\n            } else {\\\\n              throw \\\\\\\"imjoy-rpc: Unsupported data type \\\\\\\" + k + \\\\\\\",\\\\\\\" + v;\\\\n            }\\\\n      }\\\\n    }\\\\n\\\\n    if (transferables.length > 0) {\\\\n      bObject.__transferables__ = transferables;\\\\n    }\\\\n\\\\n    return bObject;\\\\n  }\\\\n\\\\n  _decode(aObject, callbackId, withPromise) {\\\\n    if (!aObject) {\\\\n      return aObject;\\\\n    }\\\\n\\\\n    var bObject, v, k;\\\\n\\\\n    if (aObject.hasOwnProperty(\\\\\\\"_rtype\\\\\\\") && aObject.hasOwnProperty(\\\\\\\"_rvalue\\\\\\\")) {\\\\n      if (aObject._rtype === \\\\\\\"custom\\\\\\\") {\\\\n        if (aObject._rvalue && typeof this._local_api._rpc_decode === \\\\\\\"function\\\\\\\") {\\\\n          bObject = this._local_api._rpc_decode(aObject._rvalue);\\\\n\\\\n          if (bObject === undefined) {\\\\n            bObject = aObject;\\\\n          }\\\\n        } else {\\\\n          bObject = aObject;\\\\n        }\\\\n      } else if (aObject._rtype === \\\\\\\"callback\\\\\\\") {\\\\n        bObject = this._genRemoteCallback(callbackId, aObject._rindex, withPromise);\\\\n      } else if (aObject._rtype === \\\\\\\"interface\\\\\\\") {\\\\n        const intfid = aObject._rid === \\\\\\\"_rlocal\\\\\\\" ? \\\\\\\"_rrmote\\\\\\\" : aObject._rid;\\\\n        bObject = this._interface_store[intfid] && this._interface_store[intfid][aObject._rvalue] || this._genRemoteMethod(aObject._rvalue, aObject._rid);\\\\n      } else if (aObject._rtype === \\\\\\\"ndarray\\\\\\\") {\\\\n        /*global nj tf*/\\\\n        //create build array/tensor if used in the plugin\\\\n        if (typeof nj !== \\\\\\\"undefined\\\\\\\" && nj.array) {\\\\n          if (Array.isArray(aObject._rvalue)) {\\\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\\\n          }\\\\n\\\\n          bObject = nj.array(aObject._rvalue, aObject._rdtype).reshape(aObject._rshape);\\\\n        } else if (typeof tf !== \\\\\\\"undefined\\\\\\\" && tf.Tensor) {\\\\n          if (Array.isArray(aObject._rvalue)) {\\\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\\\n          }\\\\n\\\\n          bObject = tf.tensor(aObject._rvalue, aObject._rshape, aObject._rdtype);\\\\n        } else {\\\\n          //keep it as regular if transfered to the main app\\\\n          bObject = aObject;\\\\n        }\\\\n      } else if (aObject._rtype === \\\\\\\"error\\\\\\\") {\\\\n        bObject = new Error(aObject._rvalue);\\\\n      } else if (aObject._rtype === \\\\\\\"file\\\\\\\") {\\\\n        bObject = aObject._rvalue; //patch relativePath\\\\n\\\\n        bObject.relativePath = aObject._rrelative_path;\\\\n      } else if (aObject._rtype === \\\\\\\"argument\\\\\\\") {\\\\n        bObject = aObject._rvalue;\\\\n      }\\\\n\\\\n      return bObject;\\\\n    } else {\\\\n      var isarray = Array.isArray(aObject);\\\\n      bObject = isarray ? [] : {};\\\\n\\\\n      for (k in aObject) {\\\\n        if (isarray || aObject.hasOwnProperty(k)) {\\\\n          v = aObject[k];\\\\n\\\\n          if (typeof v === \\\\\\\"object\\\\\\\" || Array.isArray(v)) {\\\\n            bObject[k] = this._decode(v, callbackId, withPromise);\\\\n          }\\\\n        }\\\\n      }\\\\n\\\\n      return bObject;\\\\n    }\\\\n  }\\\\n\\\\n  _wrap(args, as_interface) {\\\\n    var wrapped = this._encode(args, as_interface);\\\\n\\\\n    var result = {\\\\n      args: wrapped\\\\n    };\\\\n    return result;\\\\n  }\\\\n  /**\\\\n   * Unwraps the set of arguments delivered from the remote site,\\\\n   * replaces all callback identifiers with a function which will\\\\n   * initiate sending that callback identifier back to other site\\\\n   *\\\\n   * @param {Object} args to unwrap\\\\n   *\\\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\\\n   *\\\\n   * @returns {Array} unwrapped args\\\\n   */\\\\n\\\\n\\\\n  _unwrap(args, withPromise) {\\\\n    // var called = false;\\\\n    // wraps each callback so that the only one could be called\\\\n    // var once(cb) {\\\\n    //     return function() {\\\\n    //         if (!called) {\\\\n    //             called = true;\\\\n    //             return cb.apply(this, arguments);\\\\n    //         } else {\\\\n    //             var msg =\\\\n    //               'A callback from this set has already been executed';\\\\n    //             throw new Error(msg);\\\\n    //         }\\\\n    //     };\\\\n    // }\\\\n    var result = this._decode(args.args, args.callbackId, withPromise);\\\\n\\\\n    return result;\\\\n  }\\\\n  /**\\\\n   * Generates the wrapped function corresponding to a single remote\\\\n   * callback. When the generated function is called, it will send\\\\n   * the corresponding message to the remote site asking it to\\\\n   * execute the particular callback previously saved during a call\\\\n   * by the remote site a method from the interface of this site\\\\n   *\\\\n   * @param {Number} id of the remote callback to execute\\\\n   * @param {Number} argNum argument index of the callback\\\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\\\n   *\\\\n   * @returns {Function} wrapped remote callback\\\\n   */\\\\n\\\\n\\\\n  _genRemoteCallback(id, argNum, withPromise) {\\\\n    var me = this;\\\\n    var remoteCallback;\\\\n\\\\n    if (withPromise) {\\\\n      remoteCallback = function () {\\\\n        return new Promise((resolve, reject) => {\\\\n          var args = me._wrap(Array.prototype.slice.call(arguments));\\\\n\\\\n          var transferables = args.args.__transferables__;\\\\n          if (transferables) delete args.args.__transferables__;\\\\n          resolve.__jailed_pairs__ = reject;\\\\n          reject.__jailed_pairs__ = resolve;\\\\n\\\\n          try {\\\\n            me._connection.emit({\\\\n              type: \\\\\\\"callback\\\\\\\",\\\\n              id: id,\\\\n              _rindex: argNum,\\\\n              args: args,\\\\n              // pid :  me.id,\\\\n              promise: me._wrap([resolve, reject])\\\\n            }, transferables);\\\\n          } catch (e) {\\\\n            reject(`Failed to exectue remote callback (id: ${id}, argNum: ${argNum}).`);\\\\n          }\\\\n        });\\\\n      };\\\\n\\\\n      return remoteCallback;\\\\n    } else {\\\\n      remoteCallback = function () {\\\\n        var args = me._wrap(Array.prototype.slice.call(arguments));\\\\n\\\\n        var transferables = args.args.__transferables__;\\\\n        if (transferables) delete args.args.__transferables__;\\\\n        return me._connection.emit({\\\\n          type: \\\\\\\"callback\\\\\\\",\\\\n          id: id,\\\\n          _rindex: argNum,\\\\n          args: args // pid :  me.id\\\\n\\\\n        }, transferables);\\\\n      };\\\\n\\\\n      return remoteCallback;\\\\n    }\\\\n  }\\\\n  /**\\\\n   * Sends the notification message and breaks the connection\\\\n   */\\\\n\\\\n\\\\n  disconnect() {\\\\n    this._connection.emit({\\\\n      type: \\\\\\\"disconnect\\\\\\\"\\\\n    });\\\\n\\\\n    setTimeout(() => {\\\\n      this._connection.disconnect();\\\\n    }, 2000);\\\\n  }\\\\n\\\\n}\\\\n/**\\\\n * ReferenceStore is a special object which stores other objects\\\\n * and provides the references (number) instead. This reference\\\\n * may then be sent over a json-based communication channel (IPC\\\\n * to another Node.js process or a message to the Worker). Other\\\\n * site may then provide the reference in the responce message\\\\n * implying the given object should be activated.\\\\n *\\\\n * Primary usage for the ReferenceStore is a storage for the\\\\n * callbacks, which therefore makes it possible to initiate a\\\\n * callback execution by the opposite site (which normally cannot\\\\n * directly execute functions over the communication channel).\\\\n *\\\\n * Each stored object can only be fetched once and is not\\\\n * available for the second time. Each stored object must be\\\\n * fetched, since otherwise it will remain stored forever and\\\\n * consume memory.\\\\n *\\\\n * Stored object indeces are simply the numbers, which are however\\\\n * released along with the objects, and are later reused again (in\\\\n * order to postpone the overflow, which should not likely happen,\\\\n * but anyway).\\\\n */\\\\n\\\\nclass ReferenceStore {\\\\n  constructor() {\\\\n    this._store = {}; // stored object\\\\n\\\\n    this._indices = [0]; // smallest available indices\\\\n\\\\n    this._readyHandler = function () {};\\\\n\\\\n    this._busyHandler = function () {};\\\\n\\\\n    this._readyHandler();\\\\n  }\\\\n  /**\\\\n   * call handler when the store is empty\\\\n   *\\\\n   * @param {FUNCTION} id of a handler\\\\n   */\\\\n\\\\n\\\\n  onReady(readyHandler) {\\\\n    this._readyHandler = readyHandler || function () {};\\\\n  }\\\\n  /**\\\\n   * call handler when the store is not empty\\\\n   *\\\\n   * @param {FUNCTION} id of a handler\\\\n   */\\\\n\\\\n\\\\n  onBusy(busyHandler) {\\\\n    this._busyHandler = busyHandler || function () {};\\\\n  }\\\\n  /**\\\\n   * get the length of the store\\\\n   *\\\\n   */\\\\n\\\\n\\\\n  getStack() {\\\\n    return Object.keys(this._store).length;\\\\n  }\\\\n  /**\\\\n   * @function _genId() generates the new reference id\\\\n   *\\\\n   * @returns {Number} smallest available id and reserves it\\\\n   */\\\\n\\\\n\\\\n  _genId() {\\\\n    var id;\\\\n\\\\n    if (this._indices.length === 1) {\\\\n      id = this._indices[0]++;\\\\n    } else {\\\\n      id = this._indices.shift();\\\\n    }\\\\n\\\\n    return id;\\\\n  }\\\\n  /**\\\\n   * Releases the given reference id so that it will be available by\\\\n   * another object stored\\\\n   *\\\\n   * @param {Number} id to release\\\\n   */\\\\n\\\\n\\\\n  _releaseId(id) {\\\\n    for (var i = 0; i < this._indices.length; i++) {\\\\n      if (id < this._indices[i]) {\\\\n        this._indices.splice(i, 0, id);\\\\n\\\\n        break;\\\\n      }\\\\n    } // cleaning-up the sequence tail\\\\n\\\\n\\\\n    for (i = this._indices.length - 1; i >= 0; i--) {\\\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\\\n        this._indices.pop();\\\\n      } else {\\\\n        break;\\\\n      }\\\\n    }\\\\n  }\\\\n  /**\\\\n   * Stores the given object and returns the refernce id instead\\\\n   *\\\\n   * @param {Object} obj to store\\\\n   *\\\\n   * @returns {Number} reference id of the stored object\\\\n   */\\\\n\\\\n\\\\n  put(obj) {\\\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\\\n      this._busyHandler();\\\\n    }\\\\n\\\\n    var id = this._genId();\\\\n\\\\n    this._store[id] = obj;\\\\n    return id;\\\\n  }\\\\n  /**\\\\n   * Retrieves previously stored object and releases its reference\\\\n   *\\\\n   * @param {Number} id of an object to retrieve\\\\n   */\\\\n\\\\n\\\\n  fetch(id) {\\\\n    var obj = this._store[id];\\\\n\\\\n    if (obj && !obj.__remote_method) {\\\\n      delete this._store[id];\\\\n\\\\n      this._releaseId(id);\\\\n\\\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\\\n        this._readyHandler();\\\\n      }\\\\n    }\\\\n\\\\n    if (obj && obj.__jailed_pairs__) {\\\\n      const _id = getKeyByValue(this._store, obj.__jailed_pairs__);\\\\n\\\\n      this.fetch(_id);\\\\n    }\\\\n\\\\n    return obj;\\\\n  }\\\\n\\\\n}//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcnBjLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9zcmMvcnBjLmpzPzM1NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyB0aGUgUlBDIG9iamVjdCB1c2VkIGJvdGggYnkgdGhlIGFwcGxpY2F0aW9uXG4gKiBzaXRlLCBhbmQgYnkgZWFjaCBwbHVnaW5cbiAqL1xuaW1wb3J0IHsgcmFuZElkLCB0eXBlZEFycmF5VG9EdHlwZSwgTWVzc2FnZUVtaXR0ZXIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuXG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT04gPSBcIjAuMi4xXCI7XG5cbmNvbnN0IEFycmF5QnVmZmVyVmlldyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihcbiAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBVaW50OEFycmF5KCkpXG4pLmNvbnN0cnVjdG9yO1xuXG5mdW5jdGlvbiBfYXBwZW5kQnVmZmVyKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcbiAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcbiAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIxKSwgMCk7XG4gIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMiksIGJ1ZmZlcjEuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB0bXAuYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlCeVZhbHVlKG9iamVjdCwgdmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkuZmluZChrZXkgPT4gb2JqZWN0W2tleV0gPT09IHZhbHVlKTtcbn1cbi8qKlxuICogUlBDIG9iamVjdCByZXByZXNlbnRzIGEgc2luZ2xlIHNpdGUgaW4gdGhlXG4gKiBjb21tdW5pY2F0aW9uIHByb3RvY29sIGJldHdlZW4gdGhlIGFwcGxpY2F0aW9uIGFuZCB0aGUgcGx1Z2luXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb24gYSBzcGVjaWFsIG9iamVjdCBhbGxvd2luZyB0byBzZW5kXG4gKiBhbmQgcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIHRoZSBvcHBvc2l0ZSBzaXRlIChiYXNpY2FsbHkgaXRcbiAqIHNob3VsZCBvbmx5IHByb3ZpZGUgc2VuZCgpIGFuZCBvbk1lc3NhZ2UoKSBtZXRob2RzKVxuICovXG5leHBvcnQgY2xhc3MgUlBDIGV4dGVuZHMgTWVzc2FnZUVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBjb25maWcpIHtcbiAgICBzdXBlcihjb25maWcgJiYgY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLl9pbnRlcmZhY2Vfc3RvcmUgPSB7fTtcbiAgICB0aGlzLl9sb2NhbF9hcGkgPSBudWxsO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhbiBleGVjdXRlIGZ1bmN0aW9uXG4gICAgY29uc3QgbmFtZSA9IHRoaXMuY29uZmlnLm5hbWU7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5leGVjdXRlID1cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZXhlY3V0ZSB8fFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29ubmVjdGlvbi5leGVjdXRlIG5vdCBpbXBsZW1lbnRlZCAoaW4gXCIke25hbWV9XCIpYCk7XG4gICAgICB9O1xuICAgIHRoaXMuX3N0b3JlID0gbmV3IFJlZmVyZW5jZVN0b3JlKCk7XG4gICAgdGhpcy5fbWV0aG9kX3JlZnMgPSBuZXcgUmVmZXJlbmNlU3RvcmUoKTtcbiAgICB0aGlzLl9tZXRob2RfcmVmcy5vblJlYWR5KCgpID0+IHtcbiAgICAgIHRoaXMuX2ZpcmUoXCJyZW1vdGVJZGxlXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuX21ldGhvZF9yZWZzLm9uQnVzeSgoKSA9PiB7XG4gICAgICB0aGlzLl9maXJlKFwicmVtb3RlQnVzeVwiKTtcbiAgICB9KTtcbiAgICB0aGlzLl9zZXR1cE1lc3NhZ2VIYW5sZGVycygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoe1xuICAgICAgdHlwZTogXCJpbml0aWFsaXplZFwiLFxuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIHBlZXJfaWQ6IHRoaXMuX2Nvbm5lY3Rpb24ucGVlcl9pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHJlY2VpdmVkIGEgcmVzcG9uY2UgZnJvbSB0aGVcbiAgICogcmVtb3RlIHNpdGUgcmVwb3J0aW5nIHRoYXQgdGhlIHByZXZpb3VzbHkgcHJvdmlkZWQgaW50ZXJmYWNlXG4gICAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZXQgYXMgcmVtb3RlIGZvciB0aGF0IHNpdGVcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cblxuICBnZXRSZW1vdGVDYWxsU3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGhvZF9yZWZzLmdldFN0YWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge09iamVjdH0gc2V0IG9mIHJlbW90ZSBpbnRlcmZhY2UgbWV0aG9kc1xuICAgKi9cbiAgZ2V0UmVtb3RlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcmZhY2Vfc3RvcmVbXCJfcnJlbW90ZVwiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBzaXRlIG1ha2luZyBpdCBhdmFpbGFibGUgdG8gdGhlXG4gICAqIHJlbW90ZSBzaXRlIGJ5IHNlbmRpbmcgYSBtZXNzYWdlIHdpdGggYSBzZXQgb2YgbWV0aG9kcyBuYW1lc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gX2ludGVyZmFjZSB0byBzZXRcbiAgICovXG4gIHNldEludGVyZmFjZShfaW50ZXJmYWNlKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBmdW5jX25hbWUgb2YgdGhpcy5jb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnMpIHtcbiAgICAgICAgY29uc3QgX3JlbW90ZSA9IHRoaXMuX2ludGVyZmFjZV9zdG9yZVtcIl9ycmVtb3RlXCJdO1xuICAgICAgICBpZiAoX3JlbW90ZVtmdW5jX25hbWVdKSB7XG4gICAgICAgICAgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlW2Z1bmNfbmFtZV0pIHtcbiAgICAgICAgICAgICAgX2ludGVyZmFjZVtmdW5jX25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBfcmVtb3RlW2Z1bmNfbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtmdW5jX25hbWVdKSB7XG4gICAgICAgICAgICAgIF9pbnRlcmZhY2UuY29uc3RydWN0b3IucHJvdG90eXBlW2Z1bmNfbmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIF9yZW1vdGVbZnVuY19uYW1lXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbG9jYWxfYXBpID0gX2ludGVyZmFjZTtcbiAgICB0aGlzLl9maXJlKFwiaW50ZXJmYWNlQXZhaWxhYmxlXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBhY3R1YWwgaW50ZXJmYWNlIHRvIHRoZSByZW1vdGUgc2l0ZSB1cG9uIGl0IHdhc1xuICAgKiB1cGRhdGVkIG9yIGJ5IGEgc3BlY2lhbCByZXF1ZXN0IG9mIHRoZSByZW1vdGUgc2l0ZVxuICAgKi9cbiAgc2VuZEludGVyZmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuX2xvY2FsX2FwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJmYWNlIGlzIG5vdCBzZXQuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9sb2NhbF9hcGkuX3JpZCA9IFwiX3Jsb2NhbFwiO1xuICAgIGNvbnN0IGFwaSA9IHRoaXMuX2VuY29kZSh0aGlzLl9sb2NhbF9hcGksIHRydWUpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7IHR5cGU6IFwic2V0SW50ZXJmYWNlXCIsIGFwaTogYXBpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBtZXNzYWdlIGZyb20gdGhlIHJlbW90ZSBzaXRlXG4gICAqL1xuICAvLyB2YXIgY2FsbGJhY2tfcmVnID0gbmV3IFJlZ0V4cChcIm9udXBkYXRlfHJ1biRcIilcbiAgX3NldHVwTWVzc2FnZUhhbmxkZXJzKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJpbml0XCIsIHRoaXMuaW5pdCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImV4ZWN1dGVcIiwgZGF0YSA9PiB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5fY29ubmVjdGlvbi5leGVjdXRlKGRhdGEuY29kZSkpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImV4ZWN1dGVkXCIgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBcImV4ZWN1dGVkXCIsXG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJtZXRob2RcIiwgZGF0YSA9PiB7XG4gICAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0LCBtZXRob2QsIGFyZ3MsIHJlc3VsdDtcbiAgICAgIGxldCBfaW50ZXJmYWNlID0gdGhpcy5faW50ZXJmYWNlX3N0b3JlW2RhdGEucGlkXTtcbiAgICAgIGNvbnN0IF9tZXRob2RfY29udGV4dCA9IF9pbnRlcmZhY2UuX190aGlzX18gfHwgX2ludGVyZmFjZTtcbiAgICAgIGlmICghX2ludGVyZmFjZSkge1xuICAgICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgICAgW3Jlc29sdmUsIHJlamVjdF0gPSB0aGlzLl91bndyYXAoZGF0YS5wcm9taXNlLCBmYWxzZSk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgYHBsdWdpbiBhcGkgZnVuY3Rpb24gaXMgbm90IGF2YWlhbGJlIGluIFwiJHtkYXRhLnBpZH1cIiwgdGhlIHBsdWdpbiBtYXliZSB0ZXJtaW5hdGVkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgcGx1Z2luIGFwaSBmdW5jdGlvbiBpcyBub3QgYXZhaWFsYmUgaW4gJHtkYXRhLnBpZH0sIHRoZSBwbHVnaW4gbWF5YmUgdGVybWluYXRlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1ldGhvZCA9IF9pbnRlcmZhY2VbZGF0YS5uYW1lXTtcbiAgICAgIGFyZ3MgPSB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcbiAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcbiAgICAgICAgW3Jlc29sdmUsIHJlamVjdF0gPSB0aGlzLl91bndyYXAoZGF0YS5wcm9taXNlLCBmYWxzZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KF9tZXRob2RfY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLmNvbmZpZy5uYW1lLCBlLCBtZXRob2QpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZXRob2QuYXBwbHkoX21ldGhvZF9jb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZSwgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImNhbGxiYWNrXCIsIGRhdGEgPT4ge1xuICAgICAgbGV0IHJlc29sdmUsIHJlamVjdCwgbWV0aG9kLCBhcmdzLCByZXN1bHQ7XG4gICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgIFtyZXNvbHZlLCByZWplY3RdID0gdGhpcy5fdW53cmFwKGRhdGEucHJvbWlzZSwgZmFsc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1ldGhvZCA9IHRoaXMuX3N0b3JlLmZldGNoKGRhdGEuX3JpbmRleCk7XG4gICAgICAgICAgYXJncyA9IHRoaXMuX3Vud3JhcChkYXRhLmFyZ3MsIHRydWUpO1xuICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGJhY2sgZnVuY3Rpb24gY2FuIG9ubHkgY2FsbGVkIG9uY2UsIGlmIHlvdSB3YW50IHRvIGNhbGwgYSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgdGltZXMsIHBsZWFzZSBtYWtlIGl0IGFzIGEgcGx1Z2luIGFwaSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vaW1qb3kuaW8vZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLmNvbmZpZy5uYW1lLCBlLCBtZXRob2QpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZXRob2QgPSB0aGlzLl9zdG9yZS5mZXRjaChkYXRhLl9yaW5kZXgpO1xuICAgICAgICAgIGFyZ3MgPSB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIlBsZWFzZSBub3RpY2UgdGhhdCBjYWxsYmFjayBmdW5jdGlvbiBjYW4gb25seSBjYWxsZWQgb25jZSwgaWYgeW91IHdhbnQgdG8gY2FsbCBhIGZ1bmN0aW9uIGZvciBtdWx0aXBsZSB0aW1lcywgcGxlYXNlIG1ha2UgaXQgYXMgYSBwbHVnaW4gYXBpIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9pbWpveS5pby9kb2NzIGZvciBtb3JlIGRldGFpbHMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1ldGhvZC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZSwgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJzZXRJbnRlcmZhY2VcIiwgZGF0YSA9PiB7XG4gICAgICB0aGlzLl9zZXRSZW1vdGVJbnRlcmZhY2UoZGF0YS5hcGkpO1xuICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJnZXRJbnRlcmZhY2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fZmlyZShcImdldEludGVyZmFjZVwiKTtcbiAgICAgIGlmICh0aGlzLl9sb2NhbF9hcGkpIHtcbiAgICAgICAgdGhpcy5zZW5kSW50ZXJmYWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uY2UoXCJpbnRlcmZhY2VBdmFpbGFibGVcIiwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2VuZEludGVyZmFjZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFwiaW50ZXJmYWNlU2V0QXNSZW1vdGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fZmlyZShcImludGVyZmFjZVNldEFzUmVtb3RlXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2ZpcmUoXCJiZWZvcmVEaXNjb25uZWN0XCIpO1xuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9maXJlKFwiZGlzY29ubmVjdGVkXCIpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdHMgdG8gdGhlIHJlbW90ZSBzaXRlIGFza2luZyBpdCB0byBwcm92aWRlIGl0c1xuICAgKiBjdXJyZW50IGludGVyZmFjZVxuICAgKi9cbiAgcmVxdWVzdFJlbW90ZSgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImdldEludGVyZmFjZVwiIH0pO1xuICB9XG5cbiAgX25kYXJyYXkodHlwZWRBcnJheSwgc2hhcGUsIGR0eXBlKSB7XG4gICAgdmFyIF9kdHlwZSA9IHR5cGVkQXJyYXlUb0R0eXBlW3R5cGVkQXJyYXkuY29uc3RydWN0b3IubmFtZV07XG4gICAgaWYgKGR0eXBlICYmIGR0eXBlICE9PSBfZHR5cGUpIHtcbiAgICAgIHRocm93IFwiZHR5cGUgZG9lc24ndCBtYXRjaCB0aGUgdHlwZSBvZiB0aGUgYXJyYXk6IFwiICtcbiAgICAgICAgX2R0eXBlICtcbiAgICAgICAgXCIgIT0gXCIgK1xuICAgICAgICBkdHlwZTtcbiAgICB9XG4gICAgc2hhcGUgPSBzaGFwZSB8fCBbdHlwZWRBcnJheS5sZW5ndGhdO1xuICAgIHJldHVybiB7XG4gICAgICBfcnR5cGU6IFwibmRhcnJheVwiLFxuICAgICAgX3J2YWx1ZTogdHlwZWRBcnJheSxcbiAgICAgIF9yc2hhcGU6IHNoYXBlLFxuICAgICAgX3JkdHlwZTogX2R0eXBlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuZXcgcmVtb3RlIGludGVyZmFjZSBwcm92aWRlZCBieSB0aGUgb3RoZXIgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBsaXN0IG9mIGZ1bmN0aW9uIG5hbWVzXG4gICAqL1xuICBfc2V0UmVtb3RlSW50ZXJmYWNlKGFwaSkge1xuICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVtcIl9ycmVtb3RlXCJdID0gdGhpcy5fZGVjb2RlKGFwaSk7XG4gICAgdGhpcy5fZmlyZShcInJlbW90ZVJlYWR5XCIpO1xuICAgIHRoaXMuX3JlcG9ydFJlbW90ZVNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgd3JhcHBlZCBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIHJlbW90ZVxuICAgKiBtZXRob2QuIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZCB0aGVcbiAgICogY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG8gZXhlY3V0ZVxuICAgKiB0aGUgcGFydGljdWxhciBtZXRob2Qgb2YgaXRzIGludGVyZmFjZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgcmVtb3RlIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgcmVtb3RlIG1ldGhvZFxuICAgKi9cbiAgX2dlblJlbW90ZU1ldGhvZChuYW1lLCBpbnRlcmZhY2VfaWQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZW1vdGVNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWQgPSBtZS5fbWV0aG9kX3JlZnMucHV0KFxuICAgICAgICAgICAgaW50ZXJmYWNlX2lkID8gaW50ZXJmYWNlX2lkICsgXCIvXCIgKyBuYW1lIDogbmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIHdyYXBwZWRfcmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGlkICE9PSBudWxsKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciB3cmFwcGVkX3JlamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGlkICE9PSBudWxsKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB3cmFwcGVkX3Jlc29sdmUuX19qYWlsZWRfcGFpcnNfXyA9IHdyYXBwZWRfcmVqZWN0O1xuICAgICAgICAgIHdyYXBwZWRfcmVqZWN0Ll9famFpbGVkX3BhaXJzX18gPSB3cmFwcGVkX3Jlc29sdmU7XG5cbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVnaXN0ZXJcIiB8fCBuYW1lID09PSBcImV4cG9ydFwiIHx8IG5hbWUgPT09IFwib25cIikge1xuICAgICAgICAgICAgYXJncyA9IG1lLl93cmFwKGFyZ3MsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzID0gbWUuX3dyYXAoYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIG1lLl9jb25uZWN0aW9uLmVtaXQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWV0aG9kXCIsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIHBpZDogaW50ZXJmYWNlX2lkLFxuICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICBwcm9taXNlOiBtZS5fd3JhcChbd3JhcHBlZF9yZXNvbHZlLCB3cmFwcGVkX3JlamVjdF0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmZXJhYmxlc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoaWQpIG1lLl9tZXRob2RfcmVmcy5mZXRjaChpZCk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdHVlIHJlbW90ZSBtZXRob2QgKGludGVyZmFjZTogJHtpbnRlcmZhY2VfaWQgfHxcbiAgICAgICAgICAgICAgbWUuaWR9LCBtZXRob2Q6ICR7bmFtZX0pLCBlcnJvcjogJHtlfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJlbW90ZU1ldGhvZC5fX3JlbW90ZV9tZXRob2QgPSB0cnVlO1xuICAgIHJldHVybiByZW1vdGVNZXRob2Q7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSByZXNwb25jZSByZXBvcnRpbmcgdGhhdCBpbnRlcmZhY2UganVzdCBwcm92aWRlZCBieSB0aGVcbiAgICogcmVtb3RlIHNpdGUgd2FzIHN1Y2Nlc3NmdWxseSBzZXQgYnkgdGhpcyBzaXRlIGFzIHJlbW90ZVxuICAgKi9cbiAgX3JlcG9ydFJlbW90ZVNldCgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImludGVyZmFjZVNldEFzUmVtb3RlXCIgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgdGhlIHByb3ZpZGVkIHNldCBvZiByZW1vdGUgbWV0aG9kIGFyZ3VtZW50cyBmb3JcbiAgICogc2VuZGluZyB0byB0aGUgcmVtb3RlIHNpdGUsIHJlcGxhY2VzIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGhcbiAgICogaWRlbnRpZmllcnNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyB0byB3cmFwXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gd3JhcHBlZCBhcmd1bWVudHNcbiAgICovXG5cbiAgX2VuY29kZUludGVyZmFjZShhT2JqZWN0KSB7XG4gICAgbGV0IHYsIGssIGtleXM7XG4gICAgY29uc3QgZW5jb2RlZF9pbnRlcmZhY2UgPSB7fTtcbiAgICBhT2JqZWN0W1wiX3JpZFwiXSA9IGFPYmplY3RbXCJfcmlkXCJdIHx8IHJhbmRJZCgpO1xuICAgIC8vIGFuIG9iamVjdC9hcnJheVxuICAgIGlmIChhT2JqZWN0LmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgQXJyYXkuaXNBcnJheShhT2JqZWN0KSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGFPYmplY3QpO1xuICAgIH1cbiAgICAvLyBhIGNsYXNzXG4gICAgZWxzZSBpZiAoYU9iamVjdC5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBpbnN0YW50aWF0ZSB0aGUgY2xhc3MgYmVmb3JlIGV4cG9ydHRpbmcgaXQuXCIpO1xuICAgIH1cbiAgICAvLyBpbnN0YW5jZSBvZiBhIGNsYXNzXG4gICAgZWxzZSBpZiAoYU9iamVjdC5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoYU9iamVjdCkpLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoYU9iamVjdClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgaW50ZXJmYWNlIHR5cGVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgYk9iamVjdCA9IEFycmF5LmlzQXJyYXkoYU9iamVjdCkgPyBbXSA6IHt9O1xuXG4gICAgZm9yIChrIG9mIGtleXMpIHtcbiAgICAgIGlmIChbXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdLmluY2x1ZGVzKGspKSBjb250aW51ZTtcblxuICAgICAgaWYgKGsuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2ID0gYU9iamVjdFtrXTtcblxuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICBfcnR5cGU6IFwiaW50ZXJmYWNlXCIsXG4gICAgICAgICAgX3JpZDogYU9iamVjdFtcIl9yaWRcIl0sXG4gICAgICAgICAgX3J2YWx1ZToga1xuICAgICAgICB9O1xuICAgICAgICBlbmNvZGVkX2ludGVyZmFjZVtrXSA9IHY7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdCh2KSAhPT0gdikge1xuICAgICAgICBiT2JqZWN0W2tdID0geyBfcnR5cGU6IFwiYXJndW1lbnRcIiwgX3J2YWx1ZTogdiB9O1xuICAgICAgICBlbmNvZGVkX2ludGVyZmFjZVtrXSA9IHY7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGJPYmplY3Rba10gPSB0aGlzLl9lbmNvZGVJbnRlcmZhY2Uodik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVthT2JqZWN0W1wiX3JpZFwiXV0gPSBlbmNvZGVkX2ludGVyZmFjZTtcblxuICAgIC8vIHJlbW92ZSBpbnRlcmZhY2Ugd2hlbiBjbG9zZWRcbiAgICBpZiAoYU9iamVjdC5vbiAmJiB0eXBlb2YgYU9iamVjdC5vbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBhT2JqZWN0Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5faW50ZXJmYWNlX3N0b3JlW2FPYmplY3RbXCJfcmlkXCJdXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYk9iamVjdDtcbiAgfVxuXG4gIF9lbmNvZGUoYU9iamVjdCwgYXNfaW50ZXJmYWNlKSB7XG4gICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdO1xuICAgIGlmICghYU9iamVjdCkge1xuICAgICAgcmV0dXJuIGFPYmplY3Q7XG4gICAgfVxuICAgIGNvbnN0IF90cmFuc2ZlciA9IGFPYmplY3QuX3RyYW5zZmVyO1xuICAgIGxldCBiT2JqZWN0LCB2LCBrO1xuICAgIGNvbnN0IGlzYXJyYXkgPSBBcnJheS5pc0FycmF5KGFPYmplY3QpO1xuICAgIC8vc2tpcCBpZiBhbHJlYWR5IGVuY29kZWRcbiAgICBpZiAodHlwZW9mIGFPYmplY3QgPT09IFwib2JqZWN0XCIgJiYgYU9iamVjdC5fcnR5cGUgJiYgYU9iamVjdC5fcnZhbHVlKSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG5cbiAgICAvL2VuY29kZSBpbnRlcmZhY2VzXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGFPYmplY3QgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICFBcnJheS5pc0FycmF5KGFPYmplY3QpICYmXG4gICAgICAoYU9iamVjdC5fcmludGYgfHwgYXNfaW50ZXJmYWNlKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUludGVyZmFjZShhT2JqZWN0KTtcbiAgICB9XG5cbiAgICBpZiAoYXNfaW50ZXJmYWNlKSB7XG4gICAgICBhT2JqZWN0W1wiX3JpZFwiXSA9IGFPYmplY3RbXCJfcmlkXCJdIHx8IHJhbmRJZCgpO1xuICAgICAgdGhpcy5faW50ZXJmYWNlX3N0b3JlW2FPYmplY3RbXCJfcmlkXCJdXSA9XG4gICAgICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVthT2JqZWN0W1wiX3JpZFwiXV0gfHwgKGlzYXJyYXkgPyBbXSA6IHt9KTtcbiAgICB9XG5cbiAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgZm9yIChrIGluIGFPYmplY3QpIHtcbiAgICAgIGlmIChbXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdLmluY2x1ZGVzKGspKSBjb250aW51ZTtcbiAgICAgIGlmIChpc2FycmF5IHx8IGFPYmplY3QuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgdiA9IGFPYmplY3Rba107XG4gICAgICAgIGlmICh2ICYmIHR5cGVvZiB0aGlzLl9sb2NhbF9hcGkuX3JwY19lbmNvZGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWRfb2JqID0gdGhpcy5fbG9jYWxfYXBpLl9ycGNfZW5jb2RlKHYpO1xuICAgICAgICAgIGlmIChlbmNvZGVkX29iaiAmJiBlbmNvZGVkX29iai5fY3R5cGUpIHtcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICAgIF9ydHlwZTogXCJjdXN0b21cIixcbiAgICAgICAgICAgICAgX3J2YWx1ZTogZW5jb2RlZF9vYmosXG4gICAgICAgICAgICAgIF9yaWQ6IGFPYmplY3RbXCJfcmlkXCJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHRoZSByZXR1cm5lZCBvYmplY3QgZG9lcyBub3QgY29udGFpbiBfcnR5cGUsIGFzc3VtaW5nIHRoZSBvYmplY3QgaGFzIGJlZW4gdHJhbnNmb3JtZWRcbiAgICAgICAgICBlbHNlIGlmIChlbmNvZGVkX29iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2ID0gZW5jb2RlZF9vYmo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKGFzX2ludGVyZmFjZSkge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZF9pbnRlcmZhY2UgPSB0aGlzLl9pbnRlcmZhY2Vfc3RvcmVbYU9iamVjdFtcIl9yaWRcIl1dO1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgICAgX3J0eXBlOiBcImludGVyZmFjZVwiLFxuICAgICAgICAgICAgICBfcmlkOiBhT2JqZWN0W1wiX3JpZFwiXSxcbiAgICAgICAgICAgICAgX3J2YWx1ZToga1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVuY29kZWRfaW50ZXJmYWNlW2tdID0gdjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaW50ZXJmYWNlRnVuY05hbWUgPSBudWxsO1xuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5fbG9jYWxfYXBpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9jYWxfYXBpLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfXCIpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvY2FsX2FwaVtuYW1lXSA9PT0gdikge1xuICAgICAgICAgICAgICAgIGludGVyZmFjZUZ1bmNOYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzZWFyY2ggZm9yIHByb3RvdHlwZXNcbiAgICAgICAgICB2YXIgZnVuY3Rpb25zID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5fbG9jYWxfYXBpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lXyA9IGZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lXy5zdGFydHNXaXRoKFwiX1wiKSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9jYWxfYXBpW25hbWVfXSA9PT0gdikge1xuICAgICAgICAgICAgICBpbnRlcmZhY2VGdW5jTmFtZSA9IG5hbWVfO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpbnRlcmZhY2VGdW5jTmFtZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5fc3RvcmUucHV0KHYpO1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgICAgX3J0eXBlOiBcImNhbGxiYWNrXCIsXG4gICAgICAgICAgICAgIF9ydmFsdWU6ICh2LmNvbnN0cnVjdG9yICYmIHYuY29uc3RydWN0b3IubmFtZSkgfHwgaWQsXG4gICAgICAgICAgICAgIF9yaW5kZXg6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiT2JqZWN0W2tdID0ge1xuICAgICAgICAgICAgICBfcnR5cGU6IFwiaW50ZXJmYWNlXCIsXG4gICAgICAgICAgICAgIF9ydmFsdWU6IGludGVyZmFjZUZ1bmNOYW1lLFxuICAgICAgICAgICAgICBfcmlkOiBcIl9ybG9jYWxcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgLypnbG9iYWwgdGYqL1xuICAgICAgICAgIHR5cGVvZiB0ZiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgIHRmLlRlbnNvciAmJlxuICAgICAgICAgIHYgaW5zdGFuY2VvZiB0Zi5UZW5zb3JcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgdl9idWZmZXIgPSB2LmRhdGFTeW5jKCk7XG4gICAgICAgICAgaWYgKHYuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHZfYnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICBfcnR5cGU6IFwibmRhcnJheVwiLFxuICAgICAgICAgICAgX3J2YWx1ZTogdl9idWZmZXIsXG4gICAgICAgICAgICBfcnNoYXBlOiB2LnNoYXBlLFxuICAgICAgICAgICAgX3JkdHlwZTogdi5kdHlwZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgLypnbG9iYWwgbmoqL1xuICAgICAgICAgIHR5cGVvZiBuaiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgIG5qLk5kQXJyYXkgJiZcbiAgICAgICAgICB2IGluc3RhbmNlb2YgbmouTmRBcnJheVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZHR5cGUgPSB0eXBlZEFycmF5VG9EdHlwZVt2LnNlbGVjdGlvbi5kYXRhLmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh2LnNlbGVjdGlvbi5kYXRhLmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICBfcnR5cGU6IFwibmRhcnJheVwiLFxuICAgICAgICAgICAgX3J2YWx1ZTogdi5zZWxlY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIF9yc2hhcGU6IHYuc2hhcGUsXG4gICAgICAgICAgICBfcmR0eXBlOiBkdHlwZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcih2KTtcbiAgICAgICAgICBiT2JqZWN0W2tdID0geyBfcnR5cGU6IFwiZXJyb3JcIiwgX3J2YWx1ZTogdi50b1N0cmluZygpIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdiBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICBiT2JqZWN0W2tdID0ge1xuICAgICAgICAgICAgX3J0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIF9ydmFsdWU6IHYsXG4gICAgICAgICAgICBfcnJlbGF0aXZlX3BhdGg6IHYucmVsYXRpdmVQYXRoIHx8IHYud2Via2l0UmVsYXRpdmVQYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZW5kIG9iamVjdHMgc3VwcG9ydGVkIGJ5IHN0cnVjdHVyZSBjbG9uZSBhbGdvcml0aG1cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICB2ICE9PSBPYmplY3QodikgfHxcbiAgICAgICAgICB2IGluc3RhbmNlb2YgQm9vbGVhbiB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgICB2IGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAgICAgICB2IGluc3RhbmNlb2YgQmxvYiB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBJbWFnZURhdGEgfHxcbiAgICAgICAgICAodHlwZW9mIEZpbGVMaXN0ICE9PSBcInVuZGVmaW5lZFwiICYmIHYgaW5zdGFuY2VvZiBGaWxlTGlzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHsgX3J0eXBlOiBcImFyZ3VtZW50XCIsIF9ydmFsdWU6IHYgfTtcbiAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBpZiAodi5fdHJhbnNmZXIgfHwgX3RyYW5zZmVyKSB7XG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2godik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7IF9ydHlwZTogXCJhcmd1bWVudFwiLCBfcnZhbHVlOiB2IH07XG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyVmlldykge1xuICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh2LmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7IF9ydHlwZTogXCJhcmd1bWVudFwiLCBfcnZhbHVlOiB2IH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhbHNvIE1hcCBhbmQgU2V0XG4gICAgICAgIC8vIFRPRE86IGF2b2lkIG9iamVjdCBzdWNoIGFzIER5bmFtaWNQbHVnaW4gaW5zdGFuY2UuXG4gICAgICAgIGVsc2UgaWYgKHYuX3JpbnRmKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHRoaXMuX2VuY29kZSh2LCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGJPYmplY3Rba10gPSB0aGlzLl9lbmNvZGUodiwgYXNfaW50ZXJmYWNlKTtcbiAgICAgICAgICAvLyBtb3ZlIHRyYW5zZmVyYWJsZXMgdG8gdGhlIHRvcCBsZXZlbCBvYmplY3RcbiAgICAgICAgICBpZiAoYk9iamVjdFtrXS5fX3RyYW5zZmVyYWJsZXNfXykge1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fW3RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcImltam95LXJwYzogVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiICsgayArIFwiLFwiICsgdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBiT2JqZWN0Ll9fdHJhbnNmZXJhYmxlc19fID0gdHJhbnNmZXJhYmxlcztcbiAgICB9XG4gICAgcmV0dXJuIGJPYmplY3Q7XG4gIH1cblxuICBfZGVjb2RlKGFPYmplY3QsIGNhbGxiYWNrSWQsIHdpdGhQcm9taXNlKSB7XG4gICAgaWYgKCFhT2JqZWN0KSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG4gICAgdmFyIGJPYmplY3QsIHYsIGs7XG4gICAgaWYgKGFPYmplY3QuaGFzT3duUHJvcGVydHkoXCJfcnR5cGVcIikgJiYgYU9iamVjdC5oYXNPd25Qcm9wZXJ0eShcIl9ydmFsdWVcIikpIHtcbiAgICAgIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYU9iamVjdC5fcnZhbHVlICYmXG4gICAgICAgICAgdHlwZW9mIHRoaXMuX2xvY2FsX2FwaS5fcnBjX2RlY29kZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgIGJPYmplY3QgPSB0aGlzLl9sb2NhbF9hcGkuX3JwY19kZWNvZGUoYU9iamVjdC5fcnZhbHVlKTtcbiAgICAgICAgICBpZiAoYk9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBiT2JqZWN0ID0gYU9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiY2FsbGJhY2tcIikge1xuICAgICAgICBiT2JqZWN0ID0gdGhpcy5fZ2VuUmVtb3RlQ2FsbGJhY2soXG4gICAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgICBhT2JqZWN0Ll9yaW5kZXgsXG4gICAgICAgICAgd2l0aFByb21pc2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgY29uc3QgaW50ZmlkID0gYU9iamVjdC5fcmlkID09PSBcIl9ybG9jYWxcIiA/IFwiX3JybW90ZVwiIDogYU9iamVjdC5fcmlkO1xuICAgICAgICBiT2JqZWN0ID1cbiAgICAgICAgICAodGhpcy5faW50ZXJmYWNlX3N0b3JlW2ludGZpZF0gJiZcbiAgICAgICAgICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVtpbnRmaWRdW2FPYmplY3QuX3J2YWx1ZV0pIHx8XG4gICAgICAgICAgdGhpcy5fZ2VuUmVtb3RlTWV0aG9kKGFPYmplY3QuX3J2YWx1ZSwgYU9iamVjdC5fcmlkKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwibmRhcnJheVwiKSB7XG4gICAgICAgIC8qZ2xvYmFsIG5qIHRmKi9cbiAgICAgICAgLy9jcmVhdGUgYnVpbGQgYXJyYXkvdGVuc29yIGlmIHVzZWQgaW4gdGhlIHBsdWdpblxuICAgICAgICBpZiAodHlwZW9mIG5qICE9PSBcInVuZGVmaW5lZFwiICYmIG5qLmFycmF5KSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYU9iamVjdC5fcnZhbHVlKSkge1xuICAgICAgICAgICAgYU9iamVjdC5fcnZhbHVlID0gYU9iamVjdC5fcnZhbHVlLnJlZHVjZShfYXBwZW5kQnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYk9iamVjdCA9IG5qXG4gICAgICAgICAgICAuYXJyYXkoYU9iamVjdC5fcnZhbHVlLCBhT2JqZWN0Ll9yZHR5cGUpXG4gICAgICAgICAgICAucmVzaGFwZShhT2JqZWN0Ll9yc2hhcGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0Zi5UZW5zb3IpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhT2JqZWN0Ll9ydmFsdWUpKSB7XG4gICAgICAgICAgICBhT2JqZWN0Ll9ydmFsdWUgPSBhT2JqZWN0Ll9ydmFsdWUucmVkdWNlKF9hcHBlbmRCdWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiT2JqZWN0ID0gdGYudGVuc29yKFxuICAgICAgICAgICAgYU9iamVjdC5fcnZhbHVlLFxuICAgICAgICAgICAgYU9iamVjdC5fcnNoYXBlLFxuICAgICAgICAgICAgYU9iamVjdC5fcmR0eXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2tlZXAgaXQgYXMgcmVndWxhciBpZiB0cmFuc2ZlcmVkIHRvIHRoZSBtYWluIGFwcFxuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IG5ldyBFcnJvcihhT2JqZWN0Ll9ydmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IGFPYmplY3QuX3J2YWx1ZTtcbiAgICAgICAgLy9wYXRjaCByZWxhdGl2ZVBhdGhcbiAgICAgICAgYk9iamVjdC5yZWxhdGl2ZVBhdGggPSBhT2JqZWN0Ll9ycmVsYXRpdmVfcGF0aDtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiYXJndW1lbnRcIikge1xuICAgICAgICBiT2JqZWN0ID0gYU9iamVjdC5fcnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheShhT2JqZWN0KTtcbiAgICAgIGJPYmplY3QgPSBpc2FycmF5ID8gW10gOiB7fTtcbiAgICAgIGZvciAoayBpbiBhT2JqZWN0KSB7XG4gICAgICAgIGlmIChpc2FycmF5IHx8IGFPYmplY3QuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICB2ID0gYU9iamVjdFtrXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHRoaXMuX2RlY29kZSh2LCBjYWxsYmFja0lkLCB3aXRoUHJvbWlzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYk9iamVjdDtcbiAgICB9XG4gIH1cblxuICBfd3JhcChhcmdzLCBhc19pbnRlcmZhY2UpIHtcbiAgICB2YXIgd3JhcHBlZCA9IHRoaXMuX2VuY29kZShhcmdzLCBhc19pbnRlcmZhY2UpO1xuICAgIHZhciByZXN1bHQgPSB7IGFyZ3M6IHdyYXBwZWQgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVud3JhcHMgdGhlIHNldCBvZiBhcmd1bWVudHMgZGVsaXZlcmVkIGZyb20gdGhlIHJlbW90ZSBzaXRlLFxuICAgKiByZXBsYWNlcyBhbGwgY2FsbGJhY2sgaWRlbnRpZmllcnMgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHdpbGxcbiAgICogaW5pdGlhdGUgc2VuZGluZyB0aGF0IGNhbGxiYWNrIGlkZW50aWZpZXIgYmFjayB0byBvdGhlciBzaXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIHRvIHVud3JhcFxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhQcm9taXNlIGlzIHRydWUgbWVhbnMgdGhpcyB0aGUgY2FsbGJhY2sgc2hvdWxkIGNvbnRhaW4gYSBwcm9taXNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdW53cmFwcGVkIGFyZ3NcbiAgICovXG4gIF91bndyYXAoYXJncywgd2l0aFByb21pc2UpIHtcbiAgICAvLyB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICAvLyB3cmFwcyBlYWNoIGNhbGxiYWNrIHNvIHRoYXQgdGhlIG9ubHkgb25lIGNvdWxkIGJlIGNhbGxlZFxuICAgIC8vIHZhciBvbmNlKGNiKSB7XG4gICAgLy8gICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgLy8gICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgICAgICByZXR1cm4gY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyAgICAgICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICAgICAgdmFyIG1zZyA9XG4gICAgLy8gICAgICAgICAgICAgICAnQSBjYWxsYmFjayBmcm9tIHRoaXMgc2V0IGhhcyBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQnO1xuICAgIC8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9O1xuICAgIC8vIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZGVjb2RlKGFyZ3MuYXJncywgYXJncy5jYWxsYmFja0lkLCB3aXRoUHJvbWlzZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHdyYXBwZWQgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBhIHNpbmdsZSByZW1vdGVcbiAgICogY2FsbGJhY2suIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZFxuICAgKiB0aGUgY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG9cbiAgICogZXhlY3V0ZSB0aGUgcGFydGljdWxhciBjYWxsYmFjayBwcmV2aW91c2x5IHNhdmVkIGR1cmluZyBhIGNhbGxcbiAgICogYnkgdGhlIHJlbW90ZSBzaXRlIGEgbWV0aG9kIGZyb20gdGhlIGludGVyZmFjZSBvZiB0aGlzIHNpdGVcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIG9mIHRoZSByZW1vdGUgY2FsbGJhY2sgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYXJnTnVtIGFyZ3VtZW50IGluZGV4IG9mIHRoZSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhQcm9taXNlIGlzIHRydWUgbWVhbnMgdGhpcyB0aGUgY2FsbGJhY2sgc2hvdWxkIGNvbnRhaW4gYSBwcm9taXNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCByZW1vdGUgY2FsbGJhY2tcbiAgICovXG4gIF9nZW5SZW1vdGVDYWxsYmFjayhpZCwgYXJnTnVtLCB3aXRoUHJvbWlzZSkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHJlbW90ZUNhbGxiYWNrO1xuICAgIGlmICh3aXRoUHJvbWlzZSkge1xuICAgICAgcmVtb3RlQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB2YXIgYXJncyA9IG1lLl93cmFwKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIHJlc29sdmUuX19qYWlsZWRfcGFpcnNfXyA9IHJlamVjdDtcbiAgICAgICAgICByZWplY3QuX19qYWlsZWRfcGFpcnNfXyA9IHJlc29sdmU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lLl9jb25uZWN0aW9uLmVtaXQoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNhbGxiYWNrXCIsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIF9yaW5kZXg6IGFyZ051bSxcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgIC8vIHBpZCA6ICBtZS5pZCxcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBtZS5fd3JhcChbcmVzb2x2ZSwgcmVqZWN0XSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3R1ZSByZW1vdGUgY2FsbGJhY2sgKGlkOiAke2lkfSwgYXJnTnVtOiAke2FyZ051bX0pLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW90ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgcmV0dXJuIG1lLl9jb25uZWN0aW9uLmVtaXQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgX3JpbmRleDogYXJnTnVtLFxuICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgLy8gcGlkIDogIG1lLmlkXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2ZlcmFibGVzXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlbW90ZUNhbGxiYWNrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgbm90aWZpY2F0aW9uIG1lc3NhZ2UgYW5kIGJyZWFrcyB0aGUgY29ubmVjdGlvblxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImRpc2Nvbm5lY3RcIiB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgIH0sIDIwMDApO1xuICB9XG59XG5cbi8qKlxuICogUmVmZXJlbmNlU3RvcmUgaXMgYSBzcGVjaWFsIG9iamVjdCB3aGljaCBzdG9yZXMgb3RoZXIgb2JqZWN0c1xuICogYW5kIHByb3ZpZGVzIHRoZSByZWZlcmVuY2VzIChudW1iZXIpIGluc3RlYWQuIFRoaXMgcmVmZXJlbmNlXG4gKiBtYXkgdGhlbiBiZSBzZW50IG92ZXIgYSBqc29uLWJhc2VkIGNvbW11bmljYXRpb24gY2hhbm5lbCAoSVBDXG4gKiB0byBhbm90aGVyIE5vZGUuanMgcHJvY2VzcyBvciBhIG1lc3NhZ2UgdG8gdGhlIFdvcmtlcikuIE90aGVyXG4gKiBzaXRlIG1heSB0aGVuIHByb3ZpZGUgdGhlIHJlZmVyZW5jZSBpbiB0aGUgcmVzcG9uY2UgbWVzc2FnZVxuICogaW1wbHlpbmcgdGhlIGdpdmVuIG9iamVjdCBzaG91bGQgYmUgYWN0aXZhdGVkLlxuICpcbiAqIFByaW1hcnkgdXNhZ2UgZm9yIHRoZSBSZWZlcmVuY2VTdG9yZSBpcyBhIHN0b3JhZ2UgZm9yIHRoZVxuICogY2FsbGJhY2tzLCB3aGljaCB0aGVyZWZvcmUgbWFrZXMgaXQgcG9zc2libGUgdG8gaW5pdGlhdGUgYVxuICogY2FsbGJhY2sgZXhlY3V0aW9uIGJ5IHRoZSBvcHBvc2l0ZSBzaXRlICh3aGljaCBub3JtYWxseSBjYW5ub3RcbiAqIGRpcmVjdGx5IGV4ZWN1dGUgZnVuY3Rpb25zIG92ZXIgdGhlIGNvbW11bmljYXRpb24gY2hhbm5lbCkuXG4gKlxuICogRWFjaCBzdG9yZWQgb2JqZWN0IGNhbiBvbmx5IGJlIGZldGNoZWQgb25jZSBhbmQgaXMgbm90XG4gKiBhdmFpbGFibGUgZm9yIHRoZSBzZWNvbmQgdGltZS4gRWFjaCBzdG9yZWQgb2JqZWN0IG11c3QgYmVcbiAqIGZldGNoZWQsIHNpbmNlIG90aGVyd2lzZSBpdCB3aWxsIHJlbWFpbiBzdG9yZWQgZm9yZXZlciBhbmRcbiAqIGNvbnN1bWUgbWVtb3J5LlxuICpcbiAqIFN0b3JlZCBvYmplY3QgaW5kZWNlcyBhcmUgc2ltcGx5IHRoZSBudW1iZXJzLCB3aGljaCBhcmUgaG93ZXZlclxuICogcmVsZWFzZWQgYWxvbmcgd2l0aCB0aGUgb2JqZWN0cywgYW5kIGFyZSBsYXRlciByZXVzZWQgYWdhaW4gKGluXG4gKiBvcmRlciB0byBwb3N0cG9uZSB0aGUgb3ZlcmZsb3csIHdoaWNoIHNob3VsZCBub3QgbGlrZWx5IGhhcHBlbixcbiAqIGJ1dCBhbnl3YXkpLlxuICovXG5jbGFzcyBSZWZlcmVuY2VTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N0b3JlID0ge307IC8vIHN0b3JlZCBvYmplY3RcbiAgICB0aGlzLl9pbmRpY2VzID0gWzBdOyAvLyBzbWFsbGVzdCBhdmFpbGFibGUgaW5kaWNlc1xuICAgIHRoaXMuX3JlYWR5SGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5fYnVzeUhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX3JlYWR5SGFuZGxlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGwgaGFuZGxlciB3aGVuIHRoZSBzdG9yZSBpcyBlbXB0eVxuICAgKlxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcbiAgICovXG4gIG9uUmVhZHkocmVhZHlIYW5kbGVyKSB7XG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyID0gcmVhZHlIYW5kbGVyIHx8IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICAvKipcbiAgICogY2FsbCBoYW5kbGVyIHdoZW4gdGhlIHN0b3JlIGlzIG5vdCBlbXB0eVxuICAgKlxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcbiAgICovXG4gIG9uQnVzeShidXN5SGFuZGxlcikge1xuICAgIHRoaXMuX2J1c3lIYW5kbGVyID0gYnVzeUhhbmRsZXIgfHwgZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgc3RvcmVcbiAgICpcbiAgICovXG4gIGdldFN0YWNrKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdG9yZSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBfZ2VuSWQoKSBnZW5lcmF0ZXMgdGhlIG5ldyByZWZlcmVuY2UgaWRcbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gc21hbGxlc3QgYXZhaWxhYmxlIGlkIGFuZCByZXNlcnZlcyBpdFxuICAgKi9cbiAgX2dlbklkKCkge1xuICAgIHZhciBpZDtcbiAgICBpZiAodGhpcy5faW5kaWNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlkID0gdGhpcy5faW5kaWNlc1swXSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuX2luZGljZXMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIHJlZmVyZW5jZSBpZCBzbyB0aGF0IGl0IHdpbGwgYmUgYXZhaWxhYmxlIGJ5XG4gICAqIGFub3RoZXIgb2JqZWN0IHN0b3JlZFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgdG8gcmVsZWFzZVxuICAgKi9cbiAgX3JlbGVhc2VJZChpZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlkIDwgdGhpcy5faW5kaWNlc1tpXSkge1xuICAgICAgICB0aGlzLl9pbmRpY2VzLnNwbGljZShpLCAwLCBpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFuaW5nLXVwIHRoZSBzZXF1ZW5jZSB0YWlsXG4gICAgZm9yIChpID0gdGhpcy5faW5kaWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuX2luZGljZXNbaV0gLSAxID09PSB0aGlzLl9pbmRpY2VzW2kgLSAxXSkge1xuICAgICAgICB0aGlzLl9pbmRpY2VzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSByZWZlcm5jZSBpZCBpbnN0ZWFkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdG8gc3RvcmVcbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gcmVmZXJlbmNlIGlkIG9mIHRoZSBzdG9yZWQgb2JqZWN0XG4gICAqL1xuICBwdXQob2JqKSB7XG4gICAgaWYgKHRoaXMuX2J1c3lIYW5kbGVyICYmIE9iamVjdC5rZXlzKHRoaXMuX3N0b3JlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2J1c3lIYW5kbGVyKCk7XG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuX2dlbklkKCk7XG4gICAgdGhpcy5fc3RvcmVbaWRdID0gb2JqO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcHJldmlvdXNseSBzdG9yZWQgb2JqZWN0IGFuZCByZWxlYXNlcyBpdHMgcmVmZXJlbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBvZiBhbiBvYmplY3QgdG8gcmV0cmlldmVcbiAgICovXG4gIGZldGNoKGlkKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMuX3N0b3JlW2lkXTtcbiAgICBpZiAob2JqICYmICFvYmouX19yZW1vdGVfbWV0aG9kKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RvcmVbaWRdO1xuICAgICAgdGhpcy5fcmVsZWFzZUlkKGlkKTtcbiAgICAgIGlmICh0aGlzLl9yZWFkeUhhbmRsZXIgJiYgT2JqZWN0LmtleXModGhpcy5fc3RvcmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZWFkeUhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iaiAmJiBvYmouX19qYWlsZWRfcGFpcnNfXykge1xuICAgICAgY29uc3QgX2lkID0gZ2V0S2V5QnlWYWx1ZSh0aGlzLl9zdG9yZSwgb2JqLl9famFpbGVkX3BhaXJzX18pO1xuICAgICAgdGhpcy5mZXRjaChfaWQpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBUEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQVJBO0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBVUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXB3QkE7QUFzd0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBL0dBIiwic291cmNlUm9vdCI6IiJ9\\\\n//# sourceURL=webpack-internal:///./src/rpc.js\\\\n\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/utils.js\\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"randId\\\\\\\", function() { return randId; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"dtypeToTypedArray\\\\\\\", function() { return dtypeToTypedArray; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"typedArrayToDtype\\\\\\\", function() { return typedArrayToDtype; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"cacheRequirements\\\\\\\", function() { return cacheRequirements; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"setupServiceWorker\\\\\\\", function() { return setupServiceWorker; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"urlJoin\\\\\\\", function() { return urlJoin; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"MessageEmitter\\\\\\\", function() { return MessageEmitter; });\\\\nfunction randId() {\\\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\\\n}\\\\nconst dtypeToTypedArray = {\\\\n  int8: \\\\\\\"Int8Array\\\\\\\",\\\\n  int16: \\\\\\\"Int16Array\\\\\\\",\\\\n  int32: \\\\\\\"Int32Array\\\\\\\",\\\\n  uint8: \\\\\\\"Uint8Array\\\\\\\",\\\\n  uint16: \\\\\\\"Uint16Array\\\\\\\",\\\\n  uint32: \\\\\\\"Uint32Array\\\\\\\",\\\\n  float32: \\\\\\\"Float32Array\\\\\\\",\\\\n  float64: \\\\\\\"Float64Array\\\\\\\",\\\\n  array: \\\\\\\"Array\\\\\\\"\\\\n};\\\\nconst typedArrayToDtype = {\\\\n  Int8Array: \\\\\\\"int8\\\\\\\",\\\\n  Int16Array: \\\\\\\"int16\\\\\\\",\\\\n  Int32Array: \\\\\\\"int32\\\\\\\",\\\\n  Uint8Array: \\\\\\\"uint8\\\\\\\",\\\\n  Uint16Array: \\\\\\\"uint16\\\\\\\",\\\\n  Uint32Array: \\\\\\\"uint32\\\\\\\",\\\\n  Float32Array: \\\\\\\"float32\\\\\\\",\\\\n  Float64Array: \\\\\\\"float64\\\\\\\",\\\\n  Array: \\\\\\\"array\\\\\\\"\\\\n};\\\\n\\\\nfunction cacheUrlInServiceWorker(url) {\\\\n  return new Promise(function (resolve, reject) {\\\\n    const message = {\\\\n      command: \\\\\\\"add\\\\\\\",\\\\n      url: url\\\\n    };\\\\n\\\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\\\n      reject(\\\\\\\"Service worker is not supported.\\\\\\\");\\\\n      return;\\\\n    }\\\\n\\\\n    const messageChannel = new MessageChannel();\\\\n\\\\n    messageChannel.port1.onmessage = function (event) {\\\\n      if (event.data && event.data.error) {\\\\n        reject(event.data.error);\\\\n      } else {\\\\n        resolve(event.data && event.data.result);\\\\n      }\\\\n    };\\\\n\\\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\\\n    } else {\\\\n      reject(\\\\\\\"Service worker controller is not available\\\\\\\");\\\\n    }\\\\n  });\\\\n}\\\\n\\\\nasync function cacheRequirements(requirements) {\\\\n  if (!Array.isArray(requirements)) {\\\\n    requirementsm.code.requirements = [requirements];\\\\n  }\\\\n\\\\n  if (requirements && requirements.length > 0) {\\\\n    for (let req of requirements) {\\\\n      //remove prefix\\\\n      if (req.startsWith(\\\\\\\"js:\\\\\\\")) req = req.slice(3);\\\\n      if (req.startsWith(\\\\\\\"css:\\\\\\\")) req = req.slice(4);\\\\n      if (req.startsWith(\\\\\\\"cache:\\\\\\\")) req = req.slice(6);\\\\n      if (!req.startsWith(\\\\\\\"http\\\\\\\")) continue;\\\\n      await cacheUrlInServiceWorker(req).catch(e => {\\\\n        console.error(e);\\\\n      });\\\\n    }\\\\n  }\\\\n}\\\\nfunction setupServiceWorker(targetOrigin, cacheCallback) {\\\\n  // register service worker for offline access\\\\n  if (\\\\\\\"serviceWorker\\\\\\\" in navigator) {\\\\n    window.addEventListener(\\\\\\\"load\\\\\\\", function () {\\\\n      navigator.serviceWorker.register(\\\\\\\"/plugin-service-worker.js\\\\\\\").then(function (registration) {\\\\n        // Registration was successful\\\\n        console.log(\\\\\\\"ServiceWorker registration successful with scope: \\\\\\\", registration.scope);\\\\n      }, function (err) {\\\\n        // registration failed :(\\\\n        console.log(\\\\\\\"ServiceWorker registration failed: \\\\\\\", err);\\\\n      });\\\\n      targetOrigin = targetOrigin || \\\\\\\"*\\\\\\\";\\\\n      cacheCallback = cacheCallback || cacheRequirements;\\\\n\\\\n      if (cacheCallback && typeof cacheCallback !== \\\\\\\"function\\\\\\\") {\\\\n        throw new Error(\\\\\\\"config.cache_requirements must be a function\\\\\\\");\\\\n      }\\\\n\\\\n      window.addEventListener(\\\\\\\"message\\\\\\\", function (e) {\\\\n        if (targetOrigin === \\\\\\\"*\\\\\\\" || e.origin === targetOrigin) {\\\\n          const m = e.data;\\\\n\\\\n          if (m.type === \\\\\\\"cacheRequirements\\\\\\\") {\\\\n            cacheCallback(m.requirements);\\\\n          }\\\\n        }\\\\n      });\\\\n    });\\\\n  }\\\\n} //#Source https://bit.ly/2neWfJ2\\\\n\\\\nfunction urlJoin(...args) {\\\\n  return args.join(\\\\\\\"/\\\\\\\").replace(/[\\\\\\\\/]+/g, \\\\\\\"/\\\\\\\").replace(/^(.+):\\\\\\\\//, \\\\\\\"$1://\\\\\\\").replace(/^file:/, \\\\\\\"file:/\\\\\\\").replace(/\\\\\\\\/(\\\\\\\\?|&|#[^!])/g, \\\\\\\"$1\\\\\\\").replace(/\\\\\\\\?/g, \\\\\\\"&\\\\\\\").replace(\\\\\\\"&\\\\\\\", \\\\\\\"?\\\\\\\");\\\\n}\\\\nclass MessageEmitter {\\\\n  constructor(debug) {\\\\n    this._event_handlers = {};\\\\n    this._once_handlers = {};\\\\n    this._debug = debug;\\\\n  }\\\\n\\\\n  emit() {\\\\n    throw new Error(\\\\\\\"emit is not implemented\\\\\\\");\\\\n  }\\\\n\\\\n  on(event, handler) {\\\\n    if (!this._event_handlers[event]) {\\\\n      this._event_handlers[event] = [];\\\\n    }\\\\n\\\\n    this._event_handlers[event].push(handler);\\\\n  }\\\\n\\\\n  once(event, handler) {\\\\n    handler.___event_run_once = true;\\\\n    this.on(event, handler);\\\\n  }\\\\n\\\\n  off(event, handler) {\\\\n    if (!event && !handler) {\\\\n      // remove all events handlers\\\\n      this._event_handlers = {};\\\\n    } else if (event && !handler) {\\\\n      // remove all hanlders for the event\\\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\\\n    } else {\\\\n      // remove a specific handler\\\\n      if (this._event_handlers[event]) {\\\\n        const idx = this._event_handlers[event].indexOf(handler);\\\\n\\\\n        if (idx >= 0) {\\\\n          this._event_handlers[event].splice(idx, 1);\\\\n        }\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n  _fire(event, data) {\\\\n    if (this._event_handlers[event]) {\\\\n      var i = this._event_handlers[event].length;\\\\n\\\\n      while (i--) {\\\\n        const handler = this._event_handlers[event][i];\\\\n\\\\n        try {\\\\n          handler(data);\\\\n        } catch (e) {\\\\n          console.error(e);\\\\n        } finally {\\\\n          if (handler.___event_run_once) {\\\\n            this._event_handlers[event].splice(i, 1);\\\\n          }\\\\n        }\\\\n      }\\\\n    } else {\\\\n      if (this._debug) {\\\\n        console.warn(\\\\\\\"unhandled event\\\\\\\", event, data);\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n}//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWpveVJQQy8uL3NyYy91dGlscy5qcz8wMjVlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiByYW5kSWQoKSB7XG4gIHJldHVybiAoXG4gICAgTWF0aC5yYW5kb20oKVxuICAgICAgLnRvU3RyaW5nKDM2KVxuICAgICAgLnN1YnN0cigyLCAxMCkgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICApO1xufVxuXG5leHBvcnQgY29uc3QgZHR5cGVUb1R5cGVkQXJyYXkgPSB7XG4gIGludDg6IFwiSW50OEFycmF5XCIsXG4gIGludDE2OiBcIkludDE2QXJyYXlcIixcbiAgaW50MzI6IFwiSW50MzJBcnJheVwiLFxuICB1aW50ODogXCJVaW50OEFycmF5XCIsXG4gIHVpbnQxNjogXCJVaW50MTZBcnJheVwiLFxuICB1aW50MzI6IFwiVWludDMyQXJyYXlcIixcbiAgZmxvYXQzMjogXCJGbG9hdDMyQXJyYXlcIixcbiAgZmxvYXQ2NDogXCJGbG9hdDY0QXJyYXlcIixcbiAgYXJyYXk6IFwiQXJyYXlcIlxufTtcbmV4cG9ydCBjb25zdCB0eXBlZEFycmF5VG9EdHlwZSA9IHtcbiAgSW50OEFycmF5OiBcImludDhcIixcbiAgSW50MTZBcnJheTogXCJpbnQxNlwiLFxuICBJbnQzMkFycmF5OiBcImludDMyXCIsXG4gIFVpbnQ4QXJyYXk6IFwidWludDhcIixcbiAgVWludDE2QXJyYXk6IFwidWludDE2XCIsXG4gIFVpbnQzMkFycmF5OiBcInVpbnQzMlwiLFxuICBGbG9hdDMyQXJyYXk6IFwiZmxvYXQzMlwiLFxuICBGbG9hdDY0QXJyYXk6IFwiZmxvYXQ2NFwiLFxuICBBcnJheTogXCJhcnJheVwiXG59O1xuXG5mdW5jdGlvbiBjYWNoZVVybEluU2VydmljZVdvcmtlcih1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICBjb21tYW5kOiBcImFkZFwiLFxuICAgICAgdXJsOiB1cmxcbiAgICB9O1xuICAgIGlmICghbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgfHwgIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKSB7XG4gICAgICByZWplY3QoXCJTZXJ2aWNlIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lcnJvcikge1xuICAgICAgICByZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlci5wb3N0TWVzc2FnZShtZXNzYWdlLCBbXG4gICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQyXG4gICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KFwiU2VydmljZSB3b3JrZXIgY29udHJvbGxlciBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWNoZVJlcXVpcmVtZW50cyhyZXF1aXJlbWVudHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlcXVpcmVtZW50cykpIHtcbiAgICByZXF1aXJlbWVudHNtLmNvZGUucmVxdWlyZW1lbnRzID0gW3JlcXVpcmVtZW50c107XG4gIH1cbiAgaWYgKHJlcXVpcmVtZW50cyAmJiByZXF1aXJlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAobGV0IHJlcSBvZiByZXF1aXJlbWVudHMpIHtcbiAgICAgIC8vcmVtb3ZlIHByZWZpeFxuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFwianM6XCIpKSByZXEgPSByZXEuc2xpY2UoMyk7XG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXCJjc3M6XCIpKSByZXEgPSByZXEuc2xpY2UoNCk7XG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXCJjYWNoZTpcIikpIHJlcSA9IHJlcS5zbGljZSg2KTtcbiAgICAgIGlmICghcmVxLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSBjb250aW51ZTtcblxuICAgICAgYXdhaXQgY2FjaGVVcmxJblNlcnZpY2VXb3JrZXIocmVxKS5jYXRjaChlID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTZXJ2aWNlV29ya2VyKHRhcmdldE9yaWdpbiwgY2FjaGVDYWxsYmFjaykge1xuICAvLyByZWdpc3RlciBzZXJ2aWNlIHdvcmtlciBmb3Igb2ZmbGluZSBhY2Nlc3NcbiAgaWYgKFwic2VydmljZVdvcmtlclwiIGluIG5hdmlnYXRvcikge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKFwiL3BsdWdpbi1zZXJ2aWNlLXdvcmtlci5qc1wiKS50aGVuKFxuICAgICAgICBmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAvLyBSZWdpc3RyYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwiU2VydmljZVdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCB3aXRoIHNjb3BlOiBcIixcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5zY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIC8vIHJlZ2lzdHJhdGlvbiBmYWlsZWQgOihcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZDogXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0YXJnZXRPcmlnaW4gPSB0YXJnZXRPcmlnaW4gfHwgXCIqXCI7XG4gICAgICBjYWNoZUNhbGxiYWNrID0gY2FjaGVDYWxsYmFjayB8fCBjYWNoZVJlcXVpcmVtZW50cztcbiAgICAgIGlmIChjYWNoZUNhbGxiYWNrICYmIHR5cGVvZiBjYWNoZUNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uZmlnLmNhY2hlX3JlcXVpcmVtZW50cyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGFyZ2V0T3JpZ2luID09PSBcIipcIiB8fCBlLm9yaWdpbiA9PT0gdGFyZ2V0T3JpZ2luKSB7XG4gICAgICAgICAgY29uc3QgbSA9IGUuZGF0YTtcbiAgICAgICAgICBpZiAobS50eXBlID09PSBcImNhY2hlUmVxdWlyZW1lbnRzXCIpIHtcbiAgICAgICAgICAgIGNhY2hlQ2FsbGJhY2sobS5yZXF1aXJlbWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8jU291cmNlIGh0dHBzOi8vYml0Lmx5LzJuZVdmSjJcbmV4cG9ydCBmdW5jdGlvbiB1cmxKb2luKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3NcbiAgICAuam9pbihcIi9cIilcbiAgICAucmVwbGFjZSgvW1xcL10rL2csIFwiL1wiKVxuICAgIC5yZXBsYWNlKC9eKC4rKTpcXC8vLCBcIiQxOi8vXCIpXG4gICAgLnJlcGxhY2UoL15maWxlOi8sIFwiZmlsZTovXCIpXG4gICAgLnJlcGxhY2UoL1xcLyhcXD98JnwjW14hXSkvZywgXCIkMVwiKVxuICAgIC5yZXBsYWNlKC9cXD8vZywgXCImXCIpXG4gICAgLnJlcGxhY2UoXCImXCIsIFwiP1wiKTtcbn1cblxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoZGVidWcpIHtcbiAgICB0aGlzLl9ldmVudF9oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuX29uY2VfaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLl9kZWJ1ZyA9IGRlYnVnO1xuICB9XG4gIGVtaXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZW1pdCBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICB9XG4gIG9uY2UoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyLl9fX2V2ZW50X3J1bl9vbmNlID0gdHJ1ZTtcbiAgICB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoIWV2ZW50ICYmICFoYW5kbGVyKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGV2ZW50cyBoYW5kbGVyc1xuICAgICAgdGhpcy5fZXZlbnRfaGFuZGxlcnMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50ICYmICFoYW5kbGVyKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGhhbmxkZXJzIGZvciB0aGUgZXZlbnRcbiAgICAgIGlmICh0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0pIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgYSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICBpZiAodGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2ZpcmUoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF1baV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXIuX19fZXZlbnRfcnVuX29uY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJ1bmhhbmRsZWQgZXZlbnRcIiwgZXZlbnQsIGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6REEiLCJzb3VyY2VSb290IjoiIn0=\\\\n//# sourceURL=webpack-internal:///./src/utils.js\\\\n\\\");\\n\\n/***/ })\\n\\n/******/ });\", null);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luLndlYndvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanM/ZTdlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcmVxdWlyZShcIiEhL1VzZXJzL3dlaS5vdXlhbmcvd29ya3NwYWNlL2ltam95LXJwYy9qYXZhc2NyaXB0L25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3Qvd29ya2Vycy9JbmxpbmVXb3JrZXIuanNcIikoXCIvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0XFx0fVxcbi8qKioqKiovIFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuLyoqKioqKi8gXFx0XFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdGk6IG1vZHVsZUlkLFxcbi8qKioqKiovIFxcdFxcdFxcdGw6IGZhbHNlLFxcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9XFxuLyoqKioqKi8gXFx0XFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdFxcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbi8qKioqKiovIFxcdFxcdG1vZHVsZS5sID0gdHJ1ZTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG4vKioqKioqL1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xcbi8qKioqKiovIFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xcbi8qKioqKiovIFxcdFxcdH1cXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcXG4vKioqKioqLyBcXHRcXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcXG4vKioqKioqLyBcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcXG4vKioqKioqLyBcXHRcXHR9XFxuLyoqKioqKi8gXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcXG4vKioqKioqLyBcXHRcXHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xcbi8qKioqKiovIFxcdFxcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcXG4vKioqKioqLyBcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBucztcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcXG4vKioqKioqLyBcXHRcXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cXG4vKioqKioqLyBcXHRcXHRcXHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxcbi8qKioqKiovIFxcdFxcdFxcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBnZXR0ZXI7XFxuLyoqKioqKi8gXFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXFxcIlxcXCI7XFxuLyoqKioqKi9cXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xcbi8qKioqKiovIFxcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFxcXCIuL3NyYy9wbHVnaW4ud2Vid29ya2VyLmpzXFxcIik7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovICh7XFxuXFxuLyoqKi8gXFxcIi4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy9wbHVnaW4ud2Vid29ya2VyLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbmV2YWwoXFxcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luQ29yZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wbHVnaW5Db3JlLmpzICovIFxcXFxcXFwiLi9zcmMvcGx1Z2luQ29yZS5qc1xcXFxcXFwiKTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcnBjX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JwYy5qcyAqLyBcXFxcXFxcIi4vc3JjL3JwYy5qc1xcXFxcXFwiKTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMuanMgKi8gXFxcXFxcXCIuL3NyYy91dGlscy5qc1xcXFxcXFwiKTtcXFxcbi8qKlxcXFxuICogQ29udGFpbnMgdGhlIHJvdXRpbmVzIGxvYWRlZCBieSB0aGUgcGx1Z2luIFdvcmtlciB1bmRlciB3ZWItYnJvd3Nlci5cXFxcbiAqXFxcXG4gKiBJbml0aWFsaXplcyB0aGUgd2ViIGVudmlyb25tZW50IHZlcnNpb24gb2YgdGhlIHBsYXRmb3JtLWRlcGVuZGVudFxcXFxuICogY29ubmVjdGlvbiBvYmplY3QgZm9yIHRoZSBwbHVnaW4gc2l0ZVxcXFxuICovXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcbihmdW5jdGlvbigpIHtcXFxcbiAgLy8gbWFrZSBzdXJlIHRoaXMgcnVucyBpbnNpZGUgYSB3ZWJ3b3JrZXJcXFxcbiAgaWYgKFxcXFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiB8fFxcXFxuICAgICFzZWxmIHx8XFxcXG4gICAgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpXFxcXG4gICkge1xcXFxuICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIlRoaXMgc2NyaXB0IGNhbiBvbmx5IGxvYWRlZCBpbiBhIHdlYndvcmtlclxcXFxcXFwiKTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogQ29ubmVjdGlvbiBvYmplY3QgcHJvdmlkZWQgdG8gdGhlIFJQQyBjb25zdHJ1Y3RvcixcXFxcbiAgICogcGx1Z2luIHNpdGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSB3ZWItYmFzZWQgZW52aXJvbm1lbnQuXFxcXG4gICAqIEdsb2JhbCB3aWxsIGJlIHRoZW4gY2xlYXJlZCB0byBwcmV2ZW50IGV4cG9zdXJlIGludG8gdGhlXFxcXG4gICAqIFdvcmtlciwgc28gd2UgcHV0IHRoaXMgbG9jYWwgY29ubmVjdGlvbiBvYmplY3QgaW50byBhIGNsb3N1cmVcXFxcbiAgICovXFxcXG4gIGNsYXNzIENvbm5lY3Rpb24gZXh0ZW5kcyBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFxcXFxcIk1lc3NhZ2VFbWl0dGVyXFxcXFxcXCJdIHtcXFxcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcXFxcbiAgICAgIHN1cGVyKGNvbmZpZyAmJiBjb25maWcuZGVidWcpO1xcXFxuICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XFxcXG4gICAgfVxcXFxuICAgIGNvbm5lY3QoKSB7XFxcXG4gICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXFxcXFxcXCJtZXNzYWdlXFxcXFxcXCIsIGUgPT4ge1xcXFxuICAgICAgICB0aGlzLl9maXJlKGUuZGF0YS50eXBlLCBlLmRhdGEpO1xcXFxuICAgICAgfSk7XFxcXG4gICAgICB0aGlzLmVtaXQoe1xcXFxuICAgICAgICB0eXBlOiBcXFxcXFxcImluaXRpYWxpemVkXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdcXFxcbiAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBkaXNjb25uZWN0KCkge1xcXFxuICAgICAgdGhpcy5fZmlyZShcXFxcXFxcImJlZm9yZURpc2Nvbm5lY3RcXFxcXFxcIik7XFxcXG4gICAgICBzZWxmLmNsb3NlKCk7XFxcXG4gICAgICB0aGlzLl9maXJlKFxcXFxcXFwiZGlzY29ubmVjdGVkXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgICBlbWl0KGRhdGEpIHtcXFxcbiAgICAgIGxldCB0cmFuc2ZlcmFibGVzID0gdW5kZWZpbmVkO1xcXFxuICAgICAgaWYgKGRhdGEuX190cmFuc2ZlcmFibGVzX18pIHtcXFxcbiAgICAgICAgdHJhbnNmZXJhYmxlcyA9IGRhdGEuX190cmFuc2ZlcmFibGVzX187XFxcXG4gICAgICAgIGRlbGV0ZSBkYXRhLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgfVxcXFxuICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2ZlcmFibGVzKTtcXFxcbiAgICB9XFxcXG4gICAgYXN5bmMgZXhlY3V0ZShjb2RlKSB7XFxcXG4gICAgICBpZiAoY29kZS50eXBlID09PSBcXFxcXFxcInJlcXVpcmVtZW50c1xcXFxcXFwiKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgaWYgKFxcXFxuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgJiZcXFxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSB8fFxcXFxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFxcXFxcXFwic3RyaW5nXFxcXFxcXCIpXFxcXG4gICAgICAgICAgKSB7XFxcXG4gICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XFxcXG4gICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgPSBbY29kZS5yZXF1aXJlbWVudHNdO1xcXFxuICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZS5yZXF1aXJlbWVudHMubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBpZiAoXFxcXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFxcXFxcXFwiLmNzc1xcXFxcXFwiKSB8fFxcXFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcXFxcXFxcImNzczpcXFxcXFxcIilcXFxcbiAgICAgICAgICAgICAgICApIHtcXFxcbiAgICAgICAgICAgICAgICAgIHRocm93IFxcXFxcXFwidW5hYmxlIHRvIGltcG9ydCBjc3MgaW4gYSB3ZWJ3b3JrZXJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxcXFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcXFxcXFxcIi5qc1xcXFxcXFwiKSB8fFxcXFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcXFxcXFxcImpzOlxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgICkge1xcXFxuICAgICAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXFxcXFxcXCJqczpcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0gPSBjb2RlLnJlcXVpcmVtZW50c1tpXS5zbGljZSgzKTtcXFxcbiAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcXFxcXFxcImNhY2hlOlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgICAgLy9pZ25vcmUgY2FjaGVcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiVW5wcm9jZXNzZWQgcmVxdWlyZW1lbnRzIHVybDogXFxcXFxcXCIgKyBjb2RlLnJlcXVpcmVtZW50c1tpXVxcXFxuICAgICAgICAgICAgICAgICAgKTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgdGhyb3cgXFxcXFxcXCJmYWlsZWQgdG8gaW1wb3J0IHJlcXVpcmVkIHNjcmlwdHM6IFxcXFxcXFwiICtcXFxcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cy50b1N0cmluZygpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH0gZWxzZSBpZiAoY29kZS50eXBlID09PSBcXFxcXFxcInNjcmlwdFxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgaWYgKFxcXFxuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgJiZcXFxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSB8fFxcXFxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFxcXFxcXFwic3RyaW5nXFxcXFxcXCIpXFxcXG4gICAgICAgICAgKSB7XFxcXG4gICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2RlLnJlcXVpcmVtZW50cykpIHtcXFxcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUucmVxdWlyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgICBpbXBvcnRTY3JpcHRzKGNvZGUucmVxdWlyZW1lbnRzW2ldKTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50cyk7XFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgdGhyb3cgXFxcXFxcXCJmYWlsZWQgdG8gaW1wb3J0IHJlcXVpcmVkIHNjcmlwdHM6IFxcXFxcXFwiICtcXFxcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cy50b1N0cmluZygpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBldmFsKGNvZGUuY29udGVudCk7XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSwgZS5zdGFjayk7XFxcXG4gICAgICAgICAgdGhyb3cgZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdGhyb3cgXFxcXFxcXCJ1bnN1cHBvcnRlZCBjb2RlIHR5cGUuXFxcXFxcXCI7XFxcXG4gICAgICB9XFxcXG4gICAgICBpZiAoY29kZS50eXBlID09PSBcXFxcXFxcInJlcXVpcmVtZW50c1xcXFxcXFwiKSB7XFxcXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xcXFxuICAgICAgICAgIHR5cGU6IFxcXFxcXFwiY2FjaGVSZXF1aXJlbWVudHNcXFxcXFxcIixcXFxcbiAgICAgICAgICByZXF1aXJlbWVudHM6IGNvZGUucmVxdWlyZW1lbnRzXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcbiAgfVxcXFxuICBjb25zdCBjb25maWcgPSB7XFxcXG4gICAgdHlwZTogXFxcXFxcXCJ3ZWItd29ya2VyXFxcXFxcXCIsXFxcXG4gICAgZGVkaWNhdGVkX3RocmVhZDogdHJ1ZSxcXFxcbiAgICBhbGxvd19leGVjdXRpb246IHRydWUsXFxcXG4gICAgbGFuZzogXFxcXFxcXCJqYXZhc2NyaXB0XFxcXFxcXCIsXFxcXG4gICAgYXBpX3ZlcnNpb246IF9ycGNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFxcXFxcIkFQSV9WRVJTSU9OXFxcXFxcXCJdXFxcXG4gIH07XFxcXG4gIGNvbnN0IGNvbm4gPSBuZXcgQ29ubmVjdGlvbihjb25maWcpO1xcXFxuICBjb25uLm9uKFxcXFxcXFwiY29ubmVjdFJQQ1xcXFxcXFwiLCBkYXRhID0+IHtcXFxcbiAgICBPYmplY3QoX3BsdWdpbkNvcmVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcImNvbm5lY3RSUENcXFxcXFxcIl0pKGNvbm4sIE9iamVjdC5hc3NpZ24oZGF0YS5jb25maWcsIGNvbmZpZykpO1xcXFxuICB9KTtcXFxcbiAgY29ubi5jb25uZWN0KCk7XFxcXG4gIHNlbGYucG9zdE1lc3NhZ2Uoe1xcXFxuICAgIHR5cGU6IFxcXFxcXFwid29ya2VyLXJlYWR5XFxcXFxcXCJcXFxcbiAgfSk7XFxcXG59KSgpO1xcXFxuLy8jIHNvdXJjZVVSTD1bbW9kdWxlXVxcXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lMaTl6Y21NdmNHeDFaMmx1TG5kbFluZHZjbXRsY2k1cWN5NXFjeUlzSW5OdmRYSmpaWE1pT2xzaWQyVmljR0ZqYXpvdkwybHRhbTk1VWxCREx5NHZjM0pqTDNCc2RXZHBiaTUzWldKM2IzSnJaWEl1YW5NL09HTTFOQ0pkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJdktpcGNiaUFxSUVOdmJuUmhhVzV6SUhSb1pTQnliM1YwYVc1bGN5QnNiMkZrWldRZ1lua2dkR2hsSUhCc2RXZHBiaUJYYjNKclpYSWdkVzVrWlhJZ2QyVmlMV0p5YjNkelpYSXVYRzRnS2x4dUlDb2dTVzVwZEdsaGJHbDZaWE1nZEdobElIZGxZaUJsYm5acGNtOXViV1Z1ZENCMlpYSnphVzl1SUc5bUlIUm9aU0J3YkdGMFptOXliUzFrWlhCbGJtUmxiblJjYmlBcUlHTnZibTVsWTNScGIyNGdiMkpxWldOMElHWnZjaUIwYUdVZ2NHeDFaMmx1SUhOcGRHVmNiaUFxTDF4dWFXMXdiM0owSUhzZ1kyOXVibVZqZEZKUVF5QjlJR1p5YjIwZ1hDSXVMM0JzZFdkcGJrTnZjbVV1YW5OY0lqdGNibWx0Y0c5eWRDQjdJRUZRU1Y5V1JWSlRTVTlPSUgwZ1puSnZiU0JjSWk0dmNuQmpMbXB6WENJN1hHNXBiWEJ2Y25RZ2V5Qk5aWE56WVdkbFJXMXBkSFJsY2l3Z2NtRnVaRWxrSUgwZ1puSnZiU0JjSWk0dmRYUnBiSE11YW5OY0lqdGNibHh1S0daMWJtTjBhVzl1S0NrZ2UxeHVJQ0F2THlCdFlXdGxJSE4xY21VZ2RHaHBjeUJ5ZFc1eklHbHVjMmxrWlNCaElIZGxZbmR2Y210bGNseHVJQ0JwWmlBb1hHNGdJQ0FnZEhsd1pXOW1JRmR2Y210bGNrZHNiMkpoYkZOamIzQmxJRDA5UFNCY0luVnVaR1ZtYVc1bFpGd2lJSHg4WEc0Z0lDQWdJWE5sYkdZZ2ZIeGNiaUFnSUNBaEtITmxiR1lnYVc1emRHRnVZMlZ2WmlCWGIzSnJaWEpIYkc5aVlXeFRZMjl3WlNsY2JpQWdLU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtGd2lWR2hwY3lCelkzSnBjSFFnWTJGdUlHOXViSGtnYkc5aFpHVmtJR2x1SUdFZ2QyVmlkMjl5YTJWeVhDSXBPMXh1SUNCOVhHNGdJQzhxS2x4dUlDQWdLaUJEYjI1dVpXTjBhVzl1SUc5aWFtVmpkQ0J3Y205MmFXUmxaQ0IwYnlCMGFHVWdVbEJESUdOdmJuTjBjblZqZEc5eUxGeHVJQ0FnS2lCd2JIVm5hVzRnYzJsMFpTQnBiWEJzWlcxbGJuUmhkR2x2YmlCbWIzSWdkR2hsSUhkbFlpMWlZWE5sWkNCbGJuWnBjbTl1YldWdWRDNWNiaUFnSUNvZ1IyeHZZbUZzSUhkcGJHd2dZbVVnZEdobGJpQmpiR1ZoY21Wa0lIUnZJSEJ5WlhabGJuUWdaWGh3YjNOMWNtVWdhVzUwYnlCMGFHVmNiaUFnSUNvZ1YyOXlhMlZ5TENCemJ5QjNaU0J3ZFhRZ2RHaHBjeUJzYjJOaGJDQmpiMjV1WldOMGFXOXVJRzlpYW1WamRDQnBiblJ2SUdFZ1kyeHZjM1Z5WlZ4dUlDQWdLaTljYmlBZ1kyeGhjM01nUTI5dWJtVmpkR2x2YmlCbGVIUmxibVJ6SUUxbGMzTmhaMlZGYldsMGRHVnlJSHRjYmlBZ0lDQmpiMjV6ZEhKMVkzUnZjaWhqYjI1bWFXY3BJSHRjYmlBZ0lDQWdJSE4xY0dWeUtHTnZibVpwWnlBbUppQmpiMjVtYVdjdVpHVmlkV2NwTzF4dUlDQWdJQ0FnZEdocGN5NWpiMjVtYVdjZ1BTQmpiMjVtYVdjZ2ZId2dlMzA3WEc0Z0lDQWdmVnh1SUNBZ0lHTnZibTVsWTNRb0tTQjdYRzRnSUNBZ0lDQnpaV3htTG1Ga1pFVjJaVzUwVEdsemRHVnVaWElvWENKdFpYTnpZV2RsWENJc0lHVWdQVDRnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbDltYVhKbEtHVXVaR0YwWVM1MGVYQmxMQ0JsTG1SaGRHRXBPMXh1SUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0IwYUdsekxtVnRhWFFvZTF4dUlDQWdJQ0FnSUNCMGVYQmxPaUJjSW1sdWFYUnBZV3hwZW1Wa1hDSXNYRzRnSUNBZ0lDQWdJR052Ym1acFp6b2dkR2hwY3k1amIyNW1hV2RjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJSDFjYmlBZ0lDQmthWE5qYjI1dVpXTjBLQ2tnZTF4dUlDQWdJQ0FnZEdocGN5NWZabWx5WlNoY0ltSmxabTl5WlVScGMyTnZibTVsWTNSY0lpazdYRzRnSUNBZ0lDQnpaV3htTG1Oc2IzTmxLQ2s3WEc0Z0lDQWdJQ0IwYUdsekxsOW1hWEpsS0Z3aVpHbHpZMjl1Ym1WamRHVmtYQ0lwTzF4dUlDQWdJSDFjYmlBZ0lDQmxiV2wwS0dSaGRHRXBJSHRjYmlBZ0lDQWdJR3hsZENCMGNtRnVjMlpsY21GaWJHVnpJRDBnZFc1a1pXWnBibVZrTzF4dUlDQWdJQ0FnYVdZZ0tHUmhkR0V1WDE5MGNtRnVjMlpsY21GaWJHVnpYMThwSUh0Y2JpQWdJQ0FnSUNBZ2RISmhibk5tWlhKaFlteGxjeUE5SUdSaGRHRXVYMTkwY21GdWMyWmxjbUZpYkdWelgxODdYRzRnSUNBZ0lDQWdJR1JsYkdWMFpTQmtZWFJoTGw5ZmRISmhibk5tWlhKaFlteGxjMTlmTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnYzJWc1ppNXdiM04wVFdWemMyRm5aU2hrWVhSaExDQjBjbUZ1YzJabGNtRmliR1Z6S1R0Y2JpQWdJQ0I5WEc0Z0lDQWdZWE41Ym1NZ1pYaGxZM1YwWlNoamIyUmxLU0I3WEc0Z0lDQWdJQ0JwWmlBb1kyOWtaUzUwZVhCbElEMDlQU0JjSW5KbGNYVnBjbVZ0Wlc1MGMxd2lLU0I3WEc0Z0lDQWdJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tGeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE1nSmlaY2JpQWdJQ0FnSUNBZ0lDQWdJQ2hCY25KaGVTNXBjMEZ5Y21GNUtHTnZaR1V1Y21WeGRXbHlaVzFsYm5SektTQjhmRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQjBlWEJsYjJZZ1kyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhNZ1BUMDlJRndpYzNSeWFXNW5YQ0lwWEc0Z0lDQWdJQ0FnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvSVVGeWNtRjVMbWx6UVhKeVlYa29ZMjlrWlM1eVpYRjFhWEpsYldWdWRITXBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE1nUFNCYlkyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhOZE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z1kyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMlJsTG5KbGNYVnBjbVZ0Wlc1MGMxdHBYUzUwYjB4dmQyVnlRMkZ6WlNncExtVnVaSE5YYVhSb0tGd2lMbU56YzF3aUtTQjhmRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE5iYVYwdWMzUmhjblJ6VjJsMGFDaGNJbU56Y3pwY0lpbGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRndpZFc1aFlteGxJSFJ2SUdsdGNHOXlkQ0JqYzNNZ2FXNGdZU0IzWldKM2IzSnJaWEpjSWp0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjlrWlM1eVpYRjFhWEpsYldWdWRITmJhVjB1ZEc5TWIzZGxja05oYzJVb0tTNWxibVJ6VjJsMGFDaGNJaTVxYzF3aUtTQjhmRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE5iYVYwdWMzUmhjblJ6VjJsMGFDaGNJbXB6T2x3aUtWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHTnZaR1V1Y21WeGRXbHlaVzFsYm5SelcybGRMbk4wWVhKMGMxZHBkR2dvWENKcWN6cGNJaWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjlrWlM1eVpYRjFhWEpsYldWdWRITmJhVjBnUFNCamIyUmxMbkpsY1hWcGNtVnRaVzUwYzF0cFhTNXpiR2xqWlNnektUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsdGNHOXlkRk5qY21sd2RITW9ZMjlrWlM1eVpYRjFhWEpsYldWdWRITmJhVjBwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1kyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhOYmFWMHVjM1JoY25SelYybDBhQ2hjSW1oMGRIQmNJaWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbHRjRzl5ZEZOamNtbHdkSE1vWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE5iYVYwcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9ZMjlrWlM1eVpYRjFhWEpsYldWdWRITmJhVjB1YzNSaGNuUnpWMmwwYUNoY0ltTmhZMmhsT2x3aUtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTHk5cFoyNXZjbVVnWTJGamFHVmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGd2lWVzV3Y205alpYTnpaV1FnY21WeGRXbHlaVzFsYm5SeklIVnliRG9nWENJZ0t5QmpiMlJsTG5KbGNYVnBjbVZ0Wlc1MGMxdHBYVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZEdoeWIzY2dYQ0ptWVdsc1pXUWdkRzhnYVcxd2IzSjBJSEpsY1hWcGNtVmtJSE5qY21sd2RITTZJRndpSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyUmxMbkpsY1hWcGNtVnRaVzUwY3k1MGIxTjBjbWx1WnlncE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmU0JqWVhSamFDQW9aU2tnZTF4dUlDQWdJQ0FnSUNBZ0lIUm9jbTkzSUdVN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMGdaV3h6WlNCcFppQW9ZMjlrWlM1MGVYQmxJRDA5UFNCY0luTmpjbWx3ZEZ3aUtTQjdYRzRnSUNBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdZMjlrWlM1eVpYRjFhWEpsYldWdWRITWdKaVpjYmlBZ0lDQWdJQ0FnSUNBZ0lDaEJjbkpoZVM1cGMwRnljbUY1S0dOdlpHVXVjbVZ4ZFdseVpXMWxiblJ6S1NCOGZGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGVYQmxiMllnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE1nUFQwOUlGd2ljM1J5YVc1blhDSXBYRzRnSUNBZ0lDQWdJQ0FnS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCcFppQW9RWEp5WVhrdWFYTkJjbkpoZVNoamIyUmxMbkpsY1hWcGNtVnRaVzUwY3lrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnBJRDBnTURzZ2FTQThJR052WkdVdWNtVnhkV2x5WlcxbGJuUnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnBiWEJ2Y25SVFkzSnBjSFJ6S0dOdlpHVXVjbVZ4ZFdseVpXMWxiblJ6VzJsZEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXMXdiM0owVTJOeWFYQjBjeWhqYjJSbExuSmxjWFZwY21WdFpXNTBjeWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lIMGdZMkYwWTJnZ0tHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ1hDSm1ZV2xzWldRZ2RHOGdhVzF3YjNKMElISmxjWFZwY21Wa0lITmpjbWx3ZEhNNklGd2lJQ3RjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjJSbExuSmxjWFZwY21WdFpXNTBjeTUwYjFOMGNtbHVaeWdwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQmxkbUZzS0dOdlpHVXVZMjl1ZEdWdWRDazdYRzRnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtVnljbTl5S0dVdWJXVnpjMkZuWlN3Z1pTNXpkR0ZqYXlrN1hHNGdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ1pUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ1hDSjFibk4xY0hCdmNuUmxaQ0JqYjJSbElIUjVjR1V1WENJN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCcFppQW9ZMjlrWlM1MGVYQmxJRDA5UFNCY0luSmxjWFZwY21WdFpXNTBjMXdpS1NCN1hHNGdJQ0FnSUNBZ0lITmxiR1l1Y0c5emRFMWxjM05oWjJVb2UxeHVJQ0FnSUNBZ0lDQWdJSFI1Y0dVNklGd2lZMkZqYUdWU1pYRjFhWEpsYldWdWRITmNJaXhjYmlBZ0lDQWdJQ0FnSUNCeVpYRjFhWEpsYldWdWRITTZJR052WkdVdWNtVnhkV2x5WlcxbGJuUnpYRzRnSUNBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0JqYjI1emRDQmpiMjVtYVdjZ1BTQjdYRzRnSUNBZ2RIbHdaVG9nWENKM1pXSXRkMjl5YTJWeVhDSXNYRzRnSUNBZ1pHVmthV05oZEdWa1gzUm9jbVZoWkRvZ2RISjFaU3hjYmlBZ0lDQmhiR3h2ZDE5bGVHVmpkWFJwYjI0NklIUnlkV1VzWEc0Z0lDQWdiR0Z1WnpvZ1hDSnFZWFpoYzJOeWFYQjBYQ0lzWEc0Z0lDQWdZWEJwWDNabGNuTnBiMjQ2SUVGUVNWOVdSVkpUU1U5T1hHNGdJSDA3WEc0Z0lHTnZibk4wSUdOdmJtNGdQU0J1WlhjZ1EyOXVibVZqZEdsdmJpaGpiMjVtYVdjcE8xeHVJQ0JqYjI1dUxtOXVLRndpWTI5dWJtVmpkRkpRUTF3aUxDQmtZWFJoSUQwK0lIdGNiaUFnSUNCamIyNXVaV04wVWxCREtHTnZibTRzSUU5aWFtVmpkQzVoYzNOcFoyNG9aR0YwWVM1amIyNW1hV2NzSUdOdmJtWnBaeWtwTzF4dUlDQjlLVHRjYmlBZ1kyOXViaTVqYjI1dVpXTjBLQ2s3WEc0Z0lITmxiR1l1Y0c5emRFMWxjM05oWjJVb2UxeHVJQ0FnSUhSNWNHVTZJRndpZDI5eWEyVnlMWEpsWVdSNVhDSmNiaUFnZlNrN1hHNTlLU2dwTzF4dUlsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk95SXNJbk52ZFhKalpWSnZiM1FpT2lJaWZRPT1cXFxcbi8vIyBzb3VyY2VVUkw9d2VicGFjay1pbnRlcm5hbDovLy8uL3NyYy9wbHVnaW4ud2Vid29ya2VyLmpzXFxcXG5cXFwiKTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvcGx1Z2luQ29yZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vc3JjL3BsdWdpbkNvcmUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogY29ubmVjdFJQQyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuZXZhbChcXFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcXFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFxcXFxcImNvbm5lY3RSUENcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb25uZWN0UlBDOyB9KTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcnBjX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JwYy5qcyAqLyBcXFxcXFxcIi4vc3JjL3JwYy5qc1xcXFxcXFwiKTtcXFxcbi8qKlxcXFxuICogQ29yZSBwbHVnaW4gc2NyaXB0IGxvYWRlZCBpbnRvIHRoZSBwbHVnaW4gcHJvY2Vzcy90aHJlYWQuXFxcXG4gKlxcXFxuICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbi1zaXRlIEFQSSBnbG9iYWwgbWV0aG9kcy5cXFxcbiAqL1xcXFxuXFxcXG5mdW5jdGlvbiBjb25uZWN0UlBDKGNvbm5lY3Rpb24sIGNvbmZpZykge1xcXFxuICBjb25maWcgPSBjb25maWcgfHwge307XFxcXG4gIGNvbnN0IHJwYyA9IG5ldyBfcnBjX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcXFxcXCJSUENcXFxcXFxcIl0oY29ubmVjdGlvbiwgY29uZmlnKTtcXFxcbiAgcnBjLm9uKFxcXFxcXFwiZ2V0SW50ZXJmYWNlXFxcXFxcXCIsIGZ1bmN0aW9uICgpIHtcXFxcbiAgICBsYXVuY2hDb25uZWN0ZWQoKTtcXFxcbiAgfSk7XFxcXG4gIHJwYy5vbihcXFxcXFxcInJlbW90ZVJlYWR5XFxcXFxcXCIsIGZ1bmN0aW9uICgpIHtcXFxcbiAgICBjb25zdCBhcGkgPSBycGMuZ2V0UmVtb3RlKCkgfHwge307XFxcXG5cXFxcbiAgICBpZiAoYXBpLmV4cG9ydCkge1xcXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwiYGV4cG9ydGAgaXMgYSByZXNlcnZlZCBmdW5jdGlvbiBuYW1lXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGlmIChhcGkub25sb2FkKSB7XFxcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJgb25sb2FkYCBpcyBhIHJlc2VydmVkIGZ1bmN0aW9uIG5hbWVcXFxcXFxcIik7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgaWYgKGFwaS5kaXNwb3NlKSB7XFxcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJgZGlzcG9zZWAgaXMgYSByZXNlcnZlZCBmdW5jdGlvbiBuYW1lXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGFwaS5leHBvcnQgPSBmdW5jdGlvbiAoX2ludGVyZmFjZSkge1xcXFxuICAgICAgcnBjLnNldEludGVyZmFjZShfaW50ZXJmYWNlKTtcXFxcbiAgICB9O1xcXFxuXFxcXG4gICAgYXBpLm9uTG9hZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XFxcXG4gICAgICBoYW5kbGVyID0gY2hlY2tIYW5kbGVyKGhhbmRsZXIpO1xcXFxuXFxcXG4gICAgICBpZiAoY29ubmVjdGVkKSB7XFxcXG4gICAgICAgIGhhbmRsZXIoKTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGNvbm5lY3RlZEhhbmRsZXJzLnB1c2goaGFuZGxlcik7XFxcXG4gICAgICB9XFxcXG4gICAgfTtcXFxcblxcXFxuICAgIGFwaS5kaXNwb3NlID0gZnVuY3Rpb24gKF9pbnRlcmZhY2UpIHtcXFxcbiAgICAgIHJwYy5kaXNjb25uZWN0KCk7XFxcXG4gICAgfTtcXFxcblxcXFxuICAgIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XFxcXG4gICAgICBzZWxmLmFwaSA9IGFwaTtcXFxcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xcXFxuICAgICAgICB0eXBlOiBcXFxcXFxcImltam95X3JlbW90ZV9hcGlfcmVhZHlcXFxcXFxcIlxcXFxuICAgICAgfSk7XFxcXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93KSB7XFxcXG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXFxcXFxcXCJpbWpveV9yZW1vdGVfYXBpX3JlYWR5XFxcXFxcXCIsIHtcXFxcbiAgICAgICAgZGV0YWlsOiBhcGlcXFxcbiAgICAgIH0pKTtcXFxcbiAgICB9XFxcXG4gIH0pO1xcXFxuICBsZXQgY29ubmVjdGVkID0gZmFsc2U7XFxcXG4gIGNvbnN0IGNvbm5lY3RlZEhhbmRsZXJzID0gW107XFxcXG5cXFxcbiAgY29uc3QgbGF1bmNoQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xcXFxuICAgIGlmICghY29ubmVjdGVkKSB7XFxcXG4gICAgICBjb25uZWN0ZWQgPSB0cnVlO1xcXFxuICAgICAgbGV0IGhhbmRsZXI7XFxcXG5cXFxcbiAgICAgIHdoaWxlIChoYW5kbGVyID0gY29ubmVjdGVkSGFuZGxlcnMucG9wKCkpIHtcXFxcbiAgICAgICAgaGFuZGxlcigpO1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcbiAgfTtcXFxcblxcXFxuICBjb25zdCBjaGVja0hhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xcXFxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaGFuZGxlcjtcXFxcblxcXFxuICAgIGlmICh0eXBlICE9PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgIGNvbnN0IG1zZyA9IFxcXFxcXFwiQSBmdW5jdGlvbiBtYXkgb25seSBiZSBzdWJzcmliZWQgdG8gdGhlIGV2ZW50LCBcXFxcXFxcIiArIHR5cGUgKyBcXFxcXFxcIiB3YXMgcHJvdmlkZWQgaW5zdGVhZFxcXFxcXFwiO1xcXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgcmV0dXJuIGhhbmRsZXI7XFxcXG4gIH07XFxcXG5cXFxcbiAgcmV0dXJuIHJwYztcXFxcbn0vLyMgc291cmNlVVJMPVttb2R1bGVdXFxcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaUxpOXpjbU12Y0d4MVoybHVRMjl5WlM1cWN5NXFjeUlzSW5OdmRYSmpaWE1pT2xzaWQyVmljR0ZqYXpvdkwybHRhbTk1VWxCREx5NHZjM0pqTDNCc2RXZHBia052Y21VdWFuTS9ZVGd4TkNKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLaXBjYmlBcUlFTnZjbVVnY0d4MVoybHVJSE5qY21sd2RDQnNiMkZrWldRZ2FXNTBieUIwYUdVZ2NHeDFaMmx1SUhCeWIyTmxjM012ZEdoeVpXRmtMbHh1SUNwY2JpQXFJRWx1YVhScFlXeHBlbVZ6SUhSb1pTQndiSFZuYVc0dGMybDBaU0JCVUVrZ1oyeHZZbUZzSUcxbGRHaHZaSE11WEc0Z0tpOWNibWx0Y0c5eWRDQjdJRkpRUXlCOUlHWnliMjBnWENJdUwzSndZeTVxYzF3aU8xeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdZMjl1Ym1WamRGSlFReWhqYjI1dVpXTjBhVzl1TENCamIyNW1hV2NwSUh0Y2JpQWdZMjl1Wm1sbklEMGdZMjl1Wm1sbklIeDhJSHQ5TzF4dVhHNGdJR052Ym5OMElISndZeUE5SUc1bGR5QlNVRU1vWTI5dWJtVmpkR2x2Yml3Z1kyOXVabWxuS1R0Y2JpQWdjbkJqTG05dUtGd2laMlYwU1c1MFpYSm1ZV05sWENJc0lHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lHeGhkVzVqYUVOdmJtNWxZM1JsWkNncE8xeHVJQ0I5S1R0Y2JseHVJQ0J5Y0dNdWIyNG9YQ0p5WlcxdmRHVlNaV0ZrZVZ3aUxDQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQmpiMjV6ZENCaGNHa2dQU0J5Y0dNdVoyVjBVbVZ0YjNSbEtDa2dmSHdnZTMwN1hHNGdJQ0FnYVdZZ0tHRndhUzVsZUhCdmNuUXBJSHRjYmlBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpaGNJbUJsZUhCdmNuUmdJR2x6SUdFZ2NtVnpaWEoyWldRZ1puVnVZM1JwYjI0Z2JtRnRaVndpS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0dGd2FTNXZibXh2WVdRcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loY0ltQnZibXh2WVdSZ0lHbHpJR0VnY21WelpYSjJaV1FnWm5WdVkzUnBiMjRnYm1GdFpWd2lLVHRjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLR0Z3YVM1a2FYTndiM05sS1NCN1hHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvWENKZ1pHbHpjRzl6WldBZ2FYTWdZU0J5WlhObGNuWmxaQ0JtZFc1amRHbHZiaUJ1WVcxbFhDSXBPMXh1SUNBZ0lIMWNiaUFnSUNCaGNHa3VaWGh3YjNKMElEMGdablZ1WTNScGIyNG9YMmx1ZEdWeVptRmpaU2tnZTF4dUlDQWdJQ0FnY25CakxuTmxkRWx1ZEdWeVptRmpaU2hmYVc1MFpYSm1ZV05sS1R0Y2JpQWdJQ0I5TzF4dUlDQWdJR0Z3YVM1dmJreHZZV1FnUFNCbWRXNWpkR2x2Ymlob1lXNWtiR1Z5S1NCN1hHNGdJQ0FnSUNCb1lXNWtiR1Z5SUQwZ1kyaGxZMnRJWVc1a2JHVnlLR2hoYm1Sc1pYSXBPMXh1SUNBZ0lDQWdhV1lnS0dOdmJtNWxZM1JsWkNrZ2UxeHVJQ0FnSUNBZ0lDQm9ZVzVrYkdWeUtDazdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQmpiMjV1WldOMFpXUklZVzVrYkdWeWN5NXdkWE5vS0doaGJtUnNaWElwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDA3WEc0Z0lDQWdZWEJwTG1ScGMzQnZjMlVnUFNCbWRXNWpkR2x2YmloZmFXNTBaWEptWVdObEtTQjdYRzRnSUNBZ0lDQnljR011WkdselkyOXVibVZqZENncE8xeHVJQ0FnSUgwN1hHNWNiaUFnSUNCcFppQW9YRzRnSUNBZ0lDQjBlWEJsYjJZZ1YyOXlhMlZ5UjJ4dlltRnNVMk52Y0dVZ0lUMDlJRndpZFc1a1pXWnBibVZrWENJZ0ppWmNiaUFnSUNBZ0lITmxiR1lnYVc1emRHRnVZMlZ2WmlCWGIzSnJaWEpIYkc5aVlXeFRZMjl3WlZ4dUlDQWdJQ2tnZTF4dUlDQWdJQ0FnYzJWc1ppNWhjR2tnUFNCaGNHazdYRzRnSUNBZ0lDQnpaV3htTG5CdmMzUk5aWE56WVdkbEtIdGNiaUFnSUNBZ0lDQWdkSGx3WlRvZ1hDSnBiV3B2ZVY5eVpXMXZkR1ZmWVhCcFgzSmxZV1I1WENKY2JpQWdJQ0FnSUgwcE8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RIbHdaVzltSUhkcGJtUnZkeWtnZTF4dUlDQWdJQ0FnZDJsdVpHOTNMbVJwYzNCaGRHTm9SWFpsYm5Rb1hHNGdJQ0FnSUNBZ0lHNWxkeUJEZFhOMGIyMUZkbVZ1ZENoY0ltbHRhbTk1WDNKbGJXOTBaVjloY0dsZmNtVmhaSGxjSWl3Z2V5QmtaWFJoYVd3NklHRndhU0I5S1Z4dUlDQWdJQ0FnS1R0Y2JpQWdJQ0I5WEc0Z0lIMHBPMXh1WEc0Z0lHeGxkQ0JqYjI1dVpXTjBaV1FnUFNCbVlXeHpaVHRjYmlBZ1kyOXVjM1FnWTI5dWJtVmpkR1ZrU0dGdVpHeGxjbk1nUFNCYlhUdGNibHh1SUNCamIyNXpkQ0JzWVhWdVkyaERiMjV1WldOMFpXUWdQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0JwWmlBb0lXTnZibTVsWTNSbFpDa2dlMXh1SUNBZ0lDQWdZMjl1Ym1WamRHVmtJRDBnZEhKMVpUdGNibHh1SUNBZ0lDQWdiR1YwSUdoaGJtUnNaWEk3WEc0Z0lDQWdJQ0IzYUdsc1pTQW9LR2hoYm1Sc1pYSWdQU0JqYjI1dVpXTjBaV1JJWVc1a2JHVnljeTV3YjNBb0tTa3BJSHRjYmlBZ0lDQWdJQ0FnYUdGdVpHeGxjaWdwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZUdGNibHh1SUNCamIyNXpkQ0JqYUdWamEwaGhibVJzWlhJZ1BTQm1kVzVqZEdsdmJpaG9ZVzVrYkdWeUtTQjdYRzRnSUNBZ1kyOXVjM1FnZEhsd1pTQTlJSFI1Y0dWdlppQm9ZVzVrYkdWeU8xeHVJQ0FnSUdsbUlDaDBlWEJsSUNFOVBTQmNJbVoxYm1OMGFXOXVYQ0lwSUh0Y2JpQWdJQ0FnSUdOdmJuTjBJRzF6WnlBOVhHNGdJQ0FnSUNBZ0lGd2lRU0JtZFc1amRHbHZiaUJ0WVhrZ2IyNXNlU0JpWlNCemRXSnpjbWxpWldRZ2RHOGdkR2hsSUdWMlpXNTBMQ0JjSWlBclhHNGdJQ0FnSUNBZ0lIUjVjR1VnSzF4dUlDQWdJQ0FnSUNCY0lpQjNZWE1nY0hKdmRtbGtaV1FnYVc1emRHVmhaRndpTzF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLRzF6WnlrN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQm9ZVzVrYkdWeU8xeHVJQ0I5TzF4dVhHNGdJSEpsZEhWeWJpQnljR003WEc1OVhHNGlYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk96czdPenRCUVV0Qk8wRkJSVUU3UVVGRFFUdEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZKUVR0QlFVTkJPMEZCUTBFN1FVRkVRVHRCUVVkQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlJVRTdRVUZEUVR0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVVZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCU1VFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0luTnZkWEpqWlZKdmIzUWlPaUlpZlE9PVxcXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrLWludGVybmFsOi8vLy4vc3JjL3BsdWdpbkNvcmUuanNcXFxcblxcXCIpO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL3NyYy9ycGMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vc3JjL3JwYy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEFQSV9WRVJTSU9OLCBSUEMgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbmV2YWwoXFxcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJBUElfVkVSU0lPTlxcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFQSV9WRVJTSU9OOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJSUENcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSUEM7IH0pO1xcXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy5qcyAqLyBcXFxcXFxcIi4vc3JjL3V0aWxzLmpzXFxcXFxcXCIpO1xcXFxuLyoqXFxcXG4gKiBDb250YWlucyB0aGUgUlBDIG9iamVjdCB1c2VkIGJvdGggYnkgdGhlIGFwcGxpY2F0aW9uXFxcXG4gKiBzaXRlLCBhbmQgYnkgZWFjaCBwbHVnaW5cXFxcbiAqL1xcXFxuXFxcXG5jb25zdCBBUElfVkVSU0lPTiA9IFxcXFxcXFwiMC4yLjFcXFxcXFxcIjtcXFxcbmNvbnN0IEFycmF5QnVmZmVyVmlldyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IFVpbnQ4QXJyYXkoKSkpLmNvbnN0cnVjdG9yO1xcXFxuXFxcXG5mdW5jdGlvbiBfYXBwZW5kQnVmZmVyKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcXFxcbiAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcXFxcbiAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIxKSwgMCk7XFxcXG4gIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMiksIGJ1ZmZlcjEuYnl0ZUxlbmd0aCk7XFxcXG4gIHJldHVybiB0bXAuYnVmZmVyO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXRLZXlCeVZhbHVlKG9iamVjdCwgdmFsdWUpIHtcXFxcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkuZmluZChrZXkgPT4gb2JqZWN0W2tleV0gPT09IHZhbHVlKTtcXFxcbn1cXFxcbi8qKlxcXFxuICogUlBDIG9iamVjdCByZXByZXNlbnRzIGEgc2luZ2xlIHNpdGUgaW4gdGhlXFxcXG4gKiBjb21tdW5pY2F0aW9uIHByb3RvY29sIGJldHdlZW4gdGhlIGFwcGxpY2F0aW9uIGFuZCB0aGUgcGx1Z2luXFxcXG4gKlxcXFxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb24gYSBzcGVjaWFsIG9iamVjdCBhbGxvd2luZyB0byBzZW5kXFxcXG4gKiBhbmQgcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIHRoZSBvcHBvc2l0ZSBzaXRlIChiYXNpY2FsbHkgaXRcXFxcbiAqIHNob3VsZCBvbmx5IHByb3ZpZGUgc2VuZCgpIGFuZCBvbk1lc3NhZ2UoKSBtZXRob2RzKVxcXFxuICovXFxcXG5cXFxcblxcXFxuY2xhc3MgUlBDIGV4dGVuZHMgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcXFxcXCJNZXNzYWdlRW1pdHRlclxcXFxcXFwiXSB7XFxcXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGNvbmZpZykge1xcXFxuICAgIHN1cGVyKGNvbmZpZyAmJiBjb25maWcuZGVidWcpO1xcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xcXFxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xcXFxuICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZSA9IHt9O1xcXFxuICAgIHRoaXMuX2xvY2FsX2FwaSA9IG51bGw7IC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhbiBleGVjdXRlIGZ1bmN0aW9uXFxcXG5cXFxcbiAgICBjb25zdCBuYW1lID0gdGhpcy5jb25maWcubmFtZTtcXFxcblxcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZXhlY3V0ZSA9IHRoaXMuX2Nvbm5lY3Rpb24uZXhlY3V0ZSB8fCBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbm5lY3Rpb24uZXhlY3V0ZSBub3QgaW1wbGVtZW50ZWQgKGluIFxcXFxcXFwiJHtuYW1lfVxcXFxcXFwiKWApO1xcXFxuICAgIH07XFxcXG5cXFxcbiAgICB0aGlzLl9zdG9yZSA9IG5ldyBSZWZlcmVuY2VTdG9yZSgpO1xcXFxuICAgIHRoaXMuX21ldGhvZF9yZWZzID0gbmV3IFJlZmVyZW5jZVN0b3JlKCk7XFxcXG5cXFxcbiAgICB0aGlzLl9tZXRob2RfcmVmcy5vblJlYWR5KCgpID0+IHtcXFxcbiAgICAgIHRoaXMuX2ZpcmUoXFxcXFxcXCJyZW1vdGVJZGxlXFxcXFxcXCIpO1xcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgdGhpcy5fbWV0aG9kX3JlZnMub25CdXN5KCgpID0+IHtcXFxcbiAgICAgIHRoaXMuX2ZpcmUoXFxcXFxcXCJyZW1vdGVCdXN5XFxcXFxcXCIpO1xcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgdGhpcy5fc2V0dXBNZXNzYWdlSGFubGRlcnMoKTtcXFxcbiAgfVxcXFxuXFxcXG4gIGluaXQoKSB7XFxcXG4gICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHtcXFxcbiAgICAgIHR5cGU6IFxcXFxcXFwiaW5pdGlhbGl6ZWRcXFxcXFxcIixcXFxcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXFxcXG4gICAgICBwZWVyX2lkOiB0aGlzLl9jb25uZWN0aW9uLnBlZXJfaWRcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2V0IGEgaGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbiByZWNlaXZlZCBhIHJlc3BvbmNlIGZyb20gdGhlXFxcXG4gICAqIHJlbW90ZSBzaXRlIHJlcG9ydGluZyB0aGF0IHRoZSBwcmV2aW91c2x5IHByb3ZpZGVkIGludGVyZmFjZVxcXFxuICAgKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2V0IGFzIHJlbW90ZSBmb3IgdGhhdCBzaXRlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBnZXRSZW1vdGVDYWxsU3RhY2soKSB7XFxcXG4gICAgcmV0dXJuIHRoaXMuX21ldGhvZF9yZWZzLmdldFN0YWNrKCk7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHNldCBvZiByZW1vdGUgaW50ZXJmYWNlIG1ldGhvZHNcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBnZXRSZW1vdGUoKSB7XFxcXG4gICAgcmV0dXJuIHRoaXMuX2ludGVyZmFjZV9zdG9yZVtcXFxcXFxcIl9ycmVtb3RlXFxcXFxcXCJdO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBTZXRzIHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBzaXRlIG1ha2luZyBpdCBhdmFpbGFibGUgdG8gdGhlXFxcXG4gICAqIHJlbW90ZSBzaXRlIGJ5IHNlbmRpbmcgYSBtZXNzYWdlIHdpdGggYSBzZXQgb2YgbWV0aG9kcyBuYW1lc1xcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge09iamVjdH0gX2ludGVyZmFjZSB0byBzZXRcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBzZXRJbnRlcmZhY2UoX2ludGVyZmFjZSkge1xcXFxuICAgIGlmICh0aGlzLmNvbmZpZy5mb3J3YXJkaW5nX2Z1bmN0aW9ucykge1xcXFxuICAgICAgZm9yIChsZXQgZnVuY19uYW1lIG9mIHRoaXMuY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zKSB7XFxcXG4gICAgICAgIGNvbnN0IF9yZW1vdGUgPSB0aGlzLl9pbnRlcmZhY2Vfc3RvcmVbXFxcXFxcXCJfcnJlbW90ZVxcXFxcXFwiXTtcXFxcblxcXFxuICAgICAgICBpZiAoX3JlbW90ZVtmdW5jX25hbWVdKSB7XFxcXG4gICAgICAgICAgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xcXFxuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlW2Z1bmNfbmFtZV0pIHtcXFxcbiAgICAgICAgICAgICAgX2ludGVyZmFjZVtmdW5jX25hbWVdID0gKC4uLmFyZ3MpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBfcmVtb3RlW2Z1bmNfbmFtZV0oLi4uYXJncyk7XFxcXG4gICAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgfSBlbHNlIGlmIChfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xcXFxuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtmdW5jX25hbWVdKSB7XFxcXG4gICAgICAgICAgICAgIF9pbnRlcmZhY2UuY29uc3RydWN0b3IucHJvdG90eXBlW2Z1bmNfbmFtZV0gPSAoLi4uYXJncykgPT4ge1xcXFxuICAgICAgICAgICAgICAgIF9yZW1vdGVbZnVuY19uYW1lXSguLi5hcmdzKTtcXFxcbiAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG5cXFxcbiAgICB0aGlzLl9sb2NhbF9hcGkgPSBfaW50ZXJmYWNlO1xcXFxuXFxcXG4gICAgdGhpcy5fZmlyZShcXFxcXFxcImludGVyZmFjZUF2YWlsYWJsZVxcXFxcXFwiKTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2VuZHMgdGhlIGFjdHVhbCBpbnRlcmZhY2UgdG8gdGhlIHJlbW90ZSBzaXRlIHVwb24gaXQgd2FzXFxcXG4gICAqIHVwZGF0ZWQgb3IgYnkgYSBzcGVjaWFsIHJlcXVlc3Qgb2YgdGhlIHJlbW90ZSBzaXRlXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgc2VuZEludGVyZmFjZSgpIHtcXFxcbiAgICBpZiAoIXRoaXMuX2xvY2FsX2FwaSkge1xcXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwiaW50ZXJmYWNlIGlzIG5vdCBzZXQuXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHRoaXMuX2xvY2FsX2FwaS5fcmlkID0gXFxcXFxcXCJfcmxvY2FsXFxcXFxcXCI7XFxcXG5cXFxcbiAgICBjb25zdCBhcGkgPSB0aGlzLl9lbmNvZGUodGhpcy5fbG9jYWxfYXBpLCB0cnVlKTtcXFxcblxcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICB0eXBlOiBcXFxcXFxcInNldEludGVyZmFjZVxcXFxcXFwiLFxcXFxuICAgICAgYXBpOiBhcGlcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogSGFuZGxlcyBhIG1lc3NhZ2UgZnJvbSB0aGUgcmVtb3RlIHNpdGVcXFxcbiAgICovXFxcXG4gIC8vIHZhciBjYWxsYmFja19yZWcgPSBuZXcgUmVnRXhwKFxcXFxcXFwib251cGRhdGV8cnVuJFxcXFxcXFwiKVxcXFxuXFxcXG5cXFxcbiAgX3NldHVwTWVzc2FnZUhhbmxkZXJzKCkge1xcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXFxcXFxcXCJpbml0XFxcXFxcXCIsIHRoaXMuaW5pdCk7XFxcXG5cXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFxcXFxcXFwiZXhlY3V0ZVxcXFxcXFwiLCBkYXRhID0+IHtcXFxcbiAgICAgIFByb21pc2UucmVzb2x2ZSh0aGlzLl9jb25uZWN0aW9uLmV4ZWN1dGUoZGF0YS5jb2RlKSkudGhlbigoKSA9PiB7XFxcXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICAgICAgdHlwZTogXFxcXFxcXCJleGVjdXRlZFxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgfSkuY2F0Y2goZSA9PiB7XFxcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XFxcXG5cXFxcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHtcXFxcbiAgICAgICAgICB0eXBlOiBcXFxcXFxcImV4ZWN1dGVkXFxcXFxcXCIsXFxcXG4gICAgICAgICAgZXJyb3I6IGVcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICB9KTtcXFxcbiAgICB9KTtcXFxcblxcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXFxcXFxcXCJtZXRob2RcXFxcXFxcIiwgZGF0YSA9PiB7XFxcXG4gICAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0LCBtZXRob2QsIGFyZ3MsIHJlc3VsdDtcXFxcbiAgICAgIGxldCBfaW50ZXJmYWNlID0gdGhpcy5faW50ZXJmYWNlX3N0b3JlW2RhdGEucGlkXTtcXFxcblxcXFxuICAgICAgY29uc3QgX21ldGhvZF9jb250ZXh0ID0gX2ludGVyZmFjZS5fX3RoaXNfXyB8fCBfaW50ZXJmYWNlO1xcXFxuXFxcXG4gICAgICBpZiAoIV9pbnRlcmZhY2UpIHtcXFxcbiAgICAgICAgaWYgKGRhdGEucHJvbWlzZSkge1xcXFxuICAgICAgICAgIFtyZXNvbHZlLCByZWplY3RdID0gdGhpcy5fdW53cmFwKGRhdGEucHJvbWlzZSwgZmFsc2UpO1xcXFxuICAgICAgICAgIHJlamVjdChgcGx1Z2luIGFwaSBmdW5jdGlvbiBpcyBub3QgYXZhaWFsYmUgaW4gXFxcXFxcXCIke2RhdGEucGlkfVxcXFxcXFwiLCB0aGUgcGx1Z2luIG1heWJlIHRlcm1pbmF0ZWQuYCk7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgcGx1Z2luIGFwaSBmdW5jdGlvbiBpcyBub3QgYXZhaWFsYmUgaW4gJHtkYXRhLnBpZH0sIHRoZSBwbHVnaW4gbWF5YmUgdGVybWluYXRlZC5gKTtcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIHJldHVybjtcXFxcbiAgICAgIH1cXFxcblxcXFxuICAgICAgbWV0aG9kID0gX2ludGVyZmFjZVtkYXRhLm5hbWVdO1xcXFxuICAgICAgYXJncyA9IHRoaXMuX3Vud3JhcChkYXRhLmFyZ3MsIHRydWUpO1xcXFxuXFxcXG4gICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XFxcXG4gICAgICAgIFtyZXNvbHZlLCByZWplY3RdID0gdGhpcy5fdW53cmFwKGRhdGEucHJvbWlzZSwgZmFsc2UpO1xcXFxuXFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KF9tZXRob2RfY29udGV4dCwgYXJncyk7XFxcXG5cXFxcbiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fCBtZXRob2QuY29uc3RydWN0b3IgJiYgbWV0aG9kLmNvbnN0cnVjdG9yLm5hbWUgPT09IFxcXFxcXFwiQXN5bmNGdW5jdGlvblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xcXFxuICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLmNvbmZpZy5uYW1lLCBlLCBtZXRob2QpO1xcXFxuICAgICAgICAgIHJlamVjdChlKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICBtZXRob2QuYXBwbHkoX21ldGhvZF9jb250ZXh0LCBhcmdzKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZSwgbWV0aG9kLCBhcmdzKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcXFxcXFxcImNhbGxiYWNrXFxcXFxcXCIsIGRhdGEgPT4ge1xcXFxuICAgICAgbGV0IHJlc29sdmUsIHJlamVjdCwgbWV0aG9kLCBhcmdzLCByZXN1bHQ7XFxcXG5cXFxcbiAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcXFxcbiAgICAgICAgW3Jlc29sdmUsIHJlamVjdF0gPSB0aGlzLl91bndyYXAoZGF0YS5wcm9taXNlLCBmYWxzZSk7XFxcXG5cXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICBtZXRob2QgPSB0aGlzLl9zdG9yZS5mZXRjaChkYXRhLl9yaW5kZXgpO1xcXFxuICAgICAgICAgIGFyZ3MgPSB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcXFxcblxcXFxuICAgICAgICAgIGlmICghbWV0aG9kKSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJDYWxsYmFjayBmdW5jdGlvbiBjYW4gb25seSBjYWxsZWQgb25jZSwgaWYgeW91IHdhbnQgdG8gY2FsbCBhIGZ1bmN0aW9uIGZvciBtdWx0aXBsZSB0aW1lcywgcGxlYXNlIG1ha2UgaXQgYXMgYSBwbHVnaW4gYXBpIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9pbWpveS5pby9kb2NzIGZvciBtb3JlIGRldGFpbHMuXFxcXFxcXCIpO1xcXFxuICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShudWxsLCBhcmdzKTtcXFxcblxcXFxuICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlIHx8IG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXFxcXFxcXCJBc3luY0Z1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XFxcXG4gICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHRoaXMuY29uZmlnLm5hbWUsIGUsIG1ldGhvZCk7XFxcXG4gICAgICAgICAgcmVqZWN0KGUpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgIG1ldGhvZCA9IHRoaXMuX3N0b3JlLmZldGNoKGRhdGEuX3JpbmRleCk7XFxcXG4gICAgICAgICAgYXJncyA9IHRoaXMuX3Vud3JhcChkYXRhLmFyZ3MsIHRydWUpO1xcXFxuXFxcXG4gICAgICAgICAgaWYgKCFtZXRob2QpIHtcXFxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIlBsZWFzZSBub3RpY2UgdGhhdCBjYWxsYmFjayBmdW5jdGlvbiBjYW4gb25seSBjYWxsZWQgb25jZSwgaWYgeW91IHdhbnQgdG8gY2FsbCBhIGZ1bmN0aW9uIGZvciBtdWx0aXBsZSB0aW1lcywgcGxlYXNlIG1ha2UgaXQgYXMgYSBwbHVnaW4gYXBpIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9pbWpveS5pby9kb2NzIGZvciBtb3JlIGRldGFpbHMuXFxcXFxcXCIpO1xcXFxuICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgIG1ldGhvZC5hcHBseShudWxsLCBhcmdzKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZSwgbWV0aG9kLCBhcmdzKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcXFxcXFxcInNldEludGVyZmFjZVxcXFxcXFwiLCBkYXRhID0+IHtcXFxcbiAgICAgIHRoaXMuX3NldFJlbW90ZUludGVyZmFjZShkYXRhLmFwaSk7XFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFxcXFxcXFwiZ2V0SW50ZXJmYWNlXFxcXFxcXCIsICgpID0+IHtcXFxcbiAgICAgIHRoaXMuX2ZpcmUoXFxcXFxcXCJnZXRJbnRlcmZhY2VcXFxcXFxcIik7XFxcXG5cXFxcbiAgICAgIGlmICh0aGlzLl9sb2NhbF9hcGkpIHtcXFxcbiAgICAgICAgdGhpcy5zZW5kSW50ZXJmYWNlKCk7XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICB0aGlzLm9uY2UoXFxcXFxcXCJpbnRlcmZhY2VBdmFpbGFibGVcXFxcXFxcIiwgKCkgPT4ge1xcXFxuICAgICAgICAgIHRoaXMuc2VuZEludGVyZmFjZSgpO1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgIH1cXFxcbiAgICB9KTtcXFxcblxcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXFxcXFxcXCJpbnRlcmZhY2VTZXRBc1JlbW90ZVxcXFxcXFwiLCAoKSA9PiB7XFxcXG4gICAgICB0aGlzLl9maXJlKFxcXFxcXFwiaW50ZXJmYWNlU2V0QXNSZW1vdGVcXFxcXFxcIik7XFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFxcXFxcXFwiZGlzY29ubmVjdFxcXFxcXFwiLCAoKSA9PiB7XFxcXG4gICAgICB0aGlzLl9maXJlKFxcXFxcXFwiYmVmb3JlRGlzY29ubmVjdFxcXFxcXFwiKTtcXFxcblxcXFxuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XFxcXG5cXFxcbiAgICAgIHRoaXMuX2ZpcmUoXFxcXFxcXCJkaXNjb25uZWN0ZWRcXFxcXFxcIik7XFxcXG4gICAgfSk7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNlbmRzIGEgcmVxdWVzdHMgdG8gdGhlIHJlbW90ZSBzaXRlIGFza2luZyBpdCB0byBwcm92aWRlIGl0c1xcXFxuICAgKiBjdXJyZW50IGludGVyZmFjZVxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIHJlcXVlc3RSZW1vdGUoKSB7XFxcXG4gICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHtcXFxcbiAgICAgIHR5cGU6IFxcXFxcXFwiZ2V0SW50ZXJmYWNlXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxuXFxcXG4gIF9uZGFycmF5KHR5cGVkQXJyYXksIHNoYXBlLCBkdHlwZSkge1xcXFxuICAgIHZhciBfZHR5cGUgPSBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcInR5cGVkQXJyYXlUb0R0eXBlXFxcXFxcXCJdW3R5cGVkQXJyYXkuY29uc3RydWN0b3IubmFtZV07XFxcXG5cXFxcbiAgICBpZiAoZHR5cGUgJiYgZHR5cGUgIT09IF9kdHlwZSkge1xcXFxuICAgICAgdGhyb3cgXFxcXFxcXCJkdHlwZSBkb2Vzbid0IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBhcnJheTogXFxcXFxcXCIgKyBfZHR5cGUgKyBcXFxcXFxcIiAhPSBcXFxcXFxcIiArIGR0eXBlO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHNoYXBlID0gc2hhcGUgfHwgW3R5cGVkQXJyYXkubGVuZ3RoXTtcXFxcbiAgICByZXR1cm4ge1xcXFxuICAgICAgX3J0eXBlOiBcXFxcXFxcIm5kYXJyYXlcXFxcXFxcIixcXFxcbiAgICAgIF9ydmFsdWU6IHR5cGVkQXJyYXksXFxcXG4gICAgICBfcnNoYXBlOiBzaGFwZSxcXFxcbiAgICAgIF9yZHR5cGU6IF9kdHlwZVxcXFxuICAgIH07XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNldHMgdGhlIG5ldyByZW1vdGUgaW50ZXJmYWNlIHByb3ZpZGVkIGJ5IHRoZSBvdGhlciBzaXRlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGxpc3Qgb2YgZnVuY3Rpb24gbmFtZXNcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfc2V0UmVtb3RlSW50ZXJmYWNlKGFwaSkge1xcXFxuICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVtcXFxcXFxcIl9ycmVtb3RlXFxcXFxcXCJdID0gdGhpcy5fZGVjb2RlKGFwaSk7XFxcXG5cXFxcbiAgICB0aGlzLl9maXJlKFxcXFxcXFwicmVtb3RlUmVhZHlcXFxcXFxcIik7XFxcXG5cXFxcbiAgICB0aGlzLl9yZXBvcnRSZW1vdGVTZXQoKTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogR2VuZXJhdGVzIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gYSBzaW5nbGUgcmVtb3RlXFxcXG4gICAqIG1ldGhvZC4gV2hlbiB0aGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCwgaXQgd2lsbCBzZW5kIHRoZVxcXFxuICAgKiBjb3JyZXNwb25kaW5nIG1lc3NhZ2UgdG8gdGhlIHJlbW90ZSBzaXRlIGFza2luZyBpdCB0byBleGVjdXRlXFxcXG4gICAqIHRoZSBwYXJ0aWN1bGFyIG1ldGhvZCBvZiBpdHMgaW50ZXJmYWNlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSByZW1vdGUgbWV0aG9kXFxcXG4gICAqXFxcXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCByZW1vdGUgbWV0aG9kXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgX2dlblJlbW90ZU1ldGhvZChuYW1lLCBpbnRlcmZhY2VfaWQpIHtcXFxcbiAgICB2YXIgbWUgPSB0aGlzO1xcXFxuXFxcXG4gICAgdmFyIHJlbW90ZU1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcXFxcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxcXG4gICAgICAgIGxldCBpZCA9IG51bGw7XFxcXG5cXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICBpZCA9IG1lLl9tZXRob2RfcmVmcy5wdXQoaW50ZXJmYWNlX2lkID8gaW50ZXJmYWNlX2lkICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBuYW1lIDogbmFtZSk7XFxcXG5cXFxcbiAgICAgICAgICB2YXIgd3JhcHBlZF9yZXNvbHZlID0gZnVuY3Rpb24gKCkge1xcXFxuICAgICAgICAgICAgaWYgKGlkICE9PSBudWxsKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXFxcbiAgICAgICAgICB9O1xcXFxuXFxcXG4gICAgICAgICAgdmFyIHdyYXBwZWRfcmVqZWN0ID0gZnVuY3Rpb24gKCkge1xcXFxuICAgICAgICAgICAgaWYgKGlkICE9PSBudWxsKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcXFxuICAgICAgICAgIH07XFxcXG5cXFxcbiAgICAgICAgICB3cmFwcGVkX3Jlc29sdmUuX19qYWlsZWRfcGFpcnNfXyA9IHdyYXBwZWRfcmVqZWN0O1xcXFxuICAgICAgICAgIHdyYXBwZWRfcmVqZWN0Ll9famFpbGVkX3BhaXJzX18gPSB3cmFwcGVkX3Jlc29sdmU7XFxcXG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xcXFxuXFxcXG4gICAgICAgICAgaWYgKG5hbWUgPT09IFxcXFxcXFwicmVnaXN0ZXJcXFxcXFxcIiB8fCBuYW1lID09PSBcXFxcXFxcImV4cG9ydFxcXFxcXFwiIHx8IG5hbWUgPT09IFxcXFxcXFwib25cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgYXJncyA9IG1lLl93cmFwKGFyZ3MsIHRydWUpO1xcXFxuICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBhcmdzID0gbWUuX3dyYXAoYXJncyk7XFxcXG4gICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBhcmdzLmFyZ3MuX190cmFuc2ZlcmFibGVzX187XFxcXG4gICAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMpIGRlbGV0ZSBhcmdzLmFyZ3MuX190cmFuc2ZlcmFibGVzX187XFxcXG5cXFxcbiAgICAgICAgICBtZS5fY29ubmVjdGlvbi5lbWl0KHtcXFxcbiAgICAgICAgICAgIHR5cGU6IFxcXFxcXFwibWV0aG9kXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxcXFxuICAgICAgICAgICAgcGlkOiBpbnRlcmZhY2VfaWQsXFxcXG4gICAgICAgICAgICBhcmdzOiBhcmdzLFxcXFxuICAgICAgICAgICAgcHJvbWlzZTogbWUuX3dyYXAoW3dyYXBwZWRfcmVzb2x2ZSwgd3JhcHBlZF9yZWplY3RdKVxcXFxuICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpO1xcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgaWYgKGlkKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xcXFxuICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGV4ZWN0dWUgcmVtb3RlIG1ldGhvZCAoaW50ZXJmYWNlOiAke2ludGVyZmFjZV9pZCB8fCBtZS5pZH0sIG1ldGhvZDogJHtuYW1lfSksIGVycm9yOiAke2V9YCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH0pO1xcXFxuICAgIH07XFxcXG5cXFxcbiAgICByZW1vdGVNZXRob2QuX19yZW1vdGVfbWV0aG9kID0gdHJ1ZTtcXFxcbiAgICByZXR1cm4gcmVtb3RlTWV0aG9kO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBTZW5kcyBhIHJlc3BvbmNlIHJlcG9ydGluZyB0aGF0IGludGVyZmFjZSBqdXN0IHByb3ZpZGVkIGJ5IHRoZVxcXFxuICAgKiByZW1vdGUgc2l0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHNldCBieSB0aGlzIHNpdGUgYXMgcmVtb3RlXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgX3JlcG9ydFJlbW90ZVNldCgpIHtcXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoe1xcXFxuICAgICAgdHlwZTogXFxcXFxcXCJpbnRlcmZhY2VTZXRBc1JlbW90ZVxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFByZXBhcmVzIHRoZSBwcm92aWRlZCBzZXQgb2YgcmVtb3RlIG1ldGhvZCBhcmd1bWVudHMgZm9yXFxcXG4gICAqIHNlbmRpbmcgdG8gdGhlIHJlbW90ZSBzaXRlLCByZXBsYWNlcyBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoXFxcXG4gICAqIGlkZW50aWZpZXJzXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdG8gd3JhcFxcXFxuICAgKlxcXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHdyYXBwZWQgYXJndW1lbnRzXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgX2VuY29kZUludGVyZmFjZShhT2JqZWN0KSB7XFxcXG4gICAgbGV0IHYsIGssIGtleXM7XFxcXG4gICAgY29uc3QgZW5jb2RlZF9pbnRlcmZhY2UgPSB7fTtcXFxcbiAgICBhT2JqZWN0W1xcXFxcXFwiX3JpZFxcXFxcXFwiXSA9IGFPYmplY3RbXFxcXFxcXCJfcmlkXFxcXFxcXCJdIHx8IE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcInJhbmRJZFxcXFxcXFwiXSkoKTsgLy8gYW4gb2JqZWN0L2FycmF5XFxcXG5cXFxcbiAgICBpZiAoYU9iamVjdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IEFycmF5LmlzQXJyYXkoYU9iamVjdCkpIHtcXFxcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhhT2JqZWN0KTtcXFxcbiAgICB9IC8vIGEgY2xhc3NcXFxcbiAgICBlbHNlIGlmIChhT2JqZWN0LmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJQbGVhc2UgaW5zdGFudGlhdGUgdGhlIGNsYXNzIGJlZm9yZSBleHBvcnR0aW5nIGl0LlxcXFxcXFwiKTtcXFxcbiAgICAgIH0gLy8gaW5zdGFuY2Ugb2YgYSBjbGFzc1xcXFxuICAgICAgZWxzZSBpZiAoYU9iamVjdC5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcXFxcbiAgICAgICAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFPYmplY3QpKS5jb25jYXQoT2JqZWN0LmtleXMoYU9iamVjdCkpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgIHRocm93IEVycm9yKFxcXFxcXFwiVW5zdXBwb3J0ZWQgaW50ZXJmYWNlIHR5cGVcXFxcXFxcIik7XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgIGNvbnN0IGJPYmplY3QgPSBBcnJheS5pc0FycmF5KGFPYmplY3QpID8gW10gOiB7fTtcXFxcblxcXFxuICAgIGZvciAoayBvZiBrZXlzKSB7XFxcXG4gICAgICBpZiAoW1xcXFxcXFwiaGFzT3duUHJvcGVydHlcXFxcXFxcIiwgXFxcXFxcXCJjb25zdHJ1Y3RvclxcXFxcXFwiXS5pbmNsdWRlcyhrKSkgY29udGludWU7XFxcXG5cXFxcbiAgICAgIGlmIChrLnN0YXJ0c1dpdGgoXFxcXFxcXCJfXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgfVxcXFxuXFxcXG4gICAgICB2ID0gYU9iamVjdFtrXTtcXFxcblxcXFxuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgYk9iamVjdFtrXSA9IHtcXFxcbiAgICAgICAgICBfcnR5cGU6IFxcXFxcXFwiaW50ZXJmYWNlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgX3JpZDogYU9iamVjdFtcXFxcXFxcIl9yaWRcXFxcXFxcIl0sXFxcXG4gICAgICAgICAgX3J2YWx1ZToga1xcXFxuICAgICAgICB9O1xcXFxuICAgICAgICBlbmNvZGVkX2ludGVyZmFjZVtrXSA9IHY7XFxcXG4gICAgICB9IGVsc2UgaWYgKE9iamVjdCh2KSAhPT0gdikge1xcXFxuICAgICAgICBiT2JqZWN0W2tdID0ge1xcXFxuICAgICAgICAgIF9ydHlwZTogXFxcXFxcXCJhcmd1bWVudFxcXFxcXFwiLFxcXFxuICAgICAgICAgIF9ydmFsdWU6IHZcXFxcbiAgICAgICAgfTtcXFxcbiAgICAgICAgZW5jb2RlZF9pbnRlcmZhY2Vba10gPSB2O1xcXFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIikge1xcXFxuICAgICAgICBiT2JqZWN0W2tdID0gdGhpcy5fZW5jb2RlSW50ZXJmYWNlKHYpO1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcblxcXFxuICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVthT2JqZWN0W1xcXFxcXFwiX3JpZFxcXFxcXFwiXV0gPSBlbmNvZGVkX2ludGVyZmFjZTsgLy8gcmVtb3ZlIGludGVyZmFjZSB3aGVuIGNsb3NlZFxcXFxuXFxcXG4gICAgaWYgKGFPYmplY3Qub24gJiYgdHlwZW9mIGFPYmplY3Qub24gPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgYU9iamVjdC5vbihcXFxcXFxcImNsb3NlXFxcXFxcXCIsICgpID0+IHtcXFxcbiAgICAgICAgZGVsZXRlIHRoaXMuX2ludGVyZmFjZV9zdG9yZVthT2JqZWN0W1xcXFxcXFwiX3JpZFxcXFxcXFwiXV07XFxcXG4gICAgICB9KTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICByZXR1cm4gYk9iamVjdDtcXFxcbiAgfVxcXFxuXFxcXG4gIF9lbmNvZGUoYU9iamVjdCwgYXNfaW50ZXJmYWNlKSB7XFxcXG4gICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdO1xcXFxuXFxcXG4gICAgaWYgKCFhT2JqZWN0KSB7XFxcXG4gICAgICByZXR1cm4gYU9iamVjdDtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBjb25zdCBfdHJhbnNmZXIgPSBhT2JqZWN0Ll90cmFuc2ZlcjtcXFxcbiAgICBsZXQgYk9iamVjdCwgdiwgaztcXFxcbiAgICBjb25zdCBpc2FycmF5ID0gQXJyYXkuaXNBcnJheShhT2JqZWN0KTsgLy9za2lwIGlmIGFscmVhZHkgZW5jb2RlZFxcXFxuXFxcXG4gICAgaWYgKHR5cGVvZiBhT2JqZWN0ID09PSBcXFxcXFxcIm9iamVjdFxcXFxcXFwiICYmIGFPYmplY3QuX3J0eXBlICYmIGFPYmplY3QuX3J2YWx1ZSkge1xcXFxuICAgICAgcmV0dXJuIGFPYmplY3Q7XFxcXG4gICAgfSAvL2VuY29kZSBpbnRlcmZhY2VzXFxcXG5cXFxcblxcXFxuICAgIGlmICh0eXBlb2YgYU9iamVjdCA9PT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIiAmJiAhQXJyYXkuaXNBcnJheShhT2JqZWN0KSAmJiAoYU9iamVjdC5fcmludGYgfHwgYXNfaW50ZXJmYWNlKSkge1xcXFxuICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUludGVyZmFjZShhT2JqZWN0KTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBpZiAoYXNfaW50ZXJmYWNlKSB7XFxcXG4gICAgICBhT2JqZWN0W1xcXFxcXFwiX3JpZFxcXFxcXFwiXSA9IGFPYmplY3RbXFxcXFxcXCJfcmlkXFxcXFxcXCJdIHx8IE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcInJhbmRJZFxcXFxcXFwiXSkoKTtcXFxcbiAgICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVthT2JqZWN0W1xcXFxcXFwiX3JpZFxcXFxcXFwiXV0gPSB0aGlzLl9pbnRlcmZhY2Vfc3RvcmVbYU9iamVjdFtcXFxcXFxcIl9yaWRcXFxcXFxcIl1dIHx8IChpc2FycmF5ID8gW10gOiB7fSk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgYk9iamVjdCA9IGlzYXJyYXkgPyBbXSA6IHt9O1xcXFxuXFxcXG4gICAgZm9yIChrIGluIGFPYmplY3QpIHtcXFxcbiAgICAgIGlmIChbXFxcXFxcXCJoYXNPd25Qcm9wZXJ0eVxcXFxcXFwiLCBcXFxcXFxcImNvbnN0cnVjdG9yXFxcXFxcXCJdLmluY2x1ZGVzKGspKSBjb250aW51ZTtcXFxcblxcXFxuICAgICAgaWYgKGlzYXJyYXkgfHwgYU9iamVjdC5oYXNPd25Qcm9wZXJ0eShrKSkge1xcXFxuICAgICAgICB2ID0gYU9iamVjdFtrXTtcXFxcblxcXFxuICAgICAgICBpZiAodiAmJiB0eXBlb2YgdGhpcy5fbG9jYWxfYXBpLl9ycGNfZW5jb2RlID09PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICBjb25zdCBlbmNvZGVkX29iaiA9IHRoaXMuX2xvY2FsX2FwaS5fcnBjX2VuY29kZSh2KTtcXFxcblxcXFxuICAgICAgICAgIGlmIChlbmNvZGVkX29iaiAmJiBlbmNvZGVkX29iai5fY3R5cGUpIHtcXFxcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICAgIF9ydHlwZTogXFxcXFxcXCJjdXN0b21cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgX3J2YWx1ZTogZW5jb2RlZF9vYmosXFxcXG4gICAgICAgICAgICAgIF9yaWQ6IGFPYmplY3RbXFxcXFxcXCJfcmlkXFxcXFxcXCJdXFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgfSAvLyBpZiB0aGUgcmV0dXJuZWQgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gX3J0eXBlLCBhc3N1bWluZyB0aGUgb2JqZWN0IGhhcyBiZWVuIHRyYW5zZm9ybWVkXFxcXG4gICAgICAgICAgZWxzZSBpZiAoZW5jb2RlZF9vYmogIT09IHVuZGVmaW5lZCkge1xcXFxuICAgICAgICAgICAgICB2ID0gZW5jb2RlZF9vYmo7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICAgIGlmIChhc19pbnRlcmZhY2UpIHtcXFxcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRfaW50ZXJmYWNlID0gdGhpcy5faW50ZXJmYWNlX3N0b3JlW2FPYmplY3RbXFxcXFxcXCJfcmlkXFxcXFxcXCJdXTtcXFxcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICAgIF9ydHlwZTogXFxcXFxcXCJpbnRlcmZhY2VcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgX3JpZDogYU9iamVjdFtcXFxcXFxcIl9yaWRcXFxcXFxcIl0sXFxcXG4gICAgICAgICAgICAgIF9ydmFsdWU6IGtcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICBlbmNvZGVkX2ludGVyZmFjZVtrXSA9IHY7XFxcXG4gICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICBsZXQgaW50ZXJmYWNlRnVuY05hbWUgPSBudWxsO1xcXFxuXFxcXG4gICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9sb2NhbF9hcGkpIHtcXFxcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2NhbF9hcGkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcXFxcbiAgICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcXFxcXFxcIl9cXFxcXFxcIikpIGNvbnRpbnVlO1xcXFxuXFxcXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb2NhbF9hcGlbbmFtZV0gPT09IHYpIHtcXFxcbiAgICAgICAgICAgICAgICBpbnRlcmZhY2VGdW5jTmFtZSA9IG5hbWU7XFxcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICB9IC8vIHNlYXJjaCBmb3IgcHJvdG90eXBlc1xcXFxuXFxcXG5cXFxcbiAgICAgICAgICB2YXIgZnVuY3Rpb25zID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuX2xvY2FsX2FwaSkpO1xcXFxuXFxcXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgIHZhciBuYW1lXyA9IGZ1bmN0aW9uc1tpXTtcXFxcbiAgICAgICAgICAgIGlmIChuYW1lXy5zdGFydHNXaXRoKFxcXFxcXFwiX1xcXFxcXFwiKSkgY29udGludWU7XFxcXG5cXFxcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2NhbF9hcGlbbmFtZV9dID09PSB2KSB7XFxcXG4gICAgICAgICAgICAgIGludGVyZmFjZUZ1bmNOYW1lID0gbmFtZV87XFxcXG4gICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgIGlmICghaW50ZXJmYWNlRnVuY05hbWUpIHtcXFxcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX3N0b3JlLnB1dCh2KTtcXFxcblxcXFxuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcXFxcbiAgICAgICAgICAgICAgX3J0eXBlOiBcXFxcXFxcImNhbGxiYWNrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgIF9ydmFsdWU6IHYuY29uc3RydWN0b3IgJiYgdi5jb25zdHJ1Y3Rvci5uYW1lIHx8IGlkLFxcXFxuICAgICAgICAgICAgICBfcmluZGV4OiBpZFxcXFxuICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcXFxcbiAgICAgICAgICAgICAgX3J0eXBlOiBcXFxcXFxcImludGVyZmFjZVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICBfcnZhbHVlOiBpbnRlcmZhY2VGdW5jTmFtZSxcXFxcbiAgICAgICAgICAgICAgX3JpZDogXFxcXFxcXCJfcmxvY2FsXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9IGVsc2UgaWYgKFxcXFxuICAgICAgICAvKmdsb2JhbCB0ZiovXFxcXG4gICAgICAgIHR5cGVvZiB0ZiAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiB0Zi5UZW5zb3IgJiYgdiBpbnN0YW5jZW9mIHRmLlRlbnNvcikge1xcXFxuICAgICAgICAgIGNvbnN0IHZfYnVmZmVyID0gdi5kYXRhU3luYygpO1xcXFxuXFxcXG4gICAgICAgICAgaWYgKHYuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xcXFxuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHZfYnVmZmVyLmJ1ZmZlcik7XFxcXG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XFxcXG4gICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgYk9iamVjdFtrXSA9IHtcXFxcbiAgICAgICAgICAgIF9ydHlwZTogXFxcXFxcXCJuZGFycmF5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBfcnZhbHVlOiB2X2J1ZmZlcixcXFxcbiAgICAgICAgICAgIF9yc2hhcGU6IHYuc2hhcGUsXFxcXG4gICAgICAgICAgICBfcmR0eXBlOiB2LmR0eXBlXFxcXG4gICAgICAgICAgfTtcXFxcbiAgICAgICAgfSBlbHNlIGlmIChcXFxcbiAgICAgICAgLypnbG9iYWwgbmoqL1xcXFxuICAgICAgICB0eXBlb2YgbmogIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgbmouTmRBcnJheSAmJiB2IGluc3RhbmNlb2YgbmouTmRBcnJheSkge1xcXFxuICAgICAgICAgIHZhciBkdHlwZSA9IF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXFxcXFwidHlwZWRBcnJheVRvRHR5cGVcXFxcXFxcIl1bdi5zZWxlY3Rpb24uZGF0YS5jb25zdHJ1Y3Rvci5uYW1lXTtcXFxcblxcXFxuICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcXFxcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh2LnNlbGVjdGlvbi5kYXRhLmJ1ZmZlcik7XFxcXG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XFxcXG4gICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgYk9iamVjdFtrXSA9IHtcXFxcbiAgICAgICAgICAgIF9ydHlwZTogXFxcXFxcXCJuZGFycmF5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBfcnZhbHVlOiB2LnNlbGVjdGlvbi5kYXRhLFxcXFxuICAgICAgICAgICAgX3JzaGFwZTogdi5zaGFwZSxcXFxcbiAgICAgICAgICAgIF9yZHR5cGU6IGR0eXBlXFxcXG4gICAgICAgICAgfTtcXFxcbiAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgRXJyb3IpIHtcXFxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHYpO1xcXFxuICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICBfcnR5cGU6IFxcXFxcXFwiZXJyb3JcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIF9ydmFsdWU6IHYudG9TdHJpbmcoKVxcXFxuICAgICAgICAgIH07XFxcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgdiBpbnN0YW5jZW9mIEZpbGUpIHtcXFxcbiAgICAgICAgICBiT2JqZWN0W2tdID0ge1xcXFxuICAgICAgICAgICAgX3J0eXBlOiBcXFxcXFxcImZpbGVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIF9ydmFsdWU6IHYsXFxcXG4gICAgICAgICAgICBfcnJlbGF0aXZlX3BhdGg6IHYucmVsYXRpdmVQYXRoIHx8IHYud2Via2l0UmVsYXRpdmVQYXRoXFxcXG4gICAgICAgICAgfTtcXFxcbiAgICAgICAgfSAvLyBzZW5kIG9iamVjdHMgc3VwcG9ydGVkIGJ5IHN0cnVjdHVyZSBjbG9uZSBhbGdvcml0aG1cXFxcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobVxcXFxuICAgICAgICBlbHNlIGlmICh2ICE9PSBPYmplY3QodikgfHwgdiBpbnN0YW5jZW9mIEJvb2xlYW4gfHwgdiBpbnN0YW5jZW9mIFN0cmluZyB8fCB2IGluc3RhbmNlb2YgRGF0ZSB8fCB2IGluc3RhbmNlb2YgUmVnRXhwIHx8IHYgaW5zdGFuY2VvZiBCbG9iIHx8IHYgaW5zdGFuY2VvZiBJbWFnZURhdGEgfHwgdHlwZW9mIEZpbGVMaXN0ICE9PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiICYmIHYgaW5zdGFuY2VvZiBGaWxlTGlzdCkge1xcXFxuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcXFxcbiAgICAgICAgICAgICAgX3J0eXBlOiBcXFxcXFxcImFyZ3VtZW50XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgIF9ydmFsdWU6IHZcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcXFxcbiAgICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcXFxcbiAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHYpO1xcXFxuICAgICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICAgIF9ydHlwZTogXFxcXFxcXCJhcmd1bWVudFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICBfcnZhbHVlOiB2XFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyVmlldykge1xcXFxuICAgICAgICAgICAgaWYgKHYuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xcXFxuICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2godi5idWZmZXIpO1xcXFxuICAgICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XFxcXG4gICAgICAgICAgICAgIF9ydHlwZTogXFxcXFxcXCJhcmd1bWVudFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICBfcnZhbHVlOiB2XFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICAgIH0gLy8gVE9ETzogc3VwcG9ydCBhbHNvIE1hcCBhbmQgU2V0XFxcXG4gICAgICAgICAgLy8gVE9ETzogYXZvaWQgb2JqZWN0IHN1Y2ggYXMgRHluYW1pY1BsdWdpbiBpbnN0YW5jZS5cXFxcbiAgICAgICAgICBlbHNlIGlmICh2Ll9yaW50Zikge1xcXFxuICAgICAgICAgICAgICBiT2JqZWN0W2tdID0gdGhpcy5fZW5jb2RlKHYsIHRydWUpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICBiT2JqZWN0W2tdID0gdGhpcy5fZW5jb2RlKHYsIGFzX2ludGVyZmFjZSk7IC8vIG1vdmUgdHJhbnNmZXJhYmxlcyB0byB0aGUgdG9wIGxldmVsIG9iamVjdFxcXFxuXFxcXG4gICAgICAgICAgICAgIGlmIChiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fKSB7XFxcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fLmxlbmd0aDsgdCsrKSB7XFxcXG4gICAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2goYk9iamVjdFtrXS5fX3RyYW5zZmVyYWJsZXNfX1t0XSk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICAgICAgZGVsZXRlIGJPYmplY3Rba10uX190cmFuc2ZlcmFibGVzX187XFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgIHRocm93IFxcXFxcXFwiaW1qb3ktcnBjOiBVbnN1cHBvcnRlZCBkYXRhIHR5cGUgXFxcXFxcXCIgKyBrICsgXFxcXFxcXCIsXFxcXFxcXCIgKyB2O1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcblxcXFxuICAgIGlmICh0cmFuc2ZlcmFibGVzLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgIGJPYmplY3QuX190cmFuc2ZlcmFibGVzX18gPSB0cmFuc2ZlcmFibGVzO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHJldHVybiBiT2JqZWN0O1xcXFxuICB9XFxcXG5cXFxcbiAgX2RlY29kZShhT2JqZWN0LCBjYWxsYmFja0lkLCB3aXRoUHJvbWlzZSkge1xcXFxuICAgIGlmICghYU9iamVjdCkge1xcXFxuICAgICAgcmV0dXJuIGFPYmplY3Q7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgdmFyIGJPYmplY3QsIHYsIGs7XFxcXG5cXFxcbiAgICBpZiAoYU9iamVjdC5oYXNPd25Qcm9wZXJ0eShcXFxcXFxcIl9ydHlwZVxcXFxcXFwiKSAmJiBhT2JqZWN0Lmhhc093blByb3BlcnR5KFxcXFxcXFwiX3J2YWx1ZVxcXFxcXFwiKSkge1xcXFxuICAgICAgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcImN1c3RvbVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGlmIChhT2JqZWN0Ll9ydmFsdWUgJiYgdHlwZW9mIHRoaXMuX2xvY2FsX2FwaS5fcnBjX2RlY29kZSA9PT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgYk9iamVjdCA9IHRoaXMuX2xvY2FsX2FwaS5fcnBjX2RlY29kZShhT2JqZWN0Ll9ydmFsdWUpO1xcXFxuXFxcXG4gICAgICAgICAgaWYgKGJPYmplY3QgPT09IHVuZGVmaW5lZCkge1xcXFxuICAgICAgICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcImNhbGxiYWNrXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX2dlblJlbW90ZUNhbGxiYWNrKGNhbGxiYWNrSWQsIGFPYmplY3QuX3JpbmRleCwgd2l0aFByb21pc2UpO1xcXFxuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXFxcXFxcXCJpbnRlcmZhY2VcXFxcXFxcIikge1xcXFxuICAgICAgICBjb25zdCBpbnRmaWQgPSBhT2JqZWN0Ll9yaWQgPT09IFxcXFxcXFwiX3Jsb2NhbFxcXFxcXFwiID8gXFxcXFxcXCJfcnJtb3RlXFxcXFxcXCIgOiBhT2JqZWN0Ll9yaWQ7XFxcXG4gICAgICAgIGJPYmplY3QgPSB0aGlzLl9pbnRlcmZhY2Vfc3RvcmVbaW50ZmlkXSAmJiB0aGlzLl9pbnRlcmZhY2Vfc3RvcmVbaW50ZmlkXVthT2JqZWN0Ll9ydmFsdWVdIHx8IHRoaXMuX2dlblJlbW90ZU1ldGhvZChhT2JqZWN0Ll9ydmFsdWUsIGFPYmplY3QuX3JpZCk7XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcIm5kYXJyYXlcXFxcXFxcIikge1xcXFxuICAgICAgICAvKmdsb2JhbCBuaiB0ZiovXFxcXG4gICAgICAgIC8vY3JlYXRlIGJ1aWxkIGFycmF5L3RlbnNvciBpZiB1c2VkIGluIHRoZSBwbHVnaW5cXFxcbiAgICAgICAgaWYgKHR5cGVvZiBuaiAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiBuai5hcnJheSkge1xcXFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFPYmplY3QuX3J2YWx1ZSkpIHtcXFxcbiAgICAgICAgICAgIGFPYmplY3QuX3J2YWx1ZSA9IGFPYmplY3QuX3J2YWx1ZS5yZWR1Y2UoX2FwcGVuZEJ1ZmZlcik7XFxcXG4gICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgYk9iamVjdCA9IG5qLmFycmF5KGFPYmplY3QuX3J2YWx1ZSwgYU9iamVjdC5fcmR0eXBlKS5yZXNoYXBlKGFPYmplY3QuX3JzaGFwZSk7XFxcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRmICE9PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiICYmIHRmLlRlbnNvcikge1xcXFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFPYmplY3QuX3J2YWx1ZSkpIHtcXFxcbiAgICAgICAgICAgIGFPYmplY3QuX3J2YWx1ZSA9IGFPYmplY3QuX3J2YWx1ZS5yZWR1Y2UoX2FwcGVuZEJ1ZmZlcik7XFxcXG4gICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgYk9iamVjdCA9IHRmLnRlbnNvcihhT2JqZWN0Ll9ydmFsdWUsIGFPYmplY3QuX3JzaGFwZSwgYU9iamVjdC5fcmR0eXBlKTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAvL2tlZXAgaXQgYXMgcmVndWxhciBpZiB0cmFuc2ZlcmVkIHRvIHRoZSBtYWluIGFwcFxcXFxuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcImVycm9yXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgYk9iamVjdCA9IG5ldyBFcnJvcihhT2JqZWN0Ll9ydmFsdWUpO1xcXFxuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXFxcXFxcXCJmaWxlXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgYk9iamVjdCA9IGFPYmplY3QuX3J2YWx1ZTsgLy9wYXRjaCByZWxhdGl2ZVBhdGhcXFxcblxcXFxuICAgICAgICBiT2JqZWN0LnJlbGF0aXZlUGF0aCA9IGFPYmplY3QuX3JyZWxhdGl2ZV9wYXRoO1xcXFxuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXFxcXFxcXCJhcmd1bWVudFxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGJPYmplY3QgPSBhT2JqZWN0Ll9ydmFsdWU7XFxcXG4gICAgICB9XFxcXG5cXFxcbiAgICAgIHJldHVybiBiT2JqZWN0O1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICB2YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkoYU9iamVjdCk7XFxcXG4gICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XFxcXG5cXFxcbiAgICAgIGZvciAoayBpbiBhT2JqZWN0KSB7XFxcXG4gICAgICAgIGlmIChpc2FycmF5IHx8IGFPYmplY3QuaGFzT3duUHJvcGVydHkoaykpIHtcXFxcbiAgICAgICAgICB2ID0gYU9iamVjdFtrXTtcXFxcblxcXFxuICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIiB8fCBBcnJheS5pc0FycmF5KHYpKSB7XFxcXG4gICAgICAgICAgICBiT2JqZWN0W2tdID0gdGhpcy5fZGVjb2RlKHYsIGNhbGxiYWNrSWQsIHdpdGhQcm9taXNlKTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH1cXFxcblxcXFxuICAgICAgcmV0dXJuIGJPYmplY3Q7XFxcXG4gICAgfVxcXFxuICB9XFxcXG5cXFxcbiAgX3dyYXAoYXJncywgYXNfaW50ZXJmYWNlKSB7XFxcXG4gICAgdmFyIHdyYXBwZWQgPSB0aGlzLl9lbmNvZGUoYXJncywgYXNfaW50ZXJmYWNlKTtcXFxcblxcXFxuICAgIHZhciByZXN1bHQgPSB7XFxcXG4gICAgICBhcmdzOiB3cmFwcGVkXFxcXG4gICAgfTtcXFxcbiAgICByZXR1cm4gcmVzdWx0O1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBVbndyYXBzIHRoZSBzZXQgb2YgYXJndW1lbnRzIGRlbGl2ZXJlZCBmcm9tIHRoZSByZW1vdGUgc2l0ZSxcXFxcbiAgICogcmVwbGFjZXMgYWxsIGNhbGxiYWNrIGlkZW50aWZpZXJzIHdpdGggYSBmdW5jdGlvbiB3aGljaCB3aWxsXFxcXG4gICAqIGluaXRpYXRlIHNlbmRpbmcgdGhhdCBjYWxsYmFjayBpZGVudGlmaWVyIGJhY2sgdG8gb3RoZXIgc2l0ZVxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyB0byB1bndyYXBcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aXRoUHJvbWlzZSBpcyB0cnVlIG1lYW5zIHRoaXMgdGhlIGNhbGxiYWNrIHNob3VsZCBjb250YWluIGEgcHJvbWlzZVxcXFxuICAgKlxcXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHVud3JhcHBlZCBhcmdzXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgX3Vud3JhcChhcmdzLCB3aXRoUHJvbWlzZSkge1xcXFxuICAgIC8vIHZhciBjYWxsZWQgPSBmYWxzZTtcXFxcbiAgICAvLyB3cmFwcyBlYWNoIGNhbGxiYWNrIHNvIHRoYXQgdGhlIG9ubHkgb25lIGNvdWxkIGJlIGNhbGxlZFxcXFxuICAgIC8vIHZhciBvbmNlKGNiKSB7XFxcXG4gICAgLy8gICAgIHJldHVybiBmdW5jdGlvbigpIHtcXFxcbiAgICAvLyAgICAgICAgIGlmICghY2FsbGVkKSB7XFxcXG4gICAgLy8gICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcXFxcbiAgICAvLyAgICAgICAgICAgICByZXR1cm4gY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXFxcbiAgICAvLyAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgLy8gICAgICAgICAgICAgdmFyIG1zZyA9XFxcXG4gICAgLy8gICAgICAgICAgICAgICAnQSBjYWxsYmFjayBmcm9tIHRoaXMgc2V0IGhhcyBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQnO1xcXFxuICAgIC8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xcXFxuICAgIC8vICAgICAgICAgfVxcXFxuICAgIC8vICAgICB9O1xcXFxuICAgIC8vIH1cXFxcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZGVjb2RlKGFyZ3MuYXJncywgYXJncy5jYWxsYmFja0lkLCB3aXRoUHJvbWlzZSk7XFxcXG5cXFxcbiAgICByZXR1cm4gcmVzdWx0O1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBHZW5lcmF0ZXMgdGhlIHdyYXBwZWQgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBhIHNpbmdsZSByZW1vdGVcXFxcbiAgICogY2FsbGJhY2suIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZFxcXFxuICAgKiB0aGUgY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG9cXFxcbiAgICogZXhlY3V0ZSB0aGUgcGFydGljdWxhciBjYWxsYmFjayBwcmV2aW91c2x5IHNhdmVkIGR1cmluZyBhIGNhbGxcXFxcbiAgICogYnkgdGhlIHJlbW90ZSBzaXRlIGEgbWV0aG9kIGZyb20gdGhlIGludGVyZmFjZSBvZiB0aGlzIHNpdGVcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIG9mIHRoZSByZW1vdGUgY2FsbGJhY2sgdG8gZXhlY3V0ZVxcXFxuICAgKiBAcGFyYW0ge051bWJlcn0gYXJnTnVtIGFyZ3VtZW50IGluZGV4IG9mIHRoZSBjYWxsYmFja1xcXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhQcm9taXNlIGlzIHRydWUgbWVhbnMgdGhpcyB0aGUgY2FsbGJhY2sgc2hvdWxkIGNvbnRhaW4gYSBwcm9taXNlXFxcXG4gICAqXFxcXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCByZW1vdGUgY2FsbGJhY2tcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfZ2VuUmVtb3RlQ2FsbGJhY2soaWQsIGFyZ051bSwgd2l0aFByb21pc2UpIHtcXFxcbiAgICB2YXIgbWUgPSB0aGlzO1xcXFxuICAgIHZhciByZW1vdGVDYWxsYmFjaztcXFxcblxcXFxuICAgIGlmICh3aXRoUHJvbWlzZSkge1xcXFxuICAgICAgcmVtb3RlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxcXG4gICAgICAgICAgdmFyIGFyZ3MgPSBtZS5fd3JhcChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcXFxcblxcXFxuICAgICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgICAgIHJlc29sdmUuX19qYWlsZWRfcGFpcnNfXyA9IHJlamVjdDtcXFxcbiAgICAgICAgICByZWplY3QuX19qYWlsZWRfcGFpcnNfXyA9IHJlc29sdmU7XFxcXG5cXFxcbiAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgbWUuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICAgICAgICAgIHR5cGU6IFxcXFxcXFwiY2FsbGJhY2tcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgaWQ6IGlkLFxcXFxuICAgICAgICAgICAgICBfcmluZGV4OiBhcmdOdW0sXFxcXG4gICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXFxcXG4gICAgICAgICAgICAgIC8vIHBpZCA6ICBtZS5pZCxcXFxcbiAgICAgICAgICAgICAgcHJvbWlzZTogbWUuX3dyYXAoW3Jlc29sdmUsIHJlamVjdF0pXFxcXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKTtcXFxcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICByZWplY3QoYEZhaWxlZCB0byBleGVjdHVlIHJlbW90ZSBjYWxsYmFjayAoaWQ6ICR7aWR9LCBhcmdOdW06ICR7YXJnTnVtfSkuYCk7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgIH07XFxcXG5cXFxcbiAgICAgIHJldHVybiByZW1vdGVDYWxsYmFjaztcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgcmVtb3RlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICAgIHZhciBhcmdzID0gbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XFxcXG5cXFxcbiAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBhcmdzLmFyZ3MuX190cmFuc2ZlcmFibGVzX187XFxcXG4gICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgICByZXR1cm4gbWUuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICAgICAgdHlwZTogXFxcXFxcXCJjYWxsYmFja1xcXFxcXFwiLFxcXFxuICAgICAgICAgIGlkOiBpZCxcXFxcbiAgICAgICAgICBfcmluZGV4OiBhcmdOdW0sXFxcXG4gICAgICAgICAgYXJnczogYXJncyAvLyBwaWQgOiAgbWUuaWRcXFxcblxcXFxuICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKTtcXFxcbiAgICAgIH07XFxcXG5cXFxcbiAgICAgIHJldHVybiByZW1vdGVDYWxsYmFjaztcXFxcbiAgICB9XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNlbmRzIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZSBhbmQgYnJlYWtzIHRoZSBjb25uZWN0aW9uXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgZGlzY29ubmVjdCgpIHtcXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoe1xcXFxuICAgICAgdHlwZTogXFxcXFxcXCJkaXNjb25uZWN0XFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcblxcXFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcXFxuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XFxcXG4gICAgfSwgMjAwMCk7XFxcXG4gIH1cXFxcblxcXFxufVxcXFxuLyoqXFxcXG4gKiBSZWZlcmVuY2VTdG9yZSBpcyBhIHNwZWNpYWwgb2JqZWN0IHdoaWNoIHN0b3JlcyBvdGhlciBvYmplY3RzXFxcXG4gKiBhbmQgcHJvdmlkZXMgdGhlIHJlZmVyZW5jZXMgKG51bWJlcikgaW5zdGVhZC4gVGhpcyByZWZlcmVuY2VcXFxcbiAqIG1heSB0aGVuIGJlIHNlbnQgb3ZlciBhIGpzb24tYmFzZWQgY29tbXVuaWNhdGlvbiBjaGFubmVsIChJUENcXFxcbiAqIHRvIGFub3RoZXIgTm9kZS5qcyBwcm9jZXNzIG9yIGEgbWVzc2FnZSB0byB0aGUgV29ya2VyKS4gT3RoZXJcXFxcbiAqIHNpdGUgbWF5IHRoZW4gcHJvdmlkZSB0aGUgcmVmZXJlbmNlIGluIHRoZSByZXNwb25jZSBtZXNzYWdlXFxcXG4gKiBpbXBseWluZyB0aGUgZ2l2ZW4gb2JqZWN0IHNob3VsZCBiZSBhY3RpdmF0ZWQuXFxcXG4gKlxcXFxuICogUHJpbWFyeSB1c2FnZSBmb3IgdGhlIFJlZmVyZW5jZVN0b3JlIGlzIGEgc3RvcmFnZSBmb3IgdGhlXFxcXG4gKiBjYWxsYmFja3MsIHdoaWNoIHRoZXJlZm9yZSBtYWtlcyBpdCBwb3NzaWJsZSB0byBpbml0aWF0ZSBhXFxcXG4gKiBjYWxsYmFjayBleGVjdXRpb24gYnkgdGhlIG9wcG9zaXRlIHNpdGUgKHdoaWNoIG5vcm1hbGx5IGNhbm5vdFxcXFxuICogZGlyZWN0bHkgZXhlY3V0ZSBmdW5jdGlvbnMgb3ZlciB0aGUgY29tbXVuaWNhdGlvbiBjaGFubmVsKS5cXFxcbiAqXFxcXG4gKiBFYWNoIHN0b3JlZCBvYmplY3QgY2FuIG9ubHkgYmUgZmV0Y2hlZCBvbmNlIGFuZCBpcyBub3RcXFxcbiAqIGF2YWlsYWJsZSBmb3IgdGhlIHNlY29uZCB0aW1lLiBFYWNoIHN0b3JlZCBvYmplY3QgbXVzdCBiZVxcXFxuICogZmV0Y2hlZCwgc2luY2Ugb3RoZXJ3aXNlIGl0IHdpbGwgcmVtYWluIHN0b3JlZCBmb3JldmVyIGFuZFxcXFxuICogY29uc3VtZSBtZW1vcnkuXFxcXG4gKlxcXFxuICogU3RvcmVkIG9iamVjdCBpbmRlY2VzIGFyZSBzaW1wbHkgdGhlIG51bWJlcnMsIHdoaWNoIGFyZSBob3dldmVyXFxcXG4gKiByZWxlYXNlZCBhbG9uZyB3aXRoIHRoZSBvYmplY3RzLCBhbmQgYXJlIGxhdGVyIHJldXNlZCBhZ2FpbiAoaW5cXFxcbiAqIG9yZGVyIHRvIHBvc3Rwb25lIHRoZSBvdmVyZmxvdywgd2hpY2ggc2hvdWxkIG5vdCBsaWtlbHkgaGFwcGVuLFxcXFxuICogYnV0IGFueXdheSkuXFxcXG4gKi9cXFxcblxcXFxuY2xhc3MgUmVmZXJlbmNlU3RvcmUge1xcXFxuICBjb25zdHJ1Y3RvcigpIHtcXFxcbiAgICB0aGlzLl9zdG9yZSA9IHt9OyAvLyBzdG9yZWQgb2JqZWN0XFxcXG5cXFxcbiAgICB0aGlzLl9pbmRpY2VzID0gWzBdOyAvLyBzbWFsbGVzdCBhdmFpbGFibGUgaW5kaWNlc1xcXFxuXFxcXG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyID0gZnVuY3Rpb24gKCkge307XFxcXG5cXFxcbiAgICB0aGlzLl9idXN5SGFuZGxlciA9IGZ1bmN0aW9uICgpIHt9O1xcXFxuXFxcXG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyKCk7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIGNhbGwgaGFuZGxlciB3aGVuIHRoZSBzdG9yZSBpcyBlbXB0eVxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBvblJlYWR5KHJlYWR5SGFuZGxlcikge1xcXFxuICAgIHRoaXMuX3JlYWR5SGFuZGxlciA9IHJlYWR5SGFuZGxlciB8fCBmdW5jdGlvbiAoKSB7fTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogY2FsbCBoYW5kbGVyIHdoZW4gdGhlIHN0b3JlIGlzIG5vdCBlbXB0eVxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBvbkJ1c3koYnVzeUhhbmRsZXIpIHtcXFxcbiAgICB0aGlzLl9idXN5SGFuZGxlciA9IGJ1c3lIYW5kbGVyIHx8IGZ1bmN0aW9uICgpIHt9O1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgc3RvcmVcXFxcbiAgICpcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBnZXRTdGFjaygpIHtcXFxcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3RvcmUpLmxlbmd0aDtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogQGZ1bmN0aW9uIF9nZW5JZCgpIGdlbmVyYXRlcyB0aGUgbmV3IHJlZmVyZW5jZSBpZFxcXFxuICAgKlxcXFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBzbWFsbGVzdCBhdmFpbGFibGUgaWQgYW5kIHJlc2VydmVzIGl0XFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgX2dlbklkKCkge1xcXFxuICAgIHZhciBpZDtcXFxcblxcXFxuICAgIGlmICh0aGlzLl9pbmRpY2VzLmxlbmd0aCA9PT0gMSkge1xcXFxuICAgICAgaWQgPSB0aGlzLl9pbmRpY2VzWzBdKys7XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgIGlkID0gdGhpcy5faW5kaWNlcy5zaGlmdCgpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHJldHVybiBpZDtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIHJlZmVyZW5jZSBpZCBzbyB0aGF0IGl0IHdpbGwgYmUgYXZhaWxhYmxlIGJ5XFxcXG4gICAqIGFub3RoZXIgb2JqZWN0IHN0b3JlZFxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgdG8gcmVsZWFzZVxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIF9yZWxlYXNlSWQoaWQpIHtcXFxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2luZGljZXMubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgIGlmIChpZCA8IHRoaXMuX2luZGljZXNbaV0pIHtcXFxcbiAgICAgICAgdGhpcy5faW5kaWNlcy5zcGxpY2UoaSwgMCwgaWQpO1xcXFxuXFxcXG4gICAgICAgIGJyZWFrO1xcXFxuICAgICAgfVxcXFxuICAgIH0gLy8gY2xlYW5pbmctdXAgdGhlIHNlcXVlbmNlIHRhaWxcXFxcblxcXFxuXFxcXG4gICAgZm9yIChpID0gdGhpcy5faW5kaWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcXFxuICAgICAgaWYgKHRoaXMuX2luZGljZXNbaV0gLSAxID09PSB0aGlzLl9pbmRpY2VzW2kgLSAxXSkge1xcXFxuICAgICAgICB0aGlzLl9pbmRpY2VzLnBvcCgpO1xcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgYnJlYWs7XFxcXG4gICAgICB9XFxcXG4gICAgfVxcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBTdG9yZXMgdGhlIGdpdmVuIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgcmVmZXJuY2UgaWQgaW5zdGVhZFxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRvIHN0b3JlXFxcXG4gICAqXFxcXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJlZmVyZW5jZSBpZCBvZiB0aGUgc3RvcmVkIG9iamVjdFxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIHB1dChvYmopIHtcXFxcbiAgICBpZiAodGhpcy5fYnVzeUhhbmRsZXIgJiYgT2JqZWN0LmtleXModGhpcy5fc3RvcmUpLmxlbmd0aCA9PT0gMCkge1xcXFxuICAgICAgdGhpcy5fYnVzeUhhbmRsZXIoKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICB2YXIgaWQgPSB0aGlzLl9nZW5JZCgpO1xcXFxuXFxcXG4gICAgdGhpcy5fc3RvcmVbaWRdID0gb2JqO1xcXFxuICAgIHJldHVybiBpZDtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogUmV0cmlldmVzIHByZXZpb3VzbHkgc3RvcmVkIG9iamVjdCBhbmQgcmVsZWFzZXMgaXRzIHJlZmVyZW5jZVxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgb2YgYW4gb2JqZWN0IHRvIHJldHJpZXZlXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgZmV0Y2goaWQpIHtcXFxcbiAgICB2YXIgb2JqID0gdGhpcy5fc3RvcmVbaWRdO1xcXFxuXFxcXG4gICAgaWYgKG9iaiAmJiAhb2JqLl9fcmVtb3RlX21ldGhvZCkge1xcXFxuICAgICAgZGVsZXRlIHRoaXMuX3N0b3JlW2lkXTtcXFxcblxcXFxuICAgICAgdGhpcy5fcmVsZWFzZUlkKGlkKTtcXFxcblxcXFxuICAgICAgaWYgKHRoaXMuX3JlYWR5SGFuZGxlciAmJiBPYmplY3Qua2V5cyh0aGlzLl9zdG9yZSkubGVuZ3RoID09PSAwKSB7XFxcXG4gICAgICAgIHRoaXMuX3JlYWR5SGFuZGxlcigpO1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcblxcXFxuICAgIGlmIChvYmogJiYgb2JqLl9famFpbGVkX3BhaXJzX18pIHtcXFxcbiAgICAgIGNvbnN0IF9pZCA9IGdldEtleUJ5VmFsdWUodGhpcy5fc3RvcmUsIG9iai5fX2phaWxlZF9wYWlyc19fKTtcXFxcblxcXFxuICAgICAgdGhpcy5mZXRjaChfaWQpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHJldHVybiBvYmo7XFxcXG4gIH1cXFxcblxcXFxufS8vIyBzb3VyY2VVUkw9W21vZHVsZV1cXFxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pTGk5emNtTXZjbkJqTG1wekxtcHpJaXdpYzI5MWNtTmxjeUk2V3lKM1pXSndZV05yT2k4dmFXMXFiM2xTVUVNdkxpOXpjbU12Y25CakxtcHpQek0xTldZaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeW9xWEc0Z0tpQkRiMjUwWVdsdWN5QjBhR1VnVWxCRElHOWlhbVZqZENCMWMyVmtJR0p2ZEdnZ1lua2dkR2hsSUdGd2NHeHBZMkYwYVc5dVhHNGdLaUJ6YVhSbExDQmhibVFnWW5rZ1pXRmphQ0J3YkhWbmFXNWNiaUFxTDF4dWFXMXdiM0owSUhzZ2NtRnVaRWxrTENCMGVYQmxaRUZ5Y21GNVZHOUVkSGx3WlN3Z1RXVnpjMkZuWlVWdGFYUjBaWElnZlNCbWNtOXRJRndpTGk5MWRHbHNjeTVxYzF3aU8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1FWQkpYMVpGVWxOSlQwNGdQU0JjSWpBdU1pNHhYQ0k3WEc1Y2JtTnZibk4wSUVGeWNtRjVRblZtWm1WeVZtbGxkeUE5SUU5aWFtVmpkQzVuWlhSUWNtOTBiM1I1Y0dWUFppaGNiaUFnVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bUtHNWxkeUJWYVc1ME9FRnljbUY1S0NrcFhHNHBMbU52Ym5OMGNuVmpkRzl5TzF4dVhHNW1kVzVqZEdsdmJpQmZZWEJ3Wlc1a1FuVm1abVZ5S0dKMVptWmxjakVzSUdKMVptWmxjaklwSUh0Y2JpQWdZMjl1YzNRZ2RHMXdJRDBnYm1WM0lGVnBiblE0UVhKeVlYa29ZblZtWm1WeU1TNWllWFJsVEdWdVozUm9JQ3NnWW5WbVptVnlNaTVpZVhSbFRHVnVaM1JvS1R0Y2JpQWdkRzF3TG5ObGRDaHVaWGNnVldsdWREaEJjbkpoZVNoaWRXWm1aWEl4S1N3Z01DazdYRzRnSUhSdGNDNXpaWFFvYm1WM0lGVnBiblE0UVhKeVlYa29ZblZtWm1WeU1pa3NJR0oxWm1abGNqRXVZbmwwWlV4bGJtZDBhQ2s3WEc0Z0lISmxkSFZ5YmlCMGJYQXVZblZtWm1WeU8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCblpYUkxaWGxDZVZaaGJIVmxLRzlpYW1WamRDd2dkbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJRTlpYW1WamRDNXJaWGx6S0c5aWFtVmpkQ2t1Wm1sdVpDaHJaWGtnUFQ0Z2IySnFaV04wVzJ0bGVWMGdQVDA5SUhaaGJIVmxLVHRjYm4xY2JpOHFLbHh1SUNvZ1VsQkRJRzlpYW1WamRDQnlaWEJ5WlhObGJuUnpJR0VnYzJsdVoyeGxJSE5wZEdVZ2FXNGdkR2hsWEc0Z0tpQmpiMjF0ZFc1cFkyRjBhVzl1SUhCeWIzUnZZMjlzSUdKbGRIZGxaVzRnZEdobElHRndjR3hwWTJGMGFXOXVJR0Z1WkNCMGFHVWdjR3gxWjJsdVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUdOdmJtNWxZM1JwYjI0Z1lTQnpjR1ZqYVdGc0lHOWlhbVZqZENCaGJHeHZkMmx1WnlCMGJ5QnpaVzVrWEc0Z0tpQmhibVFnY21WalpXbDJaU0J0WlhOellXZGxjeUJtY205dElIUm9aU0J2Y0hCdmMybDBaU0J6YVhSbElDaGlZWE5wWTJGc2JIa2dhWFJjYmlBcUlITm9iM1ZzWkNCdmJteDVJSEJ5YjNacFpHVWdjMlZ1WkNncElHRnVaQ0J2YmsxbGMzTmhaMlVvS1NCdFpYUm9iMlJ6S1Z4dUlDb3ZYRzVsZUhCdmNuUWdZMnhoYzNNZ1VsQkRJR1Y0ZEdWdVpITWdUV1Z6YzJGblpVVnRhWFIwWlhJZ2UxeHVJQ0JqYjI1emRISjFZM1J2Y2loamIyNXVaV04wYVc5dUxDQmpiMjVtYVdjcElIdGNiaUFnSUNCemRYQmxjaWhqYjI1bWFXY2dKaVlnWTI5dVptbG5MbVJsWW5WbktUdGNiaUFnSUNCMGFHbHpMbDlqYjI1dVpXTjBhVzl1SUQwZ1kyOXVibVZqZEdsdmJqdGNiaUFnSUNCMGFHbHpMbU52Ym1acFp5QTlJR052Ym1acFp5QjhmQ0I3ZlR0Y2JpQWdJQ0IwYUdsekxsOXBiblJsY21aaFkyVmZjM1J2Y21VZ1BTQjdmVHRjYmlBZ0lDQjBhR2x6TGw5c2IyTmhiRjloY0drZ1BTQnVkV3hzTzF4dUlDQWdJQzh2SUcxaGEyVWdjM1Z5WlNCMGFHVnlaU0JwY3lCaGJpQmxlR1ZqZFhSbElHWjFibU4wYVc5dVhHNGdJQ0FnWTI5dWMzUWdibUZ0WlNBOUlIUm9hWE11WTI5dVptbG5MbTVoYldVN1hHNGdJQ0FnZEdocGN5NWZZMjl1Ym1WamRHbHZiaTVsZUdWamRYUmxJRDFjYmlBZ0lDQWdJSFJvYVhNdVgyTnZibTVsWTNScGIyNHVaWGhsWTNWMFpTQjhmRnh1SUNBZ0lDQWdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhnWTI5dWJtVmpkR2x2Ymk1bGVHVmpkWFJsSUc1dmRDQnBiWEJzWlcxbGJuUmxaQ0FvYVc0Z1hDSWtlMjVoYldWOVhDSXBZQ2s3WEc0Z0lDQWdJQ0I5TzF4dUlDQWdJSFJvYVhNdVgzTjBiM0psSUQwZ2JtVjNJRkpsWm1WeVpXNWpaVk4wYjNKbEtDazdYRzRnSUNBZ2RHaHBjeTVmYldWMGFHOWtYM0psWm5NZ1BTQnVaWGNnVW1WbVpYSmxibU5sVTNSdmNtVW9LVHRjYmlBZ0lDQjBhR2x6TGw5dFpYUm9iMlJmY21WbWN5NXZibEpsWVdSNUtDZ3BJRDArSUh0Y2JpQWdJQ0FnSUhSb2FYTXVYMlpwY21Vb1hDSnlaVzF2ZEdWSlpHeGxYQ0lwTzF4dUlDQWdJSDBwTzF4dUlDQWdJSFJvYVhNdVgyMWxkR2h2WkY5eVpXWnpMbTl1UW5WemVTZ29LU0E5UGlCN1hHNGdJQ0FnSUNCMGFHbHpMbDltYVhKbEtGd2ljbVZ0YjNSbFFuVnplVndpS1R0Y2JpQWdJQ0I5S1R0Y2JpQWdJQ0IwYUdsekxsOXpaWFIxY0UxbGMzTmhaMlZJWVc1c1pHVnljeWdwTzF4dUlDQjlYRzVjYmlBZ2FXNXBkQ2dwSUh0Y2JpQWdJQ0IwYUdsekxsOWpiMjV1WldOMGFXOXVMbVZ0YVhRb2UxeHVJQ0FnSUNBZ2RIbHdaVG9nWENKcGJtbDBhV0ZzYVhwbFpGd2lMRnh1SUNBZ0lDQWdZMjl1Wm1sbk9pQjBhR2x6TG1OdmJtWnBaeXhjYmlBZ0lDQWdJSEJsWlhKZmFXUTZJSFJvYVhNdVgyTnZibTVsWTNScGIyNHVjR1ZsY2w5cFpGeHVJQ0FnSUgwcE8xeHVJQ0I5WEc0Z0lDOHFLbHh1SUNBZ0tpQlRaWFFnWVNCb1lXNWtiR1Z5SUhSdklHSmxJR05oYkd4bFpDQjNhR1Z1SUhKbFkyVnBkbVZrSUdFZ2NtVnpjRzl1WTJVZ1puSnZiU0IwYUdWY2JpQWdJQ29nY21WdGIzUmxJSE5wZEdVZ2NtVndiM0owYVc1bklIUm9ZWFFnZEdobElIQnlaWFpwYjNWemJIa2djSEp2ZG1sa1pXUWdhVzUwWlhKbVlXTmxYRzRnSUNBcUlHaGhjeUJpWldWdUlITjFZMk5sYzNObWRXeHNlU0J6WlhRZ1lYTWdjbVZ0YjNSbElHWnZjaUIwYUdGMElITnBkR1ZjYmlBZ0lDcGNiaUFnSUNvZ1FIQmhjbUZ0SUh0R2RXNWpkR2x2Ym4wZ2FHRnVaR3hsY2x4dUlDQWdLaTljYmx4dUlDQm5aWFJTWlcxdmRHVkRZV3hzVTNSaFkyc29LU0I3WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE11WDIxbGRHaHZaRjl5WldaekxtZGxkRk4wWVdOcktDazdYRzRnSUgxY2JseHVJQ0F2S2lwY2JpQWdJQ29nUUhKbGRIVnlibk1nZTA5aWFtVmpkSDBnYzJWMElHOW1JSEpsYlc5MFpTQnBiblJsY21aaFkyVWdiV1YwYUc5a2MxeHVJQ0FnS2k5Y2JpQWdaMlYwVW1WdGIzUmxLQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TGw5cGJuUmxjbVpoWTJWZmMzUnZjbVZiWENKZmNuSmxiVzkwWlZ3aVhUdGNiaUFnZlZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJUWlhSeklIUm9aU0JwYm5SbGNtWmhZMlVnYjJZZ2RHaHBjeUJ6YVhSbElHMWhhMmx1WnlCcGRDQmhkbUZwYkdGaWJHVWdkRzhnZEdobFhHNGdJQ0FxSUhKbGJXOTBaU0J6YVhSbElHSjVJSE5sYm1ScGJtY2dZU0J0WlhOellXZGxJSGRwZEdnZ1lTQnpaWFFnYjJZZ2JXVjBhRzlrY3lCdVlXMWxjMXh1SUNBZ0tseHVJQ0FnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnWDJsdWRHVnlabUZqWlNCMGJ5QnpaWFJjYmlBZ0lDb3ZYRzRnSUhObGRFbHVkR1Z5Wm1GalpTaGZhVzUwWlhKbVlXTmxLU0I3WEc0Z0lDQWdhV1lnS0hSb2FYTXVZMjl1Wm1sbkxtWnZjbmRoY21ScGJtZGZablZ1WTNScGIyNXpLU0I3WEc0Z0lDQWdJQ0JtYjNJZ0tHeGxkQ0JtZFc1algyNWhiV1VnYjJZZ2RHaHBjeTVqYjI1bWFXY3VabTl5ZDJGeVpHbHVaMTltZFc1amRHbHZibk1wSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWDNKbGJXOTBaU0E5SUhSb2FYTXVYMmx1ZEdWeVptRmpaVjl6ZEc5eVpWdGNJbDl5Y21WdGIzUmxYQ0pkTzF4dUlDQWdJQ0FnSUNCcFppQW9YM0psYlc5MFpWdG1kVzVqWDI1aGJXVmRLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLRjlwYm5SbGNtWmhZMlV1WTI5dWMzUnlkV04wYjNJZ1BUMDlJRTlpYW1WamRDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLQ0ZmYVc1MFpYSm1ZV05sVzJaMWJtTmZibUZ0WlYwcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1gybHVkR1Z5Wm1GalpWdG1kVzVqWDI1aGJXVmRJRDBnS0M0dUxtRnlaM01wSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmZjbVZ0YjNSbFcyWjFibU5mYm1GdFpWMG9MaTR1WVhKbmN5azdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMDdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2hmYVc1MFpYSm1ZV05sTG1OdmJuTjBjblZqZEc5eUxtTnZibk4wY25WamRHOXlJRDA5UFNCR2RXNWpkR2x2YmlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tDRmZhVzUwWlhKbVlXTmxMbU52Ym5OMGNuVmpkRzl5TG5CeWIzUnZkSGx3WlZ0bWRXNWpYMjVoYldWZEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lGOXBiblJsY21aaFkyVXVZMjl1YzNSeWRXTjBiM0l1Y0hKdmRHOTBlWEJsVzJaMWJtTmZibUZ0WlYwZ1BTQW9MaTR1WVhKbmN5a2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUY5eVpXMXZkR1ZiWm5WdVkxOXVZVzFsWFNndUxpNWhjbWR6S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZlR0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJQ0FnZEdocGN5NWZiRzlqWVd4ZllYQnBJRDBnWDJsdWRHVnlabUZqWlR0Y2JpQWdJQ0IwYUdsekxsOW1hWEpsS0Z3aWFXNTBaWEptWVdObFFYWmhhV3hoWW14bFhDSXBPMXh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUZObGJtUnpJSFJvWlNCaFkzUjFZV3dnYVc1MFpYSm1ZV05sSUhSdklIUm9aU0J5WlcxdmRHVWdjMmwwWlNCMWNHOXVJR2wwSUhkaGMxeHVJQ0FnS2lCMWNHUmhkR1ZrSUc5eUlHSjVJR0VnYzNCbFkybGhiQ0J5WlhGMVpYTjBJRzltSUhSb1pTQnlaVzF2ZEdVZ2MybDBaVnh1SUNBZ0tpOWNiaUFnYzJWdVpFbHVkR1Z5Wm1GalpTZ3BJSHRjYmlBZ0lDQnBaaUFvSVhSb2FYTXVYMnh2WTJGc1gyRndhU2tnZTF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLRndpYVc1MFpYSm1ZV05sSUdseklHNXZkQ0J6WlhRdVhDSXBPMXh1SUNBZ0lIMWNiaUFnSUNCMGFHbHpMbDlzYjJOaGJGOWhjR2t1WDNKcFpDQTlJRndpWDNKc2IyTmhiRndpTzF4dUlDQWdJR052Ym5OMElHRndhU0E5SUhSb2FYTXVYMlZ1WTI5a1pTaDBhR2x6TGw5c2IyTmhiRjloY0drc0lIUnlkV1VwTzF4dUlDQWdJSFJvYVhNdVgyTnZibTVsWTNScGIyNHVaVzFwZENoN0lIUjVjR1U2SUZ3aWMyVjBTVzUwWlhKbVlXTmxYQ0lzSUdGd2FUb2dZWEJwSUgwcE8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRWhoYm1Sc1pYTWdZU0J0WlhOellXZGxJR1p5YjIwZ2RHaGxJSEpsYlc5MFpTQnphWFJsWEc0Z0lDQXFMMXh1SUNBdkx5QjJZWElnWTJGc2JHSmhZMnRmY21WbklEMGdibVYzSUZKbFowVjRjQ2hjSW05dWRYQmtZWFJsZkhKMWJpUmNJaWxjYmlBZ1gzTmxkSFZ3VFdWemMyRm5aVWhoYm14a1pYSnpLQ2tnZTF4dUlDQWdJSFJvYVhNdVgyTnZibTVsWTNScGIyNHViMjRvWENKcGJtbDBYQ0lzSUhSb2FYTXVhVzVwZENrN1hHNGdJQ0FnZEdocGN5NWZZMjl1Ym1WamRHbHZiaTV2YmloY0ltVjRaV04xZEdWY0lpd2daR0YwWVNBOVBpQjdYRzRnSUNBZ0lDQlFjbTl0YVhObExuSmxjMjlzZG1Vb2RHaHBjeTVmWTI5dWJtVmpkR2x2Ymk1bGVHVmpkWFJsS0dSaGRHRXVZMjlrWlNrcFhHNGdJQ0FnSUNBZ0lDNTBhR1Z1S0NncElEMCtJSHRjYmlBZ0lDQWdJQ0FnSUNCMGFHbHpMbDlqYjI1dVpXTjBhVzl1TG1WdGFYUW9leUIwZVhCbE9pQmNJbVY0WldOMWRHVmtYQ0lnZlNrN1hHNGdJQ0FnSUNBZ0lIMHBYRzRnSUNBZ0lDQWdJQzVqWVhSamFDaGxJRDArSUh0Y2JpQWdJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtVnljbTl5S0dVcE8xeHVJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyTnZibTVsWTNScGIyNHVaVzFwZENoN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwZVhCbE9pQmNJbVY0WldOMWRHVmtYQ0lzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmxjbkp2Y2pvZ1pWeHVJQ0FnSUNBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNCOUtUdGNibHh1SUNBZ0lIUm9hWE11WDJOdmJtNWxZM1JwYjI0dWIyNG9YQ0p0WlhSb2IyUmNJaXdnWkdGMFlTQTlQaUI3WEc0Z0lDQWdJQ0JzWlhRZ2NtVnpiMngyWlN3Z2NtVnFaV04wTENCdFpYUm9iMlFzSUdGeVozTXNJSEpsYzNWc2REdGNiaUFnSUNBZ0lHeGxkQ0JmYVc1MFpYSm1ZV05sSUQwZ2RHaHBjeTVmYVc1MFpYSm1ZV05sWDNOMGIzSmxXMlJoZEdFdWNHbGtYVHRjYmlBZ0lDQWdJR052Ym5OMElGOXRaWFJvYjJSZlkyOXVkR1Y0ZENBOUlGOXBiblJsY21aaFkyVXVYMTkwYUdselgxOGdmSHdnWDJsdWRHVnlabUZqWlR0Y2JpQWdJQ0FnSUdsbUlDZ2hYMmx1ZEdWeVptRmpaU2tnZTF4dUlDQWdJQ0FnSUNCcFppQW9aR0YwWVM1d2NtOXRhWE5sS1NCN1hHNGdJQ0FnSUNBZ0lDQWdXM0psYzI5c2RtVXNJSEpsYW1WamRGMGdQU0IwYUdsekxsOTFibmR5WVhBb1pHRjBZUzV3Y205dGFYTmxMQ0JtWVd4elpTazdYRzRnSUNBZ0lDQWdJQ0FnY21WcVpXTjBLRnh1SUNBZ0lDQWdJQ0FnSUNBZ1lIQnNkV2RwYmlCaGNHa2dablZ1WTNScGIyNGdhWE1nYm05MElHRjJZV2xoYkdKbElHbHVJRndpSkh0a1lYUmhMbkJwWkgxY0lpd2dkR2hsSUhCc2RXZHBiaUJ0WVhsaVpTQjBaWEp0YVc1aGRHVmtMbUJjYmlBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJR052Ym5OdmJHVXVaWEp5YjNJb1hHNGdJQ0FnSUNBZ0lDQWdJQ0JnY0d4MVoybHVJR0Z3YVNCbWRXNWpkR2x2YmlCcGN5QnViM1FnWVhaaGFXRnNZbVVnYVc0Z0pIdGtZWFJoTG5CcFpIMHNJSFJvWlNCd2JIVm5hVzRnYldGNVltVWdkR1Z5YldsdVlYUmxaQzVnWEc0Z0lDQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNDdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJRzFsZEdodlpDQTlJRjlwYm5SbGNtWmhZMlZiWkdGMFlTNXVZVzFsWFR0Y2JpQWdJQ0FnSUdGeVozTWdQU0IwYUdsekxsOTFibmR5WVhBb1pHRjBZUzVoY21kekxDQjBjblZsS1R0Y2JpQWdJQ0FnSUdsbUlDaGtZWFJoTG5CeWIyMXBjMlVwSUh0Y2JpQWdJQ0FnSUNBZ1czSmxjMjlzZG1Vc0lISmxhbVZqZEYwZ1BTQjBhR2x6TGw5MWJuZHlZWEFvWkdGMFlTNXdjbTl0YVhObExDQm1ZV3h6WlNrN1hHNGdJQ0FnSUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0FnSUNBZ2NtVnpkV3gwSUQwZ2JXVjBhRzlrTG1Gd2NHeDVLRjl0WlhSb2IyUmZZMjl1ZEdWNGRDd2dZWEpuY3lrN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdjbVZ6ZFd4MElHbHVjM1JoYm1ObGIyWWdVSEp2YldselpTQjhmRnh1SUNBZ0lDQWdJQ0FnSUNBZ0tHMWxkR2h2WkM1amIyNXpkSEoxWTNSdmNpQW1KaUJ0WlhSb2IyUXVZMjl1YzNSeWRXTjBiM0l1Ym1GdFpTQTlQVDBnWENKQmMzbHVZMFoxYm1OMGFXOXVYQ0lwWEc0Z0lDQWdJQ0FnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYTjFiSFF1ZEdobGJpaHlaWE52YkhabEtTNWpZWFJqYUNoeVpXcGxZM1FwTzF4dUlDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhOdmJIWmxLSEpsYzNWc2RDazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOUlHTmhkR05vSUNobEtTQjdYRzRnSUNBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVsY25KdmNpaDBhR2x6TG1OdmJtWnBaeTV1WVcxbExDQmxMQ0J0WlhSb2IyUXBPMXh1SUNBZ0lDQWdJQ0FnSUhKbGFtVmpkQ2hsS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnSUNCdFpYUm9iMlF1WVhCd2JIa29YMjFsZEdodlpGOWpiMjUwWlhoMExDQmhjbWR6S1R0Y2JpQWdJQ0FnSUNBZ2ZTQmpZWFJqYUNBb1pTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdOdmJuTnZiR1V1WlhKeWIzSW9kR2hwY3k1amIyNW1hV2N1Ym1GdFpTd2daU3dnYldWMGFHOWtMQ0JoY21kektUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHBPMXh1WEc0Z0lDQWdkR2hwY3k1ZlkyOXVibVZqZEdsdmJpNXZiaWhjSW1OaGJHeGlZV05yWENJc0lHUmhkR0VnUFQ0Z2UxeHVJQ0FnSUNBZ2JHVjBJSEpsYzI5c2RtVXNJSEpsYW1WamRDd2diV1YwYUc5a0xDQmhjbWR6TENCeVpYTjFiSFE3WEc0Z0lDQWdJQ0JwWmlBb1pHRjBZUzV3Y205dGFYTmxLU0I3WEc0Z0lDQWdJQ0FnSUZ0eVpYTnZiSFpsTENCeVpXcGxZM1JkSUQwZ2RHaHBjeTVmZFc1M2NtRndLR1JoZEdFdWNISnZiV2x6WlN3Z1ptRnNjMlVwTzF4dUlDQWdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0FnSUcxbGRHaHZaQ0E5SUhSb2FYTXVYM04wYjNKbExtWmxkR05vS0dSaGRHRXVYM0pwYm1SbGVDazdYRzRnSUNBZ0lDQWdJQ0FnWVhKbmN5QTlJSFJvYVhNdVgzVnVkM0poY0Noa1lYUmhMbUZ5WjNNc0lIUnlkV1VwTzF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2doYldWMGFHOWtLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUZ3aVEyRnNiR0poWTJzZ1puVnVZM1JwYjI0Z1kyRnVJRzl1YkhrZ1kyRnNiR1ZrSUc5dVkyVXNJR2xtSUhsdmRTQjNZVzUwSUhSdklHTmhiR3dnWVNCbWRXNWpkR2x2YmlCbWIzSWdiWFZzZEdsd2JHVWdkR2x0WlhNc0lIQnNaV0Z6WlNCdFlXdGxJR2wwSUdGeklHRWdjR3gxWjJsdUlHRndhU0JtZFc1amRHbHZiaTRnVTJWbElHaDBkSEJ6T2k4dmFXMXFiM2t1YVc4dlpHOWpjeUJtYjNJZ2JXOXlaU0JrWlhSaGFXeHpMbHdpWEc0Z0lDQWdJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQnlaWE4xYkhRZ1BTQnRaWFJvYjJRdVlYQndiSGtvYm5Wc2JDd2dZWEpuY3lrN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdjbVZ6ZFd4MElHbHVjM1JoYm1ObGIyWWdVSEp2YldselpTQjhmRnh1SUNBZ0lDQWdJQ0FnSUNBZ0tHMWxkR2h2WkM1amIyNXpkSEoxWTNSdmNpQW1KaUJ0WlhSb2IyUXVZMjl1YzNSeWRXTjBiM0l1Ym1GdFpTQTlQVDBnWENKQmMzbHVZMFoxYm1OMGFXOXVYQ0lwWEc0Z0lDQWdJQ0FnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYTjFiSFF1ZEdobGJpaHlaWE52YkhabEtTNWpZWFJqYUNoeVpXcGxZM1FwTzF4dUlDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhOdmJIWmxLSEpsYzNWc2RDazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOUlHTmhkR05vSUNobEtTQjdYRzRnSUNBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVsY25KdmNpaDBhR2x6TG1OdmJtWnBaeTV1WVcxbExDQmxMQ0J0WlhSb2IyUXBPMXh1SUNBZ0lDQWdJQ0FnSUhKbGFtVmpkQ2hsS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnSUNCdFpYUm9iMlFnUFNCMGFHbHpMbDl6ZEc5eVpTNW1aWFJqYUNoa1lYUmhMbDl5YVc1a1pYZ3BPMXh1SUNBZ0lDQWdJQ0FnSUdGeVozTWdQU0IwYUdsekxsOTFibmR5WVhBb1pHRjBZUzVoY21kekxDQjBjblZsS1R0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvSVcxbGRHaHZaQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCY0lsQnNaV0Z6WlNCdWIzUnBZMlVnZEdoaGRDQmpZV3hzWW1GamF5Qm1kVzVqZEdsdmJpQmpZVzRnYjI1c2VTQmpZV3hzWldRZ2IyNWpaU3dnYVdZZ2VXOTFJSGRoYm5RZ2RHOGdZMkZzYkNCaElHWjFibU4wYVc5dUlHWnZjaUJ0ZFd4MGFYQnNaU0IwYVcxbGN5d2djR3hsWVhObElHMWhhMlVnYVhRZ1lYTWdZU0J3YkhWbmFXNGdZWEJwSUdaMWJtTjBhVzl1TGlCVFpXVWdhSFIwY0hNNkx5OXBiV3B2ZVM1cGJ5OWtiMk56SUdadmNpQnRiM0psSUdSbGRHRnBiSE11WENKY2JpQWdJQ0FnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJRzFsZEdodlpDNWhjSEJzZVNodWRXeHNMQ0JoY21kektUdGNiaUFnSUNBZ0lDQWdmU0JqWVhSamFDQW9aU2tnZTF4dUlDQWdJQ0FnSUNBZ0lHTnZibk52YkdVdVpYSnliM0lvZEdocGN5NWpiMjVtYVdjdWJtRnRaU3dnWlN3Z2JXVjBhRzlrTENCaGNtZHpLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBwTzF4dUlDQWdJSFJvYVhNdVgyTnZibTVsWTNScGIyNHViMjRvWENKelpYUkpiblJsY21aaFkyVmNJaXdnWkdGMFlTQTlQaUI3WEc0Z0lDQWdJQ0IwYUdsekxsOXpaWFJTWlcxdmRHVkpiblJsY21aaFkyVW9aR0YwWVM1aGNHa3BPMXh1SUNBZ0lIMHBPMXh1SUNBZ0lIUm9hWE11WDJOdmJtNWxZM1JwYjI0dWIyNG9YQ0puWlhSSmJuUmxjbVpoWTJWY0lpd2dLQ2tnUFQ0Z2UxeHVJQ0FnSUNBZ2RHaHBjeTVmWm1seVpTaGNJbWRsZEVsdWRHVnlabUZqWlZ3aUtUdGNiaUFnSUNBZ0lHbG1JQ2gwYUdsekxsOXNiMk5oYkY5aGNHa3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXpaVzVrU1c1MFpYSm1ZV05sS0NrN1hHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbTl1WTJVb1hDSnBiblJsY21aaFkyVkJkbUZwYkdGaWJHVmNJaXdnS0NrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUhSb2FYTXVjMlZ1WkVsdWRHVnlabUZqWlNncE8xeHVJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlLVHRjYmlBZ0lDQjBhR2x6TGw5amIyNXVaV04wYVc5dUxtOXVLRndpYVc1MFpYSm1ZV05sVTJWMFFYTlNaVzF2ZEdWY0lpd2dLQ2tnUFQ0Z2UxeHVJQ0FnSUNBZ2RHaHBjeTVmWm1seVpTaGNJbWx1ZEdWeVptRmpaVk5sZEVGelVtVnRiM1JsWENJcE8xeHVJQ0FnSUgwcE8xeHVJQ0FnSUhSb2FYTXVYMk52Ym01bFkzUnBiMjR1YjI0b1hDSmthWE5qYjI1dVpXTjBYQ0lzSUNncElEMCtJSHRjYmlBZ0lDQWdJSFJvYVhNdVgyWnBjbVVvWENKaVpXWnZjbVZFYVhOamIyNXVaV04wWENJcE8xeHVJQ0FnSUNBZ2RHaHBjeTVmWTI5dWJtVmpkR2x2Ymk1a2FYTmpiMjV1WldOMEtDazdYRzRnSUNBZ0lDQjBhR2x6TGw5bWFYSmxLRndpWkdselkyOXVibVZqZEdWa1hDSXBPMXh1SUNBZ0lIMHBPMXh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUZObGJtUnpJR0VnY21WeGRXVnpkSE1nZEc4Z2RHaGxJSEpsYlc5MFpTQnphWFJsSUdGemEybHVaeUJwZENCMGJ5QndjbTkyYVdSbElHbDBjMXh1SUNBZ0tpQmpkWEp5Wlc1MElHbHVkR1Z5Wm1GalpWeHVJQ0FnS2k5Y2JpQWdjbVZ4ZFdWemRGSmxiVzkwWlNncElIdGNiaUFnSUNCMGFHbHpMbDlqYjI1dVpXTjBhVzl1TG1WdGFYUW9leUIwZVhCbE9pQmNJbWRsZEVsdWRHVnlabUZqWlZ3aUlIMHBPMXh1SUNCOVhHNWNiaUFnWDI1a1lYSnlZWGtvZEhsd1pXUkJjbkpoZVN3Z2MyaGhjR1VzSUdSMGVYQmxLU0I3WEc0Z0lDQWdkbUZ5SUY5a2RIbHdaU0E5SUhSNWNHVmtRWEp5WVhsVWIwUjBlWEJsVzNSNWNHVmtRWEp5WVhrdVkyOXVjM1J5ZFdOMGIzSXVibUZ0WlYwN1hHNGdJQ0FnYVdZZ0tHUjBlWEJsSUNZbUlHUjBlWEJsSUNFOVBTQmZaSFI1Y0dVcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUZ3aVpIUjVjR1VnWkc5bGMyNG5kQ0J0WVhSamFDQjBhR1VnZEhsd1pTQnZaaUIwYUdVZ1lYSnlZWGs2SUZ3aUlDdGNiaUFnSUNBZ0lDQWdYMlIwZVhCbElDdGNiaUFnSUNBZ0lDQWdYQ0lnSVQwZ1hDSWdLMXh1SUNBZ0lDQWdJQ0JrZEhsd1pUdGNiaUFnSUNCOVhHNGdJQ0FnYzJoaGNHVWdQU0J6YUdGd1pTQjhmQ0JiZEhsd1pXUkJjbkpoZVM1c1pXNW5kR2hkTzF4dUlDQWdJSEpsZEhWeWJpQjdYRzRnSUNBZ0lDQmZjblI1Y0dVNklGd2libVJoY25KaGVWd2lMRnh1SUNBZ0lDQWdYM0oyWVd4MVpUb2dkSGx3WldSQmNuSmhlU3hjYmlBZ0lDQWdJRjl5YzJoaGNHVTZJSE5vWVhCbExGeHVJQ0FnSUNBZ1gzSmtkSGx3WlRvZ1gyUjBlWEJsWEc0Z0lDQWdmVHRjYmlBZ2ZWeHVYRzRnSUM4cUtseHVJQ0FnS2lCVFpYUnpJSFJvWlNCdVpYY2djbVZ0YjNSbElHbHVkR1Z5Wm1GalpTQndjbTkyYVdSbFpDQmllU0IwYUdVZ2IzUm9aWElnYzJsMFpWeHVJQ0FnS2x4dUlDQWdLaUJBY0dGeVlXMGdlMEZ5Y21GNWZTQnVZVzFsY3lCc2FYTjBJRzltSUdaMWJtTjBhVzl1SUc1aGJXVnpYRzRnSUNBcUwxeHVJQ0JmYzJWMFVtVnRiM1JsU1c1MFpYSm1ZV05sS0dGd2FTa2dlMXh1SUNBZ0lIUm9hWE11WDJsdWRHVnlabUZqWlY5emRHOXlaVnRjSWw5eWNtVnRiM1JsWENKZElEMGdkR2hwY3k1ZlpHVmpiMlJsS0dGd2FTazdYRzRnSUNBZ2RHaHBjeTVmWm1seVpTaGNJbkpsYlc5MFpWSmxZV1I1WENJcE8xeHVJQ0FnSUhSb2FYTXVYM0psY0c5eWRGSmxiVzkwWlZObGRDZ3BPMXh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUVkbGJtVnlZWFJsY3lCMGFHVWdkM0poY0hCbFpDQm1kVzVqZEdsdmJpQmpiM0p5WlhOd2IyNWthVzVuSUhSdklHRWdjMmx1WjJ4bElISmxiVzkwWlZ4dUlDQWdLaUJ0WlhSb2IyUXVJRmRvWlc0Z2RHaGxJR2RsYm1WeVlYUmxaQ0JtZFc1amRHbHZiaUJwY3lCallXeHNaV1FzSUdsMElIZHBiR3dnYzJWdVpDQjBhR1ZjYmlBZ0lDb2dZMjl5Y21WemNHOXVaR2x1WnlCdFpYTnpZV2RsSUhSdklIUm9aU0J5WlcxdmRHVWdjMmwwWlNCaGMydHBibWNnYVhRZ2RHOGdaWGhsWTNWMFpWeHVJQ0FnS2lCMGFHVWdjR0Z5ZEdsamRXeGhjaUJ0WlhSb2IyUWdiMllnYVhSeklHbHVkR1Z5Wm1GalpWeHVJQ0FnS2x4dUlDQWdLaUJBY0dGeVlXMGdlMU4wY21sdVozMGdibUZ0WlNCdlppQjBhR1VnY21WdGIzUmxJRzFsZEdodlpGeHVJQ0FnS2x4dUlDQWdLaUJBY21WMGRYSnVjeUI3Um5WdVkzUnBiMjU5SUhkeVlYQndaV1FnY21WdGIzUmxJRzFsZEdodlpGeHVJQ0FnS2k5Y2JpQWdYMmRsYmxKbGJXOTBaVTFsZEdodlpDaHVZVzFsTENCcGJuUmxjbVpoWTJWZmFXUXBJSHRjYmlBZ0lDQjJZWElnYldVZ1BTQjBhR2x6TzF4dUlDQWdJSFpoY2lCeVpXMXZkR1ZOWlhSb2IyUWdQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ1WlhjZ1VISnZiV2x6WlNnb2NtVnpiMngyWlN3Z2NtVnFaV04wS1NBOVBpQjdYRzRnSUNBZ0lDQWdJR3hsZENCcFpDQTlJRzUxYkd3N1hHNGdJQ0FnSUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FXUWdQU0J0WlM1ZmJXVjBhRzlrWDNKbFpuTXVjSFYwS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdhVzUwWlhKbVlXTmxYMmxrSUQ4Z2FXNTBaWEptWVdObFgybGtJQ3NnWENJdlhDSWdLeUJ1WVcxbElEb2dibUZ0WlZ4dUlDQWdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlIZHlZWEJ3WldSZmNtVnpiMngyWlNBOUlHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR2xrSUNFOVBTQnVkV3hzS1NCdFpTNWZiV1YwYUc5a1gzSmxabk11Wm1WMFkyZ29hV1FwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlISmxjMjlzZG1VdVlYQndiSGtvZEdocGN5d2dZWEpuZFcxbGJuUnpLVHRjYmlBZ0lDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ0lDQWdJSFpoY2lCM2NtRndjR1ZrWDNKbGFtVmpkQ0E5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHbGtJQ0U5UFNCdWRXeHNLU0J0WlM1ZmJXVjBhRzlrWDNKbFpuTXVabVYwWTJnb2FXUXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUhKbGFtVmpkQzVoY0hCc2VTaDBhR2x6TENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0FnSUNBZ0lDQWdJSDA3WEc1Y2JpQWdJQ0FnSUNBZ0lDQjNjbUZ3Y0dWa1gzSmxjMjlzZG1VdVgxOXFZV2xzWldSZmNHRnBjbk5mWHlBOUlIZHlZWEJ3WldSZmNtVnFaV04wTzF4dUlDQWdJQ0FnSUNBZ0lIZHlZWEJ3WldSZmNtVnFaV04wTGw5ZmFtRnBiR1ZrWDNCaGFYSnpYMThnUFNCM2NtRndjR1ZrWDNKbGMyOXNkbVU3WEc1Y2JpQWdJQ0FnSUNBZ0lDQjJZWElnWVhKbmN5QTlJRUZ5Y21GNUxuQnliM1J2ZEhsd1pTNXpiR2xqWlM1allXeHNLR0Z5WjNWdFpXNTBjeWs3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLRzVoYldVZ1BUMDlJRndpY21WbmFYTjBaWEpjSWlCOGZDQnVZVzFsSUQwOVBTQmNJbVY0Y0c5eWRGd2lJSHg4SUc1aGJXVWdQVDA5SUZ3aWIyNWNJaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZWEpuY3lBOUlHMWxMbDkzY21Gd0tHRnlaM01zSUhSeWRXVXBPMXh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmhjbWR6SUQwZ2JXVXVYM2R5WVhBb1lYSm5jeWs3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSFpoY2lCMGNtRnVjMlpsY21GaWJHVnpJRDBnWVhKbmN5NWhjbWR6TGw5ZmRISmhibk5tWlhKaFlteGxjMTlmTzF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2gwY21GdWMyWmxjbUZpYkdWektTQmtaV3hsZEdVZ1lYSm5jeTVoY21kekxsOWZkSEpoYm5ObVpYSmhZbXhsYzE5Zk8xeHVJQ0FnSUNBZ0lDQWdJRzFsTGw5amIyNXVaV04wYVc5dUxtVnRhWFFvWEc0Z0lDQWdJQ0FnSUNBZ0lDQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIUjVjR1U2SUZ3aWJXVjBhRzlrWENJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUc1aGJXVTZJRzVoYldVc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhCcFpEb2dhVzUwWlhKbVlXTmxYMmxrTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JoY21kek9pQmhjbWR6TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J3Y205dGFYTmxPaUJ0WlM1ZmQzSmhjQ2hiZDNKaGNIQmxaRjl5WlhOdmJIWmxMQ0IzY21Gd2NHVmtYM0psYW1WamRGMHBYRzRnSUNBZ0lDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnZEhKaGJuTm1aWEpoWW14bGMxeHVJQ0FnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0FnSUgwZ1kyRjBZMmdnS0dVcElIdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2FXUXBJRzFsTGw5dFpYUm9iMlJmY21WbWN5NW1aWFJqYUNocFpDazdYRzRnSUNBZ0lDQWdJQ0FnY21WcVpXTjBLRnh1SUNBZ0lDQWdJQ0FnSUNBZ1lFWmhhV3hsWkNCMGJ5QmxlR1ZqZEhWbElISmxiVzkwWlNCdFpYUm9iMlFnS0dsdWRHVnlabUZqWlRvZ0pIdHBiblJsY21aaFkyVmZhV1FnZkh4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnYldVdWFXUjlMQ0J0WlhSb2IyUTZJQ1I3Ym1GdFpYMHBMQ0JsY25KdmNqb2dKSHRsZldCY2JpQWdJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5S1R0Y2JpQWdJQ0I5TzF4dUlDQWdJSEpsYlc5MFpVMWxkR2h2WkM1ZlgzSmxiVzkwWlY5dFpYUm9iMlFnUFNCMGNuVmxPMXh1SUNBZ0lISmxkSFZ5YmlCeVpXMXZkR1ZOWlhSb2IyUTdYRzRnSUgxY2JseHVJQ0F2S2lwY2JpQWdJQ29nVTJWdVpITWdZU0J5WlhOd2IyNWpaU0J5WlhCdmNuUnBibWNnZEdoaGRDQnBiblJsY21aaFkyVWdhblZ6ZENCd2NtOTJhV1JsWkNCaWVTQjBhR1ZjYmlBZ0lDb2djbVZ0YjNSbElITnBkR1VnZDJGeklITjFZMk5sYzNObWRXeHNlU0J6WlhRZ1lua2dkR2hwY3lCemFYUmxJR0Z6SUhKbGJXOTBaVnh1SUNBZ0tpOWNiaUFnWDNKbGNHOXlkRkpsYlc5MFpWTmxkQ2dwSUh0Y2JpQWdJQ0IwYUdsekxsOWpiMjV1WldOMGFXOXVMbVZ0YVhRb2V5QjBlWEJsT2lCY0ltbHVkR1Z5Wm1GalpWTmxkRUZ6VW1WdGIzUmxYQ0lnZlNrN1hHNGdJSDFjYmx4dUlDQXZLaXBjYmlBZ0lDb2dVSEpsY0dGeVpYTWdkR2hsSUhCeWIzWnBaR1ZrSUhObGRDQnZaaUJ5WlcxdmRHVWdiV1YwYUc5a0lHRnlaM1Z0Wlc1MGN5Qm1iM0pjYmlBZ0lDb2djMlZ1WkdsdVp5QjBieUIwYUdVZ2NtVnRiM1JsSUhOcGRHVXNJSEpsY0d4aFkyVnpJR0ZzYkNCMGFHVWdZMkZzYkdKaFkydHpJSGRwZEdoY2JpQWdJQ29nYVdSbGJuUnBabWxsY25OY2JpQWdJQ3BjYmlBZ0lDb2dRSEJoY21GdElIdEJjbkpoZVgwZ1lYSm5jeUIwYnlCM2NtRndYRzRnSUNBcVhHNGdJQ0FxSUVCeVpYUjFjbTV6SUh0QmNuSmhlWDBnZDNKaGNIQmxaQ0JoY21kMWJXVnVkSE5jYmlBZ0lDb3ZYRzVjYmlBZ1gyVnVZMjlrWlVsdWRHVnlabUZqWlNoaFQySnFaV04wS1NCN1hHNGdJQ0FnYkdWMElIWXNJR3NzSUd0bGVYTTdYRzRnSUNBZ1kyOXVjM1FnWlc1amIyUmxaRjlwYm5SbGNtWmhZMlVnUFNCN2ZUdGNiaUFnSUNCaFQySnFaV04wVzF3aVgzSnBaRndpWFNBOUlHRlBZbXBsWTNSYlhDSmZjbWxrWENKZElIeDhJSEpoYm1SSlpDZ3BPMXh1SUNBZ0lDOHZJR0Z1SUc5aWFtVmpkQzloY25KaGVWeHVJQ0FnSUdsbUlDaGhUMkpxWldOMExtTnZibk4wY25WamRHOXlJRDA5UFNCUFltcGxZM1FnZkh3Z1FYSnlZWGt1YVhOQmNuSmhlU2hoVDJKcVpXTjBLU2tnZTF4dUlDQWdJQ0FnYTJWNWN5QTlJRTlpYW1WamRDNXJaWGx6S0dGUFltcGxZM1FwTzF4dUlDQWdJSDFjYmlBZ0lDQXZMeUJoSUdOc1lYTnpYRzRnSUNBZ1pXeHpaU0JwWmlBb1lVOWlhbVZqZEM1amIyNXpkSEoxWTNSdmNpQTlQVDBnUm5WdVkzUnBiMjRwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhjSWxCc1pXRnpaU0JwYm5OMFlXNTBhV0YwWlNCMGFHVWdZMnhoYzNNZ1ltVm1iM0psSUdWNGNHOXlkSFJwYm1jZ2FYUXVYQ0lwTzF4dUlDQWdJSDFjYmlBZ0lDQXZMeUJwYm5OMFlXNWpaU0J2WmlCaElHTnNZWE56WEc0Z0lDQWdaV3h6WlNCcFppQW9ZVTlpYW1WamRDNWpiMjV6ZEhKMVkzUnZjaTVqYjI1emRISjFZM1J2Y2lBOVBUMGdSblZ1WTNScGIyNHBJSHRjYmlBZ0lDQWdJR3RsZVhNZ1BTQlBZbXBsWTNRdVoyVjBUM2R1VUhKdmNHVnlkSGxPWVcxbGN5aFBZbXBsWTNRdVoyVjBVSEp2ZEc5MGVYQmxUMllvWVU5aWFtVmpkQ2twTG1OdmJtTmhkQ2hjYmlBZ0lDQWdJQ0FnVDJKcVpXTjBMbXRsZVhNb1lVOWlhbVZqZENsY2JpQWdJQ0FnSUNrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSFJvY205M0lFVnljbTl5S0Z3aVZXNXpkWEJ3YjNKMFpXUWdhVzUwWlhKbVlXTmxJSFI1Y0dWY0lpazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1kyOXVjM1FnWWs5aWFtVmpkQ0E5SUVGeWNtRjVMbWx6UVhKeVlYa29ZVTlpYW1WamRDa2dQeUJiWFNBNklIdDlPMXh1WEc0Z0lDQWdabTl5SUNocklHOW1JR3RsZVhNcElIdGNiaUFnSUNBZ0lHbG1JQ2hiWENKb1lYTlBkMjVRY205d1pYSjBlVndpTENCY0ltTnZibk4wY25WamRHOXlYQ0pkTG1sdVkyeDFaR1Z6S0dzcEtTQmpiMjUwYVc1MVpUdGNibHh1SUNBZ0lDQWdhV1lnS0dzdWMzUmhjblJ6VjJsMGFDaGNJbDljSWlrcElIdGNiaUFnSUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQjJJRDBnWVU5aWFtVmpkRnRyWFR0Y2JseHVJQ0FnSUNBZ2FXWWdLSFI1Y0dWdlppQjJJRDA5UFNCY0ltWjFibU4wYVc5dVhDSXBJSHRjYmlBZ0lDQWdJQ0FnWWs5aWFtVmpkRnRyWFNBOUlIdGNiaUFnSUNBZ0lDQWdJQ0JmY25SNWNHVTZJRndpYVc1MFpYSm1ZV05sWENJc1hHNGdJQ0FnSUNBZ0lDQWdYM0pwWkRvZ1lVOWlhbVZqZEZ0Y0lsOXlhV1JjSWwwc1hHNGdJQ0FnSUNBZ0lDQWdYM0oyWVd4MVpUb2dhMXh1SUNBZ0lDQWdJQ0I5TzF4dUlDQWdJQ0FnSUNCbGJtTnZaR1ZrWDJsdWRHVnlabUZqWlZ0clhTQTlJSFk3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0U5aWFtVmpkQ2gyS1NBaFBUMGdkaWtnZTF4dUlDQWdJQ0FnSUNCaVQySnFaV04wVzJ0ZElEMGdleUJmY25SNWNHVTZJRndpWVhKbmRXMWxiblJjSWl3Z1gzSjJZV3gxWlRvZ2RpQjlPMXh1SUNBZ0lDQWdJQ0JsYm1OdlpHVmtYMmx1ZEdWeVptRmpaVnRyWFNBOUlIWTdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFI1Y0dWdlppQjJJRDA5UFNCY0ltOWlhbVZqZEZ3aUtTQjdYRzRnSUNBZ0lDQWdJR0pQWW1wbFkzUmJhMTBnUFNCMGFHbHpMbDlsYm1OdlpHVkpiblJsY21aaFkyVW9kaWs3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNBZ0lIUm9hWE11WDJsdWRHVnlabUZqWlY5emRHOXlaVnRoVDJKcVpXTjBXMXdpWDNKcFpGd2lYVjBnUFNCbGJtTnZaR1ZrWDJsdWRHVnlabUZqWlR0Y2JseHVJQ0FnSUM4dklISmxiVzkyWlNCcGJuUmxjbVpoWTJVZ2QyaGxiaUJqYkc5elpXUmNiaUFnSUNCcFppQW9ZVTlpYW1WamRDNXZiaUFtSmlCMGVYQmxiMllnWVU5aWFtVmpkQzV2YmlBOVBUMGdYQ0ptZFc1amRHbHZibHdpS1NCN1hHNGdJQ0FnSUNCaFQySnFaV04wTG05dUtGd2lZMnh2YzJWY0lpd2dLQ2tnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQmtaV3hsZEdVZ2RHaHBjeTVmYVc1MFpYSm1ZV05sWDNOMGIzSmxXMkZQWW1wbFkzUmJYQ0pmY21sa1hDSmRYVHRjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY200Z1lrOWlhbVZqZER0Y2JpQWdmVnh1WEc0Z0lGOWxibU52WkdVb1lVOWlhbVZqZEN3Z1lYTmZhVzUwWlhKbVlXTmxLU0I3WEc0Z0lDQWdZMjl1YzNRZ2RISmhibk5tWlhKaFlteGxjeUE5SUZ0ZE8xeHVJQ0FnSUdsbUlDZ2hZVTlpYW1WamRDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHRlBZbXBsWTNRN1hHNGdJQ0FnZlZ4dUlDQWdJR052Ym5OMElGOTBjbUZ1YzJabGNpQTlJR0ZQWW1wbFkzUXVYM1J5WVc1elptVnlPMXh1SUNBZ0lHeGxkQ0JpVDJKcVpXTjBMQ0IyTENCck8xeHVJQ0FnSUdOdmJuTjBJR2x6WVhKeVlYa2dQU0JCY25KaGVTNXBjMEZ5Y21GNUtHRlBZbXBsWTNRcE8xeHVJQ0FnSUM4dmMydHBjQ0JwWmlCaGJISmxZV1I1SUdWdVkyOWtaV1JjYmlBZ0lDQnBaaUFvZEhsd1pXOW1JR0ZQWW1wbFkzUWdQVDA5SUZ3aWIySnFaV04wWENJZ0ppWWdZVTlpYW1WamRDNWZjblI1Y0dVZ0ppWWdZVTlpYW1WamRDNWZjblpoYkhWbEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1lVOWlhbVZqZER0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2TDJWdVkyOWtaU0JwYm5SbGNtWmhZMlZ6WEc0Z0lDQWdhV1lnS0Z4dUlDQWdJQ0FnZEhsd1pXOW1JR0ZQWW1wbFkzUWdQVDA5SUZ3aWIySnFaV04wWENJZ0ppWmNiaUFnSUNBZ0lDRkJjbkpoZVM1cGMwRnljbUY1S0dGUFltcGxZM1FwSUNZbVhHNGdJQ0FnSUNBb1lVOWlhbVZqZEM1ZmNtbHVkR1lnZkh3Z1lYTmZhVzUwWlhKbVlXTmxLVnh1SUNBZ0lDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11WDJWdVkyOWtaVWx1ZEdWeVptRmpaU2hoVDJKcVpXTjBLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvWVhOZmFXNTBaWEptWVdObEtTQjdYRzRnSUNBZ0lDQmhUMkpxWldOMFcxd2lYM0pwWkZ3aVhTQTlJR0ZQWW1wbFkzUmJYQ0pmY21sa1hDSmRJSHg4SUhKaGJtUkpaQ2dwTzF4dUlDQWdJQ0FnZEdocGN5NWZhVzUwWlhKbVlXTmxYM04wYjNKbFcyRlBZbXBsWTNSYlhDSmZjbWxrWENKZFhTQTlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgybHVkR1Z5Wm1GalpWOXpkRzl5WlZ0aFQySnFaV04wVzF3aVgzSnBaRndpWFYwZ2ZId2dLR2x6WVhKeVlYa2dQeUJiWFNBNklIdDlLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmlUMkpxWldOMElEMGdhWE5oY25KaGVTQS9JRnRkSURvZ2UzMDdYRzRnSUNBZ1ptOXlJQ2hySUdsdUlHRlBZbXBsWTNRcElIdGNiaUFnSUNBZ0lHbG1JQ2hiWENKb1lYTlBkMjVRY205d1pYSjBlVndpTENCY0ltTnZibk4wY25WamRHOXlYQ0pkTG1sdVkyeDFaR1Z6S0dzcEtTQmpiMjUwYVc1MVpUdGNiaUFnSUNBZ0lHbG1JQ2hwYzJGeWNtRjVJSHg4SUdGUFltcGxZM1F1YUdGelQzZHVVSEp2Y0dWeWRIa29heWtwSUh0Y2JpQWdJQ0FnSUNBZ2RpQTlJR0ZQWW1wbFkzUmJhMTA3WEc0Z0lDQWdJQ0FnSUdsbUlDaDJJQ1ltSUhSNWNHVnZaaUIwYUdsekxsOXNiMk5oYkY5aGNHa3VYM0p3WTE5bGJtTnZaR1VnUFQwOUlGd2lablZ1WTNScGIyNWNJaWtnZTF4dUlDQWdJQ0FnSUNBZ0lHTnZibk4wSUdWdVkyOWtaV1JmYjJKcUlEMGdkR2hwY3k1ZmJHOWpZV3hmWVhCcExsOXljR05mWlc1amIyUmxLSFlwTzF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2hsYm1OdlpHVmtYMjlpYWlBbUppQmxibU52WkdWa1gyOWlhaTVmWTNSNWNHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHSlBZbXBsWTNSYmExMGdQU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRjl5ZEhsd1pUb2dYQ0pqZFhOMGIyMWNJaXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdYM0oyWVd4MVpUb2daVzVqYjJSbFpGOXZZbW9zWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRjl5YVdRNklHRlBZbXBsWTNSYlhDSmZjbWxrWENKZFhHNGdJQ0FnSUNBZ0lDQWdJQ0I5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDOHZJR2xtSUhSb1pTQnlaWFIxY201bFpDQnZZbXBsWTNRZ1pHOWxjeUJ1YjNRZ1kyOXVkR0ZwYmlCZmNuUjVjR1VzSUdGemMzVnRhVzVuSUhSb1pTQnZZbXBsWTNRZ2FHRnpJR0psWlc0Z2RISmhibk5tYjNKdFpXUmNiaUFnSUNBZ0lDQWdJQ0JsYkhObElHbG1JQ2hsYm1OdlpHVmtYMjlpYWlBaFBUMGdkVzVrWldacGJtVmtLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjJJRDBnWlc1amIyUmxaRjl2WW1vN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ2RpQTlQVDBnWENKbWRXNWpkR2x2Ymx3aUtTQjdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHRnpYMmx1ZEdWeVptRmpaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ1pXNWpiMlJsWkY5cGJuUmxjbVpoWTJVZ1BTQjBhR2x6TGw5cGJuUmxjbVpoWTJWZmMzUnZjbVZiWVU5aWFtVmpkRnRjSWw5eWFXUmNJbDFkTzF4dUlDQWdJQ0FnSUNBZ0lDQWdZazlpYW1WamRGdHJYU0E5SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWDNKMGVYQmxPaUJjSW1sdWRHVnlabUZqWlZ3aUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCZmNtbGtPaUJoVDJKcVpXTjBXMXdpWDNKcFpGd2lYU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdYM0oyWVd4MVpUb2dhMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdWdVkyOWtaV1JmYVc1MFpYSm1ZV05sVzJ0ZElEMGdkanRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZiblJwYm5WbE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCc1pYUWdhVzUwWlhKbVlXTmxSblZ1WTA1aGJXVWdQU0J1ZFd4c08xeHVJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJRzVoYldVZ2FXNGdkR2hwY3k1ZmJHOWpZV3hmWVhCcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR2hwY3k1ZmJHOWpZV3hmWVhCcExtaGhjMDkzYmxCeWIzQmxjblI1S0c1aGJXVXBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNodVlXMWxMbk4wWVhKMGMxZHBkR2dvWENKZlhDSXBLU0JqYjI1MGFXNTFaVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdhV1lnS0hSb2FYTXVYMnh2WTJGc1gyRndhVnR1WVcxbFhTQTlQVDBnZGlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVkR1Z5Wm1GalpVWjFibU5PWVcxbElEMGdibUZ0WlR0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaWNtVmhhenRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBdkx5QnpaV0Z5WTJnZ1ptOXlJSEJ5YjNSdmRIbHdaWE5jYmlBZ0lDQWdJQ0FnSUNCMllYSWdablZ1WTNScGIyNXpJRDBnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVRtRnRaWE1vWEc0Z0lDQWdJQ0FnSUNBZ0lDQlBZbXBsWTNRdVoyVjBVSEp2ZEc5MGVYQmxUMllvZEdocGN5NWZiRzlqWVd4ZllYQnBLVnh1SUNBZ0lDQWdJQ0FnSUNrN1hHNGdJQ0FnSUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JtZFc1amRHbHZibk11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhaaGNpQnVZVzFsWHlBOUlHWjFibU4wYVc5dWMxdHBYVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2h1WVcxbFh5NXpkR0Z5ZEhOWGFYUm9LRndpWDF3aUtTa2dZMjl1ZEdsdWRXVTdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR2hwY3k1ZmJHOWpZV3hmWVhCcFcyNWhiV1ZmWFNBOVBUMGdkaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JwYm5SbGNtWmhZMlZHZFc1alRtRnRaU0E5SUc1aGJXVmZPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQmljbVZoYXp0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0NGcGJuUmxjbVpoWTJWR2RXNWpUbUZ0WlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZG1GeUlHbGtJRDBnZEdocGN5NWZjM1J2Y21VdWNIVjBLSFlwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdZazlpYW1WamRGdHJYU0E5SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWDNKMGVYQmxPaUJjSW1OaGJHeGlZV05yWENJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUY5eWRtRnNkV1U2SUNoMkxtTnZibk4wY25WamRHOXlJQ1ltSUhZdVkyOXVjM1J5ZFdOMGIzSXVibUZ0WlNrZ2ZId2dhV1FzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRjl5YVc1a1pYZzZJR2xrWEc0Z0lDQWdJQ0FnSUNBZ0lDQjlPMXh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmlUMkpxWldOMFcydGRJRDBnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JmY25SNWNHVTZJRndpYVc1MFpYSm1ZV05sWENJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUY5eWRtRnNkV1U2SUdsdWRHVnlabUZqWlVaMWJtTk9ZVzFsTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JmY21sa09pQmNJbDl5Ykc5allXeGNJbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1hHNGdJQ0FnSUNBZ0lDQWdMeXBuYkc5aVlXd2dkR1lxTDF4dUlDQWdJQ0FnSUNBZ0lIUjVjR1Z2WmlCMFppQWhQVDBnWENKMWJtUmxabWx1WldSY0lpQW1KbHh1SUNBZ0lDQWdJQ0FnSUhSbUxsUmxibk52Y2lBbUpseHVJQ0FnSUNBZ0lDQWdJSFlnYVc1emRHRnVZMlZ2WmlCMFppNVVaVzV6YjNKY2JpQWdJQ0FnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdkbDlpZFdabVpYSWdQU0IyTG1SaGRHRlRlVzVqS0NrN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0hZdVgzUnlZVzV6Wm1WeUlIeDhJRjkwY21GdWMyWmxjaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkSEpoYm5ObVpYSmhZbXhsY3k1d2RYTm9LSFpmWW5WbVptVnlMbUoxWm1abGNpazdYRzRnSUNBZ0lDQWdJQ0FnSUNCa1pXeGxkR1VnZGk1ZmRISmhibk5tWlhJN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUdKUFltcGxZM1JiYTEwZ1BTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCZmNuUjVjR1U2SUZ3aWJtUmhjbkpoZVZ3aUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnWDNKMllXeDFaVG9nZGw5aWRXWm1aWElzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmZjbk5vWVhCbE9pQjJMbk5vWVhCbExGeHVJQ0FnSUNBZ0lDQWdJQ0FnWDNKa2RIbHdaVG9nZGk1a2RIbHdaVnh1SUNBZ0lDQWdJQ0FnSUgwN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9YRzRnSUNBZ0lDQWdJQ0FnTHlwbmJHOWlZV3dnYm1vcUwxeHVJQ0FnSUNBZ0lDQWdJSFI1Y0dWdlppQnVhaUFoUFQwZ1hDSjFibVJsWm1sdVpXUmNJaUFtSmx4dUlDQWdJQ0FnSUNBZ0lHNXFMazVrUVhKeVlYa2dKaVpjYmlBZ0lDQWdJQ0FnSUNCMklHbHVjM1JoYm1ObGIyWWdibW91VG1SQmNuSmhlVnh1SUNBZ0lDQWdJQ0FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQjJZWElnWkhSNWNHVWdQU0IwZVhCbFpFRnljbUY1Vkc5RWRIbHdaVnQyTG5ObGJHVmpkR2x2Ymk1a1lYUmhMbU52Ym5OMGNuVmpkRzl5TG01aGJXVmRPMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaDJMbDkwY21GdWMyWmxjaUI4ZkNCZmRISmhibk5tWlhJcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSeVlXNXpabVZ5WVdKc1pYTXVjSFZ6YUNoMkxuTmxiR1ZqZEdsdmJpNWtZWFJoTG1KMVptWmxjaWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmtaV3hsZEdVZ2RpNWZkSEpoYm5ObVpYSTdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lHSlBZbXBsWTNSYmExMGdQU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmZjblI1Y0dVNklGd2libVJoY25KaGVWd2lMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1gzSjJZV3gxWlRvZ2RpNXpaV3hsWTNScGIyNHVaR0YwWVN4Y2JpQWdJQ0FnSUNBZ0lDQWdJRjl5YzJoaGNHVTZJSFl1YzJoaGNHVXNYRzRnSUNBZ0lDQWdJQ0FnSUNCZmNtUjBlWEJsT2lCa2RIbHdaVnh1SUNBZ0lDQWdJQ0FnSUgwN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9kaUJwYm5OMFlXNWpaVzltSUVWeWNtOXlLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1kyOXVjMjlzWlM1bGNuSnZjaWgyS1R0Y2JpQWdJQ0FnSUNBZ0lDQmlUMkpxWldOMFcydGRJRDBnZXlCZmNuUjVjR1U2SUZ3aVpYSnliM0pjSWl3Z1gzSjJZV3gxWlRvZ2RpNTBiMU4wY21sdVp5Z3BJSDA3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RIbHdaVzltSUVacGJHVWdJVDA5SUZ3aWRXNWtaV1pwYm1Wa1hDSWdKaVlnZGlCcGJuTjBZVzVqWlc5bUlFWnBiR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmlUMkpxWldOMFcydGRJRDBnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdYM0owZVhCbE9pQmNJbVpwYkdWY0lpeGNiaUFnSUNBZ0lDQWdJQ0FnSUY5eWRtRnNkV1U2SUhZc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JmY25KbGJHRjBhWFpsWDNCaGRHZzZJSFl1Y21Wc1lYUnBkbVZRWVhSb0lIeDhJSFl1ZDJWaWEybDBVbVZzWVhScGRtVlFZWFJvWEc0Z0lDQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0F2THlCelpXNWtJRzlpYW1WamRITWdjM1Z3Y0c5eWRHVmtJR0o1SUhOMGNuVmpkSFZ5WlNCamJHOXVaU0JoYkdkdmNtbDBhRzFjYmlBZ0lDQWdJQ0FnTHk4Z2FIUjBjSE02THk5a1pYWmxiRzl3WlhJdWJXOTZhV3hzWVM1dmNtY3ZaVzR0VlZNdlpHOWpjeTlYWldJdlFWQkpMMWRsWWw5WGIzSnJaWEp6WDBGUVNTOVRkSEoxWTNSMWNtVmtYMk5zYjI1bFgyRnNaMjl5YVhSb2JWeHVJQ0FnSUNBZ0lDQmxiSE5sSUdsbUlDaGNiaUFnSUNBZ0lDQWdJQ0IySUNFOVBTQlBZbXBsWTNRb2Rpa2dmSHhjYmlBZ0lDQWdJQ0FnSUNCMklHbHVjM1JoYm1ObGIyWWdRbTl2YkdWaGJpQjhmRnh1SUNBZ0lDQWdJQ0FnSUhZZ2FXNXpkR0Z1WTJWdlppQlRkSEpwYm1jZ2ZIeGNiaUFnSUNBZ0lDQWdJQ0IySUdsdWMzUmhibU5sYjJZZ1JHRjBaU0I4ZkZ4dUlDQWdJQ0FnSUNBZ0lIWWdhVzV6ZEdGdVkyVnZaaUJTWldkRmVIQWdmSHhjYmlBZ0lDQWdJQ0FnSUNCMklHbHVjM1JoYm1ObGIyWWdRbXh2WWlCOGZGeHVJQ0FnSUNBZ0lDQWdJSFlnYVc1emRHRnVZMlZ2WmlCSmJXRm5aVVJoZEdFZ2ZIeGNiaUFnSUNBZ0lDQWdJQ0FvZEhsd1pXOW1JRVpwYkdWTWFYTjBJQ0U5UFNCY0luVnVaR1ZtYVc1bFpGd2lJQ1ltSUhZZ2FXNXpkR0Z1WTJWdlppQkdhV3hsVEdsemRDbGNiaUFnSUNBZ0lDQWdLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1lrOWlhbVZqZEZ0clhTQTlJSHNnWDNKMGVYQmxPaUJjSW1GeVozVnRaVzUwWENJc0lGOXlkbUZzZFdVNklIWWdmVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoMklHbHVjM1JoYm1ObGIyWWdRWEp5WVhsQ2RXWm1aWElwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZGk1ZmRISmhibk5tWlhJZ2ZId2dYM1J5WVc1elptVnlLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBjbUZ1YzJabGNtRmliR1Z6TG5CMWMyZ29kaWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmtaV3hsZEdVZ2RpNWZkSEpoYm5ObVpYSTdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lHSlBZbXBsWTNSYmExMGdQU0I3SUY5eWRIbHdaVG9nWENKaGNtZDFiV1Z1ZEZ3aUxDQmZjblpoYkhWbE9pQjJJSDA3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RpQnBibk4wWVc1alpXOW1JRUZ5Y21GNVFuVm1abVZ5Vm1sbGR5a2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaDJMbDkwY21GdWMyWmxjaUI4ZkNCZmRISmhibk5tWlhJcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSeVlXNXpabVZ5WVdKc1pYTXVjSFZ6YUNoMkxtSjFabVpsY2lrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JrWld4bGRHVWdkaTVmZEhKaGJuTm1aWEk3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJR0pQWW1wbFkzUmJhMTBnUFNCN0lGOXlkSGx3WlRvZ1hDSmhjbWQxYldWdWRGd2lMQ0JmY25aaGJIVmxPaUIySUgwN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdMeThnVkU5RVR6b2djM1Z3Y0c5eWRDQmhiSE52SUUxaGNDQmhibVFnVTJWMFhHNGdJQ0FnSUNBZ0lDOHZJRlJQUkU4NklHRjJiMmxrSUc5aWFtVmpkQ0J6ZFdOb0lHRnpJRVI1Ym1GdGFXTlFiSFZuYVc0Z2FXNXpkR0Z1WTJVdVhHNGdJQ0FnSUNBZ0lHVnNjMlVnYVdZZ0tIWXVYM0pwYm5SbUtTQjdYRzRnSUNBZ0lDQWdJQ0FnWWs5aWFtVmpkRnRyWFNBOUlIUm9hWE11WDJWdVkyOWtaU2gyTENCMGNuVmxLVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoMGVYQmxiMllnZGlBOVBUMGdYQ0p2WW1wbFkzUmNJaWtnZTF4dUlDQWdJQ0FnSUNBZ0lHSlBZbXBsWTNSYmExMGdQU0IwYUdsekxsOWxibU52WkdVb2Rpd2dZWE5mYVc1MFpYSm1ZV05sS1R0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJ0YjNabElIUnlZVzV6Wm1WeVlXSnNaWE1nZEc4Z2RHaGxJSFJ2Y0NCc1pYWmxiQ0J2WW1wbFkzUmNiaUFnSUNBZ0lDQWdJQ0JwWmlBb1lrOWlhbVZqZEZ0clhTNWZYM1J5WVc1elptVnlZV0pzWlhOZlh5a2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2RDQTlJREE3SUhRZ1BDQmlUMkpxWldOMFcydGRMbDlmZEhKaGJuTm1aWEpoWW14bGMxOWZMbXhsYm1kMGFEc2dkQ3NyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhSeVlXNXpabVZ5WVdKc1pYTXVjSFZ6YUNoaVQySnFaV04wVzJ0ZExsOWZkSEpoYm5ObVpYSmhZbXhsYzE5ZlczUmRLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0FnSUdSbGJHVjBaU0JpVDJKcVpXTjBXMnRkTGw5ZmRISmhibk5tWlhKaFlteGxjMTlmTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0IwYUhKdmR5QmNJbWx0YW05NUxYSndZem9nVlc1emRYQndiM0owWldRZ1pHRjBZU0IwZVhCbElGd2lJQ3NnYXlBcklGd2lMRndpSUNzZ2RqdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnSUNCcFppQW9kSEpoYm5ObVpYSmhZbXhsY3k1c1pXNW5kR2dnUGlBd0tTQjdYRzRnSUNBZ0lDQmlUMkpxWldOMExsOWZkSEpoYm5ObVpYSmhZbXhsYzE5ZklEMGdkSEpoYm5ObVpYSmhZbXhsY3p0Y2JpQWdJQ0I5WEc0Z0lDQWdjbVYwZFhKdUlHSlBZbXBsWTNRN1hHNGdJSDFjYmx4dUlDQmZaR1ZqYjJSbEtHRlBZbXBsWTNRc0lHTmhiR3hpWVdOclNXUXNJSGRwZEdoUWNtOXRhWE5sS1NCN1hHNGdJQ0FnYVdZZ0tDRmhUMkpxWldOMEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1lVOWlhbVZqZER0Y2JpQWdJQ0I5WEc0Z0lDQWdkbUZ5SUdKUFltcGxZM1FzSUhZc0lHczdYRzRnSUNBZ2FXWWdLR0ZQWW1wbFkzUXVhR0Z6VDNkdVVISnZjR1Z5ZEhrb1hDSmZjblI1Y0dWY0lpa2dKaVlnWVU5aWFtVmpkQzVvWVhOUGQyNVFjbTl3WlhKMGVTaGNJbDl5ZG1Gc2RXVmNJaWtwSUh0Y2JpQWdJQ0FnSUdsbUlDaGhUMkpxWldOMExsOXlkSGx3WlNBOVBUMGdYQ0pqZFhOMGIyMWNJaWtnZTF4dUlDQWdJQ0FnSUNCcFppQW9YRzRnSUNBZ0lDQWdJQ0FnWVU5aWFtVmpkQzVmY25aaGJIVmxJQ1ltWEc0Z0lDQWdJQ0FnSUNBZ2RIbHdaVzltSUhSb2FYTXVYMnh2WTJGc1gyRndhUzVmY25CalgyUmxZMjlrWlNBOVBUMGdYQ0ptZFc1amRHbHZibHdpWEc0Z0lDQWdJQ0FnSUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJR0pQWW1wbFkzUWdQU0IwYUdsekxsOXNiMk5oYkY5aGNHa3VYM0p3WTE5a1pXTnZaR1VvWVU5aWFtVmpkQzVmY25aaGJIVmxLVHRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9ZazlpYW1WamRDQTlQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JpVDJKcVpXTjBJRDBnWVU5aWFtVmpkRHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdZazlpYW1WamRDQTlJR0ZQWW1wbFkzUTdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvWVU5aWFtVmpkQzVmY25SNWNHVWdQVDA5SUZ3aVkyRnNiR0poWTJ0Y0lpa2dlMXh1SUNBZ0lDQWdJQ0JpVDJKcVpXTjBJRDBnZEdocGN5NWZaMlZ1VW1WdGIzUmxRMkZzYkdKaFkyc29YRzRnSUNBZ0lDQWdJQ0FnWTJGc2JHSmhZMnRKWkN4Y2JpQWdJQ0FnSUNBZ0lDQmhUMkpxWldOMExsOXlhVzVrWlhnc1hHNGdJQ0FnSUNBZ0lDQWdkMmwwYUZCeWIyMXBjMlZjYmlBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1lVOWlhbVZqZEM1ZmNuUjVjR1VnUFQwOUlGd2lhVzUwWlhKbVlXTmxYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYVc1MFptbGtJRDBnWVU5aWFtVmpkQzVmY21sa0lEMDlQU0JjSWw5eWJHOWpZV3hjSWlBL0lGd2lYM0p5Ylc5MFpWd2lJRG9nWVU5aWFtVmpkQzVmY21sa08xeHVJQ0FnSUNBZ0lDQmlUMkpxWldOMElEMWNiaUFnSUNBZ0lDQWdJQ0FvZEdocGN5NWZhVzUwWlhKbVlXTmxYM04wYjNKbFcybHVkR1pwWkYwZ0ppWmNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYMmx1ZEdWeVptRmpaVjl6ZEc5eVpWdHBiblJtYVdSZFcyRlBZbXBsWTNRdVgzSjJZV3gxWlYwcElIeDhYRzRnSUNBZ0lDQWdJQ0FnZEdocGN5NWZaMlZ1VW1WdGIzUmxUV1YwYUc5a0tHRlBZbXBsWTNRdVgzSjJZV3gxWlN3Z1lVOWlhbVZqZEM1ZmNtbGtLVHRjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvWVU5aWFtVmpkQzVmY25SNWNHVWdQVDA5SUZ3aWJtUmhjbkpoZVZ3aUtTQjdYRzRnSUNBZ0lDQWdJQzhxWjJ4dlltRnNJRzVxSUhSbUtpOWNiaUFnSUNBZ0lDQWdMeTlqY21WaGRHVWdZblZwYkdRZ1lYSnlZWGt2ZEdWdWMyOXlJR2xtSUhWelpXUWdhVzRnZEdobElIQnNkV2RwYmx4dUlDQWdJQ0FnSUNCcFppQW9kSGx3Wlc5bUlHNXFJQ0U5UFNCY0luVnVaR1ZtYVc1bFpGd2lJQ1ltSUc1cUxtRnljbUY1S1NCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0VGeWNtRjVMbWx6UVhKeVlYa29ZVTlpYW1WamRDNWZjblpoYkhWbEtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1lVOWlhbVZqZEM1ZmNuWmhiSFZsSUQwZ1lVOWlhbVZqZEM1ZmNuWmhiSFZsTG5KbFpIVmpaU2hmWVhCd1pXNWtRblZtWm1WeUtUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ1lrOWlhbVZqZENBOUlHNXFYRzRnSUNBZ0lDQWdJQ0FnSUNBdVlYSnlZWGtvWVU5aWFtVmpkQzVmY25aaGJIVmxMQ0JoVDJKcVpXTjBMbDl5WkhSNWNHVXBYRzRnSUNBZ0lDQWdJQ0FnSUNBdWNtVnphR0Z3WlNoaFQySnFaV04wTGw5eWMyaGhjR1VwTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tIUjVjR1Z2WmlCMFppQWhQVDBnWENKMWJtUmxabWx1WldSY0lpQW1KaUIwWmk1VVpXNXpiM0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvUVhKeVlYa3VhWE5CY25KaGVTaGhUMkpxWldOMExsOXlkbUZzZFdVcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaFQySnFaV04wTGw5eWRtRnNkV1VnUFNCaFQySnFaV04wTGw5eWRtRnNkV1V1Y21Wa2RXTmxLRjloY0hCbGJtUkNkV1ptWlhJcE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCaVQySnFaV04wSUQwZ2RHWXVkR1Z1YzI5eUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnWVU5aWFtVmpkQzVmY25aaGJIVmxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1lVOWlhbVZqZEM1ZmNuTm9ZWEJsTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdZVTlpYW1WamRDNWZjbVIwZVhCbFhHNGdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBdkwydGxaWEFnYVhRZ1lYTWdjbVZuZFd4aGNpQnBaaUIwY21GdWMyWmxjbVZrSUhSdklIUm9aU0J0WVdsdUlHRndjRnh1SUNBZ0lDQWdJQ0FnSUdKUFltcGxZM1FnUFNCaFQySnFaV04wTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHRlBZbXBsWTNRdVgzSjBlWEJsSUQwOVBTQmNJbVZ5Y205eVhDSXBJSHRjYmlBZ0lDQWdJQ0FnWWs5aWFtVmpkQ0E5SUc1bGR5QkZjbkp2Y2loaFQySnFaV04wTGw5eWRtRnNkV1VwTzF4dUlDQWdJQ0FnZlNCbGJITmxJR2xtSUNoaFQySnFaV04wTGw5eWRIbHdaU0E5UFQwZ1hDSm1hV3hsWENJcElIdGNiaUFnSUNBZ0lDQWdZazlpYW1WamRDQTlJR0ZQWW1wbFkzUXVYM0oyWVd4MVpUdGNiaUFnSUNBZ0lDQWdMeTl3WVhSamFDQnlaV3hoZEdsMlpWQmhkR2hjYmlBZ0lDQWdJQ0FnWWs5aWFtVmpkQzV5Wld4aGRHbDJaVkJoZEdnZ1BTQmhUMkpxWldOMExsOXljbVZzWVhScGRtVmZjR0YwYUR0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1lVOWlhbVZqZEM1ZmNuUjVjR1VnUFQwOUlGd2lZWEpuZFcxbGJuUmNJaWtnZTF4dUlDQWdJQ0FnSUNCaVQySnFaV04wSUQwZ1lVOWlhbVZqZEM1ZmNuWmhiSFZsTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnY21WMGRYSnVJR0pQWW1wbFkzUTdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUhaaGNpQnBjMkZ5Y21GNUlEMGdRWEp5WVhrdWFYTkJjbkpoZVNoaFQySnFaV04wS1R0Y2JpQWdJQ0FnSUdKUFltcGxZM1FnUFNCcGMyRnljbUY1SUQ4Z1cxMGdPaUI3ZlR0Y2JpQWdJQ0FnSUdadmNpQW9heUJwYmlCaFQySnFaV04wS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hwYzJGeWNtRjVJSHg4SUdGUFltcGxZM1F1YUdGelQzZHVVSEp2Y0dWeWRIa29heWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQjJJRDBnWVU5aWFtVmpkRnRyWFR0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZEhsd1pXOW1JSFlnUFQwOUlGd2liMkpxWldOMFhDSWdmSHdnUVhKeVlYa3VhWE5CY25KaGVTaDJLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZazlpYW1WamRGdHJYU0E5SUhSb2FYTXVYMlJsWTI5a1pTaDJMQ0JqWVd4c1ltRmphMGxrTENCM2FYUm9VSEp2YldselpTazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCeVpYUjFjbTRnWWs5aWFtVmpkRHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0JmZDNKaGNDaGhjbWR6TENCaGMxOXBiblJsY21aaFkyVXBJSHRjYmlBZ0lDQjJZWElnZDNKaGNIQmxaQ0E5SUhSb2FYTXVYMlZ1WTI5a1pTaGhjbWR6TENCaGMxOXBiblJsY21aaFkyVXBPMXh1SUNBZ0lIWmhjaUJ5WlhOMWJIUWdQU0I3SUdGeVozTTZJSGR5WVhCd1pXUWdmVHRjYmlBZ0lDQnlaWFIxY200Z2NtVnpkV3gwTzF4dUlDQjlYRzVjYmlBZ0x5b3FYRzRnSUNBcUlGVnVkM0poY0hNZ2RHaGxJSE5sZENCdlppQmhjbWQxYldWdWRITWdaR1ZzYVhabGNtVmtJR1p5YjIwZ2RHaGxJSEpsYlc5MFpTQnphWFJsTEZ4dUlDQWdLaUJ5WlhCc1lXTmxjeUJoYkd3Z1kyRnNiR0poWTJzZ2FXUmxiblJwWm1sbGNuTWdkMmwwYUNCaElHWjFibU4wYVc5dUlIZG9hV05vSUhkcGJHeGNiaUFnSUNvZ2FXNXBkR2xoZEdVZ2MyVnVaR2x1WnlCMGFHRjBJR05oYkd4aVlXTnJJR2xrWlc1MGFXWnBaWElnWW1GamF5QjBieUJ2ZEdobGNpQnphWFJsWEc0Z0lDQXFYRzRnSUNBcUlFQndZWEpoYlNCN1QySnFaV04wZlNCaGNtZHpJSFJ2SUhWdWQzSmhjRnh1SUNBZ0tseHVJQ0FnS2lCQWNHRnlZVzBnZTBKdmIyeGxZVzU5SUhkcGRHaFFjbTl0YVhObElHbHpJSFJ5ZFdVZ2JXVmhibk1nZEdocGN5QjBhR1VnWTJGc2JHSmhZMnNnYzJodmRXeGtJR052Ym5SaGFXNGdZU0J3Y205dGFYTmxYRzRnSUNBcVhHNGdJQ0FxSUVCeVpYUjFjbTV6SUh0QmNuSmhlWDBnZFc1M2NtRndjR1ZrSUdGeVozTmNiaUFnSUNvdlhHNGdJRjkxYm5keVlYQW9ZWEpuY3l3Z2QybDBhRkJ5YjIxcGMyVXBJSHRjYmlBZ0lDQXZMeUIyWVhJZ1kyRnNiR1ZrSUQwZ1ptRnNjMlU3WEc1Y2JpQWdJQ0F2THlCM2NtRndjeUJsWVdOb0lHTmhiR3hpWVdOcklITnZJSFJvWVhRZ2RHaGxJRzl1YkhrZ2IyNWxJR052ZFd4a0lHSmxJR05oYkd4bFpGeHVJQ0FnSUM4dklIWmhjaUJ2Ym1ObEtHTmlLU0I3WEc0Z0lDQWdMeThnSUNBZ0lISmxkSFZ5YmlCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBdkx5QWdJQ0FnSUNBZ0lHbG1JQ2doWTJGc2JHVmtLU0I3WEc0Z0lDQWdMeThnSUNBZ0lDQWdJQ0FnSUNBZ1kyRnNiR1ZrSUQwZ2RISjFaVHRjYmlBZ0lDQXZMeUFnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnWTJJdVlYQndiSGtvZEdocGN5d2dZWEpuZFcxbGJuUnpLVHRjYmlBZ0lDQXZMeUFnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0x5OGdJQ0FnSUNBZ0lDQWdJQ0FnZG1GeUlHMXpaeUE5WEc0Z0lDQWdMeThnSUNBZ0lDQWdJQ0FnSUNBZ0lDQW5RU0JqWVd4c1ltRmpheUJtY205dElIUm9hWE1nYzJWMElHaGhjeUJoYkhKbFlXUjVJR0psWlc0Z1pYaGxZM1YwWldRbk8xeHVJQ0FnSUM4dklDQWdJQ0FnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpaHRjMmNwTzF4dUlDQWdJQzh2SUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQzh2SUNBZ0lDQjlPMXh1SUNBZ0lDOHZJSDFjYmlBZ0lDQjJZWElnY21WemRXeDBJRDBnZEdocGN5NWZaR1ZqYjJSbEtHRnlaM011WVhKbmN5d2dZWEpuY3k1allXeHNZbUZqYTBsa0xDQjNhWFJvVUhKdmJXbHpaU2s3WEc0Z0lDQWdjbVYwZFhKdUlISmxjM1ZzZER0Y2JpQWdmVnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQkhaVzVsY21GMFpYTWdkR2hsSUhkeVlYQndaV1FnWm5WdVkzUnBiMjRnWTI5eWNtVnpjRzl1WkdsdVp5QjBieUJoSUhOcGJtZHNaU0J5WlcxdmRHVmNiaUFnSUNvZ1kyRnNiR0poWTJzdUlGZG9aVzRnZEdobElHZGxibVZ5WVhSbFpDQm1kVzVqZEdsdmJpQnBjeUJqWVd4c1pXUXNJR2wwSUhkcGJHd2djMlZ1WkZ4dUlDQWdLaUIwYUdVZ1kyOXljbVZ6Y0c5dVpHbHVaeUJ0WlhOellXZGxJSFJ2SUhSb1pTQnlaVzF2ZEdVZ2MybDBaU0JoYzJ0cGJtY2dhWFFnZEc5Y2JpQWdJQ29nWlhobFkzVjBaU0IwYUdVZ2NHRnlkR2xqZFd4aGNpQmpZV3hzWW1GamF5QndjbVYyYVc5MWMyeDVJSE5oZG1Wa0lHUjFjbWx1WnlCaElHTmhiR3hjYmlBZ0lDb2dZbmtnZEdobElISmxiVzkwWlNCemFYUmxJR0VnYldWMGFHOWtJR1p5YjIwZ2RHaGxJR2x1ZEdWeVptRmpaU0J2WmlCMGFHbHpJSE5wZEdWY2JpQWdJQ3BjYmlBZ0lDb2dRSEJoY21GdElIdE9kVzFpWlhKOUlHbGtJRzltSUhSb1pTQnlaVzF2ZEdVZ1kyRnNiR0poWTJzZ2RHOGdaWGhsWTNWMFpWeHVJQ0FnS2lCQWNHRnlZVzBnZTA1MWJXSmxjbjBnWVhKblRuVnRJR0Z5WjNWdFpXNTBJR2x1WkdWNElHOW1JSFJvWlNCallXeHNZbUZqYTF4dUlDQWdLaUJBY0dGeVlXMGdlMEp2YjJ4bFlXNTlJSGRwZEdoUWNtOXRhWE5sSUdseklIUnlkV1VnYldWaGJuTWdkR2hwY3lCMGFHVWdZMkZzYkdKaFkyc2djMmh2ZFd4a0lHTnZiblJoYVc0Z1lTQndjbTl0YVhObFhHNGdJQ0FxWEc0Z0lDQXFJRUJ5WlhSMWNtNXpJSHRHZFc1amRHbHZibjBnZDNKaGNIQmxaQ0J5WlcxdmRHVWdZMkZzYkdKaFkydGNiaUFnSUNvdlhHNGdJRjluWlc1U1pXMXZkR1ZEWVd4c1ltRmpheWhwWkN3Z1lYSm5UblZ0TENCM2FYUm9VSEp2YldselpTa2dlMXh1SUNBZ0lIWmhjaUJ0WlNBOUlIUm9hWE03WEc0Z0lDQWdkbUZ5SUhKbGJXOTBaVU5oYkd4aVlXTnJPMXh1SUNBZ0lHbG1JQ2gzYVhSb1VISnZiV2x6WlNrZ2UxeHVJQ0FnSUNBZ2NtVnRiM1JsUTJGc2JHSmhZMnNnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHNWxkeUJRY205dGFYTmxLQ2h5WlhOdmJIWmxMQ0J5WldwbFkzUXBJRDArSUh0Y2JpQWdJQ0FnSUNBZ0lDQjJZWElnWVhKbmN5QTlJRzFsTGw5M2NtRndLRUZ5Y21GNUxuQnliM1J2ZEhsd1pTNXpiR2xqWlM1allXeHNLR0Z5WjNWdFpXNTBjeWtwTzF4dUlDQWdJQ0FnSUNBZ0lIWmhjaUIwY21GdWMyWmxjbUZpYkdWeklEMGdZWEpuY3k1aGNtZHpMbDlmZEhKaGJuTm1aWEpoWW14bGMxOWZPMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaDBjbUZ1YzJabGNtRmliR1Z6S1NCa1pXeGxkR1VnWVhKbmN5NWhjbWR6TGw5ZmRISmhibk5tWlhKaFlteGxjMTlmTzF4dUlDQWdJQ0FnSUNBZ0lISmxjMjlzZG1VdVgxOXFZV2xzWldSZmNHRnBjbk5mWHlBOUlISmxhbVZqZER0Y2JpQWdJQ0FnSUNBZ0lDQnlaV3BsWTNRdVgxOXFZV2xzWldSZmNHRnBjbk5mWHlBOUlISmxjMjlzZG1VN1hHNGdJQ0FnSUNBZ0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJRzFsTGw5amIyNXVaV04wYVc5dUxtVnRhWFFvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwZVhCbE9pQmNJbU5oYkd4aVlXTnJYQ0lzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdRNklHbGtMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRjl5YVc1a1pYZzZJR0Z5WjA1MWJTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhjbWR6T2lCaGNtZHpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzh2SUhCcFpDQTZJQ0J0WlM1cFpDeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQndjbTl0YVhObE9pQnRaUzVmZDNKaGNDaGJjbVZ6YjJ4MlpTd2djbVZxWldOMFhTbGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2ZTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2RISmhibk5tWlhKaFlteGxjMXh1SUNBZ0lDQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdJQ0I5SUdOaGRHTm9JQ2hsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WldwbFkzUW9YRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHQkdZV2xzWldRZ2RHOGdaWGhsWTNSMVpTQnlaVzF2ZEdVZ1kyRnNiR0poWTJzZ0tHbGtPaUFrZTJsa2ZTd2dZWEpuVG5WdE9pQWtlMkZ5WjA1MWJYMHBMbUJjYmlBZ0lDQWdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lIMDdYRzRnSUNBZ0lDQnlaWFIxY200Z2NtVnRiM1JsUTJGc2JHSmhZMnM3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lISmxiVzkwWlVOaGJHeGlZV05ySUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCaGNtZHpJRDBnYldVdVgzZHlZWEFvUVhKeVlYa3VjSEp2ZEc5MGVYQmxMbk5zYVdObExtTmhiR3dvWVhKbmRXMWxiblJ6S1NrN1hHNGdJQ0FnSUNBZ0lIWmhjaUIwY21GdWMyWmxjbUZpYkdWeklEMGdZWEpuY3k1aGNtZHpMbDlmZEhKaGJuTm1aWEpoWW14bGMxOWZPMXh1SUNBZ0lDQWdJQ0JwWmlBb2RISmhibk5tWlhKaFlteGxjeWtnWkdWc1pYUmxJR0Z5WjNNdVlYSm5jeTVmWDNSeVlXNXpabVZ5WVdKc1pYTmZYenRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzFsTGw5amIyNXVaV04wYVc5dUxtVnRhWFFvWEc0Z0lDQWdJQ0FnSUNBZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEhsd1pUb2dYQ0pqWVd4c1ltRmphMXdpTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdhV1E2SUdsa0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnWDNKcGJtUmxlRG9nWVhKblRuVnRMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1lYSm5jem9nWVhKbmMxeHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z2NHbGtJRG9nSUcxbExtbGtYRzRnSUNBZ0lDQWdJQ0FnZlN4Y2JpQWdJQ0FnSUNBZ0lDQjBjbUZ1YzJabGNtRmliR1Z6WEc0Z0lDQWdJQ0FnSUNrN1hHNGdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUhKbGJXOTBaVU5oYkd4aVlXTnJPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJUWlc1a2N5QjBhR1VnYm05MGFXWnBZMkYwYVc5dUlHMWxjM05oWjJVZ1lXNWtJR0p5WldGcmN5QjBhR1VnWTI5dWJtVmpkR2x2Ymx4dUlDQWdLaTljYmlBZ1pHbHpZMjl1Ym1WamRDZ3BJSHRjYmlBZ0lDQjBhR2x6TGw5amIyNXVaV04wYVc5dUxtVnRhWFFvZXlCMGVYQmxPaUJjSW1ScGMyTnZibTVsWTNSY0lpQjlLVHRjYmlBZ0lDQnpaWFJVYVcxbGIzVjBLQ2dwSUQwK0lIdGNiaUFnSUNBZ0lIUm9hWE11WDJOdmJtNWxZM1JwYjI0dVpHbHpZMjl1Ym1WamRDZ3BPMXh1SUNBZ0lIMHNJREl3TURBcE8xeHVJQ0I5WEc1OVhHNWNiaThxS2x4dUlDb2dVbVZtWlhKbGJtTmxVM1J2Y21VZ2FYTWdZU0J6Y0dWamFXRnNJRzlpYW1WamRDQjNhR2xqYUNCemRHOXlaWE1nYjNSb1pYSWdiMkpxWldOMGMxeHVJQ29nWVc1a0lIQnliM1pwWkdWeklIUm9aU0J5WldabGNtVnVZMlZ6SUNodWRXMWlaWElwSUdsdWMzUmxZV1F1SUZSb2FYTWdjbVZtWlhKbGJtTmxYRzRnS2lCdFlYa2dkR2hsYmlCaVpTQnpaVzUwSUc5MlpYSWdZU0JxYzI5dUxXSmhjMlZrSUdOdmJXMTFibWxqWVhScGIyNGdZMmhoYm01bGJDQW9TVkJEWEc0Z0tpQjBieUJoYm05MGFHVnlJRTV2WkdVdWFuTWdjSEp2WTJWemN5QnZjaUJoSUcxbGMzTmhaMlVnZEc4Z2RHaGxJRmR2Y210bGNpa3VJRTkwYUdWeVhHNGdLaUJ6YVhSbElHMWhlU0IwYUdWdUlIQnliM1pwWkdVZ2RHaGxJSEpsWm1WeVpXNWpaU0JwYmlCMGFHVWdjbVZ6Y0c5dVkyVWdiV1Z6YzJGblpWeHVJQ29nYVcxd2JIbHBibWNnZEdobElHZHBkbVZ1SUc5aWFtVmpkQ0J6YUc5MWJHUWdZbVVnWVdOMGFYWmhkR1ZrTGx4dUlDcGNiaUFxSUZCeWFXMWhjbmtnZFhOaFoyVWdabTl5SUhSb1pTQlNaV1psY21WdVkyVlRkRzl5WlNCcGN5QmhJSE4wYjNKaFoyVWdabTl5SUhSb1pWeHVJQ29nWTJGc2JHSmhZMnR6TENCM2FHbGphQ0IwYUdWeVpXWnZjbVVnYldGclpYTWdhWFFnY0c5emMybGliR1VnZEc4Z2FXNXBkR2xoZEdVZ1lWeHVJQ29nWTJGc2JHSmhZMnNnWlhobFkzVjBhVzl1SUdKNUlIUm9aU0J2Y0hCdmMybDBaU0J6YVhSbElDaDNhR2xqYUNCdWIzSnRZV3hzZVNCallXNXViM1JjYmlBcUlHUnBjbVZqZEd4NUlHVjRaV04xZEdVZ1puVnVZM1JwYjI1eklHOTJaWElnZEdobElHTnZiVzExYm1sallYUnBiMjRnWTJoaGJtNWxiQ2t1WEc0Z0tseHVJQ29nUldGamFDQnpkRzl5WldRZ2IySnFaV04wSUdOaGJpQnZibXg1SUdKbElHWmxkR05vWldRZ2IyNWpaU0JoYm1RZ2FYTWdibTkwWEc0Z0tpQmhkbUZwYkdGaWJHVWdabTl5SUhSb1pTQnpaV052Ym1RZ2RHbHRaUzRnUldGamFDQnpkRzl5WldRZ2IySnFaV04wSUcxMWMzUWdZbVZjYmlBcUlHWmxkR05vWldRc0lITnBibU5sSUc5MGFHVnlkMmx6WlNCcGRDQjNhV3hzSUhKbGJXRnBiaUJ6ZEc5eVpXUWdabTl5WlhabGNpQmhibVJjYmlBcUlHTnZibk4xYldVZ2JXVnRiM0o1TGx4dUlDcGNiaUFxSUZOMGIzSmxaQ0J2WW1wbFkzUWdhVzVrWldObGN5QmhjbVVnYzJsdGNHeDVJSFJvWlNCdWRXMWlaWEp6TENCM2FHbGphQ0JoY21VZ2FHOTNaWFpsY2x4dUlDb2djbVZzWldGelpXUWdZV3h2Ym1jZ2QybDBhQ0IwYUdVZ2IySnFaV04wY3l3Z1lXNWtJR0Z5WlNCc1lYUmxjaUJ5WlhWelpXUWdZV2RoYVc0Z0tHbHVYRzRnS2lCdmNtUmxjaUIwYnlCd2IzTjBjRzl1WlNCMGFHVWdiM1psY21ac2IzY3NJSGRvYVdOb0lITm9iM1ZzWkNCdWIzUWdiR2xyWld4NUlHaGhjSEJsYml4Y2JpQXFJR0oxZENCaGJubDNZWGtwTGx4dUlDb3ZYRzVqYkdGemN5QlNaV1psY21WdVkyVlRkRzl5WlNCN1hHNGdJR052Ym5OMGNuVmpkRzl5S0NrZ2UxeHVJQ0FnSUhSb2FYTXVYM04wYjNKbElEMGdlMzA3SUM4dklITjBiM0psWkNCdlltcGxZM1JjYmlBZ0lDQjBhR2x6TGw5cGJtUnBZMlZ6SUQwZ1d6QmRPeUF2THlCemJXRnNiR1Z6ZENCaGRtRnBiR0ZpYkdVZ2FXNWthV05sYzF4dUlDQWdJSFJvYVhNdVgzSmxZV1I1U0dGdVpHeGxjaUE5SUdaMWJtTjBhVzl1S0NrZ2UzMDdYRzRnSUNBZ2RHaHBjeTVmWW5WemVVaGhibVJzWlhJZ1BTQm1kVzVqZEdsdmJpZ3BJSHQ5TzF4dUlDQWdJSFJvYVhNdVgzSmxZV1I1U0dGdVpHeGxjaWdwTzF4dUlDQjlYRzVjYmlBZ0x5b3FYRzRnSUNBcUlHTmhiR3dnYUdGdVpHeGxjaUIzYUdWdUlIUm9aU0J6ZEc5eVpTQnBjeUJsYlhCMGVWeHVJQ0FnS2x4dUlDQWdLaUJBY0dGeVlXMGdlMFpWVGtOVVNVOU9mU0JwWkNCdlppQmhJR2hoYm1Sc1pYSmNiaUFnSUNvdlhHNGdJRzl1VW1WaFpIa29jbVZoWkhsSVlXNWtiR1Z5S1NCN1hHNGdJQ0FnZEdocGN5NWZjbVZoWkhsSVlXNWtiR1Z5SUQwZ2NtVmhaSGxJWVc1a2JHVnlJSHg4SUdaMWJtTjBhVzl1S0NrZ2UzMDdYRzRnSUgxY2JseHVJQ0F2S2lwY2JpQWdJQ29nWTJGc2JDQm9ZVzVrYkdWeUlIZG9aVzRnZEdobElITjBiM0psSUdseklHNXZkQ0JsYlhCMGVWeHVJQ0FnS2x4dUlDQWdLaUJBY0dGeVlXMGdlMFpWVGtOVVNVOU9mU0JwWkNCdlppQmhJR2hoYm1Sc1pYSmNiaUFnSUNvdlhHNGdJRzl1UW5WemVTaGlkWE41U0dGdVpHeGxjaWtnZTF4dUlDQWdJSFJvYVhNdVgySjFjM2xJWVc1a2JHVnlJRDBnWW5WemVVaGhibVJzWlhJZ2ZId2dablZ1WTNScGIyNG9LU0I3ZlR0Y2JpQWdmVnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQm5aWFFnZEdobElHeGxibWQwYUNCdlppQjBhR1VnYzNSdmNtVmNiaUFnSUNwY2JpQWdJQ292WEc0Z0lHZGxkRk4wWVdOcktDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCUFltcGxZM1F1YTJWNWN5aDBhR2x6TGw5emRHOXlaU2t1YkdWdVozUm9PMXh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUVCbWRXNWpkR2x2YmlCZloyVnVTV1FvS1NCblpXNWxjbUYwWlhNZ2RHaGxJRzVsZHlCeVpXWmxjbVZ1WTJVZ2FXUmNiaUFnSUNwY2JpQWdJQ29nUUhKbGRIVnlibk1nZTA1MWJXSmxjbjBnYzIxaGJHeGxjM1FnWVhaaGFXeGhZbXhsSUdsa0lHRnVaQ0J5WlhObGNuWmxjeUJwZEZ4dUlDQWdLaTljYmlBZ1gyZGxia2xrS0NrZ2UxeHVJQ0FnSUhaaGNpQnBaRHRjYmlBZ0lDQnBaaUFvZEdocGN5NWZhVzVrYVdObGN5NXNaVzVuZEdnZ1BUMDlJREVwSUh0Y2JpQWdJQ0FnSUdsa0lEMGdkR2hwY3k1ZmFXNWthV05sYzFzd1hTc3JPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCcFpDQTlJSFJvYVhNdVgybHVaR2xqWlhNdWMyaHBablFvS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdhV1E3WEc0Z0lIMWNibHh1SUNBdktpcGNiaUFnSUNvZ1VtVnNaV0Z6WlhNZ2RHaGxJR2RwZG1WdUlISmxabVZ5Wlc1alpTQnBaQ0J6YnlCMGFHRjBJR2wwSUhkcGJHd2dZbVVnWVhaaGFXeGhZbXhsSUdKNVhHNGdJQ0FxSUdGdWIzUm9aWElnYjJKcVpXTjBJSE4wYjNKbFpGeHVJQ0FnS2x4dUlDQWdLaUJBY0dGeVlXMGdlMDUxYldKbGNuMGdhV1FnZEc4Z2NtVnNaV0Z6WlZ4dUlDQWdLaTljYmlBZ1gzSmxiR1ZoYzJWSlpDaHBaQ2tnZTF4dUlDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnZEdocGN5NWZhVzVrYVdObGN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnYVdZZ0tHbGtJRHdnZEdocGN5NWZhVzVrYVdObGMxdHBYU2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbDlwYm1ScFkyVnpMbk53YkdsalpTaHBMQ0F3TENCcFpDazdYRzRnSUNBZ0lDQWdJR0p5WldGck8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklHTnNaV0Z1YVc1bkxYVndJSFJvWlNCelpYRjFaVzVqWlNCMFlXbHNYRzRnSUNBZ1ptOXlJQ2hwSUQwZ2RHaHBjeTVmYVc1a2FXTmxjeTVzWlc1bmRHZ2dMU0F4T3lCcElENDlJREE3SUdrdExTa2dlMXh1SUNBZ0lDQWdhV1lnS0hSb2FYTXVYMmx1WkdsalpYTmJhVjBnTFNBeElEMDlQU0IwYUdsekxsOXBibVJwWTJWelcya2dMU0F4WFNrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TGw5cGJtUnBZMlZ6TG5CdmNDZ3BPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ0x5b3FYRzRnSUNBcUlGTjBiM0psY3lCMGFHVWdaMmwyWlc0Z2IySnFaV04wSUdGdVpDQnlaWFIxY201eklIUm9aU0J5WldabGNtNWpaU0JwWkNCcGJuTjBaV0ZrWEc0Z0lDQXFYRzRnSUNBcUlFQndZWEpoYlNCN1QySnFaV04wZlNCdlltb2dkRzhnYzNSdmNtVmNiaUFnSUNwY2JpQWdJQ29nUUhKbGRIVnlibk1nZTA1MWJXSmxjbjBnY21WbVpYSmxibU5sSUdsa0lHOW1JSFJvWlNCemRHOXlaV1FnYjJKcVpXTjBYRzRnSUNBcUwxeHVJQ0J3ZFhRb2IySnFLU0I3WEc0Z0lDQWdhV1lnS0hSb2FYTXVYMkoxYzNsSVlXNWtiR1Z5SUNZbUlFOWlhbVZqZEM1clpYbHpLSFJvYVhNdVgzTjBiM0psS1M1c1pXNW5kR2dnUFQwOUlEQXBJSHRjYmlBZ0lDQWdJSFJvYVhNdVgySjFjM2xJWVc1a2JHVnlLQ2s3WEc0Z0lDQWdmVnh1SUNBZ0lIWmhjaUJwWkNBOUlIUm9hWE11WDJkbGJrbGtLQ2s3WEc0Z0lDQWdkR2hwY3k1ZmMzUnZjbVZiYVdSZElEMGdiMkpxTzF4dUlDQWdJSEpsZEhWeWJpQnBaRHRjYmlBZ2ZWeHVYRzRnSUM4cUtseHVJQ0FnS2lCU1pYUnlhV1YyWlhNZ2NISmxkbWx2ZFhOc2VTQnpkRzl5WldRZ2IySnFaV04wSUdGdVpDQnlaV3hsWVhObGN5QnBkSE1nY21WbVpYSmxibU5sWEc0Z0lDQXFYRzRnSUNBcUlFQndZWEpoYlNCN1RuVnRZbVZ5ZlNCcFpDQnZaaUJoYmlCdlltcGxZM1FnZEc4Z2NtVjBjbWxsZG1WY2JpQWdJQ292WEc0Z0lHWmxkR05vS0dsa0tTQjdYRzRnSUNBZ2RtRnlJRzlpYWlBOUlIUm9hWE11WDNOMGIzSmxXMmxrWFR0Y2JpQWdJQ0JwWmlBb2IySnFJQ1ltSUNGdlltb3VYMTl5WlcxdmRHVmZiV1YwYUc5a0tTQjdYRzRnSUNBZ0lDQmtaV3hsZEdVZ2RHaHBjeTVmYzNSdmNtVmJhV1JkTzF4dUlDQWdJQ0FnZEdocGN5NWZjbVZzWldGelpVbGtLR2xrS1R0Y2JpQWdJQ0FnSUdsbUlDaDBhR2x6TGw5eVpXRmtlVWhoYm1Sc1pYSWdKaVlnVDJKcVpXTjBMbXRsZVhNb2RHaHBjeTVmYzNSdmNtVXBMbXhsYm1kMGFDQTlQVDBnTUNrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TGw5eVpXRmtlVWhoYm1Sc1pYSW9LVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLRzlpYWlBbUppQnZZbW91WDE5cVlXbHNaV1JmY0dGcGNuTmZYeWtnZTF4dUlDQWdJQ0FnWTI5dWMzUWdYMmxrSUQwZ1oyVjBTMlY1UW5sV1lXeDFaU2gwYUdsekxsOXpkRzl5WlN3Z2IySnFMbDlmYW1GcGJHVmtYM0JoYVhKelgxOHBPMXh1SUNBZ0lDQWdkR2hwY3k1bVpYUmphQ2hmYVdRcE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdiMkpxTzF4dUlDQjlYRzU5WEc0aVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdPenM3UVVGSlFUdEJRVVZCTzBGQlJVRTdRVUZEUVR0QlFVZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096czdPenM3T3pzN1FVRlJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJSMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZJUVR0QlFVdEJPMEZCUTBFN096czdPenM3T3p0QlFWRkJPMEZCUTBFN1FVRkRRVHRCUVVWQk96czdPenRCUVVkQk8wRkJRMEU3UVVGRFFUdEJRVVZCT3pzN096czdPenRCUVUxQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVWQk96czdPenM3UVVGSlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTkJPMEZCUlVFN096dEJRVWRCTzBGQlEwRTdRVUZEUVR0QlFVUkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRlFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVVkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGR1FUdEJRVWxCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUjBFN1FVRkRRVHRCUVVkQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVbEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkhRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlNVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJSMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRlFUczdPenM3TzBGQlNVRTdRVUZEUVR0QlFVRkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVbEJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZLUVR0QlFVMUJPMEZCUlVFN096czdPenM3UVVGTFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVWQk96czdPenM3T3pzN096czdRVUZWUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVWQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRk1RVHRCUVZOQk8wRkJRMEU3UVVGRFFUdEJRVWxCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJSVUU3T3pzN096dEJRVWxCTzBGQlEwRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkZRVHM3T3pzN096czdPenM3UVVGVlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJSa0U3UVVGTFFUdEJRVU5CTzBGQlJrRTdRVUZMUVR0QlFVZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRklRVHRCUVV0Qk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlMwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJTRUU3UVVGTFFUdEJRVU5CTzBGQlVFRTdRVUZWUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCU0VFN1FVRkxRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVoQk8wRkJTMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVaEJPMEZCUzBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGSlFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZLUVR0QlFVMUJPMEZCUTBFN1FVRkRRVHRCUVVsQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVXBCTzBGQlRVRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVaEJPMEZCUzBFN1FVRkZRVHRCUVZKQk8wRkJiVUpCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVOQk8wRkJSVUU3UVVGU1FUdEJRVlZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJTVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGTFFUdEJRVU5CTzBGQlEwRTdRVUZKUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZIUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGTFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUlVFN096czdPenM3T3pzN096czdRVUZYUVR0QlFVTkJPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVVkJPenM3T3pzN096czdPenM3T3pzN1FVRmhRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVTVCTzBGQlZVRTdRVUZEUVR0QlFVZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZNUVR0QlFWTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRlFUczdPenM3UVVGSFFUdEJRVU5CTzBGQlFVRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRWEIzUWtFN1FVRnpkMEpCT3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdRVUYxUWtFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJSVUU3T3pzN096czdRVUZMUVR0QlFVTkJPMEZCUTBFN1FVRkZRVHM3T3pzN096dEJRVXRCTzBGQlEwRTdRVUZEUVR0QlFVVkJPenM3T3pzN1FVRkpRVHRCUVVOQk8wRkJRMEU3UVVGRlFUczdPenM3T3p0QlFVdEJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkZRVHM3T3pzN096czdRVUZOUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZGUVRzN096czdPenM3TzBGQlQwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZGUVRzN096czdPenRCUVV0Qk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQkwwZEJJaXdpYzI5MWNtTmxVbTl2ZENJNklpSjlcXFxcbi8vIyBzb3VyY2VVUkw9d2VicGFjay1pbnRlcm5hbDovLy8uL3NyYy9ycGMuanNcXFxcblxcXCIpO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL3NyYy91dGlscy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy91dGlscy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmFuZElkLCBkdHlwZVRvVHlwZWRBcnJheSwgdHlwZWRBcnJheVRvRHR5cGUsIGNhY2hlUmVxdWlyZW1lbnRzLCBzZXR1cFNlcnZpY2VXb3JrZXIsIHVybEpvaW4sIE1lc3NhZ2VFbWl0dGVyICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5ldmFsKFxcXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwicmFuZElkXFxcXFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFuZElkOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJkdHlwZVRvVHlwZWRBcnJheVxcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGR0eXBlVG9UeXBlZEFycmF5OyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJ0eXBlZEFycmF5VG9EdHlwZVxcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHR5cGVkQXJyYXlUb0R0eXBlOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJjYWNoZVJlcXVpcmVtZW50c1xcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhY2hlUmVxdWlyZW1lbnRzOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJzZXR1cFNlcnZpY2VXb3JrZXJcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXR1cFNlcnZpY2VXb3JrZXI7IH0pO1xcXFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFxcXFxcInVybEpvaW5cXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1cmxKb2luOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJNZXNzYWdlRW1pdHRlclxcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1lc3NhZ2VFbWl0dGVyOyB9KTtcXFxcbmZ1bmN0aW9uIHJhbmRJZCgpIHtcXFxcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCAxMCkgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXFxcbn1cXFxcbmNvbnN0IGR0eXBlVG9UeXBlZEFycmF5ID0ge1xcXFxuICBpbnQ4OiBcXFxcXFxcIkludDhBcnJheVxcXFxcXFwiLFxcXFxuICBpbnQxNjogXFxcXFxcXCJJbnQxNkFycmF5XFxcXFxcXCIsXFxcXG4gIGludDMyOiBcXFxcXFxcIkludDMyQXJyYXlcXFxcXFxcIixcXFxcbiAgdWludDg6IFxcXFxcXFwiVWludDhBcnJheVxcXFxcXFwiLFxcXFxuICB1aW50MTY6IFxcXFxcXFwiVWludDE2QXJyYXlcXFxcXFxcIixcXFxcbiAgdWludDMyOiBcXFxcXFxcIlVpbnQzMkFycmF5XFxcXFxcXCIsXFxcXG4gIGZsb2F0MzI6IFxcXFxcXFwiRmxvYXQzMkFycmF5XFxcXFxcXCIsXFxcXG4gIGZsb2F0NjQ6IFxcXFxcXFwiRmxvYXQ2NEFycmF5XFxcXFxcXCIsXFxcXG4gIGFycmF5OiBcXFxcXFxcIkFycmF5XFxcXFxcXCJcXFxcbn07XFxcXG5jb25zdCB0eXBlZEFycmF5VG9EdHlwZSA9IHtcXFxcbiAgSW50OEFycmF5OiBcXFxcXFxcImludDhcXFxcXFxcIixcXFxcbiAgSW50MTZBcnJheTogXFxcXFxcXCJpbnQxNlxcXFxcXFwiLFxcXFxuICBJbnQzMkFycmF5OiBcXFxcXFxcImludDMyXFxcXFxcXCIsXFxcXG4gIFVpbnQ4QXJyYXk6IFxcXFxcXFwidWludDhcXFxcXFxcIixcXFxcbiAgVWludDE2QXJyYXk6IFxcXFxcXFwidWludDE2XFxcXFxcXCIsXFxcXG4gIFVpbnQzMkFycmF5OiBcXFxcXFxcInVpbnQzMlxcXFxcXFwiLFxcXFxuICBGbG9hdDMyQXJyYXk6IFxcXFxcXFwiZmxvYXQzMlxcXFxcXFwiLFxcXFxuICBGbG9hdDY0QXJyYXk6IFxcXFxcXFwiZmxvYXQ2NFxcXFxcXFwiLFxcXFxuICBBcnJheTogXFxcXFxcXCJhcnJheVxcXFxcXFwiXFxcXG59O1xcXFxuXFxcXG5mdW5jdGlvbiBjYWNoZVVybEluU2VydmljZVdvcmtlcih1cmwpIHtcXFxcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcXFxcbiAgICBjb25zdCBtZXNzYWdlID0ge1xcXFxuICAgICAgY29tbWFuZDogXFxcXFxcXCJhZGRcXFxcXFxcIixcXFxcbiAgICAgIHVybDogdXJsXFxcXG4gICAgfTtcXFxcblxcXFxuICAgIGlmICghbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgfHwgIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKSB7XFxcXG4gICAgICByZWplY3QoXFxcXFxcXCJTZXJ2aWNlIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkLlxcXFxcXFwiKTtcXFxcbiAgICAgIHJldHVybjtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBjb25zdCBtZXNzYWdlQ2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xcXFxuXFxcXG4gICAgbWVzc2FnZUNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxcXG4gICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmVycm9yKSB7XFxcXG4gICAgICAgIHJlamVjdChldmVudC5kYXRhLmVycm9yKTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnJlc3VsdCk7XFxcXG4gICAgICB9XFxcXG4gICAgfTtcXFxcblxcXFxuICAgIGlmIChuYXZpZ2F0b3Iuc2VydmljZVdvcmtlciAmJiBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyKSB7XFxcXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFttZXNzYWdlQ2hhbm5lbC5wb3J0Ml0pO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICByZWplY3QoXFxcXFxcXCJTZXJ2aWNlIHdvcmtlciBjb250cm9sbGVyIGlzIG5vdCBhdmFpbGFibGVcXFxcXFxcIik7XFxcXG4gICAgfVxcXFxuICB9KTtcXFxcbn1cXFxcblxcXFxuYXN5bmMgZnVuY3Rpb24gY2FjaGVSZXF1aXJlbWVudHMocmVxdWlyZW1lbnRzKSB7XFxcXG4gIGlmICghQXJyYXkuaXNBcnJheShyZXF1aXJlbWVudHMpKSB7XFxcXG4gICAgcmVxdWlyZW1lbnRzbS5jb2RlLnJlcXVpcmVtZW50cyA9IFtyZXF1aXJlbWVudHNdO1xcXFxuICB9XFxcXG5cXFxcbiAgaWYgKHJlcXVpcmVtZW50cyAmJiByZXF1aXJlbWVudHMubGVuZ3RoID4gMCkge1xcXFxuICAgIGZvciAobGV0IHJlcSBvZiByZXF1aXJlbWVudHMpIHtcXFxcbiAgICAgIC8vcmVtb3ZlIHByZWZpeFxcXFxuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFxcXFxcXFwianM6XFxcXFxcXCIpKSByZXEgPSByZXEuc2xpY2UoMyk7XFxcXG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXFxcXFxcXCJjc3M6XFxcXFxcXCIpKSByZXEgPSByZXEuc2xpY2UoNCk7XFxcXG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXFxcXFxcXCJjYWNoZTpcXFxcXFxcIikpIHJlcSA9IHJlcS5zbGljZSg2KTtcXFxcbiAgICAgIGlmICghcmVxLnN0YXJ0c1dpdGgoXFxcXFxcXCJodHRwXFxcXFxcXCIpKSBjb250aW51ZTtcXFxcbiAgICAgIGF3YWl0IGNhY2hlVXJsSW5TZXJ2aWNlV29ya2VyKHJlcSkuY2F0Y2goZSA9PiB7XFxcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XFxcXG4gICAgICB9KTtcXFxcbiAgICB9XFxcXG4gIH1cXFxcbn1cXFxcbmZ1bmN0aW9uIHNldHVwU2VydmljZVdvcmtlcih0YXJnZXRPcmlnaW4sIGNhY2hlQ2FsbGJhY2spIHtcXFxcbiAgLy8gcmVnaXN0ZXIgc2VydmljZSB3b3JrZXIgZm9yIG9mZmxpbmUgYWNjZXNzXFxcXG4gIGlmIChcXFxcXFxcInNlcnZpY2VXb3JrZXJcXFxcXFxcIiBpbiBuYXZpZ2F0b3IpIHtcXFxcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcXFxcXFxcImxvYWRcXFxcXFxcIiwgZnVuY3Rpb24gKCkge1xcXFxuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIoXFxcXFxcXCIvcGx1Z2luLXNlcnZpY2Utd29ya2VyLmpzXFxcXFxcXCIpLnRoZW4oZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbikge1xcXFxuICAgICAgICAvLyBSZWdpc3RyYXRpb24gd2FzIHN1Y2Nlc3NmdWxcXFxcbiAgICAgICAgY29uc29sZS5sb2coXFxcXFxcXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBzdWNjZXNzZnVsIHdpdGggc2NvcGU6IFxcXFxcXFwiLCByZWdpc3RyYXRpb24uc2NvcGUpO1xcXFxuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xcXFxuICAgICAgICAvLyByZWdpc3RyYXRpb24gZmFpbGVkIDooXFxcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXFxcXFwiU2VydmljZVdvcmtlciByZWdpc3RyYXRpb24gZmFpbGVkOiBcXFxcXFxcIiwgZXJyKTtcXFxcbiAgICAgIH0pO1xcXFxuICAgICAgdGFyZ2V0T3JpZ2luID0gdGFyZ2V0T3JpZ2luIHx8IFxcXFxcXFwiKlxcXFxcXFwiO1xcXFxuICAgICAgY2FjaGVDYWxsYmFjayA9IGNhY2hlQ2FsbGJhY2sgfHwgY2FjaGVSZXF1aXJlbWVudHM7XFxcXG5cXFxcbiAgICAgIGlmIChjYWNoZUNhbGxiYWNrICYmIHR5cGVvZiBjYWNoZUNhbGxiYWNrICE9PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwiY29uZmlnLmNhY2hlX3JlcXVpcmVtZW50cyBtdXN0IGJlIGEgZnVuY3Rpb25cXFxcXFxcIik7XFxcXG4gICAgICB9XFxcXG5cXFxcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXFxcXFwibWVzc2FnZVxcXFxcXFwiLCBmdW5jdGlvbiAoZSkge1xcXFxuICAgICAgICBpZiAodGFyZ2V0T3JpZ2luID09PSBcXFxcXFxcIipcXFxcXFxcIiB8fCBlLm9yaWdpbiA9PT0gdGFyZ2V0T3JpZ2luKSB7XFxcXG4gICAgICAgICAgY29uc3QgbSA9IGUuZGF0YTtcXFxcblxcXFxuICAgICAgICAgIGlmIChtLnR5cGUgPT09IFxcXFxcXFwiY2FjaGVSZXF1aXJlbWVudHNcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgY2FjaGVDYWxsYmFjayhtLnJlcXVpcmVtZW50cyk7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICB9KTtcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxufSAvLyNTb3VyY2UgaHR0cHM6Ly9iaXQubHkvMm5lV2ZKMlxcXFxuXFxcXG5mdW5jdGlvbiB1cmxKb2luKC4uLmFyZ3MpIHtcXFxcbiAgcmV0dXJuIGFyZ3Muam9pbihcXFxcXFxcIi9cXFxcXFxcIikucmVwbGFjZSgvW1xcXFxcXFxcL10rL2csIFxcXFxcXFwiL1xcXFxcXFwiKS5yZXBsYWNlKC9eKC4rKTpcXFxcXFxcXC8vLCBcXFxcXFxcIiQxOi8vXFxcXFxcXCIpLnJlcGxhY2UoL15maWxlOi8sIFxcXFxcXFwiZmlsZTovXFxcXFxcXCIpLnJlcGxhY2UoL1xcXFxcXFxcLyhcXFxcXFxcXD98JnwjW14hXSkvZywgXFxcXFxcXCIkMVxcXFxcXFwiKS5yZXBsYWNlKC9cXFxcXFxcXD8vZywgXFxcXFxcXCImXFxcXFxcXCIpLnJlcGxhY2UoXFxcXFxcXCImXFxcXFxcXCIsIFxcXFxcXFwiP1xcXFxcXFwiKTtcXFxcbn1cXFxcbmNsYXNzIE1lc3NhZ2VFbWl0dGVyIHtcXFxcbiAgY29uc3RydWN0b3IoZGVidWcpIHtcXFxcbiAgICB0aGlzLl9ldmVudF9oYW5kbGVycyA9IHt9O1xcXFxuICAgIHRoaXMuX29uY2VfaGFuZGxlcnMgPSB7fTtcXFxcbiAgICB0aGlzLl9kZWJ1ZyA9IGRlYnVnO1xcXFxuICB9XFxcXG5cXFxcbiAgZW1pdCgpIHtcXFxcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJlbWl0IGlzIG5vdCBpbXBsZW1lbnRlZFxcXFxcXFwiKTtcXFxcbiAgfVxcXFxuXFxcXG4gIG9uKGV2ZW50LCBoYW5kbGVyKSB7XFxcXG4gICAgaWYgKCF0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0pIHtcXFxcbiAgICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xcXFxuICB9XFxcXG5cXFxcbiAgb25jZShldmVudCwgaGFuZGxlcikge1xcXFxuICAgIGhhbmRsZXIuX19fZXZlbnRfcnVuX29uY2UgPSB0cnVlO1xcXFxuICAgIHRoaXMub24oZXZlbnQsIGhhbmRsZXIpO1xcXFxuICB9XFxcXG5cXFxcbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XFxcXG4gICAgaWYgKCFldmVudCAmJiAhaGFuZGxlcikge1xcXFxuICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudHMgaGFuZGxlcnNcXFxcbiAgICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzID0ge307XFxcXG4gICAgfSBlbHNlIGlmIChldmVudCAmJiAhaGFuZGxlcikge1xcXFxuICAgICAgLy8gcmVtb3ZlIGFsbCBoYW5sZGVycyBmb3IgdGhlIGV2ZW50XFxcXG4gICAgICBpZiAodGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdKSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0gPSBbXTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgLy8gcmVtb3ZlIGEgc3BlY2lmaWMgaGFuZGxlclxcXFxuICAgICAgaWYgKHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSkge1xcXFxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0uaW5kZXhPZihoYW5kbGVyKTtcXFxcblxcXFxuICAgICAgICBpZiAoaWR4ID49IDApIHtcXFxcbiAgICAgICAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0uc3BsaWNlKGlkeCwgMSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG4gIH1cXFxcblxcXFxuICBfZmlyZShldmVudCwgZGF0YSkge1xcXFxuICAgIGlmICh0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0pIHtcXFxcbiAgICAgIHZhciBpID0gdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdLmxlbmd0aDtcXFxcblxcXFxuICAgICAgd2hpbGUgKGktLSkge1xcXFxuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdW2ldO1xcXFxuXFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgaGFuZGxlcihkYXRhKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XFxcXG4gICAgICAgIH0gZmluYWxseSB7XFxcXG4gICAgICAgICAgaWYgKGhhbmRsZXIuX19fZXZlbnRfcnVuX29uY2UpIHtcXFxcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaSwgMSk7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICB9XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgIGlmICh0aGlzLl9kZWJ1Zykge1xcXFxuICAgICAgICBjb25zb2xlLndhcm4oXFxcXFxcXCJ1bmhhbmRsZWQgZXZlbnRcXFxcXFxcIiwgZXZlbnQsIGRhdGEpO1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcbiAgfVxcXFxuXFxcXG59Ly8jIHNvdXJjZVVSTD1bbW9kdWxlXVxcXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lMaTl6Y21NdmRYUnBiSE11YW5NdWFuTWlMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk5cGJXcHZlVkpRUXk4dUwzTnlZeTkxZEdsc2N5NXFjejh3TWpWbElsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbVY0Y0c5eWRDQm1kVzVqZEdsdmJpQnlZVzVrU1dRb0tTQjdYRzRnSUhKbGRIVnliaUFvWEc0Z0lDQWdUV0YwYUM1eVlXNWtiMjBvS1Z4dUlDQWdJQ0FnTG5SdlUzUnlhVzVuS0RNMktWeHVJQ0FnSUNBZ0xuTjFZbk4wY2lneUxDQXhNQ2tnS3lCdVpYY2dSR0YwWlNncExtZGxkRlJwYldVb0tWeHVJQ0FwTzF4dWZWeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1pIUjVjR1ZVYjFSNWNHVmtRWEp5WVhrZ1BTQjdYRzRnSUdsdWREZzZJRndpU1c1ME9FRnljbUY1WENJc1hHNGdJR2x1ZERFMk9pQmNJa2x1ZERFMlFYSnlZWGxjSWl4Y2JpQWdhVzUwTXpJNklGd2lTVzUwTXpKQmNuSmhlVndpTEZ4dUlDQjFhVzUwT0RvZ1hDSlZhVzUwT0VGeWNtRjVYQ0lzWEc0Z0lIVnBiblF4TmpvZ1hDSlZhVzUwTVRaQmNuSmhlVndpTEZ4dUlDQjFhVzUwTXpJNklGd2lWV2x1ZERNeVFYSnlZWGxjSWl4Y2JpQWdabXh2WVhRek1qb2dYQ0pHYkc5aGRETXlRWEp5WVhsY0lpeGNiaUFnWm14dllYUTJORG9nWENKR2JHOWhkRFkwUVhKeVlYbGNJaXhjYmlBZ1lYSnlZWGs2SUZ3aVFYSnlZWGxjSWx4dWZUdGNibVY0Y0c5eWRDQmpiMjV6ZENCMGVYQmxaRUZ5Y21GNVZHOUVkSGx3WlNBOUlIdGNiaUFnU1c1ME9FRnljbUY1T2lCY0ltbHVkRGhjSWl4Y2JpQWdTVzUwTVRaQmNuSmhlVG9nWENKcGJuUXhObHdpTEZ4dUlDQkpiblF6TWtGeWNtRjVPaUJjSW1sdWRETXlYQ0lzWEc0Z0lGVnBiblE0UVhKeVlYazZJRndpZFdsdWREaGNJaXhjYmlBZ1ZXbHVkREUyUVhKeVlYazZJRndpZFdsdWRERTJYQ0lzWEc0Z0lGVnBiblF6TWtGeWNtRjVPaUJjSW5WcGJuUXpNbHdpTEZ4dUlDQkdiRzloZERNeVFYSnlZWGs2SUZ3aVpteHZZWFF6TWx3aUxGeHVJQ0JHYkc5aGREWTBRWEp5WVhrNklGd2labXh2WVhRMk5Gd2lMRnh1SUNCQmNuSmhlVG9nWENKaGNuSmhlVndpWEc1OU8xeHVYRzVtZFc1amRHbHZiaUJqWVdOb1pWVnliRWx1VTJWeWRtbGpaVmR2Y210bGNpaDFjbXdwSUh0Y2JpQWdjbVYwZFhKdUlHNWxkeUJRY205dGFYTmxLR1oxYm1OMGFXOXVLSEpsYzI5c2RtVXNJSEpsYW1WamRDa2dlMXh1SUNBZ0lHTnZibk4wSUcxbGMzTmhaMlVnUFNCN1hHNGdJQ0FnSUNCamIyMXRZVzVrT2lCY0ltRmtaRndpTEZ4dUlDQWdJQ0FnZFhKc09pQjFjbXhjYmlBZ0lDQjlPMXh1SUNBZ0lHbG1JQ2doYm1GMmFXZGhkRzl5TG5ObGNuWnBZMlZYYjNKclpYSWdmSHdnSVc1aGRtbG5ZWFJ2Y2k1elpYSjJhV05sVjI5eWEyVnlMbkpsWjJsemRHVnlLU0I3WEc0Z0lDQWdJQ0J5WldwbFkzUW9YQ0pUWlhKMmFXTmxJSGR2Y210bGNpQnBjeUJ1YjNRZ2MzVndjRzl5ZEdWa0xsd2lLVHRjYmlBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNCOVhHNGdJQ0FnWTI5dWMzUWdiV1Z6YzJGblpVTm9ZVzV1Wld3Z1BTQnVaWGNnVFdWemMyRm5aVU5vWVc1dVpXd29LVHRjYmlBZ0lDQnRaWE56WVdkbFEyaGhibTVsYkM1d2IzSjBNUzV2Ym0xbGMzTmhaMlVnUFNCbWRXNWpkR2x2YmlobGRtVnVkQ2tnZTF4dUlDQWdJQ0FnYVdZZ0tHVjJaVzUwTG1SaGRHRWdKaVlnWlhabGJuUXVaR0YwWVM1bGNuSnZjaWtnZTF4dUlDQWdJQ0FnSUNCeVpXcGxZM1FvWlhabGJuUXVaR0YwWVM1bGNuSnZjaWs3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0J5WlhOdmJIWmxLR1YyWlc1MExtUmhkR0VnSmlZZ1pYWmxiblF1WkdGMFlTNXlaWE4xYkhRcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwN1hHNWNiaUFnSUNCcFppQW9ibUYyYVdkaGRHOXlMbk5sY25acFkyVlhiM0pyWlhJZ0ppWWdibUYyYVdkaGRHOXlMbk5sY25acFkyVlhiM0pyWlhJdVkyOXVkSEp2Ykd4bGNpa2dlMXh1SUNBZ0lDQWdibUYyYVdkaGRHOXlMbk5sY25acFkyVlhiM0pyWlhJdVkyOXVkSEp2Ykd4bGNpNXdiM04wVFdWemMyRm5aU2h0WlhOellXZGxMQ0JiWEc0Z0lDQWdJQ0FnSUcxbGMzTmhaMlZEYUdGdWJtVnNMbkJ2Y25ReVhHNGdJQ0FnSUNCZEtUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnY21WcVpXTjBLRndpVTJWeWRtbGpaU0IzYjNKclpYSWdZMjl1ZEhKdmJHeGxjaUJwY3lCdWIzUWdZWFpoYVd4aFlteGxYQ0lwTzF4dUlDQWdJSDFjYmlBZ2ZTazdYRzU5WEc1Y2JtVjRjRzl5ZENCaGMzbHVZeUJtZFc1amRHbHZiaUJqWVdOb1pWSmxjWFZwY21WdFpXNTBjeWh5WlhGMWFYSmxiV1Z1ZEhNcElIdGNiaUFnYVdZZ0tDRkJjbkpoZVM1cGMwRnljbUY1S0hKbGNYVnBjbVZ0Wlc1MGN5a3BJSHRjYmlBZ0lDQnlaWEYxYVhKbGJXVnVkSE50TG1OdlpHVXVjbVZ4ZFdseVpXMWxiblJ6SUQwZ1czSmxjWFZwY21WdFpXNTBjMTA3WEc0Z0lIMWNiaUFnYVdZZ0tISmxjWFZwY21WdFpXNTBjeUFtSmlCeVpYRjFhWEpsYldWdWRITXViR1Z1WjNSb0lENGdNQ2tnZTF4dUlDQWdJR1p2Y2lBb2JHVjBJSEpsY1NCdlppQnlaWEYxYVhKbGJXVnVkSE1wSUh0Y2JpQWdJQ0FnSUM4dmNtVnRiM1psSUhCeVpXWnBlRnh1SUNBZ0lDQWdhV1lnS0hKbGNTNXpkR0Z5ZEhOWGFYUm9LRndpYW5NNlhDSXBLU0J5WlhFZ1BTQnlaWEV1YzJ4cFkyVW9NeWs3WEc0Z0lDQWdJQ0JwWmlBb2NtVnhMbk4wWVhKMGMxZHBkR2dvWENKamMzTTZYQ0lwS1NCeVpYRWdQU0J5WlhFdWMyeHBZMlVvTkNrN1hHNGdJQ0FnSUNCcFppQW9jbVZ4TG5OMFlYSjBjMWRwZEdnb1hDSmpZV05vWlRwY0lpa3BJSEpsY1NBOUlISmxjUzV6YkdsalpTZzJLVHRjYmlBZ0lDQWdJR2xtSUNnaGNtVnhMbk4wWVhKMGMxZHBkR2dvWENKb2RIUndYQ0lwS1NCamIyNTBhVzUxWlR0Y2JseHVJQ0FnSUNBZ1lYZGhhWFFnWTJGamFHVlZjbXhKYmxObGNuWnBZMlZYYjNKclpYSW9jbVZ4S1M1allYUmphQ2hsSUQwK0lIdGNiaUFnSUNBZ0lDQWdZMjl1YzI5c1pTNWxjbkp2Y2lobEtUdGNiaUFnSUNBZ0lIMHBPMXh1SUNBZ0lIMWNiaUFnZlZ4dWZWeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdjMlYwZFhCVFpYSjJhV05sVjI5eWEyVnlLSFJoY21kbGRFOXlhV2RwYml3Z1kyRmphR1ZEWVd4c1ltRmpheWtnZTF4dUlDQXZMeUJ5WldkcGMzUmxjaUJ6WlhKMmFXTmxJSGR2Y210bGNpQm1iM0lnYjJabWJHbHVaU0JoWTJObGMzTmNiaUFnYVdZZ0tGd2ljMlZ5ZG1salpWZHZjbXRsY2x3aUlHbHVJRzVoZG1sbllYUnZjaWtnZTF4dUlDQWdJSGRwYm1SdmR5NWhaR1JGZG1WdWRFeHBjM1JsYm1WeUtGd2liRzloWkZ3aUxDQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJRzVoZG1sbllYUnZjaTV6WlhKMmFXTmxWMjl5YTJWeUxuSmxaMmx6ZEdWeUtGd2lMM0JzZFdkcGJpMXpaWEoyYVdObExYZHZjbXRsY2k1cWMxd2lLUzUwYUdWdUtGeHVJQ0FnSUNBZ0lDQm1kVzVqZEdsdmJpaHlaV2RwYzNSeVlYUnBiMjRwSUh0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJTWldkcGMzUnlZWFJwYjI0Z2QyRnpJSE4xWTJObGMzTm1kV3hjYmlBZ0lDQWdJQ0FnSUNCamIyNXpiMnhsTG14dlp5aGNiaUFnSUNBZ0lDQWdJQ0FnSUZ3aVUyVnlkbWxqWlZkdmNtdGxjaUJ5WldkcGMzUnlZWFJwYjI0Z2MzVmpZMlZ6YzJaMWJDQjNhWFJvSUhOamIzQmxPaUJjSWl4Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsWjJsemRISmhkR2x2Ymk1elkyOXdaVnh1SUNBZ0lDQWdJQ0FnSUNrN1hHNGdJQ0FnSUNBZ0lIMHNYRzRnSUNBZ0lDQWdJR1oxYm1OMGFXOXVLR1Z5Y2lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQzh2SUhKbFoybHpkSEpoZEdsdmJpQm1ZV2xzWldRZ09paGNiaUFnSUNBZ0lDQWdJQ0JqYjI1emIyeGxMbXh2WnloY0lsTmxjblpwWTJWWGIzSnJaWElnY21WbmFYTjBjbUYwYVc5dUlHWmhhV3hsWkRvZ1hDSXNJR1Z5Y2lrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDazdYRzRnSUNBZ0lDQjBZWEpuWlhSUGNtbG5hVzRnUFNCMFlYSm5aWFJQY21sbmFXNGdmSHdnWENJcVhDSTdYRzRnSUNBZ0lDQmpZV05vWlVOaGJHeGlZV05ySUQwZ1kyRmphR1ZEWVd4c1ltRmpheUI4ZkNCallXTm9aVkpsY1hWcGNtVnRaVzUwY3p0Y2JpQWdJQ0FnSUdsbUlDaGpZV05vWlVOaGJHeGlZV05ySUNZbUlIUjVjR1Z2WmlCallXTm9aVU5oYkd4aVlXTnJJQ0U5UFNCY0ltWjFibU4wYVc5dVhDSXBJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLRndpWTI5dVptbG5MbU5oWTJobFgzSmxjWFZwY21WdFpXNTBjeUJ0ZFhOMElHSmxJR0VnWm5WdVkzUnBiMjVjSWlrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCM2FXNWtiM2N1WVdSa1JYWmxiblJNYVhOMFpXNWxjaWhjSW0xbGMzTmhaMlZjSWl3Z1puVnVZM1JwYjI0b1pTa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2RHRnlaMlYwVDNKcFoybHVJRDA5UFNCY0lpcGNJaUI4ZkNCbExtOXlhV2RwYmlBOVBUMGdkR0Z5WjJWMFQzSnBaMmx1S1NCN1hHNGdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2JTQTlJR1V1WkdGMFlUdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2JTNTBlWEJsSUQwOVBTQmNJbU5oWTJobFVtVnhkV2x5WlcxbGJuUnpYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR05oWTJobFEyRnNiR0poWTJzb2JTNXlaWEYxYVhKbGJXVnVkSE1wTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmU2s3WEc0Z0lDQWdmU2s3WEc0Z0lIMWNibjFjYmx4dUx5OGpVMjkxY21ObElHaDBkSEJ6T2k4dlltbDBMbXg1THpKdVpWZG1TakpjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUIxY214S2IybHVLQzR1TG1GeVozTXBJSHRjYmlBZ2NtVjBkWEp1SUdGeVozTmNiaUFnSUNBdWFtOXBiaWhjSWk5Y0lpbGNiaUFnSUNBdWNtVndiR0ZqWlNndlcxeGNMMTByTDJjc0lGd2lMMXdpS1Z4dUlDQWdJQzV5WlhCc1lXTmxLQzllS0M0cktUcGNYQzh2TENCY0lpUXhPaTh2WENJcFhHNGdJQ0FnTG5KbGNHeGhZMlVvTDE1bWFXeGxPaThzSUZ3aVptbHNaVG92WENJcFhHNGdJQ0FnTG5KbGNHeGhZMlVvTDF4Y0x5aGNYRDk4Sm53alcxNGhYU2t2Wnl3Z1hDSWtNVndpS1Z4dUlDQWdJQzV5WlhCc1lXTmxLQzljWEQ4dlp5d2dYQ0ltWENJcFhHNGdJQ0FnTG5KbGNHeGhZMlVvWENJbVhDSXNJRndpUDF3aUtUdGNibjFjYmx4dVpYaHdiM0owSUdOc1lYTnpJRTFsYzNOaFoyVkZiV2wwZEdWeUlIdGNiaUFnWTI5dWMzUnlkV04wYjNJb1pHVmlkV2NwSUh0Y2JpQWdJQ0IwYUdsekxsOWxkbVZ1ZEY5b1lXNWtiR1Z5Y3lBOUlIdDlPMXh1SUNBZ0lIUm9hWE11WDI5dVkyVmZhR0Z1Wkd4bGNuTWdQU0I3ZlR0Y2JpQWdJQ0IwYUdsekxsOWtaV0oxWnlBOUlHUmxZblZuTzF4dUlDQjlYRzRnSUdWdGFYUW9LU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtGd2laVzFwZENCcGN5QnViM1FnYVcxd2JHVnRaVzUwWldSY0lpazdYRzRnSUgxY2JpQWdiMjRvWlhabGJuUXNJR2hoYm1Sc1pYSXBJSHRjYmlBZ0lDQnBaaUFvSVhSb2FYTXVYMlYyWlc1MFgyaGhibVJzWlhKelcyVjJaVzUwWFNrZ2UxeHVJQ0FnSUNBZ2RHaHBjeTVmWlhabGJuUmZhR0Z1Wkd4bGNuTmJaWFpsYm5SZElEMGdXMTA3WEc0Z0lDQWdmVnh1SUNBZ0lIUm9hWE11WDJWMlpXNTBYMmhoYm1Sc1pYSnpXMlYyWlc1MFhTNXdkWE5vS0doaGJtUnNaWElwTzF4dUlDQjlYRzRnSUc5dVkyVW9aWFpsYm5Rc0lHaGhibVJzWlhJcElIdGNiaUFnSUNCb1lXNWtiR1Z5TGw5ZlgyVjJaVzUwWDNKMWJsOXZibU5sSUQwZ2RISjFaVHRjYmlBZ0lDQjBhR2x6TG05dUtHVjJaVzUwTENCb1lXNWtiR1Z5S1R0Y2JpQWdmVnh1SUNCdlptWW9aWFpsYm5Rc0lHaGhibVJzWlhJcElIdGNiaUFnSUNCcFppQW9JV1YyWlc1MElDWW1JQ0ZvWVc1a2JHVnlLU0I3WEc0Z0lDQWdJQ0F2THlCeVpXMXZkbVVnWVd4c0lHVjJaVzUwY3lCb1lXNWtiR1Z5YzF4dUlDQWdJQ0FnZEdocGN5NWZaWFpsYm5SZmFHRnVaR3hsY25NZ1BTQjdmVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLR1YyWlc1MElDWW1JQ0ZvWVc1a2JHVnlLU0I3WEc0Z0lDQWdJQ0F2THlCeVpXMXZkbVVnWVd4c0lHaGhibXhrWlhKeklHWnZjaUIwYUdVZ1pYWmxiblJjYmlBZ0lDQWdJR2xtSUNoMGFHbHpMbDlsZG1WdWRGOW9ZVzVrYkdWeWMxdGxkbVZ1ZEYwcElIUm9hWE11WDJWMlpXNTBYMmhoYm1Sc1pYSnpXMlYyWlc1MFhTQTlJRnRkTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQXZMeUJ5WlcxdmRtVWdZU0J6Y0dWamFXWnBZeUJvWVc1a2JHVnlYRzRnSUNBZ0lDQnBaaUFvZEdocGN5NWZaWFpsYm5SZmFHRnVaR3hsY25OYlpYWmxiblJkS1NCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUdsa2VDQTlJSFJvYVhNdVgyVjJaVzUwWDJoaGJtUnNaWEp6VzJWMlpXNTBYUzVwYm1SbGVFOW1LR2hoYm1Sc1pYSXBPMXh1SUNBZ0lDQWdJQ0JwWmlBb2FXUjRJRDQ5SURBcElIdGNiaUFnSUNBZ0lDQWdJQ0IwYUdsekxsOWxkbVZ1ZEY5b1lXNWtiR1Z5YzF0bGRtVnVkRjB1YzNCc2FXTmxLR2xrZUN3Z01TazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUgxY2JpQWdYMlpwY21Vb1pYWmxiblFzSUdSaGRHRXBJSHRjYmlBZ0lDQnBaaUFvZEdocGN5NWZaWFpsYm5SZmFHRnVaR3hsY25OYlpYWmxiblJkS1NCN1hHNGdJQ0FnSUNCMllYSWdhU0E5SUhSb2FYTXVYMlYyWlc1MFgyaGhibVJzWlhKelcyVjJaVzUwWFM1c1pXNW5kR2c3WEc0Z0lDQWdJQ0IzYUdsc1pTQW9hUzB0S1NCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUdoaGJtUnNaWElnUFNCMGFHbHpMbDlsZG1WdWRGOW9ZVzVrYkdWeWMxdGxkbVZ1ZEYxYmFWMDdYRzRnSUNBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lDQWdhR0Z1Wkd4bGNpaGtZWFJoS1R0Y2JpQWdJQ0FnSUNBZ2ZTQmpZWFJqYUNBb1pTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdOdmJuTnZiR1V1WlhKeWIzSW9aU2s3WEc0Z0lDQWdJQ0FnSUgwZ1ptbHVZV3hzZVNCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0doaGJtUnNaWEl1WDE5ZlpYWmxiblJmY25WdVgyOXVZMlVwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyVjJaVzUwWDJoaGJtUnNaWEp6VzJWMlpXNTBYUzV6Y0d4cFkyVW9hU3dnTVNrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHbG1JQ2gwYUdsekxsOWtaV0oxWnlrZ2UxeHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExuZGhjbTRvWENKMWJtaGhibVJzWldRZ1pYWmxiblJjSWl3Z1pYWmxiblFzSUdSaGRHRXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnZlZ4dWZWeHVJbDBzSW0xaGNIQnBibWR6SWpvaVFVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkRRVHRCUVV0Qk8wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGVVFUdEJRVmRCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlZFRTdRVUZEUVR0QlFWZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGR1FUdEJRVU5CTzBGQlIwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVWRCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZGUVR0QlFVTkJPMEZCU1VFN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlJVRTdRVUZEUVR0QlFWRkJPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGNlJFRWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUluMD1cXFxcbi8vIyBzb3VyY2VVUkw9d2VicGFjay1pbnRlcm5hbDovLy8uL3NyYy91dGlscy5qc1xcXFxuXFxcIik7XFxuXFxuLyoqKi8gfSlcXG5cXG4vKioqKioqLyB9KTtcIiwgbnVsbCk7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/plugin.webworker.js\n");

/***/ }),

/***/ "./src/pluginCore.js":
/*!***************************!*\
  !*** ./src/pluginCore.js ***!
  \***************************/
/*! exports provided: connectRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connectRPC\", function() { return connectRPC; });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/**\n * Core plugin script loaded into the plugin process/thread.\n *\n * Initializes the plugin-site API global methods.\n */\n\nfunction connectRPC(connection, config) {\n  config = config || {};\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config);\n  rpc.on(\"getInterface\", function () {\n    launchConnected();\n  });\n  rpc.on(\"remoteReady\", function () {\n    const api = rpc.getRemote() || {};\n\n    if (api.export) {\n      throw new Error(\"`export` is a reserved function name\");\n    }\n\n    if (api.onload) {\n      throw new Error(\"`onload` is a reserved function name\");\n    }\n\n    if (api.dispose) {\n      throw new Error(\"`dispose` is a reserved function name\");\n    }\n\n    api.export = function (_interface) {\n      rpc.setInterface(_interface);\n    };\n\n    api.onLoad = function (handler) {\n      handler = checkHandler(handler);\n\n      if (connected) {\n        handler();\n      } else {\n        connectedHandlers.push(handler);\n      }\n    };\n\n    api.dispose = function (_interface) {\n      rpc.disconnect();\n    };\n\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n      self.api = api;\n      self.postMessage({\n        type: \"imjoy_remote_api_ready\"\n      });\n    } else if (typeof window) {\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: api\n      }));\n    }\n  });\n  let connected = false;\n  const connectedHandlers = [];\n\n  const launchConnected = function () {\n    if (!connected) {\n      connected = true;\n      let handler;\n\n      while (handler = connectedHandlers.pop()) {\n        handler();\n      }\n    }\n  };\n\n  const checkHandler = function (handler) {\n    const type = typeof handler;\n\n    if (type !== \"function\") {\n      const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\n      throw new Error(msg);\n    }\n\n    return handler;\n  };\n\n  return rpc;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luQ29yZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbkNvcmUuanM/YTgxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcmUgcGx1Z2luIHNjcmlwdCBsb2FkZWQgaW50byB0aGUgcGx1Z2luIHByb2Nlc3MvdGhyZWFkLlxuICpcbiAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4tc2l0ZSBBUEkgZ2xvYmFsIG1ldGhvZHMuXG4gKi9cbmltcG9ydCB7IFJQQyB9IGZyb20gXCIuL3JwYy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdFJQQyhjb25uZWN0aW9uLCBjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gIGNvbnN0IHJwYyA9IG5ldyBSUEMoY29ubmVjdGlvbiwgY29uZmlnKTtcbiAgcnBjLm9uKFwiZ2V0SW50ZXJmYWNlXCIsIGZ1bmN0aW9uKCkge1xuICAgIGxhdW5jaENvbm5lY3RlZCgpO1xuICB9KTtcblxuICBycGMub24oXCJyZW1vdGVSZWFkeVwiLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBhcGkgPSBycGMuZ2V0UmVtb3RlKCkgfHwge307XG4gICAgaWYgKGFwaS5leHBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBleHBvcnRgIGlzIGEgcmVzZXJ2ZWQgZnVuY3Rpb24gbmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5vbmxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBvbmxvYWRgIGlzIGEgcmVzZXJ2ZWQgZnVuY3Rpb24gbmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5kaXNwb3NlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGlzcG9zZWAgaXMgYSByZXNlcnZlZCBmdW5jdGlvbiBuYW1lXCIpO1xuICAgIH1cbiAgICBhcGkuZXhwb3J0ID0gZnVuY3Rpb24oX2ludGVyZmFjZSkge1xuICAgICAgcnBjLnNldEludGVyZmFjZShfaW50ZXJmYWNlKTtcbiAgICB9O1xuICAgIGFwaS5vbkxvYWQgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyID0gY2hlY2tIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICBoYW5kbGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25uZWN0ZWRIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgYXBpLmRpc3Bvc2UgPSBmdW5jdGlvbihfaW50ZXJmYWNlKSB7XG4gICAgICBycGMuZGlzY29ubmVjdCgpO1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZVxuICAgICkge1xuICAgICAgc2VsZi5hcGkgPSBhcGk7XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJpbWpveV9yZW1vdGVfYXBpX3JlYWR5XCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdykge1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudChcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIiwgeyBkZXRhaWw6IGFwaSB9KVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxldCBjb25uZWN0ZWQgPSBmYWxzZTtcbiAgY29uc3QgY29ubmVjdGVkSGFuZGxlcnMgPSBbXTtcblxuICBjb25zdCBsYXVuY2hDb25uZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWNvbm5lY3RlZCkge1xuICAgICAgY29ubmVjdGVkID0gdHJ1ZTtcblxuICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICB3aGlsZSAoKGhhbmRsZXIgPSBjb25uZWN0ZWRIYW5kbGVycy5wb3AoKSkpIHtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBjaGVja0hhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBoYW5kbGVyO1xuICAgIGlmICh0eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IG1zZyA9XG4gICAgICAgIFwiQSBmdW5jdGlvbiBtYXkgb25seSBiZSBzdWJzcmliZWQgdG8gdGhlIGV2ZW50LCBcIiArXG4gICAgICAgIHR5cGUgK1xuICAgICAgICBcIiB3YXMgcHJvdmlkZWQgaW5zdGVhZFwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyO1xuICB9O1xuXG4gIHJldHVybiBycGM7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pluginCore.js\n");

/***/ }),

/***/ "./src/pluginIframe.js":
/*!*****************************!*\
  !*** ./src/pluginIframe.js ***!
  \*****************************/
/*! exports provided: Connection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Connection\", function() { return Connection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return setupIframe; });\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/**\n * Contains the routines loaded by the plugin iframe under web-browser\n * in case when worker failed to initialize\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\n\n\n // Create a new, plain <span> element\n\nfunction _htmlToElement(html) {\n  var template = document.createElement(\"template\");\n  html = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = html;\n  return template.content.firstChild;\n}\n\nvar _importScript = function (url) {\n  //url is URL of external file, implementationCode is the code\n  //to be called from the file, location is the location to\n  //insert the <script> element\n  return new Promise((resolve, reject) => {\n    var scriptTag = document.createElement(\"script\");\n    scriptTag.src = url;\n    scriptTag.type = \"text/javascript\";\n    scriptTag.onload = resolve;\n\n    scriptTag.onreadystatechange = function () {\n      if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n        resolve();\n      }\n    };\n\n    scriptTag.onerror = reject;\n    document.head.appendChild(scriptTag);\n  });\n}; // support importScripts outside web worker\n\n\nasync function importScripts() {\n  var args = Array.prototype.slice.call(arguments),\n      len = args.length,\n      i = 0;\n\n  for (; i < len; i++) {\n    await _importScript(args[i]);\n  }\n}\n\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\n  constructor(config) {\n    super(config && config.debug);\n    this.config = config || {};\n    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n  }\n\n  connect() {\n    this.config.target_origin = this.config.target_origin || \"*\"; // this will call handleEvent function\n\n    window.addEventListener(\"message\", this);\n    this.emit({\n      type: \"initialized\",\n      config: this.config,\n      origin: window.location.origin,\n      peer_id: this.peer_id\n    });\n\n    this._fire(\"connected\");\n  }\n\n  handleEvent(e) {\n    if (e.type === \"message\" && (this.config.target_origin === \"*\" || e.origin === this.config.target_origin)) {\n      if (e.data.peer_id === this.peer_id) {\n        this._fire(e.data.type, e.data);\n      } else if (this.config.debug) {\n        console.log(`connection peer id mismatch ${e.data.peer_id} !== ${this.peer_id}`);\n      }\n    }\n  }\n\n  disconnect() {\n    this._fire(\"beforeDisconnect\");\n\n    window.removeEventListener(\"message\", this);\n\n    this._fire(\"disconnected\");\n  }\n\n  emit(data) {\n    let transferables;\n\n    if (data.__transferables__) {\n      transferables = data.__transferables__;\n      delete data.__transferables__;\n    }\n\n    parent.postMessage(data, this.config.target_origin, transferables);\n  }\n\n  async execute(code) {\n    try {\n      if (code.type === \"requirements\") {\n        if (code.requirements && (Array.isArray(code.requirements) || typeof code.requirements === \"string\")) {\n          try {\n            var link_node;\n            code.requirements = typeof code.requirements === \"string\" ? [code.requirements] : code.requirements;\n\n            if (Array.isArray(code.requirements)) {\n              for (var i = 0; i < code.requirements.length; i++) {\n                if (code.requirements[i].toLowerCase().endsWith(\".css\") || code.requirements[i].startsWith(\"css:\")) {\n                  if (code.requirements[i].startsWith(\"css:\")) {\n                    code.requirements[i] = code.requirements[i].slice(4);\n                  }\n\n                  link_node = document.createElement(\"link\");\n                  link_node.rel = \"stylesheet\";\n                  link_node.href = code.requirements[i];\n                  document.head.appendChild(link_node);\n                } else if (code.requirements[i].toLowerCase().endsWith(\".js\") || code.requirements[i].startsWith(\"js:\")) {\n                  if (code.requirements[i].startsWith(\"js:\")) {\n                    code.requirements[i] = code.requirements[i].slice(3);\n                  }\n\n                  await importScripts(code.requirements[i]);\n                } else if (code.requirements[i].startsWith(\"http\")) {\n                  await importScripts(code.requirements[i]);\n                } else if (code.requirements[i].startsWith(\"cache:\")) {//ignore cache\n                } else {\n                  console.log(\"Unprocessed requirements url: \" + code.requirements[i]);\n                }\n              }\n            } else {\n              throw \"unsupported requirements definition\";\n            }\n          } catch (e) {\n            throw \"failed to import required scripts: \" + code.requirements.toString();\n          }\n        }\n      } else if (code.type === \"script\") {\n        if (code.src) {\n          var script_node = document.createElement(\"script\");\n          script_node.setAttribute(\"type\", code.attrs.type);\n          script_node.setAttribute(\"src\", code.src);\n          document.head.appendChild(script_node);\n        } else {\n          if (code.content && (!code.attrs.type || code.attrs.type === \"text/javascript\")) {\n            // document.addEventListener(\"DOMContentLoaded\", function(){\n            eval(code.content); // });\n          } else {\n            var node = document.createElement(\"script\");\n            node.setAttribute(\"type\", code.attrs.type);\n            node.appendChild(document.createTextNode(code.content));\n            document.body.appendChild(node);\n          }\n        }\n      } else if (code.type === \"style\") {\n        const style_node = document.createElement(\"style\");\n\n        if (code.src) {\n          style_node.src = code.src;\n        }\n\n        style_node.innerHTML = code.content;\n        document.head.appendChild(style_node);\n      } else if (code.type === \"link\") {\n        const link_node_ = document.createElement(\"link\");\n\n        if (code.rel) {\n          link_node_.rel = code.rel;\n        }\n\n        if (code.href) {\n          link_node_.href = code.href;\n        }\n\n        if (code.attrs && code.attrs.type) {\n          link_node_.type = code.attrs.type;\n        }\n\n        document.head.appendChild(link_node_);\n      } else if (code.type === \"html\") {\n        document.body.appendChild(_htmlToElement(code.content));\n      } else {\n        throw \"unsupported code type.\";\n      }\n\n      parent.postMessage({\n        type: \"executed\"\n      }, this.config.target_origin);\n    } catch (e) {\n      console.error(\"failed to execute scripts: \", code, e);\n      parent.postMessage({\n        type: \"executed\",\n        error: e.stack || String(e)\n      }, this.config.target_origin);\n    }\n  }\n\n}\nfunction setupIframe(config) {\n  config = config || {};\n  config.dedicated_thread = false;\n  config.lang = \"javascript\";\n  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n  const conn = new Connection(config);\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n  conn.connect();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luSWZyYW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9zcmMvcGx1Z2luSWZyYW1lLmpzPzI2NzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyB0aGUgcm91dGluZXMgbG9hZGVkIGJ5IHRoZSBwbHVnaW4gaWZyYW1lIHVuZGVyIHdlYi1icm93c2VyXG4gKiBpbiBjYXNlIHdoZW4gd29ya2VyIGZhaWxlZCB0byBpbml0aWFsaXplXG4gKlxuICogSW5pdGlhbGl6ZXMgdGhlIHdlYiBlbnZpcm9ubWVudCB2ZXJzaW9uIG9mIHRoZSBwbGF0Zm9ybS1kZXBlbmRlbnRcbiAqIGNvbm5lY3Rpb24gb2JqZWN0IGZvciB0aGUgcGx1Z2luIHNpdGVcbiAqL1xuaW1wb3J0IHsgY29ubmVjdFJQQyB9IGZyb20gXCIuL3BsdWdpbkNvcmUuanNcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OIH0gZnJvbSBcIi4vcnBjLmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlRW1pdHRlciwgcmFuZElkIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIENyZWF0ZSBhIG5ldywgcGxhaW4gPHNwYW4+IGVsZW1lbnRcbmZ1bmN0aW9uIF9odG1sVG9FbGVtZW50KGh0bWwpIHtcbiAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICBodG1sID0gaHRtbC50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZDtcbn1cblxudmFyIF9pbXBvcnRTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgLy91cmwgaXMgVVJMIG9mIGV4dGVybmFsIGZpbGUsIGltcGxlbWVudGF0aW9uQ29kZSBpcyB0aGUgY29kZVxuICAvL3RvIGJlIGNhbGxlZCBmcm9tIHRoZSBmaWxlLCBsb2NhdGlvbiBpcyB0aGUgbG9jYXRpb24gdG9cbiAgLy9pbnNlcnQgdGhlIDxzY3JpcHQ+IGVsZW1lbnRcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBzY3JpcHRUYWcuc3JjID0gdXJsO1xuICAgIHNjcmlwdFRhZy50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcbiAgICBzY3JpcHRUYWcub25sb2FkID0gcmVzb2x2ZTtcbiAgICBzY3JpcHRUYWcub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBcImxvYWRlZFwiIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNjcmlwdFRhZy5vbmVycm9yID0gcmVqZWN0O1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0VGFnKTtcbiAgfSk7XG59O1xuXG4vLyBzdXBwb3J0IGltcG9ydFNjcmlwdHMgb3V0c2lkZSB3ZWIgd29ya2VyXG5hc3luYyBmdW5jdGlvbiBpbXBvcnRTY3JpcHRzKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgbGVuID0gYXJncy5sZW5ndGgsXG4gICAgaSA9IDA7XG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhd2FpdCBfaW1wb3J0U2NyaXB0KGFyZ3NbaV0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uIGV4dGVuZHMgTWVzc2FnZUVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcihjb25maWcgJiYgY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLnBlZXJfaWQgPSByYW5kSWQoKTtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIHRoaXMuY29uZmlnLnRhcmdldF9vcmlnaW4gPSB0aGlzLmNvbmZpZy50YXJnZXRfb3JpZ2luIHx8IFwiKlwiO1xuICAgIC8vIHRoaXMgd2lsbCBjYWxsIGhhbmRsZUV2ZW50IGZ1bmN0aW9uXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMpO1xuICAgIHRoaXMuZW1pdCh7XG4gICAgICB0eXBlOiBcImluaXRpYWxpemVkXCIsXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgcGVlcl9pZDogdGhpcy5wZWVyX2lkXG4gICAgfSk7XG4gICAgdGhpcy5fZmlyZShcImNvbm5lY3RlZFwiKTtcbiAgfVxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgaWYgKFxuICAgICAgZS50eXBlID09PSBcIm1lc3NhZ2VcIiAmJlxuICAgICAgKHRoaXMuY29uZmlnLnRhcmdldF9vcmlnaW4gPT09IFwiKlwiIHx8XG4gICAgICAgIGUub3JpZ2luID09PSB0aGlzLmNvbmZpZy50YXJnZXRfb3JpZ2luKVxuICAgICkge1xuICAgICAgaWYgKGUuZGF0YS5wZWVyX2lkID09PSB0aGlzLnBlZXJfaWQpIHtcbiAgICAgICAgdGhpcy5fZmlyZShlLmRhdGEudHlwZSwgZS5kYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYGNvbm5lY3Rpb24gcGVlciBpZCBtaXNtYXRjaCAke2UuZGF0YS5wZWVyX2lkfSAhPT0gJHt0aGlzLnBlZXJfaWR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuX2ZpcmUoXCJiZWZvcmVEaXNjb25uZWN0XCIpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzKTtcbiAgICB0aGlzLl9maXJlKFwiZGlzY29ubmVjdGVkXCIpO1xuICB9XG4gIGVtaXQoZGF0YSkge1xuICAgIGxldCB0cmFuc2ZlcmFibGVzO1xuICAgIGlmIChkYXRhLl9fdHJhbnNmZXJhYmxlc19fKSB7XG4gICAgICB0cmFuc2ZlcmFibGVzID0gZGF0YS5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgIGRlbGV0ZSBkYXRhLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgIH1cbiAgICBwYXJlbnQucG9zdE1lc3NhZ2UoZGF0YSwgdGhpcy5jb25maWcudGFyZ2V0X29yaWdpbiwgdHJhbnNmZXJhYmxlcyk7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZShjb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChjb2RlLnR5cGUgPT09IFwicmVxdWlyZW1lbnRzXCIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzICYmXG4gICAgICAgICAgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbGlua19ub2RlO1xuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgPVxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IFtjb2RlLnJlcXVpcmVtZW50c11cbiAgICAgICAgICAgICAgICA6IGNvZGUucmVxdWlyZW1lbnRzO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZS5yZXF1aXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmNzc1wiKSB8fFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImNzczpcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY3NzOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGlua19ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICAgICAgICBsaW5rX25vZGUucmVsID0gXCJzdHlsZXNoZWV0XCI7XG4gICAgICAgICAgICAgICAgICBsaW5rX25vZGUuaHJlZiA9IGNvZGUucmVxdWlyZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rX25vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmpzXCIpIHx8XG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwianM6XCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImpzOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYXdhaXQgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY2FjaGU6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAvL2lnbm9yZSBjYWNoZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgXCJVbnByb2Nlc3NlZCByZXF1aXJlbWVudHMgdXJsOiBcIiArIGNvZGUucmVxdWlyZW1lbnRzW2ldXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCByZXF1aXJlbWVudHMgZGVmaW5pdGlvblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IFwiZmFpbGVkIHRvIGltcG9ydCByZXF1aXJlZCBzY3JpcHRzOiBcIiArXG4gICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUudHlwZSA9PT0gXCJzY3JpcHRcIikge1xuICAgICAgICBpZiAoY29kZS5zcmMpIHtcbiAgICAgICAgICB2YXIgc2NyaXB0X25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgIHNjcmlwdF9ub2RlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgY29kZS5hdHRycy50eXBlKTtcbiAgICAgICAgICBzY3JpcHRfbm9kZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgY29kZS5zcmMpO1xuICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0X25vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvZGUuY29udGVudCAmJlxuICAgICAgICAgICAgKCFjb2RlLmF0dHJzLnR5cGUgfHwgY29kZS5hdHRycy50eXBlID09PSBcInRleHQvamF2YXNjcmlwdFwiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGV2YWwoY29kZS5jb250ZW50KTtcbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgY29kZS5hdHRycy50eXBlKTtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29kZS5jb250ZW50KSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwic3R5bGVcIikge1xuICAgICAgICBjb25zdCBzdHlsZV9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAoY29kZS5zcmMpIHtcbiAgICAgICAgICBzdHlsZV9ub2RlLnNyYyA9IGNvZGUuc3JjO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlX25vZGUuaW5uZXJIVE1MID0gY29kZS5jb250ZW50O1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlX25vZGUpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwibGlua1wiKSB7XG4gICAgICAgIGNvbnN0IGxpbmtfbm9kZV8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgICAgaWYgKGNvZGUucmVsKSB7XG4gICAgICAgICAgbGlua19ub2RlXy5yZWwgPSBjb2RlLnJlbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZS5ocmVmKSB7XG4gICAgICAgICAgbGlua19ub2RlXy5ocmVmID0gY29kZS5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlLmF0dHJzICYmIGNvZGUuYXR0cnMudHlwZSkge1xuICAgICAgICAgIGxpbmtfbm9kZV8udHlwZSA9IGNvZGUuYXR0cnMudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmtfbm9kZV8pO1xuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX2h0bWxUb0VsZW1lbnQoY29kZS5jb250ZW50KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcInVuc3VwcG9ydGVkIGNvZGUgdHlwZS5cIjtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXhlY3V0ZWRcIiB9LCB0aGlzLmNvbmZpZy50YXJnZXRfb3JpZ2luKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIGV4ZWN1dGUgc2NyaXB0czogXCIsIGNvZGUsIGUpO1xuICAgICAgcGFyZW50LnBvc3RNZXNzYWdlKFxuICAgICAgICB7IHR5cGU6IFwiZXhlY3V0ZWRcIiwgZXJyb3I6IGUuc3RhY2sgfHwgU3RyaW5nKGUpIH0sXG4gICAgICAgIHRoaXMuY29uZmlnLnRhcmdldF9vcmlnaW5cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwSWZyYW1lKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kZWRpY2F0ZWRfdGhyZWFkID0gZmFsc2U7XG4gIGNvbmZpZy5sYW5nID0gXCJqYXZhc2NyaXB0XCI7XG4gIGNvbmZpZy5hcGlfdmVyc2lvbiA9IEFQSV9WRVJTSU9OO1xuICBjb25zdCBjb25uID0gbmV3IENvbm5lY3Rpb24oY29uZmlnKTtcbiAgY29ubmVjdFJQQyhjb25uLCBjb25maWcpO1xuICBjb25uLmNvbm5lY3QoKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQXpKQTtBQTJKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pluginIframe.js\n");

/***/ }),

/***/ "./src/pluginWebPython.js":
/*!********************************!*\
  !*** ./src/pluginWebPython.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return setupWebPython; });\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _pluginIframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pluginIframe */ \"./src/pluginIframe.js\");\n/**\n * Contains the routines loaded by the plugin iframe under web-browser\n * in case when worker failed to initialize\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\n\n\n // Create a new, plain <span> element\n\nfunction _htmlToElement(html) {\n  var template = document.createElement(\"template\");\n  html = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = html;\n  return template.content.firstChild;\n}\n\nconst _importScript = function (url) {\n  //url is URL of external file, implementationCode is the code\n  //to be called from the file, location is the location to\n  //insert the <script> element\n  return new Promise((resolve, reject) => {\n    var scriptTag = document.createElement(\"script\");\n    scriptTag.src = url;\n    scriptTag.onload = resolve;\n\n    scriptTag.onreadystatechange = function () {\n      if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n        resolve();\n      }\n    };\n\n    scriptTag.onerror = reject;\n    document.head.appendChild(scriptTag);\n  });\n}; // support importScripts outside web worker\n\n\nasync function importScripts() {\n  var args = Array.prototype.slice.call(arguments),\n      len = args.length,\n      i = 0;\n\n  for (; i < len; i++) {\n    await _importScript(args[i]);\n  }\n}\n\nconst startup_script = `\nfrom js import api\nimport sys\nfrom types import ModuleType\nm = ModuleType(\"imjoy\")\nsys.modules[m.__name__] = m\nm.__file__ = m.__name__ + \".py\"\nm.api = api\n`;\nlet _export_plugin_api = null;\n\nconst execute_python_code = function (code) {\n  try {\n    if (!_export_plugin_api) {\n      _export_plugin_api = window.api.export;\n\n      window.api.export = function (p) {\n        if (typeof p === \"object\") {\n          const _api = {};\n\n          for (let k in p) {\n            if (!k.startsWith(\"_\")) {\n              _api[k] = p[k];\n            }\n          }\n\n          _export_plugin_api(_api);\n        } else if (typeof p === \"function\") {\n          const _api = {};\n          const getattr = window.pyodide.pyimport(\"getattr\");\n          const hasattr = window.pyodide.pyimport(\"hasattr\");\n\n          for (let k of Object.getOwnPropertyNames(p)) {\n            if (!k.startsWith(\"_\") && hasattr(p, k)) {\n              const func = getattr(p, k);\n\n              _api[k] = function () {\n                return func(...Array.prototype.slice.call(arguments));\n              };\n            }\n          }\n\n          _export_plugin_api(_api);\n        } else {\n          throw \"unsupported api export\";\n        }\n      };\n    }\n\n    window.pyodide.runPython(startup_script);\n    window.pyodide.runPython(code.content);\n  } catch (e) {\n    throw e;\n  }\n};\n\nfunction setupPyodide() {\n  return new Promise((resolve, reject) => {\n    window.languagePluginUrl = \"https://static.imjoy.io/pyodide/\";\n    importScripts(\"https://static.imjoy.io/pyodide/pyodide.js\").then(() => {\n      // hack for matplotlib etc.\n      window.iodide = {\n        output: {\n          element: function element(type) {\n            const div = document.createElement(type);\n            const output = document.getElementById(\"output\") || document.body;\n            output.appendChild(div);\n            return div;\n          }\n        }\n      };\n      window.languagePluginLoader.then(() => {\n        // pyodide is now ready to use...\n        console.log(window.pyodide.runPython(\"import sys\\nsys.version\"));\n        resolve();\n      }).catch(reject);\n    });\n  });\n} // connection object for the RPC constructor\n\n\nclass Connection extends _pluginIframe__WEBPACK_IMPORTED_MODULE_2__[\"Connection\"] {\n  constructor(config) {\n    super(config);\n  }\n\n  async execute(code) {\n    if (code.type === \"requirements\") {\n      if (code.requirements) {\n        code.requirements = typeof code.requirements === \"string\" ? [code.requirements] : code.requirements;\n\n        if (Array.isArray(code.requirements)) {\n          const python_packages = [];\n\n          for (var i = 0; i < code.requirements.length; i++) {\n            if (code.requirements[i].toLowerCase().endsWith(\".css\") || code.requirements[i].startsWith(\"css:\")) {\n              if (code.requirements[i].startsWith(\"css:\")) {\n                code.requirements[i] = code.requirements[i].slice(4);\n              }\n\n              link_node = document.createElement(\"link\");\n              link_node.rel = \"stylesheet\";\n              link_node.href = code.requirements[i];\n              document.head.appendChild(link_node);\n            } else if ( // code.requirements[i].toLowerCase().endsWith(\".js\") ||\n            code.requirements[i].startsWith(\"js:\")) {\n              if (code.requirements[i].startsWith(\"js:\")) {\n                code.requirements[i] = code.requirements[i].slice(3);\n              }\n\n              await importScripts(code.requirements[i]);\n            } else if (code.requirements[i].startsWith(\"cache:\")) {//ignore cache\n            } else if (code.requirements[i].toLowerCase().endsWith(\".js\") || code.requirements[i].startsWith(\"package:\")) {\n              if (code.requirements[i].startsWith(\"package:\")) {\n                code.requirements[i] = code.requirements[i].slice(8);\n              }\n\n              python_packages.push(code.requirements[i]);\n            } else if (code.requirements[i].startsWith(\"http:\") || code.requirements[i].startsWith(\"https:\")) {\n              console.log(\"Unprocessed requirements url: \" + code.requirements[i]);\n            } else {\n              python_packages.push(code.requirements[i]);\n            }\n          }\n\n          await window.pyodide.loadPackage(python_packages);\n        } else {\n          throw \"unsupported requirements definition\";\n        }\n      }\n    } else if (code.type === \"script\") {\n      if (code.src) {\n        var script_node = document.createElement(\"script\");\n        script_node.setAttribute(\"type\", code.attrs.type);\n        script_node.setAttribute(\"src\", code.src);\n        document.head.appendChild(script_node);\n      } else {\n        if (code.content && code.lang === \"python\") {\n          execute_python_code(code);\n        } else if (code.content && code.lang === \"javascript\") {\n          try {\n            eval(code.content);\n          } catch (e) {\n            console.error(e.message, e.stack);\n            throw e;\n          }\n        } else {\n          const node = document.createElement(\"script\");\n          node.setAttribute(\"type\", code.attrs.type);\n          node.appendChild(document.createTextNode(code.content));\n          document.body.appendChild(node);\n        }\n      }\n    } else if (code.type === \"style\") {\n      const style_node = document.createElement(\"style\");\n\n      if (code.src) {\n        style_node.src = code.src;\n      }\n\n      style_node.innerHTML = code.content;\n      document.head.appendChild(style_node);\n    } else if (code.type === \"link\") {\n      const link_node = document.createElement(\"link\");\n\n      if (code.rel) {\n        link_node.rel = code.rel;\n      }\n\n      if (code.href) {\n        link_node.href = code.href;\n      }\n\n      if (code.attrs && code.attrs.type) {\n        link_node.type = code.attrs.type;\n      }\n\n      document.head.appendChild(link_node);\n    } else if (code.type === \"html\") {\n      document.body.appendChild(_htmlToElement(code.content));\n    } else {\n      throw \"unsupported code type.\";\n    }\n  }\n\n}\n\nfunction setupWebPython(config) {\n  config = config || {};\n  config.debug = true;\n  config.dedicated_thread = false;\n  config.lang = \"python\";\n  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n  const conn = new Connection(config);\n  setupPyodide().then(() => {\n    Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n    conn.connect();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luV2ViUHl0aG9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9zcmMvcGx1Z2luV2ViUHl0aG9uLmpzPzYwYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyB0aGUgcm91dGluZXMgbG9hZGVkIGJ5IHRoZSBwbHVnaW4gaWZyYW1lIHVuZGVyIHdlYi1icm93c2VyXG4gKiBpbiBjYXNlIHdoZW4gd29ya2VyIGZhaWxlZCB0byBpbml0aWFsaXplXG4gKlxuICogSW5pdGlhbGl6ZXMgdGhlIHdlYiBlbnZpcm9ubWVudCB2ZXJzaW9uIG9mIHRoZSBwbGF0Zm9ybS1kZXBlbmRlbnRcbiAqIGNvbm5lY3Rpb24gb2JqZWN0IGZvciB0aGUgcGx1Z2luIHNpdGVcbiAqL1xuaW1wb3J0IHsgY29ubmVjdFJQQyB9IGZyb20gXCIuL3BsdWdpbkNvcmUuanNcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OIH0gZnJvbSBcIi4vcnBjLmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0aW9uIGFzIElmcmFtZUNvbm5lY3Rpb24sIGV4ZWN1dGVDb2RlIH0gZnJvbSBcIi4vcGx1Z2luSWZyYW1lXCI7XG4vLyBDcmVhdGUgYSBuZXcsIHBsYWluIDxzcGFuPiBlbGVtZW50XG5mdW5jdGlvbiBfaHRtbFRvRWxlbWVudChodG1sKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgaHRtbCA9IGh0bWwudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG4gIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG59XG5cbmNvbnN0IF9pbXBvcnRTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgLy91cmwgaXMgVVJMIG9mIGV4dGVybmFsIGZpbGUsIGltcGxlbWVudGF0aW9uQ29kZSBpcyB0aGUgY29kZVxuICAvL3RvIGJlIGNhbGxlZCBmcm9tIHRoZSBmaWxlLCBsb2NhdGlvbiBpcyB0aGUgbG9jYXRpb24gdG9cbiAgLy9pbnNlcnQgdGhlIDxzY3JpcHQ+IGVsZW1lbnRcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBzY3JpcHRUYWcuc3JjID0gdXJsO1xuICAgIHNjcmlwdFRhZy5vbmxvYWQgPSByZXNvbHZlO1xuICAgIHNjcmlwdFRhZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwibG9hZGVkXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2NyaXB0VGFnLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRUYWcpO1xuICB9KTtcbn07XG5cbi8vIHN1cHBvcnQgaW1wb3J0U2NyaXB0cyBvdXRzaWRlIHdlYiB3b3JrZXJcblxuYXN5bmMgZnVuY3Rpb24gaW1wb3J0U2NyaXB0cygpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGxlbiA9IGFyZ3MubGVuZ3RoLFxuICAgIGkgPSAwO1xuICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXdhaXQgX2ltcG9ydFNjcmlwdChhcmdzW2ldKTtcbiAgfVxufVxuXG5jb25zdCBzdGFydHVwX3NjcmlwdCA9IGBcbmZyb20ganMgaW1wb3J0IGFwaVxuaW1wb3J0IHN5c1xuZnJvbSB0eXBlcyBpbXBvcnQgTW9kdWxlVHlwZVxubSA9IE1vZHVsZVR5cGUoXCJpbWpveVwiKVxuc3lzLm1vZHVsZXNbbS5fX25hbWVfX10gPSBtXG5tLl9fZmlsZV9fID0gbS5fX25hbWVfXyArIFwiLnB5XCJcbm0uYXBpID0gYXBpXG5gO1xuXG5sZXQgX2V4cG9ydF9wbHVnaW5fYXBpID0gbnVsbDtcbmNvbnN0IGV4ZWN1dGVfcHl0aG9uX2NvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFfZXhwb3J0X3BsdWdpbl9hcGkpIHtcbiAgICAgIF9leHBvcnRfcGx1Z2luX2FwaSA9IHdpbmRvdy5hcGkuZXhwb3J0O1xuICAgICAgd2luZG93LmFwaS5leHBvcnQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGNvbnN0IF9hcGkgPSB7fTtcbiAgICAgICAgICBmb3IgKGxldCBrIGluIHApIHtcbiAgICAgICAgICAgIGlmICghay5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICAgICAgICAgICBfYXBpW2tdID0gcFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX2V4cG9ydF9wbHVnaW5fYXBpKF9hcGkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBfYXBpID0ge307XG4gICAgICAgICAgY29uc3QgZ2V0YXR0ciA9IHdpbmRvdy5weW9kaWRlLnB5aW1wb3J0KFwiZ2V0YXR0clwiKTtcbiAgICAgICAgICBjb25zdCBoYXNhdHRyID0gd2luZG93LnB5b2RpZGUucHlpbXBvcnQoXCJoYXNhdHRyXCIpO1xuICAgICAgICAgIGZvciAobGV0IGsgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocCkpIHtcbiAgICAgICAgICAgIGlmICghay5zdGFydHNXaXRoKFwiX1wiKSAmJiBoYXNhdHRyKHAsIGspKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBnZXRhdHRyKHAsIGspO1xuICAgICAgICAgICAgICBfYXBpW2tdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9leHBvcnRfcGx1Z2luX2FwaShfYXBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcInVuc3VwcG9ydGVkIGFwaSBleHBvcnRcIjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgd2luZG93LnB5b2RpZGUucnVuUHl0aG9uKHN0YXJ0dXBfc2NyaXB0KTtcbiAgICB3aW5kb3cucHlvZGlkZS5ydW5QeXRob24oY29kZS5jb250ZW50KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldHVwUHlvZGlkZSgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3aW5kb3cubGFuZ3VhZ2VQbHVnaW5VcmwgPSBcImh0dHBzOi8vc3RhdGljLmltam95LmlvL3B5b2RpZGUvXCI7XG4gICAgaW1wb3J0U2NyaXB0cyhcImh0dHBzOi8vc3RhdGljLmltam95LmlvL3B5b2RpZGUvcHlvZGlkZS5qc1wiKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIGhhY2sgZm9yIG1hdHBsb3RsaWIgZXRjLlxuICAgICAgd2luZG93LmlvZGlkZSA9IHtcbiAgICAgICAgb3V0cHV0OiB7XG4gICAgICAgICAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudCh0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXRcIikgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIG91dHB1dC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5sYW5ndWFnZVBsdWdpbkxvYWRlclxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgLy8gcHlvZGlkZSBpcyBub3cgcmVhZHkgdG8gdXNlLi4uXG4gICAgICAgICAgY29uc29sZS5sb2cod2luZG93LnB5b2RpZGUucnVuUHl0aG9uKFwiaW1wb3J0IHN5c1xcbnN5cy52ZXJzaW9uXCIpKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9KTtcbn1cbi8vIGNvbm5lY3Rpb24gb2JqZWN0IGZvciB0aGUgUlBDIGNvbnN0cnVjdG9yXG5jbGFzcyBDb25uZWN0aW9uIGV4dGVuZHMgSWZyYW1lQ29ubmVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKGNvbmZpZyk7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZShjb2RlKSB7XG4gICAgaWYgKGNvZGUudHlwZSA9PT0gXCJyZXF1aXJlbWVudHNcIikge1xuICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzKSB7XG4gICAgICAgIGNvZGUucmVxdWlyZW1lbnRzID1cbiAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gW2NvZGUucmVxdWlyZW1lbnRzXVxuICAgICAgICAgICAgOiBjb2RlLnJlcXVpcmVtZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgY29uc3QgcHl0aG9uX3BhY2thZ2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlLnJlcXVpcmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmNzc1wiKSB8fFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY3NzOlwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY3NzOlwiKSkge1xuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldID0gY29kZS5yZXF1aXJlbWVudHNbaV0uc2xpY2UoNCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGlua19ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICAgIGxpbmtfbm9kZS5yZWwgPSBcInN0eWxlc2hlZXRcIjtcbiAgICAgICAgICAgICAgbGlua19ub2RlLmhyZWYgPSBjb2RlLnJlcXVpcmVtZW50c1tpXTtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rX25vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgLy8gY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcIi5qc1wiKSB8fFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwianM6XCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJqczpcIikpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF3YWl0IGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY2FjaGU6XCIpKSB7XG4gICAgICAgICAgICAgIC8vaWdub3JlIGNhY2hlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmpzXCIpIHx8XG4gICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJwYWNrYWdlOlwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwicGFja2FnZTpcIikpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHB5dGhvbl9wYWNrYWdlcy5wdXNoKGNvZGUucmVxdWlyZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSB8fFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiaHR0cHM6XCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCJVbnByb2Nlc3NlZCByZXF1aXJlbWVudHMgdXJsOiBcIiArIGNvZGUucmVxdWlyZW1lbnRzW2ldXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBweXRob25fcGFja2FnZXMucHVzaChjb2RlLnJlcXVpcmVtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHdpbmRvdy5weW9kaWRlLmxvYWRQYWNrYWdlKHB5dGhvbl9wYWNrYWdlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCByZXF1aXJlbWVudHMgZGVmaW5pdGlvblwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgIGlmIChjb2RlLnNyYykge1xuICAgICAgICB2YXIgc2NyaXB0X25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBzY3JpcHRfbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIGNvZGUuYXR0cnMudHlwZSk7XG4gICAgICAgIHNjcmlwdF9ub2RlLnNldEF0dHJpYnV0ZShcInNyY1wiLCBjb2RlLnNyYyk7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0X25vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvZGUuY29udGVudCAmJiBjb2RlLmxhbmcgPT09IFwicHl0aG9uXCIpIHtcbiAgICAgICAgICBleGVjdXRlX3B5dGhvbl9jb2RlKGNvZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUuY29udGVudCAmJiBjb2RlLmxhbmcgPT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2YWwoY29kZS5jb250ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSwgZS5zdGFjayk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgY29kZS5hdHRycy50eXBlKTtcbiAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvZGUuY29udGVudCkpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvZGUudHlwZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICBjb25zdCBzdHlsZV9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgaWYgKGNvZGUuc3JjKSB7XG4gICAgICAgIHN0eWxlX25vZGUuc3JjID0gY29kZS5zcmM7XG4gICAgICB9XG4gICAgICBzdHlsZV9ub2RlLmlubmVySFRNTCA9IGNvZGUuY29udGVudDtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVfbm9kZSk7XG4gICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwibGlua1wiKSB7XG4gICAgICBjb25zdCBsaW5rX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgIGlmIChjb2RlLnJlbCkge1xuICAgICAgICBsaW5rX25vZGUucmVsID0gY29kZS5yZWw7XG4gICAgICB9XG4gICAgICBpZiAoY29kZS5ocmVmKSB7XG4gICAgICAgIGxpbmtfbm9kZS5ocmVmID0gY29kZS5ocmVmO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUuYXR0cnMgJiYgY29kZS5hdHRycy50eXBlKSB7XG4gICAgICAgIGxpbmtfbm9kZS50eXBlID0gY29kZS5hdHRycy50eXBlO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rX25vZGUpO1xuICAgIH0gZWxzZSBpZiAoY29kZS50eXBlID09PSBcImh0bWxcIikge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfaHRtbFRvRWxlbWVudChjb2RlLmNvbnRlbnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBjb2RlIHR5cGUuXCI7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwV2ViUHl0aG9uKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kZWJ1ZyA9IHRydWU7XG4gIGNvbmZpZy5kZWRpY2F0ZWRfdGhyZWFkID0gZmFsc2U7XG4gIGNvbmZpZy5sYW5nID0gXCJweXRob25cIjtcbiAgY29uZmlnLmFwaV92ZXJzaW9uID0gQVBJX1ZFUlNJT047XG4gIGNvbnN0IGNvbm4gPSBuZXcgQ29ubmVjdGlvbihjb25maWcpO1xuICBzZXR1cFB5b2RpZGUoKS50aGVuKCgpID0+IHtcbiAgICBjb25uZWN0UlBDKGNvbm4sIGNvbmZpZyk7XG4gICAgY29ubi5jb25uZWN0KCk7XG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUFBO0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFEQTtBQVdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNHQTtBQUNBO0FBNEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pluginWebPython.js\n");

/***/ }),

/***/ "./src/rpc.js":
/*!********************!*\
  !*** ./src/rpc.js ***!
  \********************/
/*! exports provided: API_VERSION, RPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return RPC; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\nconst API_VERSION = \"0.2.1\";\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction getKeyByValue(object, value) {\n  return Object.keys(object).find(key => object[key] === value);\n}\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\n\n\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n  constructor(connection, config) {\n    super(config && config.debug);\n    this._connection = connection;\n    this.config = config || {};\n    this._interface_store = {};\n    this._local_api = null; // make sure there is an execute function\n\n    const name = this.config.name;\n\n    this._connection.execute = this._connection.execute || function () {\n      throw new Error(`connection.execute not implemented (in \"${name}\")`);\n    };\n\n    this._store = new ReferenceStore();\n    this._method_refs = new ReferenceStore();\n\n    this._method_refs.onReady(() => {\n      this._fire(\"remoteIdle\");\n    });\n\n    this._method_refs.onBusy(() => {\n      this._fire(\"remoteBusy\");\n    });\n\n    this._setupMessageHanlders();\n  }\n\n  init() {\n    this._connection.emit({\n      type: \"initialized\",\n      config: this.config,\n      peer_id: this._connection.peer_id\n    });\n  }\n  /**\n   * Set a handler to be called when received a responce from the\n   * remote site reporting that the previously provided interface\n   * has been successfully set as remote for that site\n   *\n   * @param {Function} handler\n   */\n\n\n  getRemoteCallStack() {\n    return this._method_refs.getStack();\n  }\n  /**\n   * @returns {Object} set of remote interface methods\n   */\n\n\n  getRemote() {\n    return this._interface_store[\"_rremote\"];\n  }\n  /**\n   * Sets the interface of this site making it available to the\n   * remote site by sending a message with a set of methods names\n   *\n   * @param {Object} _interface to set\n   */\n\n\n  setInterface(_interface) {\n    if (this.config.forwarding_functions) {\n      for (let func_name of this.config.forwarding_functions) {\n        const _remote = this._interface_store[\"_rremote\"];\n\n        if (_remote[func_name]) {\n          if (_interface.constructor === Object) {\n            if (!_interface[func_name]) {\n              _interface[func_name] = (...args) => {\n                _remote[func_name](...args);\n              };\n            }\n          } else if (_interface.constructor.constructor === Function) {\n            if (!_interface.constructor.prototype[func_name]) {\n              _interface.constructor.prototype[func_name] = (...args) => {\n                _remote[func_name](...args);\n              };\n            }\n          }\n        }\n      }\n    }\n\n    this._local_api = _interface;\n\n    this._fire(\"interfaceAvailable\");\n  }\n  /**\n   * Sends the actual interface to the remote site upon it was\n   * updated or by a special request of the remote site\n   */\n\n\n  sendInterface() {\n    if (!this._local_api) {\n      throw new Error(\"interface is not set.\");\n    }\n\n    this._local_api._rid = \"_rlocal\";\n\n    const api = this._encode(this._local_api, true);\n\n    this._connection.emit({\n      type: \"setInterface\",\n      api: api\n    });\n  }\n  /**\n   * Handles a message from the remote site\n   */\n  // var callback_reg = new RegExp(\"onupdate|run$\")\n\n\n  _setupMessageHanlders() {\n    this._connection.on(\"init\", this.init);\n\n    this._connection.on(\"execute\", data => {\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\n        this._connection.emit({\n          type: \"executed\"\n        });\n      }).catch(e => {\n        console.error(e);\n\n        this._connection.emit({\n          type: \"executed\",\n          error: e\n        });\n      });\n    });\n\n    this._connection.on(\"method\", data => {\n      let resolve, reject, method, args, result;\n      let _interface = this._interface_store[data.pid];\n\n      const _method_context = _interface.__this__ || _interface;\n\n      if (!_interface) {\n        if (data.promise) {\n          [resolve, reject] = this._unwrap(data.promise, false);\n          reject(`plugin api function is not avaialbe in \"${data.pid}\", the plugin maybe terminated.`);\n        } else {\n          console.error(`plugin api function is not avaialbe in ${data.pid}, the plugin maybe terminated.`);\n        }\n\n        return;\n      }\n\n      method = _interface[data.name];\n      args = this._unwrap(data.args, true);\n\n      if (data.promise) {\n        [resolve, reject] = this._unwrap(data.promise, false);\n\n        try {\n          result = method.apply(_method_context, args);\n\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n            result.then(resolve).catch(reject);\n          } else {\n            resolve(result);\n          }\n        } catch (e) {\n          console.error(this.config.name, e, method);\n          reject(e);\n        }\n      } else {\n        try {\n          method.apply(_method_context, args);\n        } catch (e) {\n          console.error(this.config.name, e, method, args);\n        }\n      }\n    });\n\n    this._connection.on(\"callback\", data => {\n      let resolve, reject, method, args, result;\n\n      if (data.promise) {\n        [resolve, reject] = this._unwrap(data.promise, false);\n\n        try {\n          method = this._store.fetch(data._rindex);\n          args = this._unwrap(data.args, true);\n\n          if (!method) {\n            throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n          }\n\n          result = method.apply(null, args);\n\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n            result.then(resolve).catch(reject);\n          } else {\n            resolve(result);\n          }\n        } catch (e) {\n          console.error(this.config.name, e, method);\n          reject(e);\n        }\n      } else {\n        try {\n          method = this._store.fetch(data._rindex);\n          args = this._unwrap(data.args, true);\n\n          if (!method) {\n            throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n          }\n\n          method.apply(null, args);\n        } catch (e) {\n          console.error(this.config.name, e, method, args);\n        }\n      }\n    });\n\n    this._connection.on(\"setInterface\", data => {\n      this._setRemoteInterface(data.api);\n    });\n\n    this._connection.on(\"getInterface\", () => {\n      this._fire(\"getInterface\");\n\n      if (this._local_api) {\n        this.sendInterface();\n      } else {\n        this.once(\"interfaceAvailable\", () => {\n          this.sendInterface();\n        });\n      }\n    });\n\n    this._connection.on(\"interfaceSetAsRemote\", () => {\n      this._fire(\"interfaceSetAsRemote\");\n    });\n\n    this._connection.on(\"disconnect\", () => {\n      this._fire(\"beforeDisconnect\");\n\n      this._connection.disconnect();\n\n      this._fire(\"disconnected\");\n    });\n  }\n  /**\n   * Sends a requests to the remote site asking it to provide its\n   * current interface\n   */\n\n\n  requestRemote() {\n    this._connection.emit({\n      type: \"getInterface\"\n    });\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    var _dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"][typedArray.constructor.name];\n\n    if (dtype && dtype !== _dtype) {\n      throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n    }\n\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray,\n      _rshape: shape,\n      _rdtype: _dtype\n    };\n  }\n  /**\n   * Sets the new remote interface provided by the other site\n   *\n   * @param {Array} names list of function names\n   */\n\n\n  _setRemoteInterface(api) {\n    this._interface_store[\"_rremote\"] = this._decode(api);\n\n    this._fire(\"remoteReady\");\n\n    this._reportRemoteSet();\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * method. When the generated function is called, it will send the\n   * corresponding message to the remote site asking it to execute\n   * the particular method of its interface\n   *\n   * @param {String} name of the remote method\n   *\n   * @returns {Function} wrapped remote method\n   */\n\n\n  _genRemoteMethod(name, interface_id) {\n    var me = this;\n\n    var remoteMethod = function () {\n      return new Promise((resolve, reject) => {\n        let id = null;\n\n        try {\n          id = me._method_refs.put(interface_id ? interface_id + \"/\" + name : name);\n\n          var wrapped_resolve = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return resolve.apply(this, arguments);\n          };\n\n          var wrapped_reject = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return reject.apply(this, arguments);\n          };\n\n          wrapped_resolve.__jailed_pairs__ = wrapped_reject;\n          wrapped_reject.__jailed_pairs__ = wrapped_resolve;\n          var args = Array.prototype.slice.call(arguments);\n\n          if (name === \"register\" || name === \"export\" || name === \"on\") {\n            args = me._wrap(args, true);\n          } else {\n            args = me._wrap(args);\n          }\n\n          var transferables = args.args.__transferables__;\n          if (transferables) delete args.args.__transferables__;\n\n          me._connection.emit({\n            type: \"method\",\n            name: name,\n            pid: interface_id,\n            args: args,\n            promise: me._wrap([wrapped_resolve, wrapped_reject])\n          }, transferables);\n        } catch (e) {\n          if (id) me._method_refs.fetch(id);\n          reject(`Failed to exectue remote method (interface: ${interface_id || me.id}, method: ${name}), error: ${e}`);\n        }\n      });\n    };\n\n    remoteMethod.__remote_method = true;\n    return remoteMethod;\n  }\n  /**\n   * Sends a responce reporting that interface just provided by the\n   * remote site was successfully set by this site as remote\n   */\n\n\n  _reportRemoteSet() {\n    this._connection.emit({\n      type: \"interfaceSetAsRemote\"\n    });\n  }\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n\n\n  _encodeInterface(aObject) {\n    let v, k, keys;\n    const encoded_interface = {};\n    aObject[\"_rid\"] = aObject[\"_rid\"] || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])(); // an object/array\n\n    if (aObject.constructor === Object || Array.isArray(aObject)) {\n      keys = Object.keys(aObject);\n    } // a class\n    else if (aObject.constructor === Function) {\n        throw new Error(\"Please instantiate the class before exportting it.\");\n      } // instance of a class\n      else if (aObject.constructor.constructor === Function) {\n          keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n        } else {\n          throw Error(\"Unsupported interface type\");\n        }\n\n    const bObject = Array.isArray(aObject) ? [] : {};\n\n    for (k of keys) {\n      if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue;\n\n      if (k.startsWith(\"_\")) {\n        continue;\n      }\n\n      v = aObject[k];\n\n      if (typeof v === \"function\") {\n        bObject[k] = {\n          _rtype: \"interface\",\n          _rid: aObject[\"_rid\"],\n          _rvalue: k\n        };\n        encoded_interface[k] = v;\n      } else if (Object(v) !== v) {\n        bObject[k] = {\n          _rtype: \"argument\",\n          _rvalue: v\n        };\n        encoded_interface[k] = v;\n      } else if (typeof v === \"object\") {\n        bObject[k] = this._encodeInterface(v);\n      }\n    }\n\n    this._interface_store[aObject[\"_rid\"]] = encoded_interface; // remove interface when closed\n\n    if (aObject.on && typeof aObject.on === \"function\") {\n      aObject.on(\"close\", () => {\n        delete this._interface_store[aObject[\"_rid\"]];\n      });\n    }\n\n    return bObject;\n  }\n\n  _encode(aObject, as_interface) {\n    const transferables = [];\n\n    if (!aObject) {\n      return aObject;\n    }\n\n    const _transfer = aObject._transfer;\n    let bObject, v, k;\n    const isarray = Array.isArray(aObject); //skip if already encoded\n\n    if (typeof aObject === \"object\" && aObject._rtype && aObject._rvalue) {\n      return aObject;\n    } //encode interfaces\n\n\n    if (typeof aObject === \"object\" && !Array.isArray(aObject) && (aObject._rintf || as_interface)) {\n      return this._encodeInterface(aObject);\n    }\n\n    if (as_interface) {\n      aObject[\"_rid\"] = aObject[\"_rid\"] || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n      this._interface_store[aObject[\"_rid\"]] = this._interface_store[aObject[\"_rid\"]] || (isarray ? [] : {});\n    }\n\n    bObject = isarray ? [] : {};\n\n    for (k in aObject) {\n      if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue;\n\n      if (isarray || aObject.hasOwnProperty(k)) {\n        v = aObject[k];\n\n        if (v && typeof this._local_api._rpc_encode === \"function\") {\n          const encoded_obj = this._local_api._rpc_encode(v);\n\n          if (encoded_obj && encoded_obj._ctype) {\n            bObject[k] = {\n              _rtype: \"custom\",\n              _rvalue: encoded_obj,\n              _rid: aObject[\"_rid\"]\n            };\n            continue;\n          } // if the returned object does not contain _rtype, assuming the object has been transformed\n          else if (encoded_obj !== undefined) {\n              v = encoded_obj;\n            }\n        }\n\n        if (typeof v === \"function\") {\n          if (as_interface) {\n            const encoded_interface = this._interface_store[aObject[\"_rid\"]];\n            bObject[k] = {\n              _rtype: \"interface\",\n              _rid: aObject[\"_rid\"],\n              _rvalue: k\n            };\n            encoded_interface[k] = v;\n            continue;\n          }\n\n          let interfaceFuncName = null;\n\n          for (var name in this._local_api) {\n            if (this._local_api.hasOwnProperty(name)) {\n              if (name.startsWith(\"_\")) continue;\n\n              if (this._local_api[name] === v) {\n                interfaceFuncName = name;\n                break;\n              }\n            }\n          } // search for prototypes\n\n\n          var functions = Object.getOwnPropertyNames(Object.getPrototypeOf(this._local_api));\n\n          for (var i = 0; i < functions.length; i++) {\n            var name_ = functions[i];\n            if (name_.startsWith(\"_\")) continue;\n\n            if (this._local_api[name_] === v) {\n              interfaceFuncName = name_;\n              break;\n            }\n          }\n\n          if (!interfaceFuncName) {\n            var id = this._store.put(v);\n\n            bObject[k] = {\n              _rtype: \"callback\",\n              _rvalue: v.constructor && v.constructor.name || id,\n              _rindex: id\n            };\n          } else {\n            bObject[k] = {\n              _rtype: \"interface\",\n              _rvalue: interfaceFuncName,\n              _rid: \"_rlocal\"\n            };\n          }\n        } else if (\n        /*global tf*/\n        typeof tf !== \"undefined\" && tf.Tensor && v instanceof tf.Tensor) {\n          const v_buffer = v.dataSync();\n\n          if (v._transfer || _transfer) {\n            transferables.push(v_buffer.buffer);\n            delete v._transfer;\n          }\n\n          bObject[k] = {\n            _rtype: \"ndarray\",\n            _rvalue: v_buffer,\n            _rshape: v.shape,\n            _rdtype: v.dtype\n          };\n        } else if (\n        /*global nj*/\n        typeof nj !== \"undefined\" && nj.NdArray && v instanceof nj.NdArray) {\n          var dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"][v.selection.data.constructor.name];\n\n          if (v._transfer || _transfer) {\n            transferables.push(v.selection.data.buffer);\n            delete v._transfer;\n          }\n\n          bObject[k] = {\n            _rtype: \"ndarray\",\n            _rvalue: v.selection.data,\n            _rshape: v.shape,\n            _rdtype: dtype\n          };\n        } else if (v instanceof Error) {\n          console.error(v);\n          bObject[k] = {\n            _rtype: \"error\",\n            _rvalue: v.toString()\n          };\n        } else if (typeof File !== \"undefined\" && v instanceof File) {\n          bObject[k] = {\n            _rtype: \"file\",\n            _rvalue: v,\n            _rrelative_path: v.relativePath || v.webkitRelativePath\n          };\n        } // send objects supported by structure clone algorithm\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n        else if (v !== Object(v) || v instanceof Boolean || v instanceof String || v instanceof Date || v instanceof RegExp || v instanceof Blob || v instanceof ImageData || typeof FileList !== \"undefined\" && v instanceof FileList) {\n            bObject[k] = {\n              _rtype: \"argument\",\n              _rvalue: v\n            };\n          } else if (v instanceof ArrayBuffer) {\n            if (v._transfer || _transfer) {\n              transferables.push(v);\n              delete v._transfer;\n            }\n\n            bObject[k] = {\n              _rtype: \"argument\",\n              _rvalue: v\n            };\n          } else if (v instanceof ArrayBufferView) {\n            if (v._transfer || _transfer) {\n              transferables.push(v.buffer);\n              delete v._transfer;\n            }\n\n            bObject[k] = {\n              _rtype: \"argument\",\n              _rvalue: v\n            };\n          } // TODO: support also Map and Set\n          // TODO: avoid object such as DynamicPlugin instance.\n          else if (v._rintf) {\n              bObject[k] = this._encode(v, true);\n            } else if (typeof v === \"object\") {\n              bObject[k] = this._encode(v, as_interface); // move transferables to the top level object\n\n              if (bObject[k].__transferables__) {\n                for (var t = 0; t < bObject[k].__transferables__.length; t++) {\n                  transferables.push(bObject[k].__transferables__[t]);\n                }\n\n                delete bObject[k].__transferables__;\n              }\n            } else {\n              throw \"imjoy-rpc: Unsupported data type \" + k + \",\" + v;\n            }\n      }\n    }\n\n    if (transferables.length > 0) {\n      bObject.__transferables__ = transferables;\n    }\n\n    return bObject;\n  }\n\n  _decode(aObject, callbackId, withPromise) {\n    if (!aObject) {\n      return aObject;\n    }\n\n    var bObject, v, k;\n\n    if (aObject.hasOwnProperty(\"_rtype\") && aObject.hasOwnProperty(\"_rvalue\")) {\n      if (aObject._rtype === \"custom\") {\n        if (aObject._rvalue && typeof this._local_api._rpc_decode === \"function\") {\n          bObject = this._local_api._rpc_decode(aObject._rvalue);\n\n          if (bObject === undefined) {\n            bObject = aObject;\n          }\n        } else {\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"callback\") {\n        bObject = this._genRemoteCallback(callbackId, aObject._rindex, withPromise);\n      } else if (aObject._rtype === \"interface\") {\n        const intfid = aObject._rid === \"_rlocal\" ? \"_rrmote\" : aObject._rid;\n        bObject = this._interface_store[intfid] && this._interface_store[intfid][aObject._rvalue] || this._genRemoteMethod(aObject._rvalue, aObject._rid);\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          bObject = nj.array(aObject._rvalue, aObject._rdtype).reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          bObject = tf.tensor(aObject._rvalue, aObject._rshape, aObject._rdtype);\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(aObject._rvalue);\n      } else if (aObject._rtype === \"file\") {\n        bObject = aObject._rvalue; //patch relativePath\n\n        bObject.relativePath = aObject._rrelative_path;\n      } else if (aObject._rtype === \"argument\") {\n        bObject = aObject._rvalue;\n      }\n\n      return bObject;\n    } else {\n      var isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n\n      for (k in aObject) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          v = aObject[k];\n\n          if (typeof v === \"object\" || Array.isArray(v)) {\n            bObject[k] = this._decode(v, callbackId, withPromise);\n          }\n        }\n      }\n\n      return bObject;\n    }\n  }\n\n  _wrap(args, as_interface) {\n    var wrapped = this._encode(args, as_interface);\n\n    var result = {\n      args: wrapped\n    };\n    return result;\n  }\n  /**\n   * Unwraps the set of arguments delivered from the remote site,\n   * replaces all callback identifiers with a function which will\n   * initiate sending that callback identifier back to other site\n   *\n   * @param {Object} args to unwrap\n   *\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Array} unwrapped args\n   */\n\n\n  _unwrap(args, withPromise) {\n    // var called = false;\n    // wraps each callback so that the only one could be called\n    // var once(cb) {\n    //     return function() {\n    //         if (!called) {\n    //             called = true;\n    //             return cb.apply(this, arguments);\n    //         } else {\n    //             var msg =\n    //               'A callback from this set has already been executed';\n    //             throw new Error(msg);\n    //         }\n    //     };\n    // }\n    var result = this._decode(args.args, args.callbackId, withPromise);\n\n    return result;\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * callback. When the generated function is called, it will send\n   * the corresponding message to the remote site asking it to\n   * execute the particular callback previously saved during a call\n   * by the remote site a method from the interface of this site\n   *\n   * @param {Number} id of the remote callback to execute\n   * @param {Number} argNum argument index of the callback\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Function} wrapped remote callback\n   */\n\n\n  _genRemoteCallback(id, argNum, withPromise) {\n    var me = this;\n    var remoteCallback;\n\n    if (withPromise) {\n      remoteCallback = function () {\n        return new Promise((resolve, reject) => {\n          var args = me._wrap(Array.prototype.slice.call(arguments));\n\n          var transferables = args.args.__transferables__;\n          if (transferables) delete args.args.__transferables__;\n          resolve.__jailed_pairs__ = reject;\n          reject.__jailed_pairs__ = resolve;\n\n          try {\n            me._connection.emit({\n              type: \"callback\",\n              id: id,\n              _rindex: argNum,\n              args: args,\n              // pid :  me.id,\n              promise: me._wrap([resolve, reject])\n            }, transferables);\n          } catch (e) {\n            reject(`Failed to exectue remote callback (id: ${id}, argNum: ${argNum}).`);\n          }\n        });\n      };\n\n      return remoteCallback;\n    } else {\n      remoteCallback = function () {\n        var args = me._wrap(Array.prototype.slice.call(arguments));\n\n        var transferables = args.args.__transferables__;\n        if (transferables) delete args.args.__transferables__;\n        return me._connection.emit({\n          type: \"callback\",\n          id: id,\n          _rindex: argNum,\n          args: args // pid :  me.id\n\n        }, transferables);\n      };\n\n      return remoteCallback;\n    }\n  }\n  /**\n   * Sends the notification message and breaks the connection\n   */\n\n\n  disconnect() {\n    this._connection.emit({\n      type: \"disconnect\"\n    });\n\n    setTimeout(() => {\n      this._connection.disconnect();\n    }, 2000);\n  }\n\n}\n/**\n * ReferenceStore is a special object which stores other objects\n * and provides the references (number) instead. This reference\n * may then be sent over a json-based communication channel (IPC\n * to another Node.js process or a message to the Worker). Other\n * site may then provide the reference in the responce message\n * implying the given object should be activated.\n *\n * Primary usage for the ReferenceStore is a storage for the\n * callbacks, which therefore makes it possible to initiate a\n * callback execution by the opposite site (which normally cannot\n * directly execute functions over the communication channel).\n *\n * Each stored object can only be fetched once and is not\n * available for the second time. Each stored object must be\n * fetched, since otherwise it will remain stored forever and\n * consume memory.\n *\n * Stored object indeces are simply the numbers, which are however\n * released along with the objects, and are later reused again (in\n * order to postpone the overflow, which should not likely happen,\n * but anyway).\n */\n\nclass ReferenceStore {\n  constructor() {\n    this._store = {}; // stored object\n\n    this._indices = [0]; // smallest available indices\n\n    this._readyHandler = function () {};\n\n    this._busyHandler = function () {};\n\n    this._readyHandler();\n  }\n  /**\n   * call handler when the store is empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onReady(readyHandler) {\n    this._readyHandler = readyHandler || function () {};\n  }\n  /**\n   * call handler when the store is not empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onBusy(busyHandler) {\n    this._busyHandler = busyHandler || function () {};\n  }\n  /**\n   * get the length of the store\n   *\n   */\n\n\n  getStack() {\n    return Object.keys(this._store).length;\n  }\n  /**\n   * @function _genId() generates the new reference id\n   *\n   * @returns {Number} smallest available id and reserves it\n   */\n\n\n  _genId() {\n    var id;\n\n    if (this._indices.length === 1) {\n      id = this._indices[0]++;\n    } else {\n      id = this._indices.shift();\n    }\n\n    return id;\n  }\n  /**\n   * Releases the given reference id so that it will be available by\n   * another object stored\n   *\n   * @param {Number} id to release\n   */\n\n\n  _releaseId(id) {\n    for (var i = 0; i < this._indices.length; i++) {\n      if (id < this._indices[i]) {\n        this._indices.splice(i, 0, id);\n\n        break;\n      }\n    } // cleaning-up the sequence tail\n\n\n    for (i = this._indices.length - 1; i >= 0; i--) {\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\n        this._indices.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Stores the given object and returns the refernce id instead\n   *\n   * @param {Object} obj to store\n   *\n   * @returns {Number} reference id of the stored object\n   */\n\n\n  put(obj) {\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\n      this._busyHandler();\n    }\n\n    var id = this._genId();\n\n    this._store[id] = obj;\n    return id;\n  }\n  /**\n   * Retrieves previously stored object and releases its reference\n   *\n   * @param {Number} id of an object to retrieve\n   */\n\n\n  fetch(id) {\n    var obj = this._store[id];\n\n    if (obj && !obj.__remote_method) {\n      delete this._store[id];\n\n      this._releaseId(id);\n\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\n        this._readyHandler();\n      }\n    }\n\n    if (obj && obj.__jailed_pairs__) {\n      const _id = getKeyByValue(this._store, obj.__jailed_pairs__);\n\n      this.fetch(_id);\n    }\n\n    return obj;\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcnBjLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9zcmMvcnBjLmpzPzM1NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyB0aGUgUlBDIG9iamVjdCB1c2VkIGJvdGggYnkgdGhlIGFwcGxpY2F0aW9uXG4gKiBzaXRlLCBhbmQgYnkgZWFjaCBwbHVnaW5cbiAqL1xuaW1wb3J0IHsgcmFuZElkLCB0eXBlZEFycmF5VG9EdHlwZSwgTWVzc2FnZUVtaXR0ZXIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuXG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT04gPSBcIjAuMi4xXCI7XG5cbmNvbnN0IEFycmF5QnVmZmVyVmlldyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihcbiAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBVaW50OEFycmF5KCkpXG4pLmNvbnN0cnVjdG9yO1xuXG5mdW5jdGlvbiBfYXBwZW5kQnVmZmVyKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcbiAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcbiAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIxKSwgMCk7XG4gIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMiksIGJ1ZmZlcjEuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB0bXAuYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlCeVZhbHVlKG9iamVjdCwgdmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkuZmluZChrZXkgPT4gb2JqZWN0W2tleV0gPT09IHZhbHVlKTtcbn1cbi8qKlxuICogUlBDIG9iamVjdCByZXByZXNlbnRzIGEgc2luZ2xlIHNpdGUgaW4gdGhlXG4gKiBjb21tdW5pY2F0aW9uIHByb3RvY29sIGJldHdlZW4gdGhlIGFwcGxpY2F0aW9uIGFuZCB0aGUgcGx1Z2luXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb24gYSBzcGVjaWFsIG9iamVjdCBhbGxvd2luZyB0byBzZW5kXG4gKiBhbmQgcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIHRoZSBvcHBvc2l0ZSBzaXRlIChiYXNpY2FsbHkgaXRcbiAqIHNob3VsZCBvbmx5IHByb3ZpZGUgc2VuZCgpIGFuZCBvbk1lc3NhZ2UoKSBtZXRob2RzKVxuICovXG5leHBvcnQgY2xhc3MgUlBDIGV4dGVuZHMgTWVzc2FnZUVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBjb25maWcpIHtcbiAgICBzdXBlcihjb25maWcgJiYgY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLl9pbnRlcmZhY2Vfc3RvcmUgPSB7fTtcbiAgICB0aGlzLl9sb2NhbF9hcGkgPSBudWxsO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhbiBleGVjdXRlIGZ1bmN0aW9uXG4gICAgY29uc3QgbmFtZSA9IHRoaXMuY29uZmlnLm5hbWU7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5leGVjdXRlID1cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZXhlY3V0ZSB8fFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29ubmVjdGlvbi5leGVjdXRlIG5vdCBpbXBsZW1lbnRlZCAoaW4gXCIke25hbWV9XCIpYCk7XG4gICAgICB9O1xuICAgIHRoaXMuX3N0b3JlID0gbmV3IFJlZmVyZW5jZVN0b3JlKCk7XG4gICAgdGhpcy5fbWV0aG9kX3JlZnMgPSBuZXcgUmVmZXJlbmNlU3RvcmUoKTtcbiAgICB0aGlzLl9tZXRob2RfcmVmcy5vblJlYWR5KCgpID0+IHtcbiAgICAgIHRoaXMuX2ZpcmUoXCJyZW1vdGVJZGxlXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuX21ldGhvZF9yZWZzLm9uQnVzeSgoKSA9PiB7XG4gICAgICB0aGlzLl9maXJlKFwicmVtb3RlQnVzeVwiKTtcbiAgICB9KTtcbiAgICB0aGlzLl9zZXR1cE1lc3NhZ2VIYW5sZGVycygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoe1xuICAgICAgdHlwZTogXCJpbml0aWFsaXplZFwiLFxuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIHBlZXJfaWQ6IHRoaXMuX2Nvbm5lY3Rpb24ucGVlcl9pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHJlY2VpdmVkIGEgcmVzcG9uY2UgZnJvbSB0aGVcbiAgICogcmVtb3RlIHNpdGUgcmVwb3J0aW5nIHRoYXQgdGhlIHByZXZpb3VzbHkgcHJvdmlkZWQgaW50ZXJmYWNlXG4gICAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZXQgYXMgcmVtb3RlIGZvciB0aGF0IHNpdGVcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cblxuICBnZXRSZW1vdGVDYWxsU3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGhvZF9yZWZzLmdldFN0YWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge09iamVjdH0gc2V0IG9mIHJlbW90ZSBpbnRlcmZhY2UgbWV0aG9kc1xuICAgKi9cbiAgZ2V0UmVtb3RlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcmZhY2Vfc3RvcmVbXCJfcnJlbW90ZVwiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBzaXRlIG1ha2luZyBpdCBhdmFpbGFibGUgdG8gdGhlXG4gICAqIHJlbW90ZSBzaXRlIGJ5IHNlbmRpbmcgYSBtZXNzYWdlIHdpdGggYSBzZXQgb2YgbWV0aG9kcyBuYW1lc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gX2ludGVyZmFjZSB0byBzZXRcbiAgICovXG4gIHNldEludGVyZmFjZShfaW50ZXJmYWNlKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmZvcndhcmRpbmdfZnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBmdW5jX25hbWUgb2YgdGhpcy5jb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnMpIHtcbiAgICAgICAgY29uc3QgX3JlbW90ZSA9IHRoaXMuX2ludGVyZmFjZV9zdG9yZVtcIl9ycmVtb3RlXCJdO1xuICAgICAgICBpZiAoX3JlbW90ZVtmdW5jX25hbWVdKSB7XG4gICAgICAgICAgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlW2Z1bmNfbmFtZV0pIHtcbiAgICAgICAgICAgICAgX2ludGVyZmFjZVtmdW5jX25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBfcmVtb3RlW2Z1bmNfbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtmdW5jX25hbWVdKSB7XG4gICAgICAgICAgICAgIF9pbnRlcmZhY2UuY29uc3RydWN0b3IucHJvdG90eXBlW2Z1bmNfbmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIF9yZW1vdGVbZnVuY19uYW1lXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbG9jYWxfYXBpID0gX2ludGVyZmFjZTtcbiAgICB0aGlzLl9maXJlKFwiaW50ZXJmYWNlQXZhaWxhYmxlXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBhY3R1YWwgaW50ZXJmYWNlIHRvIHRoZSByZW1vdGUgc2l0ZSB1cG9uIGl0IHdhc1xuICAgKiB1cGRhdGVkIG9yIGJ5IGEgc3BlY2lhbCByZXF1ZXN0IG9mIHRoZSByZW1vdGUgc2l0ZVxuICAgKi9cbiAgc2VuZEludGVyZmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuX2xvY2FsX2FwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJmYWNlIGlzIG5vdCBzZXQuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9sb2NhbF9hcGkuX3JpZCA9IFwiX3Jsb2NhbFwiO1xuICAgIGNvbnN0IGFwaSA9IHRoaXMuX2VuY29kZSh0aGlzLl9sb2NhbF9hcGksIHRydWUpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7IHR5cGU6IFwic2V0SW50ZXJmYWNlXCIsIGFwaTogYXBpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBtZXNzYWdlIGZyb20gdGhlIHJlbW90ZSBzaXRlXG4gICAqL1xuICAvLyB2YXIgY2FsbGJhY2tfcmVnID0gbmV3IFJlZ0V4cChcIm9udXBkYXRlfHJ1biRcIilcbiAgX3NldHVwTWVzc2FnZUhhbmxkZXJzKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJpbml0XCIsIHRoaXMuaW5pdCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImV4ZWN1dGVcIiwgZGF0YSA9PiB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5fY29ubmVjdGlvbi5leGVjdXRlKGRhdGEuY29kZSkpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImV4ZWN1dGVkXCIgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBcImV4ZWN1dGVkXCIsXG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJtZXRob2RcIiwgZGF0YSA9PiB7XG4gICAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0LCBtZXRob2QsIGFyZ3MsIHJlc3VsdDtcbiAgICAgIGxldCBfaW50ZXJmYWNlID0gdGhpcy5faW50ZXJmYWNlX3N0b3JlW2RhdGEucGlkXTtcbiAgICAgIGNvbnN0IF9tZXRob2RfY29udGV4dCA9IF9pbnRlcmZhY2UuX190aGlzX18gfHwgX2ludGVyZmFjZTtcbiAgICAgIGlmICghX2ludGVyZmFjZSkge1xuICAgICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgICAgW3Jlc29sdmUsIHJlamVjdF0gPSB0aGlzLl91bndyYXAoZGF0YS5wcm9taXNlLCBmYWxzZSk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgYHBsdWdpbiBhcGkgZnVuY3Rpb24gaXMgbm90IGF2YWlhbGJlIGluIFwiJHtkYXRhLnBpZH1cIiwgdGhlIHBsdWdpbiBtYXliZSB0ZXJtaW5hdGVkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgcGx1Z2luIGFwaSBmdW5jdGlvbiBpcyBub3QgYXZhaWFsYmUgaW4gJHtkYXRhLnBpZH0sIHRoZSBwbHVnaW4gbWF5YmUgdGVybWluYXRlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1ldGhvZCA9IF9pbnRlcmZhY2VbZGF0YS5uYW1lXTtcbiAgICAgIGFyZ3MgPSB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcbiAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcbiAgICAgICAgW3Jlc29sdmUsIHJlamVjdF0gPSB0aGlzLl91bndyYXAoZGF0YS5wcm9taXNlLCBmYWxzZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KF9tZXRob2RfY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLmNvbmZpZy5uYW1lLCBlLCBtZXRob2QpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZXRob2QuYXBwbHkoX21ldGhvZF9jb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZSwgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImNhbGxiYWNrXCIsIGRhdGEgPT4ge1xuICAgICAgbGV0IHJlc29sdmUsIHJlamVjdCwgbWV0aG9kLCBhcmdzLCByZXN1bHQ7XG4gICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgIFtyZXNvbHZlLCByZWplY3RdID0gdGhpcy5fdW53cmFwKGRhdGEucHJvbWlzZSwgZmFsc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1ldGhvZCA9IHRoaXMuX3N0b3JlLmZldGNoKGRhdGEuX3JpbmRleCk7XG4gICAgICAgICAgYXJncyA9IHRoaXMuX3Vud3JhcChkYXRhLmFyZ3MsIHRydWUpO1xuICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGJhY2sgZnVuY3Rpb24gY2FuIG9ubHkgY2FsbGVkIG9uY2UsIGlmIHlvdSB3YW50IHRvIGNhbGwgYSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgdGltZXMsIHBsZWFzZSBtYWtlIGl0IGFzIGEgcGx1Z2luIGFwaSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vaW1qb3kuaW8vZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLmNvbmZpZy5uYW1lLCBlLCBtZXRob2QpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZXRob2QgPSB0aGlzLl9zdG9yZS5mZXRjaChkYXRhLl9yaW5kZXgpO1xuICAgICAgICAgIGFyZ3MgPSB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIlBsZWFzZSBub3RpY2UgdGhhdCBjYWxsYmFjayBmdW5jdGlvbiBjYW4gb25seSBjYWxsZWQgb25jZSwgaWYgeW91IHdhbnQgdG8gY2FsbCBhIGZ1bmN0aW9uIGZvciBtdWx0aXBsZSB0aW1lcywgcGxlYXNlIG1ha2UgaXQgYXMgYSBwbHVnaW4gYXBpIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9pbWpveS5pby9kb2NzIGZvciBtb3JlIGRldGFpbHMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1ldGhvZC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZSwgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJzZXRJbnRlcmZhY2VcIiwgZGF0YSA9PiB7XG4gICAgICB0aGlzLl9zZXRSZW1vdGVJbnRlcmZhY2UoZGF0YS5hcGkpO1xuICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJnZXRJbnRlcmZhY2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fZmlyZShcImdldEludGVyZmFjZVwiKTtcbiAgICAgIGlmICh0aGlzLl9sb2NhbF9hcGkpIHtcbiAgICAgICAgdGhpcy5zZW5kSW50ZXJmYWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uY2UoXCJpbnRlcmZhY2VBdmFpbGFibGVcIiwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2VuZEludGVyZmFjZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFwiaW50ZXJmYWNlU2V0QXNSZW1vdGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fZmlyZShcImludGVyZmFjZVNldEFzUmVtb3RlXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2ZpcmUoXCJiZWZvcmVEaXNjb25uZWN0XCIpO1xuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9maXJlKFwiZGlzY29ubmVjdGVkXCIpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdHMgdG8gdGhlIHJlbW90ZSBzaXRlIGFza2luZyBpdCB0byBwcm92aWRlIGl0c1xuICAgKiBjdXJyZW50IGludGVyZmFjZVxuICAgKi9cbiAgcmVxdWVzdFJlbW90ZSgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImdldEludGVyZmFjZVwiIH0pO1xuICB9XG5cbiAgX25kYXJyYXkodHlwZWRBcnJheSwgc2hhcGUsIGR0eXBlKSB7XG4gICAgdmFyIF9kdHlwZSA9IHR5cGVkQXJyYXlUb0R0eXBlW3R5cGVkQXJyYXkuY29uc3RydWN0b3IubmFtZV07XG4gICAgaWYgKGR0eXBlICYmIGR0eXBlICE9PSBfZHR5cGUpIHtcbiAgICAgIHRocm93IFwiZHR5cGUgZG9lc24ndCBtYXRjaCB0aGUgdHlwZSBvZiB0aGUgYXJyYXk6IFwiICtcbiAgICAgICAgX2R0eXBlICtcbiAgICAgICAgXCIgIT0gXCIgK1xuICAgICAgICBkdHlwZTtcbiAgICB9XG4gICAgc2hhcGUgPSBzaGFwZSB8fCBbdHlwZWRBcnJheS5sZW5ndGhdO1xuICAgIHJldHVybiB7XG4gICAgICBfcnR5cGU6IFwibmRhcnJheVwiLFxuICAgICAgX3J2YWx1ZTogdHlwZWRBcnJheSxcbiAgICAgIF9yc2hhcGU6IHNoYXBlLFxuICAgICAgX3JkdHlwZTogX2R0eXBlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuZXcgcmVtb3RlIGludGVyZmFjZSBwcm92aWRlZCBieSB0aGUgb3RoZXIgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBsaXN0IG9mIGZ1bmN0aW9uIG5hbWVzXG4gICAqL1xuICBfc2V0UmVtb3RlSW50ZXJmYWNlKGFwaSkge1xuICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVtcIl9ycmVtb3RlXCJdID0gdGhpcy5fZGVjb2RlKGFwaSk7XG4gICAgdGhpcy5fZmlyZShcInJlbW90ZVJlYWR5XCIpO1xuICAgIHRoaXMuX3JlcG9ydFJlbW90ZVNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgd3JhcHBlZCBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIHJlbW90ZVxuICAgKiBtZXRob2QuIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZCB0aGVcbiAgICogY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG8gZXhlY3V0ZVxuICAgKiB0aGUgcGFydGljdWxhciBtZXRob2Qgb2YgaXRzIGludGVyZmFjZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgcmVtb3RlIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgcmVtb3RlIG1ldGhvZFxuICAgKi9cbiAgX2dlblJlbW90ZU1ldGhvZChuYW1lLCBpbnRlcmZhY2VfaWQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZW1vdGVNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWQgPSBtZS5fbWV0aG9kX3JlZnMucHV0KFxuICAgICAgICAgICAgaW50ZXJmYWNlX2lkID8gaW50ZXJmYWNlX2lkICsgXCIvXCIgKyBuYW1lIDogbmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIHdyYXBwZWRfcmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGlkICE9PSBudWxsKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciB3cmFwcGVkX3JlamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGlkICE9PSBudWxsKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB3cmFwcGVkX3Jlc29sdmUuX19qYWlsZWRfcGFpcnNfXyA9IHdyYXBwZWRfcmVqZWN0O1xuICAgICAgICAgIHdyYXBwZWRfcmVqZWN0Ll9famFpbGVkX3BhaXJzX18gPSB3cmFwcGVkX3Jlc29sdmU7XG5cbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVnaXN0ZXJcIiB8fCBuYW1lID09PSBcImV4cG9ydFwiIHx8IG5hbWUgPT09IFwib25cIikge1xuICAgICAgICAgICAgYXJncyA9IG1lLl93cmFwKGFyZ3MsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzID0gbWUuX3dyYXAoYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIG1lLl9jb25uZWN0aW9uLmVtaXQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWV0aG9kXCIsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIHBpZDogaW50ZXJmYWNlX2lkLFxuICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICBwcm9taXNlOiBtZS5fd3JhcChbd3JhcHBlZF9yZXNvbHZlLCB3cmFwcGVkX3JlamVjdF0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmZXJhYmxlc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoaWQpIG1lLl9tZXRob2RfcmVmcy5mZXRjaChpZCk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdHVlIHJlbW90ZSBtZXRob2QgKGludGVyZmFjZTogJHtpbnRlcmZhY2VfaWQgfHxcbiAgICAgICAgICAgICAgbWUuaWR9LCBtZXRob2Q6ICR7bmFtZX0pLCBlcnJvcjogJHtlfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJlbW90ZU1ldGhvZC5fX3JlbW90ZV9tZXRob2QgPSB0cnVlO1xuICAgIHJldHVybiByZW1vdGVNZXRob2Q7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSByZXNwb25jZSByZXBvcnRpbmcgdGhhdCBpbnRlcmZhY2UganVzdCBwcm92aWRlZCBieSB0aGVcbiAgICogcmVtb3RlIHNpdGUgd2FzIHN1Y2Nlc3NmdWxseSBzZXQgYnkgdGhpcyBzaXRlIGFzIHJlbW90ZVxuICAgKi9cbiAgX3JlcG9ydFJlbW90ZVNldCgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImludGVyZmFjZVNldEFzUmVtb3RlXCIgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgdGhlIHByb3ZpZGVkIHNldCBvZiByZW1vdGUgbWV0aG9kIGFyZ3VtZW50cyBmb3JcbiAgICogc2VuZGluZyB0byB0aGUgcmVtb3RlIHNpdGUsIHJlcGxhY2VzIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGhcbiAgICogaWRlbnRpZmllcnNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyB0byB3cmFwXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gd3JhcHBlZCBhcmd1bWVudHNcbiAgICovXG5cbiAgX2VuY29kZUludGVyZmFjZShhT2JqZWN0KSB7XG4gICAgbGV0IHYsIGssIGtleXM7XG4gICAgY29uc3QgZW5jb2RlZF9pbnRlcmZhY2UgPSB7fTtcbiAgICBhT2JqZWN0W1wiX3JpZFwiXSA9IGFPYmplY3RbXCJfcmlkXCJdIHx8IHJhbmRJZCgpO1xuICAgIC8vIGFuIG9iamVjdC9hcnJheVxuICAgIGlmIChhT2JqZWN0LmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgQXJyYXkuaXNBcnJheShhT2JqZWN0KSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGFPYmplY3QpO1xuICAgIH1cbiAgICAvLyBhIGNsYXNzXG4gICAgZWxzZSBpZiAoYU9iamVjdC5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBpbnN0YW50aWF0ZSB0aGUgY2xhc3MgYmVmb3JlIGV4cG9ydHRpbmcgaXQuXCIpO1xuICAgIH1cbiAgICAvLyBpbnN0YW5jZSBvZiBhIGNsYXNzXG4gICAgZWxzZSBpZiAoYU9iamVjdC5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoYU9iamVjdCkpLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoYU9iamVjdClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgaW50ZXJmYWNlIHR5cGVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgYk9iamVjdCA9IEFycmF5LmlzQXJyYXkoYU9iamVjdCkgPyBbXSA6IHt9O1xuXG4gICAgZm9yIChrIG9mIGtleXMpIHtcbiAgICAgIGlmIChbXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdLmluY2x1ZGVzKGspKSBjb250aW51ZTtcblxuICAgICAgaWYgKGsuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2ID0gYU9iamVjdFtrXTtcblxuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICBfcnR5cGU6IFwiaW50ZXJmYWNlXCIsXG4gICAgICAgICAgX3JpZDogYU9iamVjdFtcIl9yaWRcIl0sXG4gICAgICAgICAgX3J2YWx1ZToga1xuICAgICAgICB9O1xuICAgICAgICBlbmNvZGVkX2ludGVyZmFjZVtrXSA9IHY7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdCh2KSAhPT0gdikge1xuICAgICAgICBiT2JqZWN0W2tdID0geyBfcnR5cGU6IFwiYXJndW1lbnRcIiwgX3J2YWx1ZTogdiB9O1xuICAgICAgICBlbmNvZGVkX2ludGVyZmFjZVtrXSA9IHY7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGJPYmplY3Rba10gPSB0aGlzLl9lbmNvZGVJbnRlcmZhY2Uodik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVthT2JqZWN0W1wiX3JpZFwiXV0gPSBlbmNvZGVkX2ludGVyZmFjZTtcblxuICAgIC8vIHJlbW92ZSBpbnRlcmZhY2Ugd2hlbiBjbG9zZWRcbiAgICBpZiAoYU9iamVjdC5vbiAmJiB0eXBlb2YgYU9iamVjdC5vbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBhT2JqZWN0Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5faW50ZXJmYWNlX3N0b3JlW2FPYmplY3RbXCJfcmlkXCJdXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYk9iamVjdDtcbiAgfVxuXG4gIF9lbmNvZGUoYU9iamVjdCwgYXNfaW50ZXJmYWNlKSB7XG4gICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdO1xuICAgIGlmICghYU9iamVjdCkge1xuICAgICAgcmV0dXJuIGFPYmplY3Q7XG4gICAgfVxuICAgIGNvbnN0IF90cmFuc2ZlciA9IGFPYmplY3QuX3RyYW5zZmVyO1xuICAgIGxldCBiT2JqZWN0LCB2LCBrO1xuICAgIGNvbnN0IGlzYXJyYXkgPSBBcnJheS5pc0FycmF5KGFPYmplY3QpO1xuICAgIC8vc2tpcCBpZiBhbHJlYWR5IGVuY29kZWRcbiAgICBpZiAodHlwZW9mIGFPYmplY3QgPT09IFwib2JqZWN0XCIgJiYgYU9iamVjdC5fcnR5cGUgJiYgYU9iamVjdC5fcnZhbHVlKSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG5cbiAgICAvL2VuY29kZSBpbnRlcmZhY2VzXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGFPYmplY3QgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICFBcnJheS5pc0FycmF5KGFPYmplY3QpICYmXG4gICAgICAoYU9iamVjdC5fcmludGYgfHwgYXNfaW50ZXJmYWNlKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUludGVyZmFjZShhT2JqZWN0KTtcbiAgICB9XG5cbiAgICBpZiAoYXNfaW50ZXJmYWNlKSB7XG4gICAgICBhT2JqZWN0W1wiX3JpZFwiXSA9IGFPYmplY3RbXCJfcmlkXCJdIHx8IHJhbmRJZCgpO1xuICAgICAgdGhpcy5faW50ZXJmYWNlX3N0b3JlW2FPYmplY3RbXCJfcmlkXCJdXSA9XG4gICAgICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVthT2JqZWN0W1wiX3JpZFwiXV0gfHwgKGlzYXJyYXkgPyBbXSA6IHt9KTtcbiAgICB9XG5cbiAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgZm9yIChrIGluIGFPYmplY3QpIHtcbiAgICAgIGlmIChbXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdLmluY2x1ZGVzKGspKSBjb250aW51ZTtcbiAgICAgIGlmIChpc2FycmF5IHx8IGFPYmplY3QuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgdiA9IGFPYmplY3Rba107XG4gICAgICAgIGlmICh2ICYmIHR5cGVvZiB0aGlzLl9sb2NhbF9hcGkuX3JwY19lbmNvZGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWRfb2JqID0gdGhpcy5fbG9jYWxfYXBpLl9ycGNfZW5jb2RlKHYpO1xuICAgICAgICAgIGlmIChlbmNvZGVkX29iaiAmJiBlbmNvZGVkX29iai5fY3R5cGUpIHtcbiAgICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICAgIF9ydHlwZTogXCJjdXN0b21cIixcbiAgICAgICAgICAgICAgX3J2YWx1ZTogZW5jb2RlZF9vYmosXG4gICAgICAgICAgICAgIF9yaWQ6IGFPYmplY3RbXCJfcmlkXCJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHRoZSByZXR1cm5lZCBvYmplY3QgZG9lcyBub3QgY29udGFpbiBfcnR5cGUsIGFzc3VtaW5nIHRoZSBvYmplY3QgaGFzIGJlZW4gdHJhbnNmb3JtZWRcbiAgICAgICAgICBlbHNlIGlmIChlbmNvZGVkX29iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2ID0gZW5jb2RlZF9vYmo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKGFzX2ludGVyZmFjZSkge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZF9pbnRlcmZhY2UgPSB0aGlzLl9pbnRlcmZhY2Vfc3RvcmVbYU9iamVjdFtcIl9yaWRcIl1dO1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgICAgX3J0eXBlOiBcImludGVyZmFjZVwiLFxuICAgICAgICAgICAgICBfcmlkOiBhT2JqZWN0W1wiX3JpZFwiXSxcbiAgICAgICAgICAgICAgX3J2YWx1ZToga1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVuY29kZWRfaW50ZXJmYWNlW2tdID0gdjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaW50ZXJmYWNlRnVuY05hbWUgPSBudWxsO1xuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5fbG9jYWxfYXBpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9jYWxfYXBpLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfXCIpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvY2FsX2FwaVtuYW1lXSA9PT0gdikge1xuICAgICAgICAgICAgICAgIGludGVyZmFjZUZ1bmNOYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzZWFyY2ggZm9yIHByb3RvdHlwZXNcbiAgICAgICAgICB2YXIgZnVuY3Rpb25zID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5fbG9jYWxfYXBpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lXyA9IGZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lXy5zdGFydHNXaXRoKFwiX1wiKSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9jYWxfYXBpW25hbWVfXSA9PT0gdikge1xuICAgICAgICAgICAgICBpbnRlcmZhY2VGdW5jTmFtZSA9IG5hbWVfO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpbnRlcmZhY2VGdW5jTmFtZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5fc3RvcmUucHV0KHYpO1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHtcbiAgICAgICAgICAgICAgX3J0eXBlOiBcImNhbGxiYWNrXCIsXG4gICAgICAgICAgICAgIF9ydmFsdWU6ICh2LmNvbnN0cnVjdG9yICYmIHYuY29uc3RydWN0b3IubmFtZSkgfHwgaWQsXG4gICAgICAgICAgICAgIF9yaW5kZXg6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiT2JqZWN0W2tdID0ge1xuICAgICAgICAgICAgICBfcnR5cGU6IFwiaW50ZXJmYWNlXCIsXG4gICAgICAgICAgICAgIF9ydmFsdWU6IGludGVyZmFjZUZ1bmNOYW1lLFxuICAgICAgICAgICAgICBfcmlkOiBcIl9ybG9jYWxcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgLypnbG9iYWwgdGYqL1xuICAgICAgICAgIHR5cGVvZiB0ZiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgIHRmLlRlbnNvciAmJlxuICAgICAgICAgIHYgaW5zdGFuY2VvZiB0Zi5UZW5zb3JcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgdl9idWZmZXIgPSB2LmRhdGFTeW5jKCk7XG4gICAgICAgICAgaWYgKHYuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHZfYnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICBfcnR5cGU6IFwibmRhcnJheVwiLFxuICAgICAgICAgICAgX3J2YWx1ZTogdl9idWZmZXIsXG4gICAgICAgICAgICBfcnNoYXBlOiB2LnNoYXBlLFxuICAgICAgICAgICAgX3JkdHlwZTogdi5kdHlwZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgLypnbG9iYWwgbmoqL1xuICAgICAgICAgIHR5cGVvZiBuaiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgIG5qLk5kQXJyYXkgJiZcbiAgICAgICAgICB2IGluc3RhbmNlb2YgbmouTmRBcnJheVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZHR5cGUgPSB0eXBlZEFycmF5VG9EdHlwZVt2LnNlbGVjdGlvbi5kYXRhLmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh2LnNlbGVjdGlvbi5kYXRhLmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7XG4gICAgICAgICAgICBfcnR5cGU6IFwibmRhcnJheVwiLFxuICAgICAgICAgICAgX3J2YWx1ZTogdi5zZWxlY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIF9yc2hhcGU6IHYuc2hhcGUsXG4gICAgICAgICAgICBfcmR0eXBlOiBkdHlwZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcih2KTtcbiAgICAgICAgICBiT2JqZWN0W2tdID0geyBfcnR5cGU6IFwiZXJyb3JcIiwgX3J2YWx1ZTogdi50b1N0cmluZygpIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdiBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICBiT2JqZWN0W2tdID0ge1xuICAgICAgICAgICAgX3J0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIF9ydmFsdWU6IHYsXG4gICAgICAgICAgICBfcnJlbGF0aXZlX3BhdGg6IHYucmVsYXRpdmVQYXRoIHx8IHYud2Via2l0UmVsYXRpdmVQYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZW5kIG9iamVjdHMgc3VwcG9ydGVkIGJ5IHN0cnVjdHVyZSBjbG9uZSBhbGdvcml0aG1cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICB2ICE9PSBPYmplY3QodikgfHxcbiAgICAgICAgICB2IGluc3RhbmNlb2YgQm9vbGVhbiB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgICB2IGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAgICAgICB2IGluc3RhbmNlb2YgQmxvYiB8fFxuICAgICAgICAgIHYgaW5zdGFuY2VvZiBJbWFnZURhdGEgfHxcbiAgICAgICAgICAodHlwZW9mIEZpbGVMaXN0ICE9PSBcInVuZGVmaW5lZFwiICYmIHYgaW5zdGFuY2VvZiBGaWxlTGlzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHsgX3J0eXBlOiBcImFyZ3VtZW50XCIsIF9ydmFsdWU6IHYgfTtcbiAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBpZiAodi5fdHJhbnNmZXIgfHwgX3RyYW5zZmVyKSB7XG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2godik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7IF9ydHlwZTogXCJhcmd1bWVudFwiLCBfcnZhbHVlOiB2IH07XG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyVmlldykge1xuICAgICAgICAgIGlmICh2Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh2LmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgdi5fdHJhbnNmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJPYmplY3Rba10gPSB7IF9ydHlwZTogXCJhcmd1bWVudFwiLCBfcnZhbHVlOiB2IH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhbHNvIE1hcCBhbmQgU2V0XG4gICAgICAgIC8vIFRPRE86IGF2b2lkIG9iamVjdCBzdWNoIGFzIER5bmFtaWNQbHVnaW4gaW5zdGFuY2UuXG4gICAgICAgIGVsc2UgaWYgKHYuX3JpbnRmKSB7XG4gICAgICAgICAgYk9iamVjdFtrXSA9IHRoaXMuX2VuY29kZSh2LCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGJPYmplY3Rba10gPSB0aGlzLl9lbmNvZGUodiwgYXNfaW50ZXJmYWNlKTtcbiAgICAgICAgICAvLyBtb3ZlIHRyYW5zZmVyYWJsZXMgdG8gdGhlIHRvcCBsZXZlbCBvYmplY3RcbiAgICAgICAgICBpZiAoYk9iamVjdFtrXS5fX3RyYW5zZmVyYWJsZXNfXykge1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fW3RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBiT2JqZWN0W2tdLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcImltam95LXJwYzogVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiICsgayArIFwiLFwiICsgdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBiT2JqZWN0Ll9fdHJhbnNmZXJhYmxlc19fID0gdHJhbnNmZXJhYmxlcztcbiAgICB9XG4gICAgcmV0dXJuIGJPYmplY3Q7XG4gIH1cblxuICBfZGVjb2RlKGFPYmplY3QsIGNhbGxiYWNrSWQsIHdpdGhQcm9taXNlKSB7XG4gICAgaWYgKCFhT2JqZWN0KSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG4gICAgdmFyIGJPYmplY3QsIHYsIGs7XG4gICAgaWYgKGFPYmplY3QuaGFzT3duUHJvcGVydHkoXCJfcnR5cGVcIikgJiYgYU9iamVjdC5oYXNPd25Qcm9wZXJ0eShcIl9ydmFsdWVcIikpIHtcbiAgICAgIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYU9iamVjdC5fcnZhbHVlICYmXG4gICAgICAgICAgdHlwZW9mIHRoaXMuX2xvY2FsX2FwaS5fcnBjX2RlY29kZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgIGJPYmplY3QgPSB0aGlzLl9sb2NhbF9hcGkuX3JwY19kZWNvZGUoYU9iamVjdC5fcnZhbHVlKTtcbiAgICAgICAgICBpZiAoYk9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBiT2JqZWN0ID0gYU9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiY2FsbGJhY2tcIikge1xuICAgICAgICBiT2JqZWN0ID0gdGhpcy5fZ2VuUmVtb3RlQ2FsbGJhY2soXG4gICAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgICBhT2JqZWN0Ll9yaW5kZXgsXG4gICAgICAgICAgd2l0aFByb21pc2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgY29uc3QgaW50ZmlkID0gYU9iamVjdC5fcmlkID09PSBcIl9ybG9jYWxcIiA/IFwiX3JybW90ZVwiIDogYU9iamVjdC5fcmlkO1xuICAgICAgICBiT2JqZWN0ID1cbiAgICAgICAgICAodGhpcy5faW50ZXJmYWNlX3N0b3JlW2ludGZpZF0gJiZcbiAgICAgICAgICAgIHRoaXMuX2ludGVyZmFjZV9zdG9yZVtpbnRmaWRdW2FPYmplY3QuX3J2YWx1ZV0pIHx8XG4gICAgICAgICAgdGhpcy5fZ2VuUmVtb3RlTWV0aG9kKGFPYmplY3QuX3J2YWx1ZSwgYU9iamVjdC5fcmlkKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwibmRhcnJheVwiKSB7XG4gICAgICAgIC8qZ2xvYmFsIG5qIHRmKi9cbiAgICAgICAgLy9jcmVhdGUgYnVpbGQgYXJyYXkvdGVuc29yIGlmIHVzZWQgaW4gdGhlIHBsdWdpblxuICAgICAgICBpZiAodHlwZW9mIG5qICE9PSBcInVuZGVmaW5lZFwiICYmIG5qLmFycmF5KSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYU9iamVjdC5fcnZhbHVlKSkge1xuICAgICAgICAgICAgYU9iamVjdC5fcnZhbHVlID0gYU9iamVjdC5fcnZhbHVlLnJlZHVjZShfYXBwZW5kQnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYk9iamVjdCA9IG5qXG4gICAgICAgICAgICAuYXJyYXkoYU9iamVjdC5fcnZhbHVlLCBhT2JqZWN0Ll9yZHR5cGUpXG4gICAgICAgICAgICAucmVzaGFwZShhT2JqZWN0Ll9yc2hhcGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0Zi5UZW5zb3IpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhT2JqZWN0Ll9ydmFsdWUpKSB7XG4gICAgICAgICAgICBhT2JqZWN0Ll9ydmFsdWUgPSBhT2JqZWN0Ll9ydmFsdWUucmVkdWNlKF9hcHBlbmRCdWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiT2JqZWN0ID0gdGYudGVuc29yKFxuICAgICAgICAgICAgYU9iamVjdC5fcnZhbHVlLFxuICAgICAgICAgICAgYU9iamVjdC5fcnNoYXBlLFxuICAgICAgICAgICAgYU9iamVjdC5fcmR0eXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2tlZXAgaXQgYXMgcmVndWxhciBpZiB0cmFuc2ZlcmVkIHRvIHRoZSBtYWluIGFwcFxuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IG5ldyBFcnJvcihhT2JqZWN0Ll9ydmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IGFPYmplY3QuX3J2YWx1ZTtcbiAgICAgICAgLy9wYXRjaCByZWxhdGl2ZVBhdGhcbiAgICAgICAgYk9iamVjdC5yZWxhdGl2ZVBhdGggPSBhT2JqZWN0Ll9ycmVsYXRpdmVfcGF0aDtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiYXJndW1lbnRcIikge1xuICAgICAgICBiT2JqZWN0ID0gYU9iamVjdC5fcnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheShhT2JqZWN0KTtcbiAgICAgIGJPYmplY3QgPSBpc2FycmF5ID8gW10gOiB7fTtcbiAgICAgIGZvciAoayBpbiBhT2JqZWN0KSB7XG4gICAgICAgIGlmIChpc2FycmF5IHx8IGFPYmplY3QuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICB2ID0gYU9iamVjdFtrXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgYk9iamVjdFtrXSA9IHRoaXMuX2RlY29kZSh2LCBjYWxsYmFja0lkLCB3aXRoUHJvbWlzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYk9iamVjdDtcbiAgICB9XG4gIH1cblxuICBfd3JhcChhcmdzLCBhc19pbnRlcmZhY2UpIHtcbiAgICB2YXIgd3JhcHBlZCA9IHRoaXMuX2VuY29kZShhcmdzLCBhc19pbnRlcmZhY2UpO1xuICAgIHZhciByZXN1bHQgPSB7IGFyZ3M6IHdyYXBwZWQgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVud3JhcHMgdGhlIHNldCBvZiBhcmd1bWVudHMgZGVsaXZlcmVkIGZyb20gdGhlIHJlbW90ZSBzaXRlLFxuICAgKiByZXBsYWNlcyBhbGwgY2FsbGJhY2sgaWRlbnRpZmllcnMgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHdpbGxcbiAgICogaW5pdGlhdGUgc2VuZGluZyB0aGF0IGNhbGxiYWNrIGlkZW50aWZpZXIgYmFjayB0byBvdGhlciBzaXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIHRvIHVud3JhcFxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhQcm9taXNlIGlzIHRydWUgbWVhbnMgdGhpcyB0aGUgY2FsbGJhY2sgc2hvdWxkIGNvbnRhaW4gYSBwcm9taXNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdW53cmFwcGVkIGFyZ3NcbiAgICovXG4gIF91bndyYXAoYXJncywgd2l0aFByb21pc2UpIHtcbiAgICAvLyB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICAvLyB3cmFwcyBlYWNoIGNhbGxiYWNrIHNvIHRoYXQgdGhlIG9ubHkgb25lIGNvdWxkIGJlIGNhbGxlZFxuICAgIC8vIHZhciBvbmNlKGNiKSB7XG4gICAgLy8gICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgLy8gICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgICAgICByZXR1cm4gY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyAgICAgICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICAgICAgdmFyIG1zZyA9XG4gICAgLy8gICAgICAgICAgICAgICAnQSBjYWxsYmFjayBmcm9tIHRoaXMgc2V0IGhhcyBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQnO1xuICAgIC8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9O1xuICAgIC8vIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZGVjb2RlKGFyZ3MuYXJncywgYXJncy5jYWxsYmFja0lkLCB3aXRoUHJvbWlzZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHdyYXBwZWQgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBhIHNpbmdsZSByZW1vdGVcbiAgICogY2FsbGJhY2suIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZFxuICAgKiB0aGUgY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG9cbiAgICogZXhlY3V0ZSB0aGUgcGFydGljdWxhciBjYWxsYmFjayBwcmV2aW91c2x5IHNhdmVkIGR1cmluZyBhIGNhbGxcbiAgICogYnkgdGhlIHJlbW90ZSBzaXRlIGEgbWV0aG9kIGZyb20gdGhlIGludGVyZmFjZSBvZiB0aGlzIHNpdGVcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIG9mIHRoZSByZW1vdGUgY2FsbGJhY2sgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYXJnTnVtIGFyZ3VtZW50IGluZGV4IG9mIHRoZSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhQcm9taXNlIGlzIHRydWUgbWVhbnMgdGhpcyB0aGUgY2FsbGJhY2sgc2hvdWxkIGNvbnRhaW4gYSBwcm9taXNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCByZW1vdGUgY2FsbGJhY2tcbiAgICovXG4gIF9nZW5SZW1vdGVDYWxsYmFjayhpZCwgYXJnTnVtLCB3aXRoUHJvbWlzZSkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHJlbW90ZUNhbGxiYWNrO1xuICAgIGlmICh3aXRoUHJvbWlzZSkge1xuICAgICAgcmVtb3RlQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB2YXIgYXJncyA9IG1lLl93cmFwKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIHJlc29sdmUuX19qYWlsZWRfcGFpcnNfXyA9IHJlamVjdDtcbiAgICAgICAgICByZWplY3QuX19qYWlsZWRfcGFpcnNfXyA9IHJlc29sdmU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lLl9jb25uZWN0aW9uLmVtaXQoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNhbGxiYWNrXCIsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIF9yaW5kZXg6IGFyZ051bSxcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgIC8vIHBpZCA6ICBtZS5pZCxcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBtZS5fd3JhcChbcmVzb2x2ZSwgcmVqZWN0XSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3R1ZSByZW1vdGUgY2FsbGJhY2sgKGlkOiAke2lkfSwgYXJnTnVtOiAke2FyZ051bX0pLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW90ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5hcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgcmV0dXJuIG1lLl9jb25uZWN0aW9uLmVtaXQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgX3JpbmRleDogYXJnTnVtLFxuICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgLy8gcGlkIDogIG1lLmlkXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2ZlcmFibGVzXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlbW90ZUNhbGxiYWNrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgbm90aWZpY2F0aW9uIG1lc3NhZ2UgYW5kIGJyZWFrcyB0aGUgY29ubmVjdGlvblxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImRpc2Nvbm5lY3RcIiB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgIH0sIDIwMDApO1xuICB9XG59XG5cbi8qKlxuICogUmVmZXJlbmNlU3RvcmUgaXMgYSBzcGVjaWFsIG9iamVjdCB3aGljaCBzdG9yZXMgb3RoZXIgb2JqZWN0c1xuICogYW5kIHByb3ZpZGVzIHRoZSByZWZlcmVuY2VzIChudW1iZXIpIGluc3RlYWQuIFRoaXMgcmVmZXJlbmNlXG4gKiBtYXkgdGhlbiBiZSBzZW50IG92ZXIgYSBqc29uLWJhc2VkIGNvbW11bmljYXRpb24gY2hhbm5lbCAoSVBDXG4gKiB0byBhbm90aGVyIE5vZGUuanMgcHJvY2VzcyBvciBhIG1lc3NhZ2UgdG8gdGhlIFdvcmtlcikuIE90aGVyXG4gKiBzaXRlIG1heSB0aGVuIHByb3ZpZGUgdGhlIHJlZmVyZW5jZSBpbiB0aGUgcmVzcG9uY2UgbWVzc2FnZVxuICogaW1wbHlpbmcgdGhlIGdpdmVuIG9iamVjdCBzaG91bGQgYmUgYWN0aXZhdGVkLlxuICpcbiAqIFByaW1hcnkgdXNhZ2UgZm9yIHRoZSBSZWZlcmVuY2VTdG9yZSBpcyBhIHN0b3JhZ2UgZm9yIHRoZVxuICogY2FsbGJhY2tzLCB3aGljaCB0aGVyZWZvcmUgbWFrZXMgaXQgcG9zc2libGUgdG8gaW5pdGlhdGUgYVxuICogY2FsbGJhY2sgZXhlY3V0aW9uIGJ5IHRoZSBvcHBvc2l0ZSBzaXRlICh3aGljaCBub3JtYWxseSBjYW5ub3RcbiAqIGRpcmVjdGx5IGV4ZWN1dGUgZnVuY3Rpb25zIG92ZXIgdGhlIGNvbW11bmljYXRpb24gY2hhbm5lbCkuXG4gKlxuICogRWFjaCBzdG9yZWQgb2JqZWN0IGNhbiBvbmx5IGJlIGZldGNoZWQgb25jZSBhbmQgaXMgbm90XG4gKiBhdmFpbGFibGUgZm9yIHRoZSBzZWNvbmQgdGltZS4gRWFjaCBzdG9yZWQgb2JqZWN0IG11c3QgYmVcbiAqIGZldGNoZWQsIHNpbmNlIG90aGVyd2lzZSBpdCB3aWxsIHJlbWFpbiBzdG9yZWQgZm9yZXZlciBhbmRcbiAqIGNvbnN1bWUgbWVtb3J5LlxuICpcbiAqIFN0b3JlZCBvYmplY3QgaW5kZWNlcyBhcmUgc2ltcGx5IHRoZSBudW1iZXJzLCB3aGljaCBhcmUgaG93ZXZlclxuICogcmVsZWFzZWQgYWxvbmcgd2l0aCB0aGUgb2JqZWN0cywgYW5kIGFyZSBsYXRlciByZXVzZWQgYWdhaW4gKGluXG4gKiBvcmRlciB0byBwb3N0cG9uZSB0aGUgb3ZlcmZsb3csIHdoaWNoIHNob3VsZCBub3QgbGlrZWx5IGhhcHBlbixcbiAqIGJ1dCBhbnl3YXkpLlxuICovXG5jbGFzcyBSZWZlcmVuY2VTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N0b3JlID0ge307IC8vIHN0b3JlZCBvYmplY3RcbiAgICB0aGlzLl9pbmRpY2VzID0gWzBdOyAvLyBzbWFsbGVzdCBhdmFpbGFibGUgaW5kaWNlc1xuICAgIHRoaXMuX3JlYWR5SGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5fYnVzeUhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuX3JlYWR5SGFuZGxlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGwgaGFuZGxlciB3aGVuIHRoZSBzdG9yZSBpcyBlbXB0eVxuICAgKlxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcbiAgICovXG4gIG9uUmVhZHkocmVhZHlIYW5kbGVyKSB7XG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyID0gcmVhZHlIYW5kbGVyIHx8IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICAvKipcbiAgICogY2FsbCBoYW5kbGVyIHdoZW4gdGhlIHN0b3JlIGlzIG5vdCBlbXB0eVxuICAgKlxuICAgKiBAcGFyYW0ge0ZVTkNUSU9OfSBpZCBvZiBhIGhhbmRsZXJcbiAgICovXG4gIG9uQnVzeShidXN5SGFuZGxlcikge1xuICAgIHRoaXMuX2J1c3lIYW5kbGVyID0gYnVzeUhhbmRsZXIgfHwgZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgc3RvcmVcbiAgICpcbiAgICovXG4gIGdldFN0YWNrKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdG9yZSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBfZ2VuSWQoKSBnZW5lcmF0ZXMgdGhlIG5ldyByZWZlcmVuY2UgaWRcbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gc21hbGxlc3QgYXZhaWxhYmxlIGlkIGFuZCByZXNlcnZlcyBpdFxuICAgKi9cbiAgX2dlbklkKCkge1xuICAgIHZhciBpZDtcbiAgICBpZiAodGhpcy5faW5kaWNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlkID0gdGhpcy5faW5kaWNlc1swXSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuX2luZGljZXMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIHJlZmVyZW5jZSBpZCBzbyB0aGF0IGl0IHdpbGwgYmUgYXZhaWxhYmxlIGJ5XG4gICAqIGFub3RoZXIgb2JqZWN0IHN0b3JlZFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgdG8gcmVsZWFzZVxuICAgKi9cbiAgX3JlbGVhc2VJZChpZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlkIDwgdGhpcy5faW5kaWNlc1tpXSkge1xuICAgICAgICB0aGlzLl9pbmRpY2VzLnNwbGljZShpLCAwLCBpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFuaW5nLXVwIHRoZSBzZXF1ZW5jZSB0YWlsXG4gICAgZm9yIChpID0gdGhpcy5faW5kaWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuX2luZGljZXNbaV0gLSAxID09PSB0aGlzLl9pbmRpY2VzW2kgLSAxXSkge1xuICAgICAgICB0aGlzLl9pbmRpY2VzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSByZWZlcm5jZSBpZCBpbnN0ZWFkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdG8gc3RvcmVcbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gcmVmZXJlbmNlIGlkIG9mIHRoZSBzdG9yZWQgb2JqZWN0XG4gICAqL1xuICBwdXQob2JqKSB7XG4gICAgaWYgKHRoaXMuX2J1c3lIYW5kbGVyICYmIE9iamVjdC5rZXlzKHRoaXMuX3N0b3JlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2J1c3lIYW5kbGVyKCk7XG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuX2dlbklkKCk7XG4gICAgdGhpcy5fc3RvcmVbaWRdID0gb2JqO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcHJldmlvdXNseSBzdG9yZWQgb2JqZWN0IGFuZCByZWxlYXNlcyBpdHMgcmVmZXJlbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBvZiBhbiBvYmplY3QgdG8gcmV0cmlldmVcbiAgICovXG4gIGZldGNoKGlkKSB7XG4gICAgdmFyIG9iaiA9IHRoaXMuX3N0b3JlW2lkXTtcbiAgICBpZiAob2JqICYmICFvYmouX19yZW1vdGVfbWV0aG9kKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RvcmVbaWRdO1xuICAgICAgdGhpcy5fcmVsZWFzZUlkKGlkKTtcbiAgICAgIGlmICh0aGlzLl9yZWFkeUhhbmRsZXIgJiYgT2JqZWN0LmtleXModGhpcy5fc3RvcmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZWFkeUhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iaiAmJiBvYmouX19qYWlsZWRfcGFpcnNfXykge1xuICAgICAgY29uc3QgX2lkID0gZ2V0S2V5QnlWYWx1ZSh0aGlzLl9zdG9yZSwgb2JqLl9famFpbGVkX3BhaXJzX18pO1xuICAgICAgdGhpcy5mZXRjaChfaWQpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBUEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQVJBO0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBVUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXB3QkE7QUFzd0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBL0dBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/rpc.js\n");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: randId, dtypeToTypedArray, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randId\", function() { return randId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"urlJoin\", function() { return urlJoin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\nconst dtypeToTypedArray = {\n  int8: \"Int8Array\",\n  int16: \"Int16Array\",\n  int32: \"Int32Array\",\n  uint8: \"Uint8Array\",\n  uint16: \"Uint16Array\",\n  uint32: \"Uint32Array\",\n  float32: \"Float32Array\",\n  float64: \"Float64Array\",\n  array: \"Array\"\n};\nconst typedArrayToDtype = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\"\n};\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url\n    };\n\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n\n    const messageChannel = new MessageChannel();\n\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  if (!Array.isArray(requirements)) {\n    requirementsm.code.requirements = [requirements];\n  }\n\n  if (requirements && requirements.length > 0) {\n    for (let req of requirements) {\n      //remove prefix\n      if (req.startsWith(\"js:\")) req = req.slice(3);\n      if (req.startsWith(\"css:\")) req = req.slice(4);\n      if (req.startsWith(\"cache:\")) req = req.slice(6);\n      if (!req.startsWith(\"http\")) continue;\n      await cacheUrlInServiceWorker(req).catch(e => {\n        console.error(e);\n      });\n    }\n  }\n}\nfunction setupServiceWorker(targetOrigin, cacheCallback) {\n  // register service worker for offline access\n  if (\"serviceWorker\" in navigator) {\n    window.addEventListener(\"load\", function () {\n      navigator.serviceWorker.register(\"/plugin-service-worker.js\").then(function (registration) {\n        // Registration was successful\n        console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n      }, function (err) {\n        // registration failed :(\n        console.log(\"ServiceWorker registration failed: \", err);\n      });\n      targetOrigin = targetOrigin || \"*\";\n      cacheCallback = cacheCallback || cacheRequirements;\n\n      if (cacheCallback && typeof cacheCallback !== \"function\") {\n        throw new Error(\"config.cache_requirements must be a function\");\n      }\n\n      window.addEventListener(\"message\", function (e) {\n        if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n          const m = e.data;\n\n          if (m.type === \"cacheRequirements\") {\n            cacheCallback(m.requirements);\n          }\n        }\n      });\n    });\n  }\n} //#Source https://bit.ly/2neWfJ2\n\nfunction urlJoin(...args) {\n  return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n\n    this._event_handlers[event].push(handler);\n  }\n\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWpveVJQQy8uL3NyYy91dGlscy5qcz8wMjVlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiByYW5kSWQoKSB7XG4gIHJldHVybiAoXG4gICAgTWF0aC5yYW5kb20oKVxuICAgICAgLnRvU3RyaW5nKDM2KVxuICAgICAgLnN1YnN0cigyLCAxMCkgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICApO1xufVxuXG5leHBvcnQgY29uc3QgZHR5cGVUb1R5cGVkQXJyYXkgPSB7XG4gIGludDg6IFwiSW50OEFycmF5XCIsXG4gIGludDE2OiBcIkludDE2QXJyYXlcIixcbiAgaW50MzI6IFwiSW50MzJBcnJheVwiLFxuICB1aW50ODogXCJVaW50OEFycmF5XCIsXG4gIHVpbnQxNjogXCJVaW50MTZBcnJheVwiLFxuICB1aW50MzI6IFwiVWludDMyQXJyYXlcIixcbiAgZmxvYXQzMjogXCJGbG9hdDMyQXJyYXlcIixcbiAgZmxvYXQ2NDogXCJGbG9hdDY0QXJyYXlcIixcbiAgYXJyYXk6IFwiQXJyYXlcIlxufTtcbmV4cG9ydCBjb25zdCB0eXBlZEFycmF5VG9EdHlwZSA9IHtcbiAgSW50OEFycmF5OiBcImludDhcIixcbiAgSW50MTZBcnJheTogXCJpbnQxNlwiLFxuICBJbnQzMkFycmF5OiBcImludDMyXCIsXG4gIFVpbnQ4QXJyYXk6IFwidWludDhcIixcbiAgVWludDE2QXJyYXk6IFwidWludDE2XCIsXG4gIFVpbnQzMkFycmF5OiBcInVpbnQzMlwiLFxuICBGbG9hdDMyQXJyYXk6IFwiZmxvYXQzMlwiLFxuICBGbG9hdDY0QXJyYXk6IFwiZmxvYXQ2NFwiLFxuICBBcnJheTogXCJhcnJheVwiXG59O1xuXG5mdW5jdGlvbiBjYWNoZVVybEluU2VydmljZVdvcmtlcih1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICBjb21tYW5kOiBcImFkZFwiLFxuICAgICAgdXJsOiB1cmxcbiAgICB9O1xuICAgIGlmICghbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgfHwgIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKSB7XG4gICAgICByZWplY3QoXCJTZXJ2aWNlIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lcnJvcikge1xuICAgICAgICByZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlci5wb3N0TWVzc2FnZShtZXNzYWdlLCBbXG4gICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQyXG4gICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KFwiU2VydmljZSB3b3JrZXIgY29udHJvbGxlciBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWNoZVJlcXVpcmVtZW50cyhyZXF1aXJlbWVudHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlcXVpcmVtZW50cykpIHtcbiAgICByZXF1aXJlbWVudHNtLmNvZGUucmVxdWlyZW1lbnRzID0gW3JlcXVpcmVtZW50c107XG4gIH1cbiAgaWYgKHJlcXVpcmVtZW50cyAmJiByZXF1aXJlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAobGV0IHJlcSBvZiByZXF1aXJlbWVudHMpIHtcbiAgICAgIC8vcmVtb3ZlIHByZWZpeFxuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFwianM6XCIpKSByZXEgPSByZXEuc2xpY2UoMyk7XG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXCJjc3M6XCIpKSByZXEgPSByZXEuc2xpY2UoNCk7XG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXCJjYWNoZTpcIikpIHJlcSA9IHJlcS5zbGljZSg2KTtcbiAgICAgIGlmICghcmVxLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSBjb250aW51ZTtcblxuICAgICAgYXdhaXQgY2FjaGVVcmxJblNlcnZpY2VXb3JrZXIocmVxKS5jYXRjaChlID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTZXJ2aWNlV29ya2VyKHRhcmdldE9yaWdpbiwgY2FjaGVDYWxsYmFjaykge1xuICAvLyByZWdpc3RlciBzZXJ2aWNlIHdvcmtlciBmb3Igb2ZmbGluZSBhY2Nlc3NcbiAgaWYgKFwic2VydmljZVdvcmtlclwiIGluIG5hdmlnYXRvcikge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKFwiL3BsdWdpbi1zZXJ2aWNlLXdvcmtlci5qc1wiKS50aGVuKFxuICAgICAgICBmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAvLyBSZWdpc3RyYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwiU2VydmljZVdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCB3aXRoIHNjb3BlOiBcIixcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5zY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIC8vIHJlZ2lzdHJhdGlvbiBmYWlsZWQgOihcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZDogXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0YXJnZXRPcmlnaW4gPSB0YXJnZXRPcmlnaW4gfHwgXCIqXCI7XG4gICAgICBjYWNoZUNhbGxiYWNrID0gY2FjaGVDYWxsYmFjayB8fCBjYWNoZVJlcXVpcmVtZW50cztcbiAgICAgIGlmIChjYWNoZUNhbGxiYWNrICYmIHR5cGVvZiBjYWNoZUNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uZmlnLmNhY2hlX3JlcXVpcmVtZW50cyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGFyZ2V0T3JpZ2luID09PSBcIipcIiB8fCBlLm9yaWdpbiA9PT0gdGFyZ2V0T3JpZ2luKSB7XG4gICAgICAgICAgY29uc3QgbSA9IGUuZGF0YTtcbiAgICAgICAgICBpZiAobS50eXBlID09PSBcImNhY2hlUmVxdWlyZW1lbnRzXCIpIHtcbiAgICAgICAgICAgIGNhY2hlQ2FsbGJhY2sobS5yZXF1aXJlbWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8jU291cmNlIGh0dHBzOi8vYml0Lmx5LzJuZVdmSjJcbmV4cG9ydCBmdW5jdGlvbiB1cmxKb2luKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3NcbiAgICAuam9pbihcIi9cIilcbiAgICAucmVwbGFjZSgvW1xcL10rL2csIFwiL1wiKVxuICAgIC5yZXBsYWNlKC9eKC4rKTpcXC8vLCBcIiQxOi8vXCIpXG4gICAgLnJlcGxhY2UoL15maWxlOi8sIFwiZmlsZTovXCIpXG4gICAgLnJlcGxhY2UoL1xcLyhcXD98JnwjW14hXSkvZywgXCIkMVwiKVxuICAgIC5yZXBsYWNlKC9cXD8vZywgXCImXCIpXG4gICAgLnJlcGxhY2UoXCImXCIsIFwiP1wiKTtcbn1cblxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoZGVidWcpIHtcbiAgICB0aGlzLl9ldmVudF9oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuX29uY2VfaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLl9kZWJ1ZyA9IGRlYnVnO1xuICB9XG4gIGVtaXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZW1pdCBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICB9XG4gIG9uY2UoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyLl9fX2V2ZW50X3J1bl9vbmNlID0gdHJ1ZTtcbiAgICB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoIWV2ZW50ICYmICFoYW5kbGVyKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGV2ZW50cyBoYW5kbGVyc1xuICAgICAgdGhpcy5fZXZlbnRfaGFuZGxlcnMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50ICYmICFoYW5kbGVyKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGhhbmxkZXJzIGZvciB0aGUgZXZlbnRcbiAgICAgIGlmICh0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0pIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgYSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICBpZiAodGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2ZpcmUoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF1baV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXIuX19fZXZlbnRfcnVuX29uY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJ1bmhhbmRsZWQgZXZlbnRcIiwgZXZlbnQsIGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6REEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils.js\n");

/***/ })

/******/ });
});