(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("imjoyRPC", [], factory);
	else if(typeof exports === 'object')
		exports["imjoyRPC"] = factory();
	else
		root["imjoyRPC"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd29ya2VyLWxvYWRlci9kaXN0L3dvcmtlcnMvSW5saW5lV29ya2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9ub2RlX21vZHVsZXMvd29ya2VyLWxvYWRlci9kaXN0L3dvcmtlcnMvSW5saW5lV29ya2VyLmpzPzc3ODUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMzQzOTEzL2hvdy10by1jcmVhdGUtYS13ZWItd29ya2VyLWZyb20tYS1zdHJpbmdcblxudmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBibG9iO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBCbG9iQnVpbGRlciA9IERlcHJlY2F0ZWQsIGJ1dCB3aWRlbHkgaW1wbGVtZW50ZWRcbiAgICAgICAgdmFyIEJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XG5cbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuXG4gICAgICAgIGJsb2IuYXBwZW5kKGNvbnRlbnQpO1xuXG4gICAgICAgIGJsb2IgPSBibG9iLmdldEJsb2IoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVGhlIHByb3Bvc2VkIEFQSVxuICAgICAgICBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG5ldyBXb3JrZXIoJ2RhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0lubGluZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgV29ya2VyKHVybCk7XG4gIH1cbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/worker-loader/dist/workers/InlineWorker.js\n");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, description, module, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"imjoy-rpc\\\",\\\"version\\\":\\\"0.2.14\\\",\\\"description\\\":\\\"Remote procedure calls for ImJoy.\\\",\\\"module\\\":\\\"index.js\\\",\\\"scripts\\\":{\\\"build\\\":\\\"rm -rf dist && npm run build-umd\\\",\\\"build-umd\\\":\\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\\",\\\"watch\\\":\\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\\",\\\"publish\\\":\\\"npm install && npm run build && npm publish\\\",\\\"serve\\\":\\\"webpack-dev-server\\\",\\\"stats\\\":\\\"webpack --profile --json > stats.json\\\",\\\"stats-prod\\\":\\\"webpack --profile --json --mode production > stats-prod.json\\\",\\\"analyze\\\":\\\"webpack-bundle-analyzer -p 9999 stats.json\\\",\\\"analyze-prod\\\":\\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\\",\\\"clean\\\":\\\"rimraf dist/*\\\",\\\"deploy\\\":\\\"npm run build && node deploy-site.js\\\",\\\"format\\\":\\\"prettier --write \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"check-format\\\":\\\"prettier --check \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"test\\\":\\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\\",\\\"test-watch\\\":\\\"karma start --auto-watch --browsers Chrome,FirefoxHeadless karma.conf.js --debug\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\\"},\\\"keywords\\\":[\\\"imjoy\\\",\\\"rpc\\\"],\\\"author\\\":\\\"imjoy-team <imjoy.team@gmail.com>\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/imjoy-team/imjoy-rpc/issues\\\"},\\\"homepage\\\":\\\"https://github.com/imjoy-team/imjoy-rpc\\\",\\\"dependencies\\\":{},\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.0.0-beta.39\\\",\\\"@babel/plugin-syntax-dynamic-import\\\":\\\"^7.0.0-beta.39\\\",\\\"@babel/polyfill\\\":\\\"^7.0.0-beta.39\\\",\\\"@babel/preset-env\\\":\\\"^7.0.0-beta.39\\\",\\\"@types/requirejs\\\":\\\"^2.1.28\\\",\\\"babel-core\\\":\\\"^6.26.0\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"babel-loader\\\":\\\"^8.1.0\\\",\\\"babel-runtime\\\":\\\"^6.26.0\\\",\\\"chai\\\":\\\"^4.2.0\\\",\\\"clean-webpack-plugin\\\":\\\"^0.1.19\\\",\\\"copy-webpack-plugin\\\":\\\"^5.0.5\\\",\\\"eslint\\\":\\\"^6.8.0\\\",\\\"eslint-config-prettier\\\":\\\"^4.2.0\\\",\\\"eslint-loader\\\":\\\"^4.0.2\\\",\\\"file-loader\\\":\\\"^0.11.2\\\",\\\"fs-extra\\\":\\\"^0.30.0\\\",\\\"gh-pages\\\":\\\"^2.0.1\\\",\\\"html-loader\\\":\\\"^0.5.5\\\",\\\"html-webpack-plugin\\\":\\\"^3.2.0\\\",\\\"json-loader\\\":\\\"^0.5.4\\\",\\\"karma\\\":\\\"^4.4.1\\\",\\\"karma-chrome-launcher\\\":\\\"^3.1.0\\\",\\\"karma-firefox-launcher\\\":\\\"^1.3.0\\\",\\\"karma-mocha\\\":\\\"^1.3.0\\\",\\\"karma-spec-reporter\\\":\\\"0.0.32\\\",\\\"karma-webpack\\\":\\\"^4.0.2\\\",\\\"lerna\\\":\\\"^3.8.0\\\",\\\"lodash.debounce\\\":\\\"^4.0.8\\\",\\\"mocha\\\":\\\"^7.1.2\\\",\\\"postcss\\\":\\\"^6.0.2\\\",\\\"prettier\\\":\\\"^1.6.1\\\",\\\"rimraf\\\":\\\"^2.6.2\\\",\\\"schema-utils\\\":\\\"^0.4.3\\\",\\\"socket.io-client\\\":\\\"^2.3.0\\\",\\\"style-loader\\\":\\\"^0.18.1\\\",\\\"url-loader\\\":\\\"^0.5.9\\\",\\\"webpack\\\":\\\"^4.0.0\\\",\\\"webpack-bundle-analyzer\\\":\\\"^3.3.2\\\",\\\"webpack-cli\\\":\\\"^3.1.2\\\",\\\"webpack-dev-server\\\":\\\"^3.1.1\\\",\\\"webpack-merge\\\":\\\"^4.1.1\\\",\\\"workbox-webpack-plugin\\\":\\\"^4.3.1\\\",\\\"worker-loader\\\":\\\"^2.0.0\\\",\\\"write-file-webpack-plugin\\\":\\\"^4.5.1\\\"},\\\"eslintConfig\\\":{\\\"globals\\\":{\\\"document\\\":true,\\\"window\\\":true}}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWNrYWdlLmpzb24uanMiLCJzb3VyY2VzIjpbXSwibWFwcGluZ3MiOiIiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./package.json\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: RPC, API_VERSION, VERSION, waitForInitialization, setupRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"waitForInitialization\", function() { return waitForInitialization; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupRPC\", function() { return setupRPC; });\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin.webworker.js */ \"./src/plugin.webworker.js\");\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginIframe.js */ \"./src/pluginIframe.js\");\n/* harmony import */ var _pluginWebPython_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pluginWebPython.js */ \"./src/pluginWebPython.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_4__[\"RPC\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_4__[\"API_VERSION\"]; });\n\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../package.json */ \"./package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ \"./package.json\", 1);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return _package_json__WEBPACK_IMPORTED_MODULE_5__[\"version\"]; });\n\n/**\n * Contains the code executed in the sandboxed frame under web-browser\n *\n * Tries to create a Web-Worker inside the frame and set up the\n * communication between the worker and the parent window. Some\n * browsers restrict creating a worker inside a sandboxed iframe - if\n * this happens, the plugin initialized right inside the frame (in the\n * same thread)\n */\n\n\n\n\n\n\n\nfunction _inIframe() {\n  try {\n    return window.self !== window.top;\n  } catch (e) {\n    return true;\n  }\n}\n/**\n * Initializes the plugin inside a web worker. May throw an exception\n * in case this was not permitted by the browser.\n */\n\n\nfunction setupWebWorker(config) {\n  if (!config.allow_execution) throw new Error(\"web-worker plugin can only work with allow_execution=true\");\n  const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a(); // mixed content warning in Chrome silently skips worker\n  // initialization without exception, handling this with timeout\n\n  const fallbackTimeout = setTimeout(function () {\n    worker.terminate();\n    console.warn(`Plugin failed to start as a web-worker, running in an iframe instead.`);\n    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n  }, 2000);\n  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"randId\"])(); // forwarding messages between the worker and parent window\n\n  worker.addEventListener(\"message\", function (e) {\n    let transferables = undefined;\n    const m = e.data;\n\n    if (m.type === \"worker-ready\") {\n      // send config to the worker\n      worker.postMessage({\n        type: \"connectRPC\",\n        config: config\n      });\n      clearTimeout(fallbackTimeout);\n      return;\n    } else if (m.type === \"initialized\") {\n      // complete the missing fields\n      m.config = Object.assign({}, config, m.config);\n      m.origin = window.location.origin;\n      m.peer_id = peer_id;\n    } else if (m.type === \"imjoy_remote_api_ready\") {\n      // if it's a webworker, there will be no api object returned\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: null\n      }));\n    } else if (m.type === \"cacheRequirements\" && typeof cache_requirements === \"function\") {\n      cache_requirements(m.requirements);\n    } else if (m.type === \"disconnect\") {\n      worker.terminate();\n    } else {\n      if (m.__transferables__) {\n        transferables = m.__transferables__;\n        delete m.__transferables__;\n      }\n    }\n\n    parent.postMessage(m, config.target_origin || \"*\", transferables);\n  });\n  window.addEventListener(\"message\", function (e) {\n    let transferables = undefined;\n    const m = e.data;\n\n    if (m.__transferables__) {\n      transferables = m.__transferables__;\n      delete m.__transferables__;\n    }\n\n    if (m.peer_id === peer_id) {\n      worker.postMessage(m, transferables);\n    } else if (config.debug) {\n      console.log(`connection peer id mismatch ${m.peer_id} !== ${peer_id}`);\n    }\n  });\n}\n\nfunction waitForInitialization(config) {\n  if (!_inIframe()) {\n    throw new Error(\"waitForInitialization (imjoy-rpc) should only run inside an iframe.\");\n  }\n\n  config = config || {};\n  const targetOrigin = config.target_origin || \"*\";\n\n  if (config.credential_required && typeof config.verify_credential !== \"function\") {\n    throw new Error(\"Please also provide the `verify_credential` function with `credential_required`.\");\n  }\n\n  if (config.credential_required && targetOrigin === \"*\") {\n    throw new Error(\"`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.\");\n  }\n\n  const done = () => {\n    window.removeEventListener(\"message\", handleEvent);\n  };\n\n  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"randId\"])();\n\n  const handleEvent = e => {\n    if (e.type === \"message\" && (targetOrigin === \"*\" || e.origin === targetOrigin)) {\n      if (e.data.type === \"initialize\") {\n        done();\n\n        if (e.data.peer_id !== peer_id) {\n          // TODO: throw an error when we are sure all the peers will send the peer_id\n          console.warn(`${e.data.config && e.data.config.name}: connection peer id mismatch ${e.data.peer_id} !== ${peer_id}`);\n        }\n\n        const cfg = e.data.config; // override the target_origin setting if it's configured by the rpc client\n        // otherwise take the setting from the core\n\n        if (targetOrigin !== \"*\") {\n          cfg.target_origin = targetOrigin;\n        }\n\n        if (config.credential_required) {\n          config.verify_credential(cfg.credential).then(result => {\n            if (result && result.auth && !result.error) {\n              // pass the authentication information with tokens\n              cfg.auth = result.auth;\n              setupRPC(cfg).then(() => {\n                console.log(\"ImJoy RPC loaded successfully!\");\n              });\n            } else {\n              throw new Error(\"Failed to verify the credentail:\" + (result && result.error));\n            }\n          });\n        } else {\n          setupRPC(cfg).then(() => {\n            console.log(\"ImJoy RPC loaded successfully!\");\n          });\n        }\n      } else {\n        throw new Error(`unrecognized message: ${e.data}`);\n      }\n    }\n  };\n\n  window.addEventListener(\"message\", handleEvent);\n  parent.postMessage({\n    type: \"imjoyRPCReady\",\n    config: config,\n    peer_id: peer_id\n  }, \"*\");\n}\nfunction setupRPC(config) {\n  config = config || {};\n  if (!config.name) throw new Error(\"Please specify a name for your app.\");\n  config.version = config.version || \"0.1.0\";\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"randId\"])();\n  config.allow_execution = config.allow_execution || false;\n\n  if (config.enable_service_worker) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n  }\n\n  if (config.cache_requirements) {\n    delete config.cache_requirements;\n  } // remove functions\n\n\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return new Promise((resolve, reject) => {\n    if (_inIframe()) {\n      if (config.type === \"web-worker\") {\n        try {\n          setupWebWorker(config);\n        } catch (e) {\n          // fallback to iframe\n          Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n        }\n      } else if (config.type === \"web-python\" || config.type === \"web-python-window\") {\n        Object(_pluginWebPython_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(config);\n      } else if ([\"rpc-window\", \"rpc-worker\", \"iframe\", \"window\"].includes(config.type)) {\n        Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n      } else {\n        console.error(\"Unsupported plugin type: \" + config.type);\n        reject(\"Unsupported plugin type: \" + config.type);\n      }\n\n      try {\n        const handleEvent = e => {\n          const api = e.detail;\n\n          if (config.expose_api_globally) {\n            window.api = api;\n          } // imjoy plugin api\n\n\n          resolve(api);\n          window.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n        };\n\n        window.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n      } catch (e) {\n        reject(e);\n      }\n    } else {\n      reject(new Error(\"imjoy-rpc should only run inside an iframe.\"));\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL21haW4uanM/NTZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRhaW5zIHRoZSBjb2RlIGV4ZWN1dGVkIGluIHRoZSBzYW5kYm94ZWQgZnJhbWUgdW5kZXIgd2ViLWJyb3dzZXJcbiAqXG4gKiBUcmllcyB0byBjcmVhdGUgYSBXZWItV29ya2VyIGluc2lkZSB0aGUgZnJhbWUgYW5kIHNldCB1cCB0aGVcbiAqIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgd29ya2VyIGFuZCB0aGUgcGFyZW50IHdpbmRvdy4gU29tZVxuICogYnJvd3NlcnMgcmVzdHJpY3QgY3JlYXRpbmcgYSB3b3JrZXIgaW5zaWRlIGEgc2FuZGJveGVkIGlmcmFtZSAtIGlmXG4gKiB0aGlzIGhhcHBlbnMsIHRoZSBwbHVnaW4gaW5pdGlhbGl6ZWQgcmlnaHQgaW5zaWRlIHRoZSBmcmFtZSAoaW4gdGhlXG4gKiBzYW1lIHRocmVhZClcbiAqL1xuaW1wb3J0IFBsdWdpbldvcmtlciBmcm9tIFwiLi9wbHVnaW4ud2Vid29ya2VyLmpzXCI7XG5pbXBvcnQgc2V0dXBJZnJhbWUgZnJvbSBcIi4vcGx1Z2luSWZyYW1lLmpzXCI7XG5pbXBvcnQgc2V0dXBXZWJQeXRob24gZnJvbSBcIi4vcGx1Z2luV2ViUHl0aG9uLmpzXCI7XG5pbXBvcnQgeyBzZXR1cFNlcnZpY2VXb3JrZXIsIHJhbmRJZCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cbmV4cG9ydCB7IFJQQywgQVBJX1ZFUlNJT04gfSBmcm9tIFwiLi9ycGMuanNcIjtcbmV4cG9ydCB7IHZlcnNpb24gYXMgVkVSU0lPTiB9IGZyb20gXCIuLi9wYWNrYWdlLmpzb25cIjtcblxuZnVuY3Rpb24gX2luSWZyYW1lKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBpbnNpZGUgYSB3ZWIgd29ya2VyLiBNYXkgdGhyb3cgYW4gZXhjZXB0aW9uXG4gKiBpbiBjYXNlIHRoaXMgd2FzIG5vdCBwZXJtaXR0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gKi9cbmZ1bmN0aW9uIHNldHVwV2ViV29ya2VyKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZy5hbGxvd19leGVjdXRpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJ3ZWItd29ya2VyIHBsdWdpbiBjYW4gb25seSB3b3JrIHdpdGggYWxsb3dfZXhlY3V0aW9uPXRydWVcIlxuICAgICk7XG4gIGNvbnN0IHdvcmtlciA9IG5ldyBQbHVnaW5Xb3JrZXIoKTtcbiAgLy8gbWl4ZWQgY29udGVudCB3YXJuaW5nIGluIENocm9tZSBzaWxlbnRseSBza2lwcyB3b3JrZXJcbiAgLy8gaW5pdGlhbGl6YXRpb24gd2l0aG91dCBleGNlcHRpb24sIGhhbmRsaW5nIHRoaXMgd2l0aCB0aW1lb3V0XG4gIGNvbnN0IGZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBQbHVnaW4gZmFpbGVkIHRvIHN0YXJ0IGFzIGEgd2ViLXdvcmtlciwgcnVubmluZyBpbiBhbiBpZnJhbWUgaW5zdGVhZC5gXG4gICAgKTtcbiAgICBzZXR1cElmcmFtZShjb25maWcpO1xuICB9LCAyMDAwKTtcbiAgY29uc3QgcGVlcl9pZCA9IHJhbmRJZCgpO1xuXG4gIC8vIGZvcndhcmRpbmcgbWVzc2FnZXMgYmV0d2VlbiB0aGUgd29ya2VyIGFuZCBwYXJlbnQgd2luZG93XG4gIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgbGV0IHRyYW5zZmVyYWJsZXMgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgbSA9IGUuZGF0YTtcbiAgICBpZiAobS50eXBlID09PSBcIndvcmtlci1yZWFkeVwiKSB7XG4gICAgICAvLyBzZW5kIGNvbmZpZyB0byB0aGUgd29ya2VyXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImNvbm5lY3RSUENcIiwgY29uZmlnOiBjb25maWcgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoZmFsbGJhY2tUaW1lb3V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKG0udHlwZSA9PT0gXCJpbml0aWFsaXplZFwiKSB7XG4gICAgICAvLyBjb21wbGV0ZSB0aGUgbWlzc2luZyBmaWVsZHNcbiAgICAgIG0uY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCBtLmNvbmZpZyk7XG4gICAgICBtLm9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICBtLnBlZXJfaWQgPSBwZWVyX2lkO1xuICAgIH0gZWxzZSBpZiAobS50eXBlID09PSBcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIikge1xuICAgICAgLy8gaWYgaXQncyBhIHdlYndvcmtlciwgdGhlcmUgd2lsbCBiZSBubyBhcGkgb2JqZWN0IHJldHVybmVkXG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVwiLCB7IGRldGFpbDogbnVsbCB9KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgbS50eXBlID09PSBcImNhY2hlUmVxdWlyZW1lbnRzXCIgJiZcbiAgICAgIHR5cGVvZiBjYWNoZV9yZXF1aXJlbWVudHMgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgY2FjaGVfcmVxdWlyZW1lbnRzKG0ucmVxdWlyZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG0udHlwZSA9PT0gXCJkaXNjb25uZWN0XCIpIHtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG0uX190cmFuc2ZlcmFibGVzX18pIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcyA9IG0uX190cmFuc2ZlcmFibGVzX187XG4gICAgICAgIGRlbGV0ZSBtLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJlbnQucG9zdE1lc3NhZ2UobSwgY29uZmlnLnRhcmdldF9vcmlnaW4gfHwgXCIqXCIsIHRyYW5zZmVyYWJsZXMpO1xuICB9KTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgIGxldCB0cmFuc2ZlcmFibGVzID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG0gPSBlLmRhdGE7XG4gICAgaWYgKG0uX190cmFuc2ZlcmFibGVzX18pIHtcbiAgICAgIHRyYW5zZmVyYWJsZXMgPSBtLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgZGVsZXRlIG0uX190cmFuc2ZlcmFibGVzX187XG4gICAgfVxuICAgIGlmIChtLnBlZXJfaWQgPT09IHBlZXJfaWQpIHtcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShtLCB0cmFuc2ZlcmFibGVzKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYGNvbm5lY3Rpb24gcGVlciBpZCBtaXNtYXRjaCAke20ucGVlcl9pZH0gIT09ICR7cGVlcl9pZH1gKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FpdEZvckluaXRpYWxpemF0aW9uKGNvbmZpZykge1xuICBpZiAoIV9pbklmcmFtZSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJ3YWl0Rm9ySW5pdGlhbGl6YXRpb24gKGltam95LXJwYykgc2hvdWxkIG9ubHkgcnVuIGluc2lkZSBhbiBpZnJhbWUuXCJcbiAgICApO1xuICB9XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgY29uc3QgdGFyZ2V0T3JpZ2luID0gY29uZmlnLnRhcmdldF9vcmlnaW4gfHwgXCIqXCI7XG4gIGlmIChcbiAgICBjb25maWcuY3JlZGVudGlhbF9yZXF1aXJlZCAmJlxuICAgIHR5cGVvZiBjb25maWcudmVyaWZ5X2NyZWRlbnRpYWwgIT09IFwiZnVuY3Rpb25cIlxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlBsZWFzZSBhbHNvIHByb3ZpZGUgdGhlIGB2ZXJpZnlfY3JlZGVudGlhbGAgZnVuY3Rpb24gd2l0aCBgY3JlZGVudGlhbF9yZXF1aXJlZGAuXCJcbiAgICApO1xuICB9XG4gIGlmIChjb25maWcuY3JlZGVudGlhbF9yZXF1aXJlZCAmJiB0YXJnZXRPcmlnaW4gPT09IFwiKlwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgdGFyZ2V0X29yaWdpbmAgd2FzIHNldCB0byBgKmAgd2l0aCBgY3JlZGVudGlhbF9yZXF1aXJlZD10cnVlYCwgdGhlcmUgaXMgYSBzZWN1cml0eSByaXNrIHRoYXQgeW91IG1heSBsZWFrIHRoZSBjcmVkZW50aWFsIHRvIHdlYnNpdGUgZnJvbSBvdGhlciBvcmlnaW4uIFBsZWFzZSBzcGVjaWZ5IHRoZSBgdGFyZ2V0X29yaWdpbmAgZXhwbGljaXRseS5cIlxuICAgICk7XG4gIH1cbiAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlRXZlbnQpO1xuICB9O1xuICBjb25zdCBwZWVyX2lkID0gcmFuZElkKCk7XG4gIGNvbnN0IGhhbmRsZUV2ZW50ID0gZSA9PiB7XG4gICAgaWYgKFxuICAgICAgZS50eXBlID09PSBcIm1lc3NhZ2VcIiAmJlxuICAgICAgKHRhcmdldE9yaWdpbiA9PT0gXCIqXCIgfHwgZS5vcmlnaW4gPT09IHRhcmdldE9yaWdpbilcbiAgICApIHtcbiAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gXCJpbml0aWFsaXplXCIpIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBpZiAoZS5kYXRhLnBlZXJfaWQgIT09IHBlZXJfaWQpIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aHJvdyBhbiBlcnJvciB3aGVuIHdlIGFyZSBzdXJlIGFsbCB0aGUgcGVlcnMgd2lsbCBzZW5kIHRoZSBwZWVyX2lkXG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYCR7ZS5kYXRhLmNvbmZpZyAmJlxuICAgICAgICAgICAgICBlLmRhdGEuY29uZmlnLm5hbWV9OiBjb25uZWN0aW9uIHBlZXIgaWQgbWlzbWF0Y2ggJHtcbiAgICAgICAgICAgICAgZS5kYXRhLnBlZXJfaWRcbiAgICAgICAgICAgIH0gIT09ICR7cGVlcl9pZH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZmcgPSBlLmRhdGEuY29uZmlnO1xuICAgICAgICAvLyBvdmVycmlkZSB0aGUgdGFyZ2V0X29yaWdpbiBzZXR0aW5nIGlmIGl0J3MgY29uZmlndXJlZCBieSB0aGUgcnBjIGNsaWVudFxuICAgICAgICAvLyBvdGhlcndpc2UgdGFrZSB0aGUgc2V0dGluZyBmcm9tIHRoZSBjb3JlXG4gICAgICAgIGlmICh0YXJnZXRPcmlnaW4gIT09IFwiKlwiKSB7XG4gICAgICAgICAgY2ZnLnRhcmdldF9vcmlnaW4gPSB0YXJnZXRPcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jcmVkZW50aWFsX3JlcXVpcmVkKSB7XG4gICAgICAgICAgY29uZmlnLnZlcmlmeV9jcmVkZW50aWFsKGNmZy5jcmVkZW50aWFsKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5hdXRoICYmICFyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gcGFzcyB0aGUgYXV0aGVudGljYXRpb24gaW5mb3JtYXRpb24gd2l0aCB0b2tlbnNcbiAgICAgICAgICAgICAgY2ZnLmF1dGggPSByZXN1bHQuYXV0aDtcbiAgICAgICAgICAgICAgc2V0dXBSUEMoY2ZnKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkltSm95IFJQQyBsb2FkZWQgc3VjY2Vzc2Z1bGx5IVwiKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJGYWlsZWQgdG8gdmVyaWZ5IHRoZSBjcmVkZW50YWlsOlwiICsgKHJlc3VsdCAmJiByZXN1bHQuZXJyb3IpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0dXBSUEMoY2ZnKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW1Kb3kgUlBDIGxvYWRlZCBzdWNjZXNzZnVsbHkhXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBtZXNzYWdlOiAke2UuZGF0YX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVFdmVudCk7XG4gIHBhcmVudC5wb3N0TWVzc2FnZShcbiAgICB7IHR5cGU6IFwiaW1qb3lSUENSZWFkeVwiLCBjb25maWc6IGNvbmZpZywgcGVlcl9pZDogcGVlcl9pZCB9LFxuICAgIFwiKlwiXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFJQQyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBpZiAoIWNvbmZpZy5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3BlY2lmeSBhIG5hbWUgZm9yIHlvdXIgYXBwLlwiKTtcbiAgY29uZmlnLnZlcnNpb24gPSBjb25maWcudmVyc2lvbiB8fCBcIjAuMS4wXCI7XG4gIGNvbmZpZy5kZXNjcmlwdGlvbiA9XG4gICAgY29uZmlnLmRlc2NyaXB0aW9uIHx8IGBbVE9ETzogYWRkIGRlc2NyaXB0aW9uIGZvciAke2NvbmZpZy5uYW1lfSBdYDtcbiAgY29uZmlnLnR5cGUgPSBjb25maWcudHlwZSB8fCBcInJwYy13aW5kb3dcIjtcbiAgY29uZmlnLmlkID0gY29uZmlnLmlkIHx8IHJhbmRJZCgpO1xuICBjb25maWcuYWxsb3dfZXhlY3V0aW9uID0gY29uZmlnLmFsbG93X2V4ZWN1dGlvbiB8fCBmYWxzZTtcbiAgaWYgKGNvbmZpZy5lbmFibGVfc2VydmljZV93b3JrZXIpIHtcbiAgICBzZXR1cFNlcnZpY2VXb3JrZXIoXG4gICAgICBjb25maWcuYmFzZV91cmwsXG4gICAgICBjb25maWcudGFyZ2V0X29yaWdpbixcbiAgICAgIGNvbmZpZy5jYWNoZV9yZXF1aXJlbWVudHNcbiAgICApO1xuICB9XG4gIGlmIChjb25maWcuY2FjaGVfcmVxdWlyZW1lbnRzKSB7XG4gICAgZGVsZXRlIGNvbmZpZy5jYWNoZV9yZXF1aXJlbWVudHM7XG4gIH1cbiAgLy8gcmVtb3ZlIGZ1bmN0aW9uc1xuICBjb25maWcgPSBPYmplY3Qua2V5cyhjb25maWcpLnJlZHVjZSgocCwgYykgPT4ge1xuICAgIGlmICh0eXBlb2YgY29uZmlnW2NdICE9PSBcImZ1bmN0aW9uXCIpIHBbY10gPSBjb25maWdbY107XG4gICAgcmV0dXJuIHA7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoX2luSWZyYW1lKCkpIHtcbiAgICAgIGlmIChjb25maWcudHlwZSA9PT0gXCJ3ZWItd29ya2VyXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZXR1cFdlYldvcmtlcihjb25maWcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gZmFsbGJhY2sgdG8gaWZyYW1lXG4gICAgICAgICAgc2V0dXBJZnJhbWUoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgY29uZmlnLnR5cGUgPT09IFwid2ViLXB5dGhvblwiIHx8XG4gICAgICAgIGNvbmZpZy50eXBlID09PSBcIndlYi1weXRob24td2luZG93XCJcbiAgICAgICkge1xuICAgICAgICBzZXR1cFdlYlB5dGhvbihjb25maWcpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgW1wicnBjLXdpbmRvd1wiLCBcInJwYy13b3JrZXJcIiwgXCJpZnJhbWVcIiwgXCJ3aW5kb3dcIl0uaW5jbHVkZXMoY29uZmlnLnR5cGUpXG4gICAgICApIHtcbiAgICAgICAgc2V0dXBJZnJhbWUoY29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbnN1cHBvcnRlZCBwbHVnaW4gdHlwZTogXCIgKyBjb25maWcudHlwZSk7XG4gICAgICAgIHJlamVjdChcIlVuc3VwcG9ydGVkIHBsdWdpbiB0eXBlOiBcIiArIGNvbmZpZy50eXBlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUV2ZW50ID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgYXBpID0gZS5kZXRhaWw7XG4gICAgICAgICAgaWYgKGNvbmZpZy5leHBvc2VfYXBpX2dsb2JhbGx5KSB7XG4gICAgICAgICAgICB3aW5kb3cuYXBpID0gYXBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbWpveSBwbHVnaW4gYXBpXG4gICAgICAgICAgcmVzb2x2ZShhcGkpO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVwiLCBoYW5kbGVFdmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVwiLCBoYW5kbGVFdmVudCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImltam95LXJwYyBzaG91bGQgb25seSBydW4gaW5zaWRlIGFuIGlmcmFtZS5cIikpO1xuICAgIH1cbiAgfSk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./src/plugin.webworker.js":
/*!*********************************!*\
  !*** ./src/plugin.webworker.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function() {\n  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/plugin.webworker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./src/plugin.webworker.js\\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \\\\\\\"./src/pluginCore.js\\\\\\\");\\\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \\\\\\\"./src/rpc.js\\\\\\\");\\\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \\\\\\\"./src/utils.js\\\\\\\");\\\\n/**\\\\n * Contains the routines loaded by the plugin Worker under web-browser.\\\\n *\\\\n * Initializes the web environment version of the platform-dependent\\\\n * connection object for the plugin site\\\\n */\\\\n\\\\n\\\\n\\\\n\\\\n(function() {\\\\n  // make sure this runs inside a webworker\\\\n  if (\\\\n    typeof WorkerGlobalScope === \\\\\\\"undefined\\\\\\\" ||\\\\n    !self ||\\\\n    !(self instanceof WorkerGlobalScope)\\\\n  ) {\\\\n    throw new Error(\\\\\\\"This script can only loaded in a webworker\\\\\\\");\\\\n  }\\\\n  /**\\\\n   * Connection object provided to the RPC constructor,\\\\n   * plugin site implementation for the web-based environment.\\\\n   * Global will be then cleared to prevent exposure into the\\\\n   * Worker, so we put this local connection object into a closure\\\\n   */\\\\n  class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\\\\\\\"MessageEmitter\\\\\\\"] {\\\\n    constructor(config) {\\\\n      super(config && config.debug);\\\\n      this.config = config || {};\\\\n    }\\\\n    connect() {\\\\n      self.addEventListener(\\\\\\\"message\\\\\\\", e => {\\\\n        this._fire(e.data.type, e.data);\\\\n      });\\\\n      this.emit({\\\\n        type: \\\\\\\"initialized\\\\\\\",\\\\n        config: this.config\\\\n      });\\\\n    }\\\\n    disconnect() {\\\\n      this._fire(\\\\\\\"beforeDisconnect\\\\\\\");\\\\n      self.close();\\\\n      this._fire(\\\\\\\"disconnected\\\\\\\");\\\\n    }\\\\n    emit(data) {\\\\n      let transferables = undefined;\\\\n      if (data.__transferables__) {\\\\n        transferables = data.__transferables__;\\\\n        delete data.__transferables__;\\\\n      }\\\\n      self.postMessage(data, transferables);\\\\n    }\\\\n    async execute(code) {\\\\n      if (code.type === \\\\\\\"requirements\\\\\\\") {\\\\n        try {\\\\n          if (\\\\n            code.requirements &&\\\\n            (Array.isArray(code.requirements) ||\\\\n              typeof code.requirements === \\\\\\\"string\\\\\\\")\\\\n          ) {\\\\n            try {\\\\n              if (!Array.isArray(code.requirements)) {\\\\n                code.requirements = [code.requirements];\\\\n              }\\\\n              for (var i = 0; i < code.requirements.length; i++) {\\\\n                if (\\\\n                  code.requirements[i].toLowerCase().endsWith(\\\\\\\".css\\\\\\\") ||\\\\n                  code.requirements[i].startsWith(\\\\\\\"css:\\\\\\\")\\\\n                ) {\\\\n                  throw \\\\\\\"unable to import css in a webworker\\\\\\\";\\\\n                } else if (\\\\n                  code.requirements[i].toLowerCase().endsWith(\\\\\\\".js\\\\\\\") ||\\\\n                  code.requirements[i].startsWith(\\\\\\\"js:\\\\\\\")\\\\n                ) {\\\\n                  if (code.requirements[i].startsWith(\\\\\\\"js:\\\\\\\")) {\\\\n                    code.requirements[i] = code.requirements[i].slice(3);\\\\n                  }\\\\n                  importScripts(code.requirements[i]);\\\\n                } else if (code.requirements[i].startsWith(\\\\\\\"http\\\\\\\")) {\\\\n                  importScripts(code.requirements[i]);\\\\n                } else if (code.requirements[i].startsWith(\\\\\\\"cache:\\\\\\\")) {\\\\n                  //ignore cache\\\\n                } else {\\\\n                  console.log(\\\\n                    \\\\\\\"Unprocessed requirements url: \\\\\\\" + code.requirements[i]\\\\n                  );\\\\n                }\\\\n              }\\\\n            } catch (e) {\\\\n              throw \\\\\\\"failed to import required scripts: \\\\\\\" +\\\\n                code.requirements.toString();\\\\n            }\\\\n          }\\\\n        } catch (e) {\\\\n          throw e;\\\\n        }\\\\n      } else if (code.type === \\\\\\\"script\\\\\\\") {\\\\n        try {\\\\n          if (\\\\n            code.requirements &&\\\\n            (Array.isArray(code.requirements) ||\\\\n              typeof code.requirements === \\\\\\\"string\\\\\\\")\\\\n          ) {\\\\n            try {\\\\n              if (Array.isArray(code.requirements)) {\\\\n                for (let i = 0; i < code.requirements.length; i++) {\\\\n                  importScripts(code.requirements[i]);\\\\n                }\\\\n              } else {\\\\n                importScripts(code.requirements);\\\\n              }\\\\n            } catch (e) {\\\\n              throw \\\\\\\"failed to import required scripts: \\\\\\\" +\\\\n                code.requirements.toString();\\\\n            }\\\\n          }\\\\n          eval(code.content);\\\\n        } catch (e) {\\\\n          console.error(e.message, e.stack);\\\\n          throw e;\\\\n        }\\\\n      } else {\\\\n        throw \\\\\\\"unsupported code type.\\\\\\\";\\\\n      }\\\\n      if (code.type === \\\\\\\"requirements\\\\\\\") {\\\\n        self.postMessage({\\\\n          type: \\\\\\\"cacheRequirements\\\\\\\",\\\\n          requirements: code.requirements\\\\n        });\\\\n      }\\\\n    }\\\\n  }\\\\n  const config = {\\\\n    type: \\\\\\\"web-worker\\\\\\\",\\\\n    dedicated_thread: true,\\\\n    allow_execution: true,\\\\n    lang: \\\\\\\"javascript\\\\\\\",\\\\n    api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\\\\\\\"API_VERSION\\\\\\\"]\\\\n  };\\\\n  const conn = new Connection(config);\\\\n  conn.on(\\\\\\\"connectRPC\\\\\\\", data => {\\\\n    Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"connectRPC\\\\\\\"])(conn, Object.assign(data.config, config));\\\\n  });\\\\n  conn.connect();\\\\n  self.postMessage({\\\\n    type: \\\\\\\"worker-ready\\\\\\\"\\\\n  });\\\\n})();\\\\n//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luLndlYndvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanM/OGM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRhaW5zIHRoZSByb3V0aW5lcyBsb2FkZWQgYnkgdGhlIHBsdWdpbiBXb3JrZXIgdW5kZXIgd2ViLWJyb3dzZXIuXG4gKlxuICogSW5pdGlhbGl6ZXMgdGhlIHdlYiBlbnZpcm9ubWVudCB2ZXJzaW9uIG9mIHRoZSBwbGF0Zm9ybS1kZXBlbmRlbnRcbiAqIGNvbm5lY3Rpb24gb2JqZWN0IGZvciB0aGUgcGx1Z2luIHNpdGVcbiAqL1xuaW1wb3J0IHsgY29ubmVjdFJQQyB9IGZyb20gXCIuL3BsdWdpbkNvcmUuanNcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OIH0gZnJvbSBcIi4vcnBjLmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlRW1pdHRlciwgcmFuZElkIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBtYWtlIHN1cmUgdGhpcyBydW5zIGluc2lkZSBhIHdlYndvcmtlclxuICBpZiAoXG4gICAgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSBcInVuZGVmaW5lZFwiIHx8XG4gICAgIXNlbGYgfHxcbiAgICAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzY3JpcHQgY2FuIG9ubHkgbG9hZGVkIGluIGEgd2Vid29ya2VyXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0aW9uIG9iamVjdCBwcm92aWRlZCB0byB0aGUgUlBDIGNvbnN0cnVjdG9yLFxuICAgKiBwbHVnaW4gc2l0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHdlYi1iYXNlZCBlbnZpcm9ubWVudC5cbiAgICogR2xvYmFsIHdpbGwgYmUgdGhlbiBjbGVhcmVkIHRvIHByZXZlbnQgZXhwb3N1cmUgaW50byB0aGVcbiAgICogV29ya2VyLCBzbyB3ZSBwdXQgdGhpcyBsb2NhbCBjb25uZWN0aW9uIG9iamVjdCBpbnRvIGEgY2xvc3VyZVxuICAgKi9cbiAgY2xhc3MgQ29ubmVjdGlvbiBleHRlbmRzIE1lc3NhZ2VFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgIHN1cGVyKGNvbmZpZyAmJiBjb25maWcuZGVidWcpO1xuICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGUgPT4ge1xuICAgICAgICB0aGlzLl9maXJlKGUuZGF0YS50eXBlLCBlLmRhdGEpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoe1xuICAgICAgICB0eXBlOiBcImluaXRpYWxpemVkXCIsXG4gICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgdGhpcy5fZmlyZShcImJlZm9yZURpc2Nvbm5lY3RcIik7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB0aGlzLl9maXJlKFwiZGlzY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBlbWl0KGRhdGEpIHtcbiAgICAgIGxldCB0cmFuc2ZlcmFibGVzID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGRhdGEuX190cmFuc2ZlcmFibGVzX18pIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcyA9IGRhdGEuX190cmFuc2ZlcmFibGVzX187XG4gICAgICAgIGRlbGV0ZSBkYXRhLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgfVxuICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2ZlcmFibGVzKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZShjb2RlKSB7XG4gICAgICBpZiAoY29kZS50eXBlID09PSBcInJlcXVpcmVtZW50c1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgJiZcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSB8fFxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgPSBbY29kZS5yZXF1aXJlbWVudHNdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZS5yZXF1aXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmNzc1wiKSB8fFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImNzczpcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IFwidW5hYmxlIHRvIGltcG9ydCBjc3MgaW4gYSB3ZWJ3b3JrZXJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcIi5qc1wiKSB8fFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImpzOlwiKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJqczpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0gPSBjb2RlLnJlcXVpcmVtZW50c1tpXS5zbGljZSgzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImNhY2hlOlwiKSkge1xuICAgICAgICAgICAgICAgICAgLy9pZ25vcmUgY2FjaGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgIFwiVW5wcm9jZXNzZWQgcmVxdWlyZW1lbnRzIHVybDogXCIgKyBjb2RlLnJlcXVpcmVtZW50c1tpXVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJmYWlsZWQgdG8gaW1wb3J0IHJlcXVpcmVkIHNjcmlwdHM6IFwiICtcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZS50eXBlID09PSBcInNjcmlwdFwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgJiZcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSB8fFxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2RlLnJlcXVpcmVtZW50cykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUucmVxdWlyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpbXBvcnRTY3JpcHRzKGNvZGUucmVxdWlyZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJmYWlsZWQgdG8gaW1wb3J0IHJlcXVpcmVkIHNjcmlwdHM6IFwiICtcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBldmFsKGNvZGUuY29udGVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSwgZS5zdGFjayk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBjb2RlIHR5cGUuXCI7XG4gICAgICB9XG4gICAgICBpZiAoY29kZS50eXBlID09PSBcInJlcXVpcmVtZW50c1wiKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFwiY2FjaGVSZXF1aXJlbWVudHNcIixcbiAgICAgICAgICByZXF1aXJlbWVudHM6IGNvZGUucmVxdWlyZW1lbnRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBjb25maWcgPSB7XG4gICAgdHlwZTogXCJ3ZWItd29ya2VyXCIsXG4gICAgZGVkaWNhdGVkX3RocmVhZDogdHJ1ZSxcbiAgICBhbGxvd19leGVjdXRpb246IHRydWUsXG4gICAgbGFuZzogXCJqYXZhc2NyaXB0XCIsXG4gICAgYXBpX3ZlcnNpb246IEFQSV9WRVJTSU9OXG4gIH07XG4gIGNvbnN0IGNvbm4gPSBuZXcgQ29ubmVjdGlvbihjb25maWcpO1xuICBjb25uLm9uKFwiY29ubmVjdFJQQ1wiLCBkYXRhID0+IHtcbiAgICBjb25uZWN0UlBDKGNvbm4sIE9iamVjdC5hc3NpZ24oZGF0YS5jb25maWcsIGNvbmZpZykpO1xuICB9KTtcbiAgY29ubi5jb25uZWN0KCk7XG4gIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgIHR5cGU6IFwid29ya2VyLXJlYWR5XCJcbiAgfSk7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\\\n//# sourceURL=webpack-internal:///./src/plugin.webworker.js\\\\n\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/pluginCore.js\\\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"connectRPC\\\\\\\", function() { return connectRPC; });\\\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \\\\\\\"./src/rpc.js\\\\\\\");\\\\n/**\\\\n * Core plugin script loaded into the plugin process/thread.\\\\n *\\\\n * Initializes the plugin-site API global methods.\\\\n */\\\\n\\\\nfunction connectRPC(connection, config) {\\\\n  config = config || {};\\\\n  const codecs = {};\\\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"RPC\\\\\\\"](connection, config, codecs);\\\\n  rpc.on(\\\\\\\"getInterface\\\\\\\", function () {\\\\n    launchConnected();\\\\n  });\\\\n  rpc.on(\\\\\\\"remoteReady\\\\\\\", function () {\\\\n    const api = rpc.getRemote() || {};\\\\n\\\\n    if (api.export) {\\\\n      throw new Error(\\\\\\\"`export` is a reserved function name\\\\\\\");\\\\n    }\\\\n\\\\n    if (api.onload) {\\\\n      throw new Error(\\\\\\\"`onload` is a reserved function name\\\\\\\");\\\\n    }\\\\n\\\\n    if (api.dispose) {\\\\n      throw new Error(\\\\\\\"`dispose` is a reserved function name\\\\\\\");\\\\n    }\\\\n\\\\n    api.registerCodec = function (config) {\\\\n      if (!config[\\\\\\\"name\\\\\\\"] || !config[\\\\\\\"encoder\\\\\\\"] && !config[\\\\\\\"decoder\\\\\\\"]) {\\\\n        throw new Error(\\\\\\\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\\\\\\\");\\\\n      } else {\\\\n        if (config.type) {\\\\n          for (let k of Object.keys(codecs)) {\\\\n            if (codecs[k].type === config.type || k === config.name) {\\\\n              delete codecs[k];\\\\n              console.warn(\\\\\\\"Remove duplicated codec: \\\\\\\" + k);\\\\n            }\\\\n          }\\\\n        }\\\\n\\\\n        codecs[config[\\\\\\\"name\\\\\\\"]] = config;\\\\n      }\\\\n    };\\\\n\\\\n    api.disposeObject = function (obj) {\\\\n      rpc.disposeObject(obj);\\\\n    };\\\\n\\\\n    api.export = function (_interface, config) {\\\\n      rpc.setInterface(_interface, config);\\\\n    };\\\\n\\\\n    api.onLoad = function (handler) {\\\\n      handler = checkHandler(handler);\\\\n\\\\n      if (connected) {\\\\n        handler();\\\\n      } else {\\\\n        connectedHandlers.push(handler);\\\\n      }\\\\n    };\\\\n\\\\n    api.dispose = function (_interface) {\\\\n      rpc.disconnect();\\\\n    };\\\\n\\\\n    if (typeof WorkerGlobalScope !== \\\\\\\"undefined\\\\\\\" && self instanceof WorkerGlobalScope) {\\\\n      self.api = api;\\\\n      self.postMessage({\\\\n        type: \\\\\\\"imjoy_remote_api_ready\\\\\\\"\\\\n      });\\\\n    } else if (typeof window) {\\\\n      window.dispatchEvent(new CustomEvent(\\\\\\\"imjoy_remote_api_ready\\\\\\\", {\\\\n        detail: api\\\\n      }));\\\\n    }\\\\n  });\\\\n  let connected = false;\\\\n  const connectedHandlers = [];\\\\n\\\\n  const launchConnected = function () {\\\\n    if (!connected) {\\\\n      connected = true;\\\\n      let handler;\\\\n\\\\n      while (handler = connectedHandlers.pop()) {\\\\n        handler();\\\\n      }\\\\n    }\\\\n  };\\\\n\\\\n  const checkHandler = function (handler) {\\\\n    const type = typeof handler;\\\\n\\\\n    if (type !== \\\\\\\"function\\\\\\\") {\\\\n      const msg = \\\\\\\"A function may only be subsribed to the event, \\\\\\\" + type + \\\\\\\" was provided instead\\\\\\\";\\\\n      throw new Error(msg);\\\\n    }\\\\n\\\\n    return handler;\\\\n  };\\\\n\\\\n  return rpc;\\\\n}//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luQ29yZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbkNvcmUuanM/YTgxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcmUgcGx1Z2luIHNjcmlwdCBsb2FkZWQgaW50byB0aGUgcGx1Z2luIHByb2Nlc3MvdGhyZWFkLlxuICpcbiAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4tc2l0ZSBBUEkgZ2xvYmFsIG1ldGhvZHMuXG4gKi9cbmltcG9ydCB7IFJQQyB9IGZyb20gXCIuL3JwYy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdFJQQyhjb25uZWN0aW9uLCBjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25zdCBjb2RlY3MgPSB7fTtcblxuICBjb25zdCBycGMgPSBuZXcgUlBDKGNvbm5lY3Rpb24sIGNvbmZpZywgY29kZWNzKTtcbiAgcnBjLm9uKFwiZ2V0SW50ZXJmYWNlXCIsIGZ1bmN0aW9uKCkge1xuICAgIGxhdW5jaENvbm5lY3RlZCgpO1xuICB9KTtcblxuICBycGMub24oXCJyZW1vdGVSZWFkeVwiLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBhcGkgPSBycGMuZ2V0UmVtb3RlKCkgfHwge307XG4gICAgaWYgKGFwaS5leHBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBleHBvcnRgIGlzIGEgcmVzZXJ2ZWQgZnVuY3Rpb24gbmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5vbmxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBvbmxvYWRgIGlzIGEgcmVzZXJ2ZWQgZnVuY3Rpb24gbmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5kaXNwb3NlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGlzcG9zZWAgaXMgYSByZXNlcnZlZCBmdW5jdGlvbiBuYW1lXCIpO1xuICAgIH1cbiAgICBhcGkucmVnaXN0ZXJDb2RlYyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgaWYgKCFjb25maWdbXCJuYW1lXCJdIHx8ICghY29uZmlnW1wiZW5jb2RlclwiXSAmJiAhY29uZmlnW1wiZGVjb2RlclwiXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBjb2RlYyBmb3JtYXQsIHBsZWFzZSBtYWtlIHN1cmUgeW91IHByb3ZpZGUgYSBuYW1lLCB0eXBlLCBlbmNvZGVyIGFuZCBkZWNvZGVyLlwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgICBmb3IgKGxldCBrIG9mIE9iamVjdC5rZXlzKGNvZGVjcykpIHtcbiAgICAgICAgICAgIGlmIChjb2RlY3Nba10udHlwZSA9PT0gY29uZmlnLnR5cGUgfHwgayA9PT0gY29uZmlnLm5hbWUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGNvZGVjc1trXTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUmVtb3ZlIGR1cGxpY2F0ZWQgY29kZWM6IFwiICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvZGVjc1tjb25maWdbXCJuYW1lXCJdXSA9IGNvbmZpZztcbiAgICAgIH1cbiAgICB9O1xuICAgIGFwaS5kaXNwb3NlT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBycGMuZGlzcG9zZU9iamVjdChvYmopO1xuICAgIH07XG4gICAgYXBpLmV4cG9ydCA9IGZ1bmN0aW9uKF9pbnRlcmZhY2UsIGNvbmZpZykge1xuICAgICAgcnBjLnNldEludGVyZmFjZShfaW50ZXJmYWNlLCBjb25maWcpO1xuICAgIH07XG4gICAgYXBpLm9uTG9hZCA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIgPSBjaGVja0hhbmRsZXIoaGFuZGxlcik7XG4gICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbm5lY3RlZEhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBhcGkuZGlzcG9zZSA9IGZ1bmN0aW9uKF9pbnRlcmZhY2UpIHtcbiAgICAgIHJwYy5kaXNjb25uZWN0KCk7XG4gICAgfTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlXG4gICAgKSB7XG4gICAgICBzZWxmLmFwaSA9IGFwaTtcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93KSB7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVwiLCB7IGRldGFpbDogYXBpIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGNvbm5lY3RlZCA9IGZhbHNlO1xuICBjb25zdCBjb25uZWN0ZWRIYW5kbGVycyA9IFtdO1xuXG4gIGNvbnN0IGxhdW5jaENvbm5lY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghY29ubmVjdGVkKSB7XG4gICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgICBsZXQgaGFuZGxlcjtcbiAgICAgIHdoaWxlICgoaGFuZGxlciA9IGNvbm5lY3RlZEhhbmRsZXJzLnBvcCgpKSkge1xuICAgICAgICBoYW5kbGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNoZWNrSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGhhbmRsZXI7XG4gICAgaWYgKHR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgbXNnID1cbiAgICAgICAgXCJBIGZ1bmN0aW9uIG1heSBvbmx5IGJlIHN1YnNyaWJlZCB0byB0aGUgZXZlbnQsIFwiICtcbiAgICAgICAgdHlwZSArXG4gICAgICAgIFwiIHdhcyBwcm92aWRlZCBpbnN0ZWFkXCI7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH07XG5cbiAgcmV0dXJuIHJwYztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\\\\n//# sourceURL=webpack-internal:///./src/pluginCore.js\\\\n\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/rpc.js\\\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"API_VERSION\\\\\\\", function() { return API_VERSION; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"RPC\\\\\\\", function() { return RPC; });\\\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \\\\\\\"./src/utils.js\\\\\\\");\\\\n/**\\\\n * Contains the RPC object used both by the application\\\\n * site, and by each plugin\\\\n */\\\\n\\\\nconst API_VERSION = \\\\\\\"0.2.3\\\\\\\";\\\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\\\n\\\\nfunction _appendBuffer(buffer1, buffer2) {\\\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\\\n  tmp.set(new Uint8Array(buffer1), 0);\\\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\\\n  return tmp.buffer;\\\\n}\\\\n\\\\nfunction indexObject(obj, is) {\\\\n  if (typeof is == \\\\\\\"string\\\\\\\") return indexObject(obj, is.split(\\\\\\\".\\\\\\\"));else if (is.length == 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\\\n}\\\\n/**\\\\n * RPC object represents a single site in the\\\\n * communication protocol between the application and the plugin\\\\n *\\\\n * @param {Object} connection a special object allowing to send\\\\n * and receive messages from the opposite site (basically it\\\\n * should only provide send() and onMessage() methods)\\\\n */\\\\n\\\\n\\\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"MessageEmitter\\\\\\\"] {\\\\n  constructor(connection, config, codecs) {\\\\n    super(config && config.debug);\\\\n    this._connection = connection;\\\\n    this.config = config || {};\\\\n    this._codecs = codecs || {};\\\\n    this._object_store = {};\\\\n    this._method_weakmap = new WeakMap();\\\\n    this._object_weakmap = new WeakMap();\\\\n    this._local_api = null; // make sure there is an execute function\\\\n\\\\n    const name = this.config.name;\\\\n\\\\n    this._connection.execute = this._connection.execute || function () {\\\\n      throw new Error(`connection.execute not implemented (in \\\\\\\"${name}\\\\\\\")`);\\\\n    };\\\\n\\\\n    this._store = new ReferenceStore();\\\\n    this._method_refs = new ReferenceStore();\\\\n\\\\n    this._method_refs.onReady(() => {\\\\n      this._fire(\\\\\\\"remoteIdle\\\\\\\");\\\\n    });\\\\n\\\\n    this._method_refs.onBusy(() => {\\\\n      this._fire(\\\\\\\"remoteBusy\\\\\\\");\\\\n    });\\\\n\\\\n    this._setupMessageHanlders();\\\\n  }\\\\n\\\\n  init() {\\\\n    this._connection.emit({\\\\n      type: \\\\\\\"initialized\\\\\\\",\\\\n      config: this.config,\\\\n      peer_id: this._connection.peer_id\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Set a handler to be called when received a responce from the\\\\n   * remote site reporting that the previously provided interface\\\\n   * has been successfully set as remote for that site\\\\n   *\\\\n   * @param {Function} handler\\\\n   */\\\\n\\\\n\\\\n  getRemoteCallStack() {\\\\n    return this._method_refs.getStack();\\\\n  }\\\\n  /**\\\\n   * @returns {Object} set of remote interface methods\\\\n   */\\\\n\\\\n\\\\n  getRemote() {\\\\n    return this._remote_interface;\\\\n  }\\\\n  /**\\\\n   * Sets the interface of this site making it available to the\\\\n   * remote site by sending a message with a set of methods names\\\\n   *\\\\n   * @param {Object} _interface to set\\\\n   */\\\\n\\\\n\\\\n  setInterface(_interface, config) {\\\\n    config = config || {};\\\\n    this.config.name = config.name || this.config.name;\\\\n    this.config.description = config.description || this.config.description;\\\\n\\\\n    if (this.config.forwarding_functions) {\\\\n      for (let func_name of this.config.forwarding_functions) {\\\\n        const _remote = this._remote_interface;\\\\n\\\\n        if (_remote[func_name]) {\\\\n          if (_interface.constructor === Object) {\\\\n            if (!_interface[func_name]) {\\\\n              _interface[func_name] = (...args) => {\\\\n                _remote[func_name](...args);\\\\n              };\\\\n            }\\\\n          } else if (_interface.constructor.constructor === Function) {\\\\n            if (!_interface.constructor.prototype[func_name]) {\\\\n              _interface.constructor.prototype[func_name] = (...args) => {\\\\n                _remote[func_name](...args);\\\\n              };\\\\n            }\\\\n          }\\\\n        }\\\\n      }\\\\n    }\\\\n\\\\n    this._local_api = _interface;\\\\n\\\\n    this._fire(\\\\\\\"interfaceAvailable\\\\\\\");\\\\n  }\\\\n  /**\\\\n   * Sends the actual interface to the remote site upon it was\\\\n   * updated or by a special request of the remote site\\\\n   */\\\\n\\\\n\\\\n  sendInterface() {\\\\n    if (!this._local_api) {\\\\n      throw new Error(\\\\\\\"interface is not set.\\\\\\\");\\\\n    }\\\\n\\\\n    this._encode(this._local_api, true).then(api => {\\\\n      this._connection.emit({\\\\n        type: \\\\\\\"setInterface\\\\\\\",\\\\n        api: api\\\\n      });\\\\n    });\\\\n  }\\\\n\\\\n  _disposeObject(objectId) {\\\\n    if (this._object_store[objectId]) {\\\\n      delete this._object_store[objectId];\\\\n    } else {\\\\n      throw new Error(`Object (id=${objectId}) not found.`);\\\\n    }\\\\n  }\\\\n\\\\n  disposeObject(obj) {\\\\n    return new Promise((resolve, reject) => {\\\\n      if (this._object_weakmap.has(obj)) {\\\\n        const objectId = this._object_weakmap.get(obj);\\\\n\\\\n        this._connection.once(\\\\\\\"disposed\\\\\\\", data => {\\\\n          if (data.error) reject(new Error(data.error));else resolve();\\\\n        });\\\\n\\\\n        this._connection.emit({\\\\n          type: \\\\\\\"disposeObject\\\\\\\",\\\\n          object_id: objectId\\\\n        });\\\\n      } else {\\\\n        throw new Error(\\\\\\\"Invalid object\\\\\\\");\\\\n      }\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Handles a message from the remote site\\\\n   */\\\\n  // var callback_reg = new RegExp(\\\\\\\"onupdate|run$\\\\\\\")\\\\n\\\\n\\\\n  _setupMessageHanlders() {\\\\n    this._connection.on(\\\\\\\"init\\\\\\\", this.init);\\\\n\\\\n    this._connection.on(\\\\\\\"execute\\\\\\\", data => {\\\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\\\n        this._connection.emit({\\\\n          type: \\\\\\\"executed\\\\\\\"\\\\n        });\\\\n      }).catch(e => {\\\\n        console.error(e);\\\\n\\\\n        this._connection.emit({\\\\n          type: \\\\\\\"executed\\\\\\\",\\\\n          error: String(e)\\\\n        });\\\\n      });\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"method\\\\\\\", async data => {\\\\n      let resolve, reject, method, args, result;\\\\n\\\\n      try {\\\\n        if (data.promise) {\\\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\\\n        }\\\\n\\\\n        const _interface = this._object_store[data.object_id];\\\\n        method = indexObject(_interface, data.name);\\\\n        args = await this._unwrap(data.args, true);\\\\n\\\\n        if (data.promise) {\\\\n          result = method.apply(_interface, args);\\\\n\\\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\\\\\\"AsyncFunction\\\\\\\") {\\\\n            result.then(resolve).catch(reject);\\\\n          } else {\\\\n            resolve(result);\\\\n          }\\\\n        } else {\\\\n          method.apply(_interface, args);\\\\n        }\\\\n      } catch (err) {\\\\n        console.error(this.config.name, err);\\\\n\\\\n        if (reject) {\\\\n          reject(err);\\\\n        }\\\\n      }\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"callback\\\\\\\", async data => {\\\\n      let resolve, reject, method, args, result;\\\\n\\\\n      try {\\\\n        if (data.promise) {\\\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\\\n        }\\\\n\\\\n        if (data.promise) {\\\\n          method = this._store.fetch(data.id);\\\\n          args = await this._unwrap(data.args, true);\\\\n\\\\n          if (!method) {\\\\n            throw new Error(\\\\\\\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\\\\\");\\\\n          }\\\\n\\\\n          result = method.apply(null, args);\\\\n\\\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\\\\\\"AsyncFunction\\\\\\\") {\\\\n            result.then(resolve).catch(reject);\\\\n          } else {\\\\n            resolve(result);\\\\n          }\\\\n        } else {\\\\n          method = this._store.fetch(data.id);\\\\n          args = await this._unwrap(data.args, true);\\\\n\\\\n          if (!method) {\\\\n            throw new Error(\\\\\\\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\\\\\");\\\\n          }\\\\n\\\\n          method.apply(null, args);\\\\n        }\\\\n      } catch (err) {\\\\n        console.error(this.config.name, err);\\\\n\\\\n        if (reject) {\\\\n          reject(err);\\\\n        }\\\\n      }\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"disposeObject\\\\\\\", data => {\\\\n      try {\\\\n        this._disposeObject(data.object_id);\\\\n\\\\n        this._connection.emit({\\\\n          type: \\\\\\\"disposed\\\\\\\"\\\\n        });\\\\n      } catch (e) {\\\\n        console.error(e);\\\\n\\\\n        this._connection.emit({\\\\n          type: \\\\\\\"disposed\\\\\\\",\\\\n          error: String(e)\\\\n        });\\\\n      }\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"setInterface\\\\\\\", data => {\\\\n      this._setRemoteInterface(data.api);\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"getInterface\\\\\\\", () => {\\\\n      this._fire(\\\\\\\"getInterface\\\\\\\");\\\\n\\\\n      if (this._local_api) {\\\\n        this.sendInterface();\\\\n      } else {\\\\n        this.once(\\\\\\\"interfaceAvailable\\\\\\\", () => {\\\\n          this.sendInterface();\\\\n        });\\\\n      }\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"interfaceSetAsRemote\\\\\\\", () => {\\\\n      this._fire(\\\\\\\"interfaceSetAsRemote\\\\\\\");\\\\n    });\\\\n\\\\n    this._connection.on(\\\\\\\"disconnect\\\\\\\", () => {\\\\n      this._fire(\\\\\\\"beforeDisconnect\\\\\\\");\\\\n\\\\n      this._connection.disconnect();\\\\n\\\\n      this._fire(\\\\\\\"disconnected\\\\\\\");\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Sends a requests to the remote site asking it to provide its\\\\n   * current interface\\\\n   */\\\\n\\\\n\\\\n  requestRemote() {\\\\n    this._connection.emit({\\\\n      type: \\\\\\\"getInterface\\\\\\\"\\\\n    });\\\\n  }\\\\n\\\\n  _ndarray(typedArray, shape, dtype) {\\\\n    var _dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"typedArrayToDtype\\\\\\\"][typedArray.constructor.name];\\\\n\\\\n    if (dtype && dtype !== _dtype) {\\\\n      throw \\\\\\\"dtype doesn't match the type of the array: \\\\\\\" + _dtype + \\\\\\\" != \\\\\\\" + dtype;\\\\n    }\\\\n\\\\n    shape = shape || [typedArray.length];\\\\n    return {\\\\n      _rtype: \\\\\\\"ndarray\\\\\\\",\\\\n      _rvalue: typedArray.buffer,\\\\n      _rshape: shape,\\\\n      _rdtype: _dtype\\\\n    };\\\\n  }\\\\n  /**\\\\n   * Sets the new remote interface provided by the other site\\\\n   *\\\\n   * @param {Array} names list of function names\\\\n   */\\\\n\\\\n\\\\n  _setRemoteInterface(api) {\\\\n    this._decode(api).then(intf => {\\\\n      this._remote_interface = intf;\\\\n\\\\n      this._fire(\\\\\\\"remoteReady\\\\\\\");\\\\n\\\\n      this._reportRemoteSet();\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Generates the wrapped function corresponding to a single remote\\\\n   * method. When the generated function is called, it will send the\\\\n   * corresponding message to the remote site asking it to execute\\\\n   * the particular method of its interface\\\\n   *\\\\n   * @param {String} name of the remote method\\\\n   *\\\\n   * @returns {Function} wrapped remote method\\\\n   */\\\\n\\\\n\\\\n  _genRemoteMethod(targetId, name, objectId) {\\\\n    var me = this;\\\\n\\\\n    var remoteMethod = function () {\\\\n      return new Promise(async (resolve, reject) => {\\\\n        let id = null;\\\\n\\\\n        try {\\\\n          id = me._method_refs.put(objectId ? objectId + \\\\\\\"/\\\\\\\" + name : name);\\\\n\\\\n          var wrapped_resolve = function () {\\\\n            if (id !== null) me._method_refs.fetch(id);\\\\n            return resolve.apply(this, arguments);\\\\n          };\\\\n\\\\n          var wrapped_reject = function () {\\\\n            if (id !== null) me._method_refs.fetch(id);\\\\n            return reject.apply(this, arguments);\\\\n          };\\\\n\\\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\\\n\\\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\\\n          var args = Array.prototype.slice.call(arguments);\\\\n\\\\n          if (name === \\\\\\\"register\\\\\\\" || name === \\\\\\\"export\\\\\\\" || name === \\\\\\\"on\\\\\\\") {\\\\n            args = await me._wrap(args, true);\\\\n          } else {\\\\n            args = await me._wrap(args);\\\\n          }\\\\n\\\\n          var transferables = args.__transferables__;\\\\n          if (transferables) delete args.__transferables__;\\\\n\\\\n          me._connection.emit({\\\\n            type: \\\\\\\"method\\\\\\\",\\\\n            target_id: targetId,\\\\n            name: name,\\\\n            object_id: objectId,\\\\n            args: args,\\\\n            promise: encodedPromise\\\\n          }, transferables);\\\\n        } catch (e) {\\\\n          if (id) me._method_refs.fetch(id);\\\\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\\\\n        }\\\\n      });\\\\n    };\\\\n\\\\n    remoteMethod.__remote_method = true;\\\\n    return remoteMethod;\\\\n  }\\\\n  /**\\\\n   * Sends a responce reporting that interface just provided by the\\\\n   * remote site was successfully set by this site as remote\\\\n   */\\\\n\\\\n\\\\n  _reportRemoteSet() {\\\\n    this._connection.emit({\\\\n      type: \\\\\\\"interfaceSetAsRemote\\\\\\\"\\\\n    });\\\\n  }\\\\n  /**\\\\n   * Prepares the provided set of remote method arguments for\\\\n   * sending to the remote site, replaces all the callbacks with\\\\n   * identifiers\\\\n   *\\\\n   * @param {Array} args to wrap\\\\n   *\\\\n   * @returns {Array} wrapped arguments\\\\n   */\\\\n\\\\n\\\\n  async _encode(aObject, asInterface, objectId) {\\\\n    const aType = typeof aObject;\\\\n\\\\n    if (aType === \\\\\\\"number\\\\\\\" || aType === \\\\\\\"string\\\\\\\" || aType === \\\\\\\"boolean\\\\\\\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\\\n      return aObject;\\\\n    }\\\\n\\\\n    let bObject;\\\\n\\\\n    if (typeof aObject === \\\\\\\"function\\\\\\\") {\\\\n      if (asInterface) {\\\\n        if (!objectId) throw new Error(\\\\\\\"objectId is not specified.\\\\\\\");\\\\n        bObject = {\\\\n          _rtype: \\\\\\\"interface\\\\\\\",\\\\n          _rtarget_id: this._connection.peer_id,\\\\n          _rintf: objectId,\\\\n          _rvalue: asInterface\\\\n        };\\\\n\\\\n        this._method_weakmap.set(aObject, bObject);\\\\n      } else if (this._method_weakmap.has(aObject)) {\\\\n        bObject = this._method_weakmap.get(aObject);\\\\n      } else {\\\\n        const cid = this._store.put(aObject);\\\\n\\\\n        bObject = {\\\\n          _rtype: \\\\\\\"callback\\\\\\\",\\\\n          _rtarget_id: this._connection.peer_id,\\\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\\\n          _rvalue: cid\\\\n        };\\\\n      }\\\\n\\\\n      return bObject;\\\\n    } // skip if already encoded\\\\n\\\\n\\\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\\\n      // make sure the interface functions are encoded\\\\n      if (aObject._rintf) {\\\\n        const temp = aObject._rtype;\\\\n        delete aObject._rtype;\\\\n        bObject = await this._encode(aObject, asInterface, objectId);\\\\n        bObject._rtype = temp;\\\\n      } else {\\\\n        bObject = aObject;\\\\n      }\\\\n\\\\n      return bObject;\\\\n    }\\\\n\\\\n    const transferables = [];\\\\n    const _transfer = aObject._transfer;\\\\n    const isarray = Array.isArray(aObject);\\\\n\\\\n    for (let tp of Object.keys(this._codecs)) {\\\\n      const codec = this._codecs[tp];\\\\n\\\\n      if (codec.encoder && aObject instanceof codec.type) {\\\\n        // TODO: what if multiple encoders found\\\\n        const encodedObj = await Promise.resolve(codec.encoder(aObject));\\\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\\\n\\\\n        if (encodedObj && encodedObj._rintf) {\\\\n          const temp = encodedObj._rtype;\\\\n          delete encodedObj._rtype;\\\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\\\n          encodedObj._rtype = temp;\\\\n        }\\\\n\\\\n        bObject = encodedObj;\\\\n        return bObject;\\\\n      }\\\\n    }\\\\n\\\\n    if (\\\\n    /*global tf*/\\\\n    typeof tf !== \\\\\\\"undefined\\\\\\\" && tf.Tensor && aObject instanceof tf.Tensor) {\\\\n      const v_buffer = aObject.dataSync();\\\\n\\\\n      if (aObject._transfer || _transfer) {\\\\n        transferables.push(v_buffer.buffer);\\\\n        delete aObject._transfer;\\\\n      }\\\\n\\\\n      bObject = {\\\\n        _rtype: \\\\\\\"ndarray\\\\\\\",\\\\n        _rvalue: v_buffer.buffer,\\\\n        _rshape: aObject.shape,\\\\n        _rdtype: aObject.dtype\\\\n      };\\\\n    } else if (\\\\n    /*global nj*/\\\\n    typeof nj !== \\\\\\\"undefined\\\\\\\" && nj.NdArray && aObject instanceof nj.NdArray) {\\\\n      var dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"typedArrayToDtype\\\\\\\"][aObject.selection.data.constructor.name];\\\\n\\\\n      if (aObject._transfer || _transfer) {\\\\n        transferables.push(aObject.selection.data.buffer);\\\\n        delete aObject._transfer;\\\\n      }\\\\n\\\\n      bObject = {\\\\n        _rtype: \\\\\\\"ndarray\\\\\\\",\\\\n        _rvalue: aObject.selection.data.buffer,\\\\n        _rshape: aObject.shape,\\\\n        _rdtype: dtype\\\\n      };\\\\n    } else if (aObject instanceof Error) {\\\\n      console.error(aObject);\\\\n      bObject = {\\\\n        _rtype: \\\\\\\"error\\\\\\\",\\\\n        _rvalue: aObject.toString()\\\\n      };\\\\n    } else if (typeof File !== \\\\\\\"undefined\\\\\\\" && aObject instanceof File) {\\\\n      bObject = {\\\\n        _rtype: \\\\\\\"file\\\\\\\",\\\\n        _rvalue: aObject,\\\\n        _rpath: aObject._path || aObject.webkitRelativePath\\\\n      };\\\\n    } // send objects supported by structure clone algorithm\\\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \\\\\\\"undefined\\\\\\\" && aObject instanceof FileList) {\\\\n        bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\\\n      } else if (typeof File !== \\\\\\\"undefined\\\\\\\" && aObject instanceof File) {\\\\n        bObject = {\\\\n          _rtype: \\\\\\\"file\\\\\\\",\\\\n          _rname: aObject.name,\\\\n          _rmime: aObject.type,\\\\n          _rvalue: aObject,\\\\n          _rpath: aObject._path || aObject.webkitRelativePath\\\\n        };\\\\n      } else if (aObject instanceof Blob) {\\\\n        bObject = {\\\\n          _rtype: \\\\\\\"blob\\\\\\\",\\\\n          _rvalue: aObject\\\\n        };\\\\n      } else if (aObject instanceof ArrayBufferView) {\\\\n        if (aObject._transfer || _transfer) {\\\\n          transferables.push(aObject.buffer);\\\\n          delete aObject._transfer;\\\\n        }\\\\n\\\\n        const dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"typedArrayToDtype\\\\\\\"][aObject.constructor.name];\\\\n        bObject = {\\\\n          _rtype: \\\\\\\"typedarray\\\\\\\",\\\\n          _rvalue: aObject.buffer,\\\\n          _rdtype: dtype\\\\n        };\\\\n      } else if (aObject instanceof DataView) {\\\\n        if (aObject._transfer || _transfer) {\\\\n          transferables.push(aObject.buffer);\\\\n          delete aObject._transfer;\\\\n        }\\\\n\\\\n        bObject = {\\\\n          _rtype: \\\\\\\"memoryview\\\\\\\",\\\\n          _rvalue: aObject.buffer\\\\n        };\\\\n      } else if (aObject instanceof Set) {\\\\n        bObject = {\\\\n          _rtype: \\\\\\\"set\\\\\\\",\\\\n          _rvalue: await this._encode(Array.from(aObject), asInterface)\\\\n        };\\\\n      } else if (aObject instanceof Map) {\\\\n        bObject = {\\\\n          _rtype: \\\\\\\"orderedmap\\\\\\\",\\\\n          _rvalue: await this._encode(Array.from(aObject), asInterface)\\\\n        };\\\\n      } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\\\n        bObject = isarray ? [] : {};\\\\n        let keys; // an object/array\\\\n\\\\n        if (aObject.constructor === Object || Array.isArray(aObject)) {\\\\n          keys = Object.keys(aObject);\\\\n        } // a class\\\\n        else if (aObject.constructor === Function) {\\\\n            throw new Error(\\\\\\\"Please instantiate the class before exportting it.\\\\\\\");\\\\n          } // instance of a class\\\\n          else if (aObject.constructor.constructor === Function) {\\\\n              keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\\\n              // always encode class instance as interface\\\\n\\\\n              asInterface = true;\\\\n            } else {\\\\n              throw Error(\\\\\\\"Unsupported interface type\\\\\\\");\\\\n            } // encode interfaces\\\\n\\\\n\\\\n        if (aObject._rintf || asInterface) {\\\\n          if (!objectId) {\\\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"randId\\\\\\\"])();\\\\n            this._object_store[objectId] = aObject;\\\\n          }\\\\n\\\\n          for (let k of keys) {\\\\n            if (k === \\\\\\\"constructor\\\\\\\") continue;\\\\n\\\\n            if (k.startsWith(\\\\\\\"_\\\\\\\")) {\\\\n              continue;\\\\n            }\\\\n\\\\n            bObject[k] = await this._encode(aObject[k], typeof asInterface === \\\\\\\"string\\\\\\\" ? asInterface + \\\\\\\".\\\\\\\" + k : k, objectId);\\\\n          } // object id for dispose the object remotely\\\\n\\\\n\\\\n          bObject._rintf = objectId; // remove interface when closed\\\\n\\\\n          if (aObject.on && typeof aObject.on === \\\\\\\"function\\\\\\\") {\\\\n            aObject.on(\\\\\\\"close\\\\\\\", () => {\\\\n              delete this._object_store[objectId];\\\\n            });\\\\n          }\\\\n        } else {\\\\n          for (let k of keys) {\\\\n            if ([\\\\\\\"hasOwnProperty\\\\\\\", \\\\\\\"constructor\\\\\\\"].includes(k)) continue;\\\\n            bObject[k] = await this._encode(aObject[k]);\\\\n          }\\\\n        } // for example, browserFS object\\\\n\\\\n      } else if (typeof aObject === \\\\\\\"object\\\\\\\") {\\\\n        const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\\\n        const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"randId\\\\\\\"])();\\\\n\\\\n        for (let k of keys) {\\\\n          if ([\\\\\\\"hasOwnProperty\\\\\\\", \\\\\\\"constructor\\\\\\\"].includes(k)) continue; // encode as interface\\\\n\\\\n          bObject[k] = await this._encode(aObject[k], k, bObject);\\\\n        } // object id, used for dispose the object\\\\n\\\\n\\\\n        bObject._rintf = objectId;\\\\n      } else {\\\\n        throw \\\\\\\"imjoy-rpc: Unsupported data type:\\\\\\\" + aObject;\\\\n      }\\\\n\\\\n    if (transferables.length > 0) {\\\\n      bObject.__transferables__ = transferables;\\\\n    }\\\\n\\\\n    if (!bObject) {\\\\n      throw new Error(\\\\\\\"Failed to encode object\\\\\\\");\\\\n    }\\\\n\\\\n    return bObject;\\\\n  }\\\\n\\\\n  async _decode(aObject, withPromise) {\\\\n    if (!aObject) {\\\\n      return aObject;\\\\n    }\\\\n\\\\n    var bObject, v, k;\\\\n\\\\n    if (aObject[\\\\\\\"_rtype\\\\\\\"]) {\\\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\\\n        if (aObject._rintf) {\\\\n          const temp = aObject._rtype;\\\\n          delete aObject._rtype;\\\\n          aObject = await this._decode(aObject, withPromise);\\\\n          aObject._rtype = temp;\\\\n        }\\\\n\\\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\\\n      } else if (aObject._rtype === \\\\\\\"callback\\\\\\\") {\\\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\\\n      } else if (aObject._rtype === \\\\\\\"interface\\\\\\\") {\\\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\\\n      } else if (aObject._rtype === \\\\\\\"ndarray\\\\\\\") {\\\\n        /*global nj tf*/\\\\n        //create build array/tensor if used in the plugin\\\\n        if (typeof nj !== \\\\\\\"undefined\\\\\\\" && nj.array) {\\\\n          if (Array.isArray(aObject._rvalue)) {\\\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\\\n          }\\\\n\\\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\\\n        } else if (typeof tf !== \\\\\\\"undefined\\\\\\\" && tf.Tensor) {\\\\n          if (Array.isArray(aObject._rvalue)) {\\\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\\\n          }\\\\n\\\\n          const arraytype = eval(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"dtypeToTypedArray\\\\\\\"][aObject._rdtype]);\\\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\\\n        } else {\\\\n          //keep it as regular if transfered to the main app\\\\n          bObject = aObject;\\\\n        }\\\\n      } else if (aObject._rtype === \\\\\\\"error\\\\\\\") {\\\\n        bObject = new Error(aObject._rvalue);\\\\n      } else if (aObject._rtype === \\\\\\\"file\\\\\\\") {\\\\n        if (aObject._rvalue instanceof File) {\\\\n          bObject = aObject._rvalue; //patch _path\\\\n\\\\n          bObject._path = aObject._rpath;\\\\n        } else {\\\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\\\n            type: aObject._rmime\\\\n          });\\\\n          bObject._path = aObject._rpath;\\\\n        }\\\\n      } else if (aObject._rtype === \\\\\\\"typedarray\\\\\\\") {\\\\n        const arraytype = eval(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"dtypeToTypedArray\\\\\\\"][aObject._rdtype]);\\\\n        if (!arraytype) throw new Error(\\\\\\\"unsupported dtype: \\\\\\\" + aObject._rdtype);\\\\n        bObject = new arraytype(aObject._rvalue);\\\\n      } else if (aObject._rtype === \\\\\\\"memoryview\\\\\\\") {\\\\n        bObject = new DataView(aObject._rvalue);\\\\n      } else if (aObject._rtype === \\\\\\\"blob\\\\\\\") {\\\\n        if (aObject._rvalue instanceof Blob) {\\\\n          bObject = aObject._rvalue;\\\\n        } else {\\\\n          bObject = new Blob([aObject._rvalue], {\\\\n            type: aObject._rmime\\\\n          });\\\\n        }\\\\n      } else if (aObject._rtype === \\\\\\\"orderedmap\\\\\\\") {\\\\n        bObject = new Map((await this._decode(aObject._rvalue, withPromise)));\\\\n      } else if (aObject._rtype === \\\\\\\"set\\\\\\\") {\\\\n        bObject = new Set((await this._decode(aObject._rvalue, withPromise)));\\\\n      } else {\\\\n        // make sure all the interface functions are decoded\\\\n        if (aObject._rintf) {\\\\n          const temp = aObject._rtype;\\\\n          delete aObject._rtype;\\\\n          aObject = await this._decode(aObject, withPromise);\\\\n          aObject._rtype = temp;\\\\n        }\\\\n\\\\n        bObject = aObject;\\\\n      }\\\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\\\n      var isarray = Array.isArray(aObject);\\\\n      bObject = isarray ? [] : {};\\\\n\\\\n      for (k in aObject) {\\\\n        if (isarray || aObject.hasOwnProperty(k)) {\\\\n          v = aObject[k];\\\\n          bObject[k] = await this._decode(v, withPromise);\\\\n        }\\\\n      }\\\\n    } else {\\\\n      bObject = aObject;\\\\n    }\\\\n\\\\n    if (bObject === undefined) {\\\\n      throw new Error(\\\\\\\"Failed to decode object\\\\\\\");\\\\n    } // store the object id for dispose\\\\n\\\\n\\\\n    if (aObject._rintf) {\\\\n      this._object_weakmap.set(bObject, aObject._rintf);\\\\n    }\\\\n\\\\n    return bObject;\\\\n  }\\\\n\\\\n  async _wrap(args, asInterface) {\\\\n    var wrapped = await this._encode(args, asInterface);\\\\n    return wrapped;\\\\n  }\\\\n  /**\\\\n   * Unwraps the set of arguments delivered from the remote site,\\\\n   * replaces all callback identifiers with a function which will\\\\n   * initiate sending that callback identifier back to other site\\\\n   *\\\\n   * @param {Object} args to unwrap\\\\n   *\\\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\\\n   *\\\\n   * @returns {Array} unwrapped args\\\\n   */\\\\n\\\\n\\\\n  async _unwrap(args, withPromise) {\\\\n    var result = await this._decode(args, withPromise);\\\\n    return result;\\\\n  }\\\\n  /**\\\\n   * Generates the wrapped function corresponding to a single remote\\\\n   * callback. When the generated function is called, it will send\\\\n   * the corresponding message to the remote site asking it to\\\\n   * execute the particular callback previously saved during a call\\\\n   * by the remote site a method from the interface of this site\\\\n   *\\\\n   * @param {Number} id of the remote callback to execute\\\\n   * @param {Number} argNum argument index of the callback\\\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\\\n   *\\\\n   * @returns {Function} wrapped remote callback\\\\n   */\\\\n\\\\n\\\\n  _genRemoteCallback(targetId, cid, withPromise) {\\\\n    var me = this;\\\\n    var remoteCallback;\\\\n\\\\n    if (withPromise) {\\\\n      remoteCallback = function () {\\\\n        return new Promise(async (resolve, reject) => {\\\\n          var args = await me._wrap(Array.prototype.slice.call(arguments));\\\\n          var transferables = args.__transferables__;\\\\n          if (transferables) delete args.__transferables__;\\\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\\\n\\\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\\\n\\\\n          try {\\\\n            me._connection.emit({\\\\n              type: \\\\\\\"callback\\\\\\\",\\\\n              target_id: targetId,\\\\n              id: cid,\\\\n              args: args,\\\\n              promise: encodedPromise\\\\n            }, transferables);\\\\n          } catch (e) {\\\\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\\\\n          }\\\\n        });\\\\n      };\\\\n\\\\n      return remoteCallback;\\\\n    } else {\\\\n      remoteCallback = async function () {\\\\n        var args = await me._wrap(Array.prototype.slice.call(arguments));\\\\n        var transferables = args.__transferables__;\\\\n        if (transferables) delete args.__transferables__;\\\\n        return me._connection.emit({\\\\n          type: \\\\\\\"callback\\\\\\\",\\\\n          target_id: targetId,\\\\n          id: cid,\\\\n          args: args\\\\n        }, transferables);\\\\n      };\\\\n\\\\n      return remoteCallback;\\\\n    }\\\\n  }\\\\n  /**\\\\n   * Sends the notification message and breaks the connection\\\\n   */\\\\n\\\\n\\\\n  disconnect() {\\\\n    this._connection.emit({\\\\n      type: \\\\\\\"disconnect\\\\\\\"\\\\n    });\\\\n\\\\n    setTimeout(() => {\\\\n      this._connection.disconnect();\\\\n    }, 2000);\\\\n  }\\\\n\\\\n}\\\\n/**\\\\n * ReferenceStore is a special object which stores other objects\\\\n * and provides the references (number) instead. This reference\\\\n * may then be sent over a json-based communication channel (IPC\\\\n * to another Node.js process or a message to the Worker). Other\\\\n * site may then provide the reference in the responce message\\\\n * implying the given object should be activated.\\\\n *\\\\n * Primary usage for the ReferenceStore is a storage for the\\\\n * callbacks, which therefore makes it possible to initiate a\\\\n * callback execution by the opposite site (which normally cannot\\\\n * directly execute functions over the communication channel).\\\\n *\\\\n * Each stored object can only be fetched once and is not\\\\n * available for the second time. Each stored object must be\\\\n * fetched, since otherwise it will remain stored forever and\\\\n * consume memory.\\\\n *\\\\n * Stored object indeces are simply the numbers, which are however\\\\n * released along with the objects, and are later reused again (in\\\\n * order to postpone the overflow, which should not likely happen,\\\\n * but anyway).\\\\n */\\\\n\\\\nclass ReferenceStore {\\\\n  constructor() {\\\\n    this._store = {}; // stored object\\\\n\\\\n    this._indices = [0]; // smallest available indices\\\\n\\\\n    this._readyHandler = function () {};\\\\n\\\\n    this._busyHandler = function () {};\\\\n\\\\n    this._readyHandler();\\\\n  }\\\\n  /**\\\\n   * call handler when the store is empty\\\\n   *\\\\n   * @param {FUNCTION} id of a handler\\\\n   */\\\\n\\\\n\\\\n  onReady(readyHandler) {\\\\n    this._readyHandler = readyHandler || function () {};\\\\n  }\\\\n  /**\\\\n   * call handler when the store is not empty\\\\n   *\\\\n   * @param {FUNCTION} id of a handler\\\\n   */\\\\n\\\\n\\\\n  onBusy(busyHandler) {\\\\n    this._busyHandler = busyHandler || function () {};\\\\n  }\\\\n  /**\\\\n   * get the length of the store\\\\n   *\\\\n   */\\\\n\\\\n\\\\n  getStack() {\\\\n    return Object.keys(this._store).length;\\\\n  }\\\\n  /**\\\\n   * @function _genId() generates the new reference id\\\\n   *\\\\n   * @returns {Number} smallest available id and reserves it\\\\n   */\\\\n\\\\n\\\\n  _genId() {\\\\n    var id;\\\\n\\\\n    if (this._indices.length === 1) {\\\\n      id = this._indices[0]++;\\\\n    } else {\\\\n      id = this._indices.shift();\\\\n    }\\\\n\\\\n    return id;\\\\n  }\\\\n  /**\\\\n   * Releases the given reference id so that it will be available by\\\\n   * another object stored\\\\n   *\\\\n   * @param {Number} id to release\\\\n   */\\\\n\\\\n\\\\n  _releaseId(id) {\\\\n    for (var i = 0; i < this._indices.length; i++) {\\\\n      if (id < this._indices[i]) {\\\\n        this._indices.splice(i, 0, id);\\\\n\\\\n        break;\\\\n      }\\\\n    } // cleaning-up the sequence tail\\\\n\\\\n\\\\n    for (i = this._indices.length - 1; i >= 0; i--) {\\\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\\\n        this._indices.pop();\\\\n      } else {\\\\n        break;\\\\n      }\\\\n    }\\\\n  }\\\\n  /**\\\\n   * Stores the given object and returns the refernce id instead\\\\n   *\\\\n   * @param {Object} obj to store\\\\n   *\\\\n   * @returns {Number} reference id of the stored object\\\\n   */\\\\n\\\\n\\\\n  put(obj) {\\\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\\\n      this._busyHandler();\\\\n    }\\\\n\\\\n    var id = this._genId();\\\\n\\\\n    this._store[id] = obj;\\\\n    return id;\\\\n  }\\\\n  /**\\\\n   * Retrieves previously stored object and releases its reference\\\\n   *\\\\n   * @param {Number} id of an object to retrieve\\\\n   */\\\\n\\\\n\\\\n  fetch(id) {\\\\n    var obj = this._store[id];\\\\n\\\\n    if (obj && !obj.__remote_method) {\\\\n      delete this._store[id];\\\\n\\\\n      this._releaseId(id);\\\\n\\\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\\\n        this._readyHandler();\\\\n      }\\\\n    }\\\\n\\\\n    if (obj && obj.__promise_pair) {\\\\n      this.fetch(obj.__promise_pair);\\\\n    }\\\\n\\\\n    return obj;\\\\n  }\\\\n\\\\n}//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcnBjLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9zcmMvcnBjLmpzPzM1NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyB0aGUgUlBDIG9iamVjdCB1c2VkIGJvdGggYnkgdGhlIGFwcGxpY2F0aW9uXG4gKiBzaXRlLCBhbmQgYnkgZWFjaCBwbHVnaW5cbiAqL1xuaW1wb3J0IHtcbiAgcmFuZElkLFxuICB0eXBlZEFycmF5VG9EdHlwZSxcbiAgZHR5cGVUb1R5cGVkQXJyYXksXG4gIE1lc3NhZ2VFbWl0dGVyXG59IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTiA9IFwiMC4yLjNcIjtcblxuY29uc3QgQXJyYXlCdWZmZXJWaWV3ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKFxuICBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IFVpbnQ4QXJyYXkoKSlcbikuY29uc3RydWN0b3I7XG5cbmZ1bmN0aW9uIF9hcHBlbmRCdWZmZXIoYnVmZmVyMSwgYnVmZmVyMikge1xuICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheShidWZmZXIxLmJ5dGVMZW5ndGggKyBidWZmZXIyLmJ5dGVMZW5ndGgpO1xuICB0bXAuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcjEpLCAwKTtcbiAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIyKSwgYnVmZmVyMS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHRtcC5idWZmZXI7XG59XG5cbmZ1bmN0aW9uIGluZGV4T2JqZWN0KG9iaiwgaXMpIHtcbiAgaWYgKHR5cGVvZiBpcyA9PSBcInN0cmluZ1wiKSByZXR1cm4gaW5kZXhPYmplY3Qob2JqLCBpcy5zcGxpdChcIi5cIikpO1xuICBlbHNlIGlmIChpcy5sZW5ndGggPT0gMCkgcmV0dXJuIG9iajtcbiAgZWxzZSByZXR1cm4gaW5kZXhPYmplY3Qob2JqW2lzWzBdXSwgaXMuc2xpY2UoMSkpO1xufVxuXG4vKipcbiAqIFJQQyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbmdsZSBzaXRlIGluIHRoZVxuICogY29tbXVuaWNhdGlvbiBwcm90b2NvbCBiZXR3ZWVuIHRoZSBhcHBsaWNhdGlvbiBhbmQgdGhlIHBsdWdpblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uIGEgc3BlY2lhbCBvYmplY3QgYWxsb3dpbmcgdG8gc2VuZFxuICogYW5kIHJlY2VpdmUgbWVzc2FnZXMgZnJvbSB0aGUgb3Bwb3NpdGUgc2l0ZSAoYmFzaWNhbGx5IGl0XG4gKiBzaG91bGQgb25seSBwcm92aWRlIHNlbmQoKSBhbmQgb25NZXNzYWdlKCkgbWV0aG9kcylcbiAqL1xuZXhwb3J0IGNsYXNzIFJQQyBleHRlbmRzIE1lc3NhZ2VFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgY29uZmlnLCBjb2RlY3MpIHtcbiAgICBzdXBlcihjb25maWcgJiYgY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLl9jb2RlY3MgPSBjb2RlY3MgfHwge307XG4gICAgdGhpcy5fb2JqZWN0X3N0b3JlID0ge307XG4gICAgdGhpcy5fbWV0aG9kX3dlYWttYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX29iamVjdF93ZWFrbWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLl9sb2NhbF9hcGkgPSBudWxsO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhbiBleGVjdXRlIGZ1bmN0aW9uXG4gICAgY29uc3QgbmFtZSA9IHRoaXMuY29uZmlnLm5hbWU7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5leGVjdXRlID1cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZXhlY3V0ZSB8fFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29ubmVjdGlvbi5leGVjdXRlIG5vdCBpbXBsZW1lbnRlZCAoaW4gXCIke25hbWV9XCIpYCk7XG4gICAgICB9O1xuICAgIHRoaXMuX3N0b3JlID0gbmV3IFJlZmVyZW5jZVN0b3JlKCk7XG4gICAgdGhpcy5fbWV0aG9kX3JlZnMgPSBuZXcgUmVmZXJlbmNlU3RvcmUoKTtcbiAgICB0aGlzLl9tZXRob2RfcmVmcy5vblJlYWR5KCgpID0+IHtcbiAgICAgIHRoaXMuX2ZpcmUoXCJyZW1vdGVJZGxlXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuX21ldGhvZF9yZWZzLm9uQnVzeSgoKSA9PiB7XG4gICAgICB0aGlzLl9maXJlKFwicmVtb3RlQnVzeVwiKTtcbiAgICB9KTtcbiAgICB0aGlzLl9zZXR1cE1lc3NhZ2VIYW5sZGVycygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoe1xuICAgICAgdHlwZTogXCJpbml0aWFsaXplZFwiLFxuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIHBlZXJfaWQ6IHRoaXMuX2Nvbm5lY3Rpb24ucGVlcl9pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHJlY2VpdmVkIGEgcmVzcG9uY2UgZnJvbSB0aGVcbiAgICogcmVtb3RlIHNpdGUgcmVwb3J0aW5nIHRoYXQgdGhlIHByZXZpb3VzbHkgcHJvdmlkZWQgaW50ZXJmYWNlXG4gICAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZXQgYXMgcmVtb3RlIGZvciB0aGF0IHNpdGVcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cblxuICBnZXRSZW1vdGVDYWxsU3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGhvZF9yZWZzLmdldFN0YWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge09iamVjdH0gc2V0IG9mIHJlbW90ZSBpbnRlcmZhY2UgbWV0aG9kc1xuICAgKi9cbiAgZ2V0UmVtb3RlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW1vdGVfaW50ZXJmYWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGludGVyZmFjZSBvZiB0aGlzIHNpdGUgbWFraW5nIGl0IGF2YWlsYWJsZSB0byB0aGVcbiAgICogcmVtb3RlIHNpdGUgYnkgc2VuZGluZyBhIG1lc3NhZ2Ugd2l0aCBhIHNldCBvZiBtZXRob2RzIG5hbWVzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBfaW50ZXJmYWNlIHRvIHNldFxuICAgKi9cbiAgc2V0SW50ZXJmYWNlKF9pbnRlcmZhY2UsIGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmNvbmZpZy5uYW1lID0gY29uZmlnLm5hbWUgfHwgdGhpcy5jb25maWcubmFtZTtcbiAgICB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbiA9IGNvbmZpZy5kZXNjcmlwdGlvbiB8fCB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICBpZiAodGhpcy5jb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGZ1bmNfbmFtZSBvZiB0aGlzLmNvbmZpZy5mb3J3YXJkaW5nX2Z1bmN0aW9ucykge1xuICAgICAgICBjb25zdCBfcmVtb3RlID0gdGhpcy5fcmVtb3RlX2ludGVyZmFjZTtcbiAgICAgICAgaWYgKF9yZW1vdGVbZnVuY19uYW1lXSkge1xuICAgICAgICAgIGlmIChfaW50ZXJmYWNlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghX2ludGVyZmFjZVtmdW5jX25hbWVdKSB7XG4gICAgICAgICAgICAgIF9pbnRlcmZhY2VbZnVuY19uYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgX3JlbW90ZVtmdW5jX25hbWVdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbZnVuY19uYW1lXSkge1xuICAgICAgICAgICAgICBfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtmdW5jX25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBfcmVtb3RlW2Z1bmNfbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2xvY2FsX2FwaSA9IF9pbnRlcmZhY2U7XG4gICAgdGhpcy5fZmlyZShcImludGVyZmFjZUF2YWlsYWJsZVwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgYWN0dWFsIGludGVyZmFjZSB0byB0aGUgcmVtb3RlIHNpdGUgdXBvbiBpdCB3YXNcbiAgICogdXBkYXRlZCBvciBieSBhIHNwZWNpYWwgcmVxdWVzdCBvZiB0aGUgcmVtb3RlIHNpdGVcbiAgICovXG4gIHNlbmRJbnRlcmZhY2UoKSB7XG4gICAgaWYgKCF0aGlzLl9sb2NhbF9hcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVyZmFjZSBpcyBub3Qgc2V0LlwiKTtcbiAgICB9XG4gICAgdGhpcy5fZW5jb2RlKHRoaXMuX2xvY2FsX2FwaSwgdHJ1ZSkudGhlbihhcGkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHsgdHlwZTogXCJzZXRJbnRlcmZhY2VcIiwgYXBpOiBhcGkgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfZGlzcG9zZU9iamVjdChvYmplY3RJZCkge1xuICAgIGlmICh0aGlzLl9vYmplY3Rfc3RvcmVbb2JqZWN0SWRdKSB7XG4gICAgICBkZWxldGUgdGhpcy5fb2JqZWN0X3N0b3JlW29iamVjdElkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgKGlkPSR7b2JqZWN0SWR9KSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZU9iamVjdChvYmopIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX29iamVjdF93ZWFrbWFwLmhhcyhvYmopKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdElkID0gdGhpcy5fb2JqZWN0X3dlYWttYXAuZ2V0KG9iaik7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ub25jZShcImRpc3Bvc2VkXCIsIGRhdGEgPT4ge1xuICAgICAgICAgIGlmIChkYXRhLmVycm9yKSByZWplY3QobmV3IEVycm9yKGRhdGEuZXJyb3IpKTtcbiAgICAgICAgICBlbHNlIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XG4gICAgICAgICAgdHlwZTogXCJkaXNwb3NlT2JqZWN0XCIsXG4gICAgICAgICAgb2JqZWN0X2lkOiBvYmplY3RJZFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb2JqZWN0XCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBtZXNzYWdlIGZyb20gdGhlIHJlbW90ZSBzaXRlXG4gICAqL1xuICAvLyB2YXIgY2FsbGJhY2tfcmVnID0gbmV3IFJlZ0V4cChcIm9udXBkYXRlfHJ1biRcIilcbiAgX3NldHVwTWVzc2FnZUhhbmxkZXJzKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJpbml0XCIsIHRoaXMuaW5pdCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImV4ZWN1dGVcIiwgZGF0YSA9PiB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5fY29ubmVjdGlvbi5leGVjdXRlKGRhdGEuY29kZSkpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImV4ZWN1dGVkXCIgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBcImV4ZWN1dGVkXCIsXG4gICAgICAgICAgICBlcnJvcjogU3RyaW5nKGUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcIm1ldGhvZFwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGxldCByZXNvbHZlLCByZWplY3QsIG1ldGhvZCwgYXJncywgcmVzdWx0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGRhdGEucHJvbWlzZSkge1xuICAgICAgICAgIFtyZXNvbHZlLCByZWplY3RdID0gYXdhaXQgdGhpcy5fdW53cmFwKGRhdGEucHJvbWlzZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9pbnRlcmZhY2UgPSB0aGlzLl9vYmplY3Rfc3RvcmVbZGF0YS5vYmplY3RfaWRdO1xuICAgICAgICBtZXRob2QgPSBpbmRleE9iamVjdChfaW50ZXJmYWNlLCBkYXRhLm5hbWUpO1xuICAgICAgICBhcmdzID0gYXdhaXQgdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcbiAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkoX2ludGVyZmFjZSwgYXJncyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZC5hcHBseShfaW50ZXJmYWNlLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZXJyKTtcbiAgICAgICAgaWYgKHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFwiY2FsbGJhY2tcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0LCBtZXRob2QsIGFyZ3MsIHJlc3VsdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcbiAgICAgICAgICBbcmVzb2x2ZSwgcmVqZWN0XSA9IGF3YWl0IHRoaXMuX3Vud3JhcChkYXRhLnByb21pc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgICAgbWV0aG9kID0gdGhpcy5fc3RvcmUuZmV0Y2goZGF0YS5pZCk7XG4gICAgICAgICAgYXJncyA9IGF3YWl0IHRoaXMuX3Vud3JhcChkYXRhLmFyZ3MsIHRydWUpO1xuICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGJhY2sgZnVuY3Rpb24gY2FuIG9ubHkgY2FsbGVkIG9uY2UsIGlmIHlvdSB3YW50IHRvIGNhbGwgYSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgdGltZXMsIHBsZWFzZSBtYWtlIGl0IGFzIGEgcGx1Z2luIGFwaSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vaW1qb3kuaW8vZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZCA9IHRoaXMuX3N0b3JlLmZldGNoKGRhdGEuaWQpO1xuICAgICAgICAgIGFyZ3MgPSBhd2FpdCB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIlBsZWFzZSBub3RpY2UgdGhhdCBjYWxsYmFjayBmdW5jdGlvbiBjYW4gb25seSBjYWxsZWQgb25jZSwgaWYgeW91IHdhbnQgdG8gY2FsbCBhIGZ1bmN0aW9uIGZvciBtdWx0aXBsZSB0aW1lcywgcGxlYXNlIG1ha2UgaXQgYXMgYSBwbHVnaW4gYXBpIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9pbWpveS5pby9kb2NzIGZvciBtb3JlIGRldGFpbHMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1ldGhvZC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZXJyKTtcbiAgICAgICAgaWYgKHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImRpc3Bvc2VPYmplY3RcIiwgZGF0YSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9kaXNwb3NlT2JqZWN0KGRhdGEub2JqZWN0X2lkKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHtcbiAgICAgICAgICB0eXBlOiBcImRpc3Bvc2VkXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XG4gICAgICAgICAgdHlwZTogXCJkaXNwb3NlZFwiLFxuICAgICAgICAgIGVycm9yOiBTdHJpbmcoZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcInNldEludGVyZmFjZVwiLCBkYXRhID0+IHtcbiAgICAgIHRoaXMuX3NldFJlbW90ZUludGVyZmFjZShkYXRhLmFwaSk7XG4gICAgfSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImdldEludGVyZmFjZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9maXJlKFwiZ2V0SW50ZXJmYWNlXCIpO1xuICAgICAgaWYgKHRoaXMuX2xvY2FsX2FwaSkge1xuICAgICAgICB0aGlzLnNlbmRJbnRlcmZhY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25jZShcImludGVyZmFjZUF2YWlsYWJsZVwiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZW5kSW50ZXJmYWNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJpbnRlcmZhY2VTZXRBc1JlbW90ZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9maXJlKFwiaW50ZXJmYWNlU2V0QXNSZW1vdGVcIik7XG4gICAgfSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fZmlyZShcImJlZm9yZURpc2Nvbm5lY3RcIik7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuX2ZpcmUoXCJkaXNjb25uZWN0ZWRcIik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSByZXF1ZXN0cyB0byB0aGUgcmVtb3RlIHNpdGUgYXNraW5nIGl0IHRvIHByb3ZpZGUgaXRzXG4gICAqIGN1cnJlbnQgaW50ZXJmYWNlXG4gICAqL1xuICByZXF1ZXN0UmVtb3RlKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7IHR5cGU6IFwiZ2V0SW50ZXJmYWNlXCIgfSk7XG4gIH1cblxuICBfbmRhcnJheSh0eXBlZEFycmF5LCBzaGFwZSwgZHR5cGUpIHtcbiAgICB2YXIgX2R0eXBlID0gdHlwZWRBcnJheVRvRHR5cGVbdHlwZWRBcnJheS5jb25zdHJ1Y3Rvci5uYW1lXTtcbiAgICBpZiAoZHR5cGUgJiYgZHR5cGUgIT09IF9kdHlwZSkge1xuICAgICAgdGhyb3cgXCJkdHlwZSBkb2Vzbid0IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBhcnJheTogXCIgK1xuICAgICAgICBfZHR5cGUgK1xuICAgICAgICBcIiAhPSBcIiArXG4gICAgICAgIGR0eXBlO1xuICAgIH1cbiAgICBzaGFwZSA9IHNoYXBlIHx8IFt0eXBlZEFycmF5Lmxlbmd0aF07XG4gICAgcmV0dXJuIHtcbiAgICAgIF9ydHlwZTogXCJuZGFycmF5XCIsXG4gICAgICBfcnZhbHVlOiB0eXBlZEFycmF5LmJ1ZmZlcixcbiAgICAgIF9yc2hhcGU6IHNoYXBlLFxuICAgICAgX3JkdHlwZTogX2R0eXBlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuZXcgcmVtb3RlIGludGVyZmFjZSBwcm92aWRlZCBieSB0aGUgb3RoZXIgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBsaXN0IG9mIGZ1bmN0aW9uIG5hbWVzXG4gICAqL1xuICBfc2V0UmVtb3RlSW50ZXJmYWNlKGFwaSkge1xuICAgIHRoaXMuX2RlY29kZShhcGkpLnRoZW4oaW50ZiA9PiB7XG4gICAgICB0aGlzLl9yZW1vdGVfaW50ZXJmYWNlID0gaW50ZjtcbiAgICAgIHRoaXMuX2ZpcmUoXCJyZW1vdGVSZWFkeVwiKTtcbiAgICAgIHRoaXMuX3JlcG9ydFJlbW90ZVNldCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgd3JhcHBlZCBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIHJlbW90ZVxuICAgKiBtZXRob2QuIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZCB0aGVcbiAgICogY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG8gZXhlY3V0ZVxuICAgKiB0aGUgcGFydGljdWxhciBtZXRob2Qgb2YgaXRzIGludGVyZmFjZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgcmVtb3RlIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgcmVtb3RlIG1ldGhvZFxuICAgKi9cbiAgX2dlblJlbW90ZU1ldGhvZCh0YXJnZXRJZCwgbmFtZSwgb2JqZWN0SWQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZW1vdGVNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWQgPSBtZS5fbWV0aG9kX3JlZnMucHV0KG9iamVjdElkID8gb2JqZWN0SWQgKyBcIi9cIiArIG5hbWUgOiBuYW1lKTtcbiAgICAgICAgICB2YXIgd3JhcHBlZF9yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaWQgIT09IG51bGwpIG1lLl9tZXRob2RfcmVmcy5mZXRjaChpZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHdyYXBwZWRfcmVqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaWQgIT09IG51bGwpIG1lLl9tZXRob2RfcmVmcy5mZXRjaChpZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGVuY29kZWRQcm9taXNlID0gYXdhaXQgbWUuX3dyYXAoW1xuICAgICAgICAgICAgd3JhcHBlZF9yZXNvbHZlLFxuICAgICAgICAgICAgd3JhcHBlZF9yZWplY3RcbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIC8vIHN0b3JlIHRoZSBrZXkgaWQgZm9yIHJlbW92aW5nIHRoZW0gZnJvbSB0aGUgcmVmZXJlbmNlIHN0b3JlIHRvZ2V0aGVyXG4gICAgICAgICAgd3JhcHBlZF9yZXNvbHZlLl9fcHJvbWlzZV9wYWlyID0gZW5jb2RlZFByb21pc2VbMV0uX3J2YWx1ZTtcbiAgICAgICAgICB3cmFwcGVkX3JlamVjdC5fX3Byb21pc2VfcGFpciA9IGVuY29kZWRQcm9taXNlWzBdLl9ydmFsdWU7XG5cbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVnaXN0ZXJcIiB8fCBuYW1lID09PSBcImV4cG9ydFwiIHx8IG5hbWUgPT09IFwib25cIikge1xuICAgICAgICAgICAgYXJncyA9IGF3YWl0IG1lLl93cmFwKGFyZ3MsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzID0gYXdhaXQgbWUuX3dyYXAoYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuX190cmFuc2ZlcmFibGVzX187XG4gICAgICAgICAgbWUuX2Nvbm5lY3Rpb24uZW1pdChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtZXRob2RcIixcbiAgICAgICAgICAgICAgdGFyZ2V0X2lkOiB0YXJnZXRJZCxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgb2JqZWN0X2lkOiBvYmplY3RJZCxcbiAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgcHJvbWlzZTogZW5jb2RlZFByb21pc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChpZCkgbWUuX21ldGhvZF9yZWZzLmZldGNoKGlkKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN0dWUgcmVtb3RlIG1ldGhvZCAoaW50ZXJmYWNlOiAke29iamVjdElkIHx8XG4gICAgICAgICAgICAgIG1lLmlkfSwgbWV0aG9kOiAke25hbWV9KSwgZXJyb3I6ICR7ZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZW1vdGVNZXRob2QuX19yZW1vdGVfbWV0aG9kID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVtb3RlTWV0aG9kO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVzcG9uY2UgcmVwb3J0aW5nIHRoYXQgaW50ZXJmYWNlIGp1c3QgcHJvdmlkZWQgYnkgdGhlXG4gICAqIHJlbW90ZSBzaXRlIHdhcyBzdWNjZXNzZnVsbHkgc2V0IGJ5IHRoaXMgc2l0ZSBhcyByZW1vdGVcbiAgICovXG4gIF9yZXBvcnRSZW1vdGVTZXQoKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHsgdHlwZTogXCJpbnRlcmZhY2VTZXRBc1JlbW90ZVwiIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSBwcm92aWRlZCBzZXQgb2YgcmVtb3RlIG1ldGhvZCBhcmd1bWVudHMgZm9yXG4gICAqIHNlbmRpbmcgdG8gdGhlIHJlbW90ZSBzaXRlLCByZXBsYWNlcyBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoXG4gICAqIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdG8gd3JhcFxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHdyYXBwZWQgYXJndW1lbnRzXG4gICAqL1xuICBhc3luYyBfZW5jb2RlKGFPYmplY3QsIGFzSW50ZXJmYWNlLCBvYmplY3RJZCkge1xuICAgIGNvbnN0IGFUeXBlID0gdHlwZW9mIGFPYmplY3Q7XG4gICAgaWYgKFxuICAgICAgYVR5cGUgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgIGFUeXBlID09PSBcInN0cmluZ1wiIHx8XG4gICAgICBhVHlwZSA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAgIGFPYmplY3QgPT09IG51bGwgfHxcbiAgICAgIGFPYmplY3QgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgYU9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgKSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG5cbiAgICBsZXQgYk9iamVjdDtcbiAgICBpZiAodHlwZW9mIGFPYmplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKGFzSW50ZXJmYWNlKSB7XG4gICAgICAgIGlmICghb2JqZWN0SWQpIHRocm93IG5ldyBFcnJvcihcIm9iamVjdElkIGlzIG5vdCBzcGVjaWZpZWQuXCIpO1xuICAgICAgICBiT2JqZWN0ID0ge1xuICAgICAgICAgIF9ydHlwZTogXCJpbnRlcmZhY2VcIixcbiAgICAgICAgICBfcnRhcmdldF9pZDogdGhpcy5fY29ubmVjdGlvbi5wZWVyX2lkLFxuICAgICAgICAgIF9yaW50Zjogb2JqZWN0SWQsXG4gICAgICAgICAgX3J2YWx1ZTogYXNJbnRlcmZhY2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbWV0aG9kX3dlYWttYXAuc2V0KGFPYmplY3QsIGJPYmplY3QpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9tZXRob2Rfd2Vha21hcC5oYXMoYU9iamVjdCkpIHtcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX21ldGhvZF93ZWFrbWFwLmdldChhT2JqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNpZCA9IHRoaXMuX3N0b3JlLnB1dChhT2JqZWN0KTtcbiAgICAgICAgYk9iamVjdCA9IHtcbiAgICAgICAgICBfcnR5cGU6IFwiY2FsbGJhY2tcIixcbiAgICAgICAgICBfcnRhcmdldF9pZDogdGhpcy5fY29ubmVjdGlvbi5wZWVyX2lkLFxuICAgICAgICAgIF9ybmFtZTogKGFPYmplY3QuY29uc3RydWN0b3IgJiYgYU9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lKSB8fCBjaWQsXG4gICAgICAgICAgX3J2YWx1ZTogY2lkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYk9iamVjdDtcbiAgICB9XG5cbiAgICAvLyBza2lwIGlmIGFscmVhZHkgZW5jb2RlZFxuICAgIGlmIChhT2JqZWN0LmNvbnN0cnVjdG9yIGluc3RhbmNlb2YgT2JqZWN0ICYmIGFPYmplY3QuX3J0eXBlKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIGludGVyZmFjZSBmdW5jdGlvbnMgYXJlIGVuY29kZWRcbiAgICAgIGlmIChhT2JqZWN0Ll9yaW50Zikge1xuICAgICAgICBjb25zdCB0ZW1wID0gYU9iamVjdC5fcnR5cGU7XG4gICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll9ydHlwZTtcblxuICAgICAgICBiT2JqZWN0ID0gYXdhaXQgdGhpcy5fZW5jb2RlKGFPYmplY3QsIGFzSW50ZXJmYWNlLCBvYmplY3RJZCk7XG4gICAgICAgIGJPYmplY3QuX3J0eXBlID0gdGVtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJPYmplY3Q7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdO1xuICAgIGNvbnN0IF90cmFuc2ZlciA9IGFPYmplY3QuX3RyYW5zZmVyO1xuICAgIGNvbnN0IGlzYXJyYXkgPSBBcnJheS5pc0FycmF5KGFPYmplY3QpO1xuXG4gICAgZm9yIChsZXQgdHAgb2YgT2JqZWN0LmtleXModGhpcy5fY29kZWNzKSkge1xuICAgICAgY29uc3QgY29kZWMgPSB0aGlzLl9jb2RlY3NbdHBdO1xuICAgICAgaWYgKGNvZGVjLmVuY29kZXIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIGNvZGVjLnR5cGUpIHtcbiAgICAgICAgLy8gVE9ETzogd2hhdCBpZiBtdWx0aXBsZSBlbmNvZGVycyBmb3VuZFxuICAgICAgICBjb25zdCBlbmNvZGVkT2JqID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGNvZGVjLmVuY29kZXIoYU9iamVjdCkpO1xuICAgICAgICBpZiAoZW5jb2RlZE9iaiAmJiAhZW5jb2RlZE9iai5fcnR5cGUpIGVuY29kZWRPYmouX3J0eXBlID0gY29kZWMubmFtZTtcbiAgICAgICAgLy8gZW5jb2RlIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGludGVyZmFjZSBvYmplY3RcbiAgICAgICAgaWYgKGVuY29kZWRPYmogJiYgZW5jb2RlZE9iai5fcmludGYpIHtcbiAgICAgICAgICBjb25zdCB0ZW1wID0gZW5jb2RlZE9iai5fcnR5cGU7XG4gICAgICAgICAgZGVsZXRlIGVuY29kZWRPYmouX3J0eXBlO1xuICAgICAgICAgIGVuY29kZWRPYmogPSBhd2FpdCB0aGlzLl9lbmNvZGUoZW5jb2RlZE9iaiwgYXNJbnRlcmZhY2UsIG9iamVjdElkKTtcbiAgICAgICAgICBlbmNvZGVkT2JqLl9ydHlwZSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgYk9iamVjdCA9IGVuY29kZWRPYmo7XG4gICAgICAgIHJldHVybiBiT2JqZWN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIC8qZ2xvYmFsIHRmKi9cbiAgICAgIHR5cGVvZiB0ZiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgdGYuVGVuc29yICYmXG4gICAgICBhT2JqZWN0IGluc3RhbmNlb2YgdGYuVGVuc29yXG4gICAgKSB7XG4gICAgICBjb25zdCB2X2J1ZmZlciA9IGFPYmplY3QuZGF0YVN5bmMoKTtcbiAgICAgIGlmIChhT2JqZWN0Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHZfYnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll90cmFuc2ZlcjtcbiAgICAgIH1cbiAgICAgIGJPYmplY3QgPSB7XG4gICAgICAgIF9ydHlwZTogXCJuZGFycmF5XCIsXG4gICAgICAgIF9ydmFsdWU6IHZfYnVmZmVyLmJ1ZmZlcixcbiAgICAgICAgX3JzaGFwZTogYU9iamVjdC5zaGFwZSxcbiAgICAgICAgX3JkdHlwZTogYU9iamVjdC5kdHlwZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLypnbG9iYWwgbmoqL1xuICAgICAgdHlwZW9mIG5qICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICBuai5OZEFycmF5ICYmXG4gICAgICBhT2JqZWN0IGluc3RhbmNlb2YgbmouTmRBcnJheVxuICAgICkge1xuICAgICAgdmFyIGR0eXBlID0gdHlwZWRBcnJheVRvRHR5cGVbYU9iamVjdC5zZWxlY3Rpb24uZGF0YS5jb25zdHJ1Y3Rvci5uYW1lXTtcbiAgICAgIGlmIChhT2JqZWN0Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGFPYmplY3Quc2VsZWN0aW9uLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgZGVsZXRlIGFPYmplY3QuX3RyYW5zZmVyO1xuICAgICAgfVxuICAgICAgYk9iamVjdCA9IHtcbiAgICAgICAgX3J0eXBlOiBcIm5kYXJyYXlcIixcbiAgICAgICAgX3J2YWx1ZTogYU9iamVjdC5zZWxlY3Rpb24uZGF0YS5idWZmZXIsXG4gICAgICAgIF9yc2hhcGU6IGFPYmplY3Quc2hhcGUsXG4gICAgICAgIF9yZHR5cGU6IGR0eXBlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYU9iamVjdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGFPYmplY3QpO1xuICAgICAgYk9iamVjdCA9IHsgX3J0eXBlOiBcImVycm9yXCIsIF9ydmFsdWU6IGFPYmplY3QudG9TdHJpbmcoKSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgIGJPYmplY3QgPSB7XG4gICAgICAgIF9ydHlwZTogXCJmaWxlXCIsXG4gICAgICAgIF9ydmFsdWU6IGFPYmplY3QsXG4gICAgICAgIF9ycGF0aDogYU9iamVjdC5fcGF0aCB8fCBhT2JqZWN0LndlYmtpdFJlbGF0aXZlUGF0aFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gc2VuZCBvYmplY3RzIHN1cHBvcnRlZCBieSBzdHJ1Y3R1cmUgY2xvbmUgYWxnb3JpdGhtXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobVxuICAgIGVsc2UgaWYgKFxuICAgICAgYU9iamVjdCAhPT0gT2JqZWN0KGFPYmplY3QpIHx8XG4gICAgICBhT2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbiB8fFxuICAgICAgYU9iamVjdCBpbnN0YW5jZW9mIFN0cmluZyB8fFxuICAgICAgYU9iamVjdCBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgIGFPYmplY3QgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAgIGFPYmplY3QgaW5zdGFuY2VvZiBJbWFnZURhdGEgfHxcbiAgICAgICh0eXBlb2YgRmlsZUxpc3QgIT09IFwidW5kZWZpbmVkXCIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIEZpbGVMaXN0KVxuICAgICkge1xuICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XG4gICAgICAvLyBUT0RPOiBhdm9pZCBvYmplY3Qgc3VjaCBhcyBEeW5hbWljUGx1Z2luIGluc3RhbmNlLlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgIGJPYmplY3QgPSB7XG4gICAgICAgIF9ydHlwZTogXCJmaWxlXCIsXG4gICAgICAgIF9ybmFtZTogYU9iamVjdC5uYW1lLFxuICAgICAgICBfcm1pbWU6IGFPYmplY3QudHlwZSxcbiAgICAgICAgX3J2YWx1ZTogYU9iamVjdCxcbiAgICAgICAgX3JwYXRoOiBhT2JqZWN0Ll9wYXRoIHx8IGFPYmplY3Qud2Via2l0UmVsYXRpdmVQYXRoXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYU9iamVjdCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgIGJPYmplY3QgPSB7IF9ydHlwZTogXCJibG9iXCIsIF9ydmFsdWU6IGFPYmplY3QgfTtcbiAgICB9IGVsc2UgaWYgKGFPYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAgIGlmIChhT2JqZWN0Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGFPYmplY3QuYnVmZmVyKTtcbiAgICAgICAgZGVsZXRlIGFPYmplY3QuX3RyYW5zZmVyO1xuICAgICAgfVxuICAgICAgY29uc3QgZHR5cGUgPSB0eXBlZEFycmF5VG9EdHlwZVthT2JqZWN0LmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgICAgYk9iamVjdCA9IHtcbiAgICAgICAgX3J0eXBlOiBcInR5cGVkYXJyYXlcIixcbiAgICAgICAgX3J2YWx1ZTogYU9iamVjdC5idWZmZXIsXG4gICAgICAgIF9yZHR5cGU6IGR0eXBlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYU9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICBpZiAoYU9iamVjdC5fdHJhbnNmZXIgfHwgX3RyYW5zZmVyKSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChhT2JqZWN0LmJ1ZmZlcik7XG4gICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll90cmFuc2ZlcjtcbiAgICAgIH1cbiAgICAgIGJPYmplY3QgPSB7IF9ydHlwZTogXCJtZW1vcnl2aWV3XCIsIF9ydmFsdWU6IGFPYmplY3QuYnVmZmVyIH07XG4gICAgfSBlbHNlIGlmIChhT2JqZWN0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBiT2JqZWN0ID0ge1xuICAgICAgICBfcnR5cGU6IFwic2V0XCIsXG4gICAgICAgIF9ydmFsdWU6IGF3YWl0IHRoaXMuX2VuY29kZShBcnJheS5mcm9tKGFPYmplY3QpLCBhc0ludGVyZmFjZSlcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChhT2JqZWN0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBiT2JqZWN0ID0ge1xuICAgICAgICBfcnR5cGU6IFwib3JkZXJlZG1hcFwiLFxuICAgICAgICBfcnZhbHVlOiBhd2FpdCB0aGlzLl9lbmNvZGUoQXJyYXkuZnJvbShhT2JqZWN0KSwgYXNJbnRlcmZhY2UpXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhT2JqZWN0LmNvbnN0cnVjdG9yIGluc3RhbmNlb2YgT2JqZWN0IHx8XG4gICAgICBBcnJheS5pc0FycmF5KGFPYmplY3QpXG4gICAgKSB7XG4gICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgICBsZXQga2V5cztcbiAgICAgIC8vIGFuIG9iamVjdC9hcnJheVxuICAgICAgaWYgKGFPYmplY3QuY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCBBcnJheS5pc0FycmF5KGFPYmplY3QpKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhhT2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIC8vIGEgY2xhc3NcbiAgICAgIGVsc2UgaWYgKGFPYmplY3QuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBpbnN0YW50aWF0ZSB0aGUgY2xhc3MgYmVmb3JlIGV4cG9ydHRpbmcgaXQuXCIpO1xuICAgICAgfVxuICAgICAgLy8gaW5zdGFuY2Ugb2YgYSBjbGFzc1xuICAgICAgZWxzZSBpZiAoYU9iamVjdC5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFxuICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihhT2JqZWN0KVxuICAgICAgICApLmNvbmNhdChPYmplY3Qua2V5cyhhT2JqZWN0KSk7XG4gICAgICAgIC8vIFRPRE86IHVzZSBhIHByb3h5IG9iamVjdCB0byByZXByZXNlbnQgdGhlIGFjdHVhbCBvYmplY3RcbiAgICAgICAgLy8gYWx3YXlzIGVuY29kZSBjbGFzcyBpbnN0YW5jZSBhcyBpbnRlcmZhY2VcbiAgICAgICAgYXNJbnRlcmZhY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBpbnRlcmZhY2UgdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIC8vIGVuY29kZSBpbnRlcmZhY2VzXG4gICAgICBpZiAoYU9iamVjdC5fcmludGYgfHwgYXNJbnRlcmZhY2UpIHtcbiAgICAgICAgaWYgKCFvYmplY3RJZCkge1xuICAgICAgICAgIG9iamVjdElkID0gcmFuZElkKCk7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0X3N0b3JlW29iamVjdElkXSA9IGFPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgayBvZiBrZXlzKSB7XG4gICAgICAgICAgaWYgKGsgPT09IFwiY29uc3RydWN0b3JcIikgY29udGludWU7XG4gICAgICAgICAgaWYgKGsuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiT2JqZWN0W2tdID0gYXdhaXQgdGhpcy5fZW5jb2RlKFxuICAgICAgICAgICAgYU9iamVjdFtrXSxcbiAgICAgICAgICAgIHR5cGVvZiBhc0ludGVyZmFjZSA9PT0gXCJzdHJpbmdcIiA/IGFzSW50ZXJmYWNlICsgXCIuXCIgKyBrIDogayxcbiAgICAgICAgICAgIG9iamVjdElkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgaWQgZm9yIGRpc3Bvc2UgdGhlIG9iamVjdCByZW1vdGVseVxuICAgICAgICBiT2JqZWN0Ll9yaW50ZiA9IG9iamVjdElkO1xuICAgICAgICAvLyByZW1vdmUgaW50ZXJmYWNlIHdoZW4gY2xvc2VkXG4gICAgICAgIGlmIChhT2JqZWN0Lm9uICYmIHR5cGVvZiBhT2JqZWN0Lm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBhT2JqZWN0Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX29iamVjdF9zdG9yZVtvYmplY3RJZF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGsgb2Yga2V5cykge1xuICAgICAgICAgIGlmIChbXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdLmluY2x1ZGVzKGspKSBjb250aW51ZTtcbiAgICAgICAgICBiT2JqZWN0W2tdID0gYXdhaXQgdGhpcy5fZW5jb2RlKGFPYmplY3Rba10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBmb3IgZXhhbXBsZSwgYnJvd3NlckZTIG9iamVjdFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFPYmplY3QgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKGFPYmplY3QpXG4gICAgICApLmNvbmNhdChPYmplY3Qua2V5cyhhT2JqZWN0KSk7XG4gICAgICBjb25zdCBvYmplY3RJZCA9IHJhbmRJZCgpO1xuXG4gICAgICBmb3IgKGxldCBrIG9mIGtleXMpIHtcbiAgICAgICAgaWYgKFtcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl0uaW5jbHVkZXMoaykpIGNvbnRpbnVlO1xuICAgICAgICAvLyBlbmNvZGUgYXMgaW50ZXJmYWNlXG4gICAgICAgIGJPYmplY3Rba10gPSBhd2FpdCB0aGlzLl9lbmNvZGUoYU9iamVjdFtrXSwgaywgYk9iamVjdCk7XG4gICAgICB9XG4gICAgICAvLyBvYmplY3QgaWQsIHVzZWQgZm9yIGRpc3Bvc2UgdGhlIG9iamVjdFxuICAgICAgYk9iamVjdC5fcmludGYgPSBvYmplY3RJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJpbWpveS1ycGM6IFVuc3VwcG9ydGVkIGRhdGEgdHlwZTpcIiArIGFPYmplY3Q7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZmVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgYk9iamVjdC5fX3RyYW5zZmVyYWJsZXNfXyA9IHRyYW5zZmVyYWJsZXM7XG4gICAgfVxuICAgIGlmICghYk9iamVjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGVuY29kZSBvYmplY3RcIik7XG4gICAgfVxuICAgIHJldHVybiBiT2JqZWN0O1xuICB9XG5cbiAgYXN5bmMgX2RlY29kZShhT2JqZWN0LCB3aXRoUHJvbWlzZSkge1xuICAgIGlmICghYU9iamVjdCkge1xuICAgICAgcmV0dXJuIGFPYmplY3Q7XG4gICAgfVxuICAgIHZhciBiT2JqZWN0LCB2LCBrO1xuICAgIGlmIChhT2JqZWN0W1wiX3J0eXBlXCJdKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2NvZGVjc1thT2JqZWN0Ll9ydHlwZV0gJiZcbiAgICAgICAgdGhpcy5fY29kZWNzW2FPYmplY3QuX3J0eXBlXS5kZWNvZGVyXG4gICAgICApIHtcbiAgICAgICAgaWYgKGFPYmplY3QuX3JpbnRmKSB7XG4gICAgICAgICAgY29uc3QgdGVtcCA9IGFPYmplY3QuX3J0eXBlO1xuICAgICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll9ydHlwZTtcbiAgICAgICAgICBhT2JqZWN0ID0gYXdhaXQgdGhpcy5fZGVjb2RlKGFPYmplY3QsIHdpdGhQcm9taXNlKTtcbiAgICAgICAgICBhT2JqZWN0Ll9ydHlwZSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgYk9iamVjdCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICB0aGlzLl9jb2RlY3NbYU9iamVjdC5fcnR5cGVdLmRlY29kZXIoYU9iamVjdClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiY2FsbGJhY2tcIikge1xuICAgICAgICBiT2JqZWN0ID0gdGhpcy5fZ2VuUmVtb3RlQ2FsbGJhY2soXG4gICAgICAgICAgYU9iamVjdC5fcnRhcmdldF9pZCxcbiAgICAgICAgICBhT2JqZWN0Ll9ydmFsdWUsXG4gICAgICAgICAgd2l0aFByb21pc2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX2dlblJlbW90ZU1ldGhvZChcbiAgICAgICAgICBhT2JqZWN0Ll9ydGFyZ2V0X2lkLFxuICAgICAgICAgIGFPYmplY3QuX3J2YWx1ZSxcbiAgICAgICAgICBhT2JqZWN0Ll9yaW50ZlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJuZGFycmF5XCIpIHtcbiAgICAgICAgLypnbG9iYWwgbmogdGYqL1xuICAgICAgICAvL2NyZWF0ZSBidWlsZCBhcnJheS90ZW5zb3IgaWYgdXNlZCBpbiB0aGUgcGx1Z2luXG4gICAgICAgIGlmICh0eXBlb2YgbmogIT09IFwidW5kZWZpbmVkXCIgJiYgbmouYXJyYXkpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhT2JqZWN0Ll9ydmFsdWUpKSB7XG4gICAgICAgICAgICBhT2JqZWN0Ll9ydmFsdWUgPSBhT2JqZWN0Ll9ydmFsdWUucmVkdWNlKF9hcHBlbmRCdWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiT2JqZWN0ID0gbmpcbiAgICAgICAgICAgIC5hcnJheShuZXcgVWludDgoYU9iamVjdC5fcnZhbHVlKSwgYU9iamVjdC5fcmR0eXBlKVxuICAgICAgICAgICAgLnJlc2hhcGUoYU9iamVjdC5fcnNoYXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGYgIT09IFwidW5kZWZpbmVkXCIgJiYgdGYuVGVuc29yKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYU9iamVjdC5fcnZhbHVlKSkge1xuICAgICAgICAgICAgYU9iamVjdC5fcnZhbHVlID0gYU9iamVjdC5fcnZhbHVlLnJlZHVjZShfYXBwZW5kQnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXJyYXl0eXBlID0gZXZhbChkdHlwZVRvVHlwZWRBcnJheVthT2JqZWN0Ll9yZHR5cGVdKTtcbiAgICAgICAgICBiT2JqZWN0ID0gdGYudGVuc29yKFxuICAgICAgICAgICAgbmV3IGFycmF5dHlwZShhT2JqZWN0Ll9ydmFsdWUpLFxuICAgICAgICAgICAgYU9iamVjdC5fcnNoYXBlLFxuICAgICAgICAgICAgYU9iamVjdC5fcmR0eXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2tlZXAgaXQgYXMgcmVndWxhciBpZiB0cmFuc2ZlcmVkIHRvIHRoZSBtYWluIGFwcFxuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IG5ldyBFcnJvcihhT2JqZWN0Ll9ydmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgaWYgKGFPYmplY3QuX3J2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICBiT2JqZWN0ID0gYU9iamVjdC5fcnZhbHVlO1xuICAgICAgICAgIC8vcGF0Y2ggX3BhdGhcbiAgICAgICAgICBiT2JqZWN0Ll9wYXRoID0gYU9iamVjdC5fcnBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYk9iamVjdCA9IG5ldyBGaWxlKFthT2JqZWN0Ll9ydmFsdWVdLCBhT2JqZWN0Ll9ybmFtZSwge1xuICAgICAgICAgICAgdHlwZTogYU9iamVjdC5fcm1pbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiT2JqZWN0Ll9wYXRoID0gYU9iamVjdC5fcnBhdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwidHlwZWRhcnJheVwiKSB7XG4gICAgICAgIGNvbnN0IGFycmF5dHlwZSA9IGV2YWwoZHR5cGVUb1R5cGVkQXJyYXlbYU9iamVjdC5fcmR0eXBlXSk7XG4gICAgICAgIGlmICghYXJyYXl0eXBlKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGR0eXBlOiBcIiArIGFPYmplY3QuX3JkdHlwZSk7XG4gICAgICAgIGJPYmplY3QgPSBuZXcgYXJyYXl0eXBlKGFPYmplY3QuX3J2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcIm1lbW9yeXZpZXdcIikge1xuICAgICAgICBiT2JqZWN0ID0gbmV3IERhdGFWaWV3KGFPYmplY3QuX3J2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcImJsb2JcIikge1xuICAgICAgICBpZiAoYU9iamVjdC5fcnZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0Ll9ydmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYk9iamVjdCA9IG5ldyBCbG9iKFthT2JqZWN0Ll9ydmFsdWVdLCB7IHR5cGU6IGFPYmplY3QuX3JtaW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcIm9yZGVyZWRtYXBcIikge1xuICAgICAgICBiT2JqZWN0ID0gbmV3IE1hcChhd2FpdCB0aGlzLl9kZWNvZGUoYU9iamVjdC5fcnZhbHVlLCB3aXRoUHJvbWlzZSkpO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICBiT2JqZWN0ID0gbmV3IFNldChhd2FpdCB0aGlzLl9kZWNvZGUoYU9iamVjdC5fcnZhbHVlLCB3aXRoUHJvbWlzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaW50ZXJmYWNlIGZ1bmN0aW9ucyBhcmUgZGVjb2RlZFxuICAgICAgICBpZiAoYU9iamVjdC5fcmludGYpIHtcbiAgICAgICAgICBjb25zdCB0ZW1wID0gYU9iamVjdC5fcnR5cGU7XG4gICAgICAgICAgZGVsZXRlIGFPYmplY3QuX3J0eXBlO1xuICAgICAgICAgIGFPYmplY3QgPSBhd2FpdCB0aGlzLl9kZWNvZGUoYU9iamVjdCwgd2l0aFByb21pc2UpO1xuICAgICAgICAgIGFPYmplY3QuX3J0eXBlID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBiT2JqZWN0ID0gYU9iamVjdDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFPYmplY3QuY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCBBcnJheS5pc0FycmF5KGFPYmplY3QpKSB7XG4gICAgICB2YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkoYU9iamVjdCk7XG4gICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgICBmb3IgKGsgaW4gYU9iamVjdCkge1xuICAgICAgICBpZiAoaXNhcnJheSB8fCBhT2JqZWN0Lmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgdiA9IGFPYmplY3Rba107XG4gICAgICAgICAgYk9iamVjdFtrXSA9IGF3YWl0IHRoaXMuX2RlY29kZSh2LCB3aXRoUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XG4gICAgfVxuICAgIGlmIChiT2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgb2JqZWN0XCIpO1xuICAgIH1cbiAgICAvLyBzdG9yZSB0aGUgb2JqZWN0IGlkIGZvciBkaXNwb3NlXG4gICAgaWYgKGFPYmplY3QuX3JpbnRmKSB7XG4gICAgICB0aGlzLl9vYmplY3Rfd2Vha21hcC5zZXQoYk9iamVjdCwgYU9iamVjdC5fcmludGYpO1xuICAgIH1cbiAgICByZXR1cm4gYk9iamVjdDtcbiAgfVxuXG4gIGFzeW5jIF93cmFwKGFyZ3MsIGFzSW50ZXJmYWNlKSB7XG4gICAgdmFyIHdyYXBwZWQgPSBhd2FpdCB0aGlzLl9lbmNvZGUoYXJncywgYXNJbnRlcmZhY2UpO1xuICAgIHJldHVybiB3cmFwcGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFVud3JhcHMgdGhlIHNldCBvZiBhcmd1bWVudHMgZGVsaXZlcmVkIGZyb20gdGhlIHJlbW90ZSBzaXRlLFxuICAgKiByZXBsYWNlcyBhbGwgY2FsbGJhY2sgaWRlbnRpZmllcnMgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHdpbGxcbiAgICogaW5pdGlhdGUgc2VuZGluZyB0aGF0IGNhbGxiYWNrIGlkZW50aWZpZXIgYmFjayB0byBvdGhlciBzaXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIHRvIHVud3JhcFxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhQcm9taXNlIGlzIHRydWUgbWVhbnMgdGhpcyB0aGUgY2FsbGJhY2sgc2hvdWxkIGNvbnRhaW4gYSBwcm9taXNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdW53cmFwcGVkIGFyZ3NcbiAgICovXG4gIGFzeW5jIF91bndyYXAoYXJncywgd2l0aFByb21pc2UpIHtcbiAgICB2YXIgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVjb2RlKGFyZ3MsIHdpdGhQcm9taXNlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgd3JhcHBlZCBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIHJlbW90ZVxuICAgKiBjYWxsYmFjay4gV2hlbiB0aGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCwgaXQgd2lsbCBzZW5kXG4gICAqIHRoZSBjb3JyZXNwb25kaW5nIG1lc3NhZ2UgdG8gdGhlIHJlbW90ZSBzaXRlIGFza2luZyBpdCB0b1xuICAgKiBleGVjdXRlIHRoZSBwYXJ0aWN1bGFyIGNhbGxiYWNrIHByZXZpb3VzbHkgc2F2ZWQgZHVyaW5nIGEgY2FsbFxuICAgKiBieSB0aGUgcmVtb3RlIHNpdGUgYSBtZXRob2QgZnJvbSB0aGUgaW50ZXJmYWNlIG9mIHRoaXMgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgb2YgdGhlIHJlbW90ZSBjYWxsYmFjayB0byBleGVjdXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdOdW0gYXJndW1lbnQgaW5kZXggb2YgdGhlIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFByb21pc2UgaXMgdHJ1ZSBtZWFucyB0aGlzIHRoZSBjYWxsYmFjayBzaG91bGQgY29udGFpbiBhIHByb21pc2VcbiAgICpcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSB3cmFwcGVkIHJlbW90ZSBjYWxsYmFja1xuICAgKi9cbiAgX2dlblJlbW90ZUNhbGxiYWNrKHRhcmdldElkLCBjaWQsIHdpdGhQcm9taXNlKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcmVtb3RlQ2FsbGJhY2s7XG4gICAgaWYgKHdpdGhQcm9taXNlKSB7XG4gICAgICByZW1vdGVDYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHZhciBhcmdzID0gYXdhaXQgbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBhcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcblxuICAgICAgICAgIGNvbnN0IGVuY29kZWRQcm9taXNlID0gYXdhaXQgbWUuX3dyYXAoW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICAgIC8vIHN0b3JlIHRoZSBrZXkgaWQgZm9yIHJlbW92aW5nIHRoZW0gZnJvbSB0aGUgcmVmZXJlbmNlIHN0b3JlIHRvZ2V0aGVyXG4gICAgICAgICAgcmVzb2x2ZS5fX3Byb21pc2VfcGFpciA9IGVuY29kZWRQcm9taXNlWzFdLl9ydmFsdWU7XG4gICAgICAgICAgcmVqZWN0Ll9fcHJvbWlzZV9wYWlyID0gZW5jb2RlZFByb21pc2VbMF0uX3J2YWx1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWUuX2Nvbm5lY3Rpb24uZW1pdChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgICB0YXJnZXRfaWQ6IHRhcmdldElkLFxuICAgICAgICAgICAgICAgIGlkOiBjaWQsXG4gICAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBlbmNvZGVkUHJvbWlzZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGV4ZWN0dWUgcmVtb3RlIGNhbGxiYWNrICggaWQ6ICR7Y2lkfSkuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW90ZUNhbGxiYWNrID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXdhaXQgbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMpIGRlbGV0ZSBhcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICByZXR1cm4gbWUuX2Nvbm5lY3Rpb24uZW1pdChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImNhbGxiYWNrXCIsXG4gICAgICAgICAgICB0YXJnZXRfaWQ6IHRhcmdldElkLFxuICAgICAgICAgICAgaWQ6IGNpZCxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyYW5zZmVyYWJsZXNcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZSBhbmQgYnJlYWtzIHRoZSBjb25uZWN0aW9uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7IHR5cGU6IFwiZGlzY29ubmVjdFwiIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgfSwgMjAwMCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VTdG9yZSBpcyBhIHNwZWNpYWwgb2JqZWN0IHdoaWNoIHN0b3JlcyBvdGhlciBvYmplY3RzXG4gKiBhbmQgcHJvdmlkZXMgdGhlIHJlZmVyZW5jZXMgKG51bWJlcikgaW5zdGVhZC4gVGhpcyByZWZlcmVuY2VcbiAqIG1heSB0aGVuIGJlIHNlbnQgb3ZlciBhIGpzb24tYmFzZWQgY29tbXVuaWNhdGlvbiBjaGFubmVsIChJUENcbiAqIHRvIGFub3RoZXIgTm9kZS5qcyBwcm9jZXNzIG9yIGEgbWVzc2FnZSB0byB0aGUgV29ya2VyKS4gT3RoZXJcbiAqIHNpdGUgbWF5IHRoZW4gcHJvdmlkZSB0aGUgcmVmZXJlbmNlIGluIHRoZSByZXNwb25jZSBtZXNzYWdlXG4gKiBpbXBseWluZyB0aGUgZ2l2ZW4gb2JqZWN0IHNob3VsZCBiZSBhY3RpdmF0ZWQuXG4gKlxuICogUHJpbWFyeSB1c2FnZSBmb3IgdGhlIFJlZmVyZW5jZVN0b3JlIGlzIGEgc3RvcmFnZSBmb3IgdGhlXG4gKiBjYWxsYmFja3MsIHdoaWNoIHRoZXJlZm9yZSBtYWtlcyBpdCBwb3NzaWJsZSB0byBpbml0aWF0ZSBhXG4gKiBjYWxsYmFjayBleGVjdXRpb24gYnkgdGhlIG9wcG9zaXRlIHNpdGUgKHdoaWNoIG5vcm1hbGx5IGNhbm5vdFxuICogZGlyZWN0bHkgZXhlY3V0ZSBmdW5jdGlvbnMgb3ZlciB0aGUgY29tbXVuaWNhdGlvbiBjaGFubmVsKS5cbiAqXG4gKiBFYWNoIHN0b3JlZCBvYmplY3QgY2FuIG9ubHkgYmUgZmV0Y2hlZCBvbmNlIGFuZCBpcyBub3RcbiAqIGF2YWlsYWJsZSBmb3IgdGhlIHNlY29uZCB0aW1lLiBFYWNoIHN0b3JlZCBvYmplY3QgbXVzdCBiZVxuICogZmV0Y2hlZCwgc2luY2Ugb3RoZXJ3aXNlIGl0IHdpbGwgcmVtYWluIHN0b3JlZCBmb3JldmVyIGFuZFxuICogY29uc3VtZSBtZW1vcnkuXG4gKlxuICogU3RvcmVkIG9iamVjdCBpbmRlY2VzIGFyZSBzaW1wbHkgdGhlIG51bWJlcnMsIHdoaWNoIGFyZSBob3dldmVyXG4gKiByZWxlYXNlZCBhbG9uZyB3aXRoIHRoZSBvYmplY3RzLCBhbmQgYXJlIGxhdGVyIHJldXNlZCBhZ2FpbiAoaW5cbiAqIG9yZGVyIHRvIHBvc3Rwb25lIHRoZSBvdmVyZmxvdywgd2hpY2ggc2hvdWxkIG5vdCBsaWtlbHkgaGFwcGVuLFxuICogYnV0IGFueXdheSkuXG4gKi9cbmNsYXNzIFJlZmVyZW5jZVN0b3JlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fc3RvcmUgPSB7fTsgLy8gc3RvcmVkIG9iamVjdFxuICAgIHRoaXMuX2luZGljZXMgPSBbMF07IC8vIHNtYWxsZXN0IGF2YWlsYWJsZSBpbmRpY2VzXG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLl9idXN5SGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogY2FsbCBoYW5kbGVyIHdoZW4gdGhlIHN0b3JlIGlzIGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSB7RlVOQ1RJT059IGlkIG9mIGEgaGFuZGxlclxuICAgKi9cbiAgb25SZWFkeShyZWFkeUhhbmRsZXIpIHtcbiAgICB0aGlzLl9yZWFkeUhhbmRsZXIgPSByZWFkeUhhbmRsZXIgfHwgZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxsIGhhbmRsZXIgd2hlbiB0aGUgc3RvcmUgaXMgbm90IGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSB7RlVOQ1RJT059IGlkIG9mIGEgaGFuZGxlclxuICAgKi9cbiAgb25CdXN5KGJ1c3lIYW5kbGVyKSB7XG4gICAgdGhpcy5fYnVzeUhhbmRsZXIgPSBidXN5SGFuZGxlciB8fCBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBzdG9yZVxuICAgKlxuICAgKi9cbiAgZ2V0U3RhY2soKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3N0b3JlKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIF9nZW5JZCgpIGdlbmVyYXRlcyB0aGUgbmV3IHJlZmVyZW5jZSBpZFxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBzbWFsbGVzdCBhdmFpbGFibGUgaWQgYW5kIHJlc2VydmVzIGl0XG4gICAqL1xuICBfZ2VuSWQoKSB7XG4gICAgdmFyIGlkO1xuICAgIGlmICh0aGlzLl9pbmRpY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWQgPSB0aGlzLl9pbmRpY2VzWzBdKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gdGhpcy5faW5kaWNlcy5zaGlmdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gcmVmZXJlbmNlIGlkIHNvIHRoYXQgaXQgd2lsbCBiZSBhdmFpbGFibGUgYnlcbiAgICogYW5vdGhlciBvYmplY3Qgc3RvcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCB0byByZWxlYXNlXG4gICAqL1xuICBfcmVsZWFzZUlkKGlkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaWQgPCB0aGlzLl9pbmRpY2VzW2ldKSB7XG4gICAgICAgIHRoaXMuX2luZGljZXMuc3BsaWNlKGksIDAsIGlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2xlYW5pbmctdXAgdGhlIHNlcXVlbmNlIHRhaWxcbiAgICBmb3IgKGkgPSB0aGlzLl9pbmRpY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy5faW5kaWNlc1tpXSAtIDEgPT09IHRoaXMuX2luZGljZXNbaSAtIDFdKSB7XG4gICAgICAgIHRoaXMuX2luZGljZXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiBvYmplY3QgYW5kIHJldHVybnMgdGhlIHJlZmVybmNlIGlkIGluc3RlYWRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0byBzdG9yZVxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSByZWZlcmVuY2UgaWQgb2YgdGhlIHN0b3JlZCBvYmplY3RcbiAgICovXG4gIHB1dChvYmopIHtcbiAgICBpZiAodGhpcy5fYnVzeUhhbmRsZXIgJiYgT2JqZWN0LmtleXModGhpcy5fc3RvcmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fYnVzeUhhbmRsZXIoKTtcbiAgICB9XG4gICAgdmFyIGlkID0gdGhpcy5fZ2VuSWQoKTtcbiAgICB0aGlzLl9zdG9yZVtpZF0gPSBvYmo7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBwcmV2aW91c2x5IHN0b3JlZCBvYmplY3QgYW5kIHJlbGVhc2VzIGl0cyByZWZlcmVuY2VcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIG9mIGFuIG9iamVjdCB0byByZXRyaWV2ZVxuICAgKi9cbiAgZmV0Y2goaWQpIHtcbiAgICB2YXIgb2JqID0gdGhpcy5fc3RvcmVbaWRdO1xuICAgIGlmIChvYmogJiYgIW9iai5fX3JlbW90ZV9tZXRob2QpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtpZF07XG4gICAgICB0aGlzLl9yZWxlYXNlSWQoaWQpO1xuICAgICAgaWYgKHRoaXMuX3JlYWR5SGFuZGxlciAmJiBPYmplY3Qua2V5cyh0aGlzLl9zdG9yZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5SGFuZGxlcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqICYmIG9iai5fX3Byb21pc2VfcGFpcikge1xuICAgICAgdGhpcy5mZXRjaChvYmouX19wcm9taXNlX3BhaXIpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQU9BO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBVUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBUkE7QUFrQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdDBCQTtBQXcwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTlHQSIsInNvdXJjZVJvb3QiOiIifQ==\\\\n//# sourceURL=webpack-internal:///./src/rpc.js\\\\n\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/utils.js\\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"randId\\\\\\\", function() { return randId; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"dtypeToTypedArray\\\\\\\", function() { return dtypeToTypedArray; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"typedArrayToDtype\\\\\\\", function() { return typedArrayToDtype; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"cacheRequirements\\\\\\\", function() { return cacheRequirements; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"setupServiceWorker\\\\\\\", function() { return setupServiceWorker; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"urlJoin\\\\\\\", function() { return urlJoin; });\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"MessageEmitter\\\\\\\", function() { return MessageEmitter; });\\\\nfunction randId() {\\\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\\\n}\\\\nconst dtypeToTypedArray = {\\\\n  int8: \\\\\\\"Int8Array\\\\\\\",\\\\n  int16: \\\\\\\"Int16Array\\\\\\\",\\\\n  int32: \\\\\\\"Int32Array\\\\\\\",\\\\n  uint8: \\\\\\\"Uint8Array\\\\\\\",\\\\n  uint16: \\\\\\\"Uint16Array\\\\\\\",\\\\n  uint32: \\\\\\\"Uint32Array\\\\\\\",\\\\n  float32: \\\\\\\"Float32Array\\\\\\\",\\\\n  float64: \\\\\\\"Float64Array\\\\\\\",\\\\n  array: \\\\\\\"Array\\\\\\\"\\\\n};\\\\nconst typedArrayToDtype = {\\\\n  Int8Array: \\\\\\\"int8\\\\\\\",\\\\n  Int16Array: \\\\\\\"int16\\\\\\\",\\\\n  Int32Array: \\\\\\\"int32\\\\\\\",\\\\n  Uint8Array: \\\\\\\"uint8\\\\\\\",\\\\n  Uint16Array: \\\\\\\"uint16\\\\\\\",\\\\n  Uint32Array: \\\\\\\"uint32\\\\\\\",\\\\n  Float32Array: \\\\\\\"float32\\\\\\\",\\\\n  Float64Array: \\\\\\\"float64\\\\\\\",\\\\n  Array: \\\\\\\"array\\\\\\\"\\\\n};\\\\n\\\\nfunction cacheUrlInServiceWorker(url) {\\\\n  return new Promise(function (resolve, reject) {\\\\n    const message = {\\\\n      command: \\\\\\\"add\\\\\\\",\\\\n      url: url\\\\n    };\\\\n\\\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\\\n      reject(\\\\\\\"Service worker is not supported.\\\\\\\");\\\\n      return;\\\\n    }\\\\n\\\\n    const messageChannel = new MessageChannel();\\\\n\\\\n    messageChannel.port1.onmessage = function (event) {\\\\n      if (event.data && event.data.error) {\\\\n        reject(event.data.error);\\\\n      } else {\\\\n        resolve(event.data && event.data.result);\\\\n      }\\\\n    };\\\\n\\\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\\\n    } else {\\\\n      reject(\\\\\\\"Service worker controller is not available\\\\\\\");\\\\n    }\\\\n  });\\\\n}\\\\n\\\\nasync function cacheRequirements(requirements) {\\\\n  if (!Array.isArray(requirements)) {\\\\n    requirementsm.code.requirements = [requirements];\\\\n  }\\\\n\\\\n  if (requirements && requirements.length > 0) {\\\\n    for (let req of requirements) {\\\\n      //remove prefix\\\\n      if (req.startsWith(\\\\\\\"js:\\\\\\\")) req = req.slice(3);\\\\n      if (req.startsWith(\\\\\\\"css:\\\\\\\")) req = req.slice(4);\\\\n      if (req.startsWith(\\\\\\\"cache:\\\\\\\")) req = req.slice(6);\\\\n      if (!req.startsWith(\\\\\\\"http\\\\\\\")) continue;\\\\n      await cacheUrlInServiceWorker(req).catch(e => {\\\\n        console.error(e);\\\\n      });\\\\n    }\\\\n  }\\\\n}\\\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\\\n  // register service worker for offline access\\\\n  if (\\\\\\\"serviceWorker\\\\\\\" in navigator) {\\\\n    baseUrl = baseUrl || \\\\\\\"/\\\\\\\";\\\\n    navigator.serviceWorker.register(baseUrl + \\\\\\\"plugin-service-worker.js\\\\\\\").then(function (registration) {\\\\n      // Registration was successful\\\\n      console.log(\\\\\\\"ServiceWorker registration successful with scope: \\\\\\\", registration.scope);\\\\n    }, function (err) {\\\\n      // registration failed :(\\\\n      console.log(\\\\\\\"ServiceWorker registration failed: \\\\\\\", err);\\\\n    });\\\\n    targetOrigin = targetOrigin || \\\\\\\"*\\\\\\\";\\\\n    cacheCallback = cacheCallback || cacheRequirements;\\\\n\\\\n    if (cacheCallback && typeof cacheCallback !== \\\\\\\"function\\\\\\\") {\\\\n      throw new Error(\\\\\\\"config.cache_requirements must be a function\\\\\\\");\\\\n    }\\\\n\\\\n    window.addEventListener(\\\\\\\"message\\\\\\\", function (e) {\\\\n      if (targetOrigin === \\\\\\\"*\\\\\\\" || e.origin === targetOrigin) {\\\\n        const m = e.data;\\\\n\\\\n        if (m.type === \\\\\\\"cacheRequirements\\\\\\\") {\\\\n          cacheCallback(m.requirements);\\\\n        }\\\\n      }\\\\n    });\\\\n  }\\\\n} //#Source https://bit.ly/2neWfJ2\\\\n\\\\nfunction urlJoin(...args) {\\\\n  return args.join(\\\\\\\"/\\\\\\\").replace(/[\\\\\\\\/]+/g, \\\\\\\"/\\\\\\\").replace(/^(.+):\\\\\\\\//, \\\\\\\"$1://\\\\\\\").replace(/^file:/, \\\\\\\"file:/\\\\\\\").replace(/\\\\\\\\/(\\\\\\\\?|&|#[^!])/g, \\\\\\\"$1\\\\\\\").replace(/\\\\\\\\?/g, \\\\\\\"&\\\\\\\").replace(\\\\\\\"&\\\\\\\", \\\\\\\"?\\\\\\\");\\\\n}\\\\nclass MessageEmitter {\\\\n  constructor(debug) {\\\\n    this._event_handlers = {};\\\\n    this._once_handlers = {};\\\\n    this._debug = debug;\\\\n  }\\\\n\\\\n  emit() {\\\\n    throw new Error(\\\\\\\"emit is not implemented\\\\\\\");\\\\n  }\\\\n\\\\n  on(event, handler) {\\\\n    if (!this._event_handlers[event]) {\\\\n      this._event_handlers[event] = [];\\\\n    }\\\\n\\\\n    this._event_handlers[event].push(handler);\\\\n  }\\\\n\\\\n  once(event, handler) {\\\\n    handler.___event_run_once = true;\\\\n    this.on(event, handler);\\\\n  }\\\\n\\\\n  off(event, handler) {\\\\n    if (!event && !handler) {\\\\n      // remove all events handlers\\\\n      this._event_handlers = {};\\\\n    } else if (event && !handler) {\\\\n      // remove all hanlders for the event\\\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\\\n    } else {\\\\n      // remove a specific handler\\\\n      if (this._event_handlers[event]) {\\\\n        const idx = this._event_handlers[event].indexOf(handler);\\\\n\\\\n        if (idx >= 0) {\\\\n          this._event_handlers[event].splice(idx, 1);\\\\n        }\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n  _fire(event, data) {\\\\n    if (this._event_handlers[event]) {\\\\n      var i = this._event_handlers[event].length;\\\\n\\\\n      while (i--) {\\\\n        const handler = this._event_handlers[event][i];\\\\n\\\\n        try {\\\\n          handler(data);\\\\n        } catch (e) {\\\\n          console.error(e);\\\\n        } finally {\\\\n          if (handler.___event_run_once) {\\\\n            this._event_handlers[event].splice(i, 1);\\\\n          }\\\\n        }\\\\n      }\\\\n    } else {\\\\n      if (this._debug) {\\\\n        console.warn(\\\\\\\"unhandled event\\\\\\\", event, data);\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n}//# sourceURL=[module]\\\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWpveVJQQy8uL3NyYy91dGlscy5qcz8wMjVlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiByYW5kSWQoKSB7XG4gIHJldHVybiAoXG4gICAgTWF0aC5yYW5kb20oKVxuICAgICAgLnRvU3RyaW5nKDM2KVxuICAgICAgLnN1YnN0cigyLCAxMCkgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICApO1xufVxuXG5leHBvcnQgY29uc3QgZHR5cGVUb1R5cGVkQXJyYXkgPSB7XG4gIGludDg6IFwiSW50OEFycmF5XCIsXG4gIGludDE2OiBcIkludDE2QXJyYXlcIixcbiAgaW50MzI6IFwiSW50MzJBcnJheVwiLFxuICB1aW50ODogXCJVaW50OEFycmF5XCIsXG4gIHVpbnQxNjogXCJVaW50MTZBcnJheVwiLFxuICB1aW50MzI6IFwiVWludDMyQXJyYXlcIixcbiAgZmxvYXQzMjogXCJGbG9hdDMyQXJyYXlcIixcbiAgZmxvYXQ2NDogXCJGbG9hdDY0QXJyYXlcIixcbiAgYXJyYXk6IFwiQXJyYXlcIlxufTtcbmV4cG9ydCBjb25zdCB0eXBlZEFycmF5VG9EdHlwZSA9IHtcbiAgSW50OEFycmF5OiBcImludDhcIixcbiAgSW50MTZBcnJheTogXCJpbnQxNlwiLFxuICBJbnQzMkFycmF5OiBcImludDMyXCIsXG4gIFVpbnQ4QXJyYXk6IFwidWludDhcIixcbiAgVWludDE2QXJyYXk6IFwidWludDE2XCIsXG4gIFVpbnQzMkFycmF5OiBcInVpbnQzMlwiLFxuICBGbG9hdDMyQXJyYXk6IFwiZmxvYXQzMlwiLFxuICBGbG9hdDY0QXJyYXk6IFwiZmxvYXQ2NFwiLFxuICBBcnJheTogXCJhcnJheVwiXG59O1xuXG5mdW5jdGlvbiBjYWNoZVVybEluU2VydmljZVdvcmtlcih1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICBjb21tYW5kOiBcImFkZFwiLFxuICAgICAgdXJsOiB1cmxcbiAgICB9O1xuICAgIGlmICghbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgfHwgIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKSB7XG4gICAgICByZWplY3QoXCJTZXJ2aWNlIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lcnJvcikge1xuICAgICAgICByZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlci5wb3N0TWVzc2FnZShtZXNzYWdlLCBbXG4gICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQyXG4gICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KFwiU2VydmljZSB3b3JrZXIgY29udHJvbGxlciBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWNoZVJlcXVpcmVtZW50cyhyZXF1aXJlbWVudHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlcXVpcmVtZW50cykpIHtcbiAgICByZXF1aXJlbWVudHNtLmNvZGUucmVxdWlyZW1lbnRzID0gW3JlcXVpcmVtZW50c107XG4gIH1cbiAgaWYgKHJlcXVpcmVtZW50cyAmJiByZXF1aXJlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAobGV0IHJlcSBvZiByZXF1aXJlbWVudHMpIHtcbiAgICAgIC8vcmVtb3ZlIHByZWZpeFxuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFwianM6XCIpKSByZXEgPSByZXEuc2xpY2UoMyk7XG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXCJjc3M6XCIpKSByZXEgPSByZXEuc2xpY2UoNCk7XG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXCJjYWNoZTpcIikpIHJlcSA9IHJlcS5zbGljZSg2KTtcbiAgICAgIGlmICghcmVxLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSBjb250aW51ZTtcblxuICAgICAgYXdhaXQgY2FjaGVVcmxJblNlcnZpY2VXb3JrZXIocmVxKS5jYXRjaChlID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTZXJ2aWNlV29ya2VyKGJhc2VVcmwsIHRhcmdldE9yaWdpbiwgY2FjaGVDYWxsYmFjaykge1xuICAvLyByZWdpc3RlciBzZXJ2aWNlIHdvcmtlciBmb3Igb2ZmbGluZSBhY2Nlc3NcbiAgaWYgKFwic2VydmljZVdvcmtlclwiIGluIG5hdmlnYXRvcikge1xuICAgIGJhc2VVcmwgPSBiYXNlVXJsIHx8IFwiL1wiO1xuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKGJhc2VVcmwgKyBcInBsdWdpbi1zZXJ2aWNlLXdvcmtlci5qc1wiKS50aGVuKFxuICAgICAgZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIC8vIFJlZ2lzdHJhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwgd2l0aCBzY29wZTogXCIsXG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnNjb3BlXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIHJlZ2lzdHJhdGlvbiBmYWlsZWQgOihcbiAgICAgICAgY29uc29sZS5sb2coXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQ6IFwiLCBlcnIpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGFyZ2V0T3JpZ2luID0gdGFyZ2V0T3JpZ2luIHx8IFwiKlwiO1xuICAgIGNhY2hlQ2FsbGJhY2sgPSBjYWNoZUNhbGxiYWNrIHx8IGNhY2hlUmVxdWlyZW1lbnRzO1xuICAgIGlmIChjYWNoZUNhbGxiYWNrICYmIHR5cGVvZiBjYWNoZUNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmZpZy5jYWNoZV9yZXF1aXJlbWVudHMgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRhcmdldE9yaWdpbiA9PT0gXCIqXCIgfHwgZS5vcmlnaW4gPT09IHRhcmdldE9yaWdpbikge1xuICAgICAgICBjb25zdCBtID0gZS5kYXRhO1xuICAgICAgICBpZiAobS50eXBlID09PSBcImNhY2hlUmVxdWlyZW1lbnRzXCIpIHtcbiAgICAgICAgICBjYWNoZUNhbGxiYWNrKG0ucmVxdWlyZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8vI1NvdXJjZSBodHRwczovL2JpdC5seS8ybmVXZkoyXG5leHBvcnQgZnVuY3Rpb24gdXJsSm9pbiguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzXG4gICAgLmpvaW4oXCIvXCIpXG4gICAgLnJlcGxhY2UoL1tcXC9dKy9nLCBcIi9cIilcbiAgICAucmVwbGFjZSgvXiguKyk6XFwvLywgXCIkMTovL1wiKVxuICAgIC5yZXBsYWNlKC9eZmlsZTovLCBcImZpbGU6L1wiKVxuICAgIC5yZXBsYWNlKC9cXC8oXFw/fCZ8I1teIV0pL2csIFwiJDFcIilcbiAgICAucmVwbGFjZSgvXFw/L2csIFwiJlwiKVxuICAgIC5yZXBsYWNlKFwiJlwiLCBcIj9cIik7XG59XG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlRW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGRlYnVnKSB7XG4gICAgdGhpcy5fZXZlbnRfaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLl9vbmNlX2hhbmRsZXJzID0ge307XG4gICAgdGhpcy5fZGVidWcgPSBkZWJ1ZztcbiAgfVxuICBlbWl0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImVtaXQgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIG9uKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0pIHtcbiAgICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgfVxuICBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaGFuZGxlci5fX19ldmVudF9ydW5fb25jZSA9IHRydWU7XG4gICAgdGhpcy5vbihldmVudCwgaGFuZGxlcik7XG4gIH1cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKCFldmVudCAmJiAhaGFuZGxlcikge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudHMgaGFuZGxlcnNcbiAgICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzID0ge307XG4gICAgfSBlbHNlIGlmIChldmVudCAmJiAhaGFuZGxlcikge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBoYW5sZGVycyBmb3IgdGhlIGV2ZW50XG4gICAgICBpZiAodGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdKSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGEgc3BlY2lmaWMgaGFuZGxlclxuICAgICAgaWYgKHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0uaW5kZXhPZihoYW5kbGVyKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9maXJlKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdW2ldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoYW5kbGVyLl9fX2V2ZW50X3J1bl9vbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidW5oYW5kbGVkIGV2ZW50XCIsIGV2ZW50LCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpEQSIsInNvdXJjZVJvb3QiOiIifQ==\\\\n//# sourceURL=webpack-internal:///./src/utils.js\\\\n\\\");\\n\\n/***/ })\\n\\n/******/ });\", null);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luLndlYndvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanM/ZTdlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcmVxdWlyZShcIiEhL1VzZXJzL3dlaS5vdXlhbmcvd29ya3NwYWNlL2ltam95LXJwYy9qYXZhc2NyaXB0L25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3Qvd29ya2Vycy9JbmxpbmVXb3JrZXIuanNcIikoXCIvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0XFx0fVxcbi8qKioqKiovIFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuLyoqKioqKi8gXFx0XFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdGk6IG1vZHVsZUlkLFxcbi8qKioqKiovIFxcdFxcdFxcdGw6IGZhbHNlLFxcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9XFxuLyoqKioqKi8gXFx0XFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdFxcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbi8qKioqKiovIFxcdFxcdG1vZHVsZS5sID0gdHJ1ZTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG4vKioqKioqL1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xcbi8qKioqKiovIFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xcbi8qKioqKiovIFxcdFxcdH1cXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcXG4vKioqKioqLyBcXHRcXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcXG4vKioqKioqLyBcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcXG4vKioqKioqLyBcXHRcXHR9XFxuLyoqKioqKi8gXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcXG4vKioqKioqLyBcXHRcXHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xcbi8qKioqKiovIFxcdFxcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcXG4vKioqKioqLyBcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBucztcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcXG4vKioqKioqLyBcXHRcXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cXG4vKioqKioqLyBcXHRcXHRcXHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxcbi8qKioqKiovIFxcdFxcdFxcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBnZXR0ZXI7XFxuLyoqKioqKi8gXFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXFxcIlxcXCI7XFxuLyoqKioqKi9cXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xcbi8qKioqKiovIFxcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFxcXCIuL3NyYy9wbHVnaW4ud2Vid29ya2VyLmpzXFxcIik7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovICh7XFxuXFxuLyoqKi8gXFxcIi4vc3JjL3BsdWdpbi53ZWJ3b3JrZXIuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy9wbHVnaW4ud2Vid29ya2VyLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbmV2YWwoXFxcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luQ29yZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wbHVnaW5Db3JlLmpzICovIFxcXFxcXFwiLi9zcmMvcGx1Z2luQ29yZS5qc1xcXFxcXFwiKTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcnBjX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JwYy5qcyAqLyBcXFxcXFxcIi4vc3JjL3JwYy5qc1xcXFxcXFwiKTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMuanMgKi8gXFxcXFxcXCIuL3NyYy91dGlscy5qc1xcXFxcXFwiKTtcXFxcbi8qKlxcXFxuICogQ29udGFpbnMgdGhlIHJvdXRpbmVzIGxvYWRlZCBieSB0aGUgcGx1Z2luIFdvcmtlciB1bmRlciB3ZWItYnJvd3Nlci5cXFxcbiAqXFxcXG4gKiBJbml0aWFsaXplcyB0aGUgd2ViIGVudmlyb25tZW50IHZlcnNpb24gb2YgdGhlIHBsYXRmb3JtLWRlcGVuZGVudFxcXFxuICogY29ubmVjdGlvbiBvYmplY3QgZm9yIHRoZSBwbHVnaW4gc2l0ZVxcXFxuICovXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcbihmdW5jdGlvbigpIHtcXFxcbiAgLy8gbWFrZSBzdXJlIHRoaXMgcnVucyBpbnNpZGUgYSB3ZWJ3b3JrZXJcXFxcbiAgaWYgKFxcXFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiB8fFxcXFxuICAgICFzZWxmIHx8XFxcXG4gICAgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpXFxcXG4gICkge1xcXFxuICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIlRoaXMgc2NyaXB0IGNhbiBvbmx5IGxvYWRlZCBpbiBhIHdlYndvcmtlclxcXFxcXFwiKTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogQ29ubmVjdGlvbiBvYmplY3QgcHJvdmlkZWQgdG8gdGhlIFJQQyBjb25zdHJ1Y3RvcixcXFxcbiAgICogcGx1Z2luIHNpdGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSB3ZWItYmFzZWQgZW52aXJvbm1lbnQuXFxcXG4gICAqIEdsb2JhbCB3aWxsIGJlIHRoZW4gY2xlYXJlZCB0byBwcmV2ZW50IGV4cG9zdXJlIGludG8gdGhlXFxcXG4gICAqIFdvcmtlciwgc28gd2UgcHV0IHRoaXMgbG9jYWwgY29ubmVjdGlvbiBvYmplY3QgaW50byBhIGNsb3N1cmVcXFxcbiAgICovXFxcXG4gIGNsYXNzIENvbm5lY3Rpb24gZXh0ZW5kcyBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFxcXFxcIk1lc3NhZ2VFbWl0dGVyXFxcXFxcXCJdIHtcXFxcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcXFxcbiAgICAgIHN1cGVyKGNvbmZpZyAmJiBjb25maWcuZGVidWcpO1xcXFxuICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XFxcXG4gICAgfVxcXFxuICAgIGNvbm5lY3QoKSB7XFxcXG4gICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXFxcXFxcXCJtZXNzYWdlXFxcXFxcXCIsIGUgPT4ge1xcXFxuICAgICAgICB0aGlzLl9maXJlKGUuZGF0YS50eXBlLCBlLmRhdGEpO1xcXFxuICAgICAgfSk7XFxcXG4gICAgICB0aGlzLmVtaXQoe1xcXFxuICAgICAgICB0eXBlOiBcXFxcXFxcImluaXRpYWxpemVkXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdcXFxcbiAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBkaXNjb25uZWN0KCkge1xcXFxuICAgICAgdGhpcy5fZmlyZShcXFxcXFxcImJlZm9yZURpc2Nvbm5lY3RcXFxcXFxcIik7XFxcXG4gICAgICBzZWxmLmNsb3NlKCk7XFxcXG4gICAgICB0aGlzLl9maXJlKFxcXFxcXFwiZGlzY29ubmVjdGVkXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgICBlbWl0KGRhdGEpIHtcXFxcbiAgICAgIGxldCB0cmFuc2ZlcmFibGVzID0gdW5kZWZpbmVkO1xcXFxuICAgICAgaWYgKGRhdGEuX190cmFuc2ZlcmFibGVzX18pIHtcXFxcbiAgICAgICAgdHJhbnNmZXJhYmxlcyA9IGRhdGEuX190cmFuc2ZlcmFibGVzX187XFxcXG4gICAgICAgIGRlbGV0ZSBkYXRhLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgfVxcXFxuICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2ZlcmFibGVzKTtcXFxcbiAgICB9XFxcXG4gICAgYXN5bmMgZXhlY3V0ZShjb2RlKSB7XFxcXG4gICAgICBpZiAoY29kZS50eXBlID09PSBcXFxcXFxcInJlcXVpcmVtZW50c1xcXFxcXFwiKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgaWYgKFxcXFxuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgJiZcXFxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSB8fFxcXFxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFxcXFxcXFwic3RyaW5nXFxcXFxcXCIpXFxcXG4gICAgICAgICAgKSB7XFxcXG4gICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XFxcXG4gICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgPSBbY29kZS5yZXF1aXJlbWVudHNdO1xcXFxuICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZS5yZXF1aXJlbWVudHMubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBpZiAoXFxcXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFxcXFxcXFwiLmNzc1xcXFxcXFwiKSB8fFxcXFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcXFxcXFxcImNzczpcXFxcXFxcIilcXFxcbiAgICAgICAgICAgICAgICApIHtcXFxcbiAgICAgICAgICAgICAgICAgIHRocm93IFxcXFxcXFwidW5hYmxlIHRvIGltcG9ydCBjc3MgaW4gYSB3ZWJ3b3JrZXJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxcXFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcXFxcXFxcIi5qc1xcXFxcXFwiKSB8fFxcXFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcXFxcXFxcImpzOlxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgICkge1xcXFxuICAgICAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXFxcXFxcXCJqczpcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0gPSBjb2RlLnJlcXVpcmVtZW50c1tpXS5zbGljZSgzKTtcXFxcbiAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcXFxcXFxcImNhY2hlOlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgICAgLy9pZ25vcmUgY2FjaGVcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiVW5wcm9jZXNzZWQgcmVxdWlyZW1lbnRzIHVybDogXFxcXFxcXCIgKyBjb2RlLnJlcXVpcmVtZW50c1tpXVxcXFxuICAgICAgICAgICAgICAgICAgKTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgdGhyb3cgXFxcXFxcXCJmYWlsZWQgdG8gaW1wb3J0IHJlcXVpcmVkIHNjcmlwdHM6IFxcXFxcXFwiICtcXFxcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cy50b1N0cmluZygpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH0gZWxzZSBpZiAoY29kZS50eXBlID09PSBcXFxcXFxcInNjcmlwdFxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgaWYgKFxcXFxuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgJiZcXFxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNvZGUucmVxdWlyZW1lbnRzKSB8fFxcXFxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFxcXFxcXFwic3RyaW5nXFxcXFxcXCIpXFxcXG4gICAgICAgICAgKSB7XFxcXG4gICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2RlLnJlcXVpcmVtZW50cykpIHtcXFxcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUucmVxdWlyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgICBpbXBvcnRTY3JpcHRzKGNvZGUucmVxdWlyZW1lbnRzW2ldKTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50cyk7XFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgdGhyb3cgXFxcXFxcXCJmYWlsZWQgdG8gaW1wb3J0IHJlcXVpcmVkIHNjcmlwdHM6IFxcXFxcXFwiICtcXFxcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50cy50b1N0cmluZygpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBldmFsKGNvZGUuY29udGVudCk7XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSwgZS5zdGFjayk7XFxcXG4gICAgICAgICAgdGhyb3cgZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdGhyb3cgXFxcXFxcXCJ1bnN1cHBvcnRlZCBjb2RlIHR5cGUuXFxcXFxcXCI7XFxcXG4gICAgICB9XFxcXG4gICAgICBpZiAoY29kZS50eXBlID09PSBcXFxcXFxcInJlcXVpcmVtZW50c1xcXFxcXFwiKSB7XFxcXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xcXFxuICAgICAgICAgIHR5cGU6IFxcXFxcXFwiY2FjaGVSZXF1aXJlbWVudHNcXFxcXFxcIixcXFxcbiAgICAgICAgICByZXF1aXJlbWVudHM6IGNvZGUucmVxdWlyZW1lbnRzXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcbiAgfVxcXFxuICBjb25zdCBjb25maWcgPSB7XFxcXG4gICAgdHlwZTogXFxcXFxcXCJ3ZWItd29ya2VyXFxcXFxcXCIsXFxcXG4gICAgZGVkaWNhdGVkX3RocmVhZDogdHJ1ZSxcXFxcbiAgICBhbGxvd19leGVjdXRpb246IHRydWUsXFxcXG4gICAgbGFuZzogXFxcXFxcXCJqYXZhc2NyaXB0XFxcXFxcXCIsXFxcXG4gICAgYXBpX3ZlcnNpb246IF9ycGNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFxcXFxcIkFQSV9WRVJTSU9OXFxcXFxcXCJdXFxcXG4gIH07XFxcXG4gIGNvbnN0IGNvbm4gPSBuZXcgQ29ubmVjdGlvbihjb25maWcpO1xcXFxuICBjb25uLm9uKFxcXFxcXFwiY29ubmVjdFJQQ1xcXFxcXFwiLCBkYXRhID0+IHtcXFxcbiAgICBPYmplY3QoX3BsdWdpbkNvcmVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcImNvbm5lY3RSUENcXFxcXFxcIl0pKGNvbm4sIE9iamVjdC5hc3NpZ24oZGF0YS5jb25maWcsIGNvbmZpZykpO1xcXFxuICB9KTtcXFxcbiAgY29ubi5jb25uZWN0KCk7XFxcXG4gIHNlbGYucG9zdE1lc3NhZ2Uoe1xcXFxuICAgIHR5cGU6IFxcXFxcXFwid29ya2VyLXJlYWR5XFxcXFxcXCJcXFxcbiAgfSk7XFxcXG59KSgpO1xcXFxuLy8jIHNvdXJjZVVSTD1bbW9kdWxlXVxcXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lMaTl6Y21NdmNHeDFaMmx1TG5kbFluZHZjbXRsY2k1cWN5NXFjeUlzSW5OdmRYSmpaWE1pT2xzaWQyVmljR0ZqYXpvdkwybHRhbTk1VWxCREx5NHZjM0pqTDNCc2RXZHBiaTUzWldKM2IzSnJaWEl1YW5NL09HTTFOQ0pkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJdktpcGNiaUFxSUVOdmJuUmhhVzV6SUhSb1pTQnliM1YwYVc1bGN5QnNiMkZrWldRZ1lua2dkR2hsSUhCc2RXZHBiaUJYYjNKclpYSWdkVzVrWlhJZ2QyVmlMV0p5YjNkelpYSXVYRzRnS2x4dUlDb2dTVzVwZEdsaGJHbDZaWE1nZEdobElIZGxZaUJsYm5acGNtOXViV1Z1ZENCMlpYSnphVzl1SUc5bUlIUm9aU0J3YkdGMFptOXliUzFrWlhCbGJtUmxiblJjYmlBcUlHTnZibTVsWTNScGIyNGdiMkpxWldOMElHWnZjaUIwYUdVZ2NHeDFaMmx1SUhOcGRHVmNiaUFxTDF4dWFXMXdiM0owSUhzZ1kyOXVibVZqZEZKUVF5QjlJR1p5YjIwZ1hDSXVMM0JzZFdkcGJrTnZjbVV1YW5OY0lqdGNibWx0Y0c5eWRDQjdJRUZRU1Y5V1JWSlRTVTlPSUgwZ1puSnZiU0JjSWk0dmNuQmpMbXB6WENJN1hHNXBiWEJ2Y25RZ2V5Qk5aWE56WVdkbFJXMXBkSFJsY2l3Z2NtRnVaRWxrSUgwZ1puSnZiU0JjSWk0dmRYUnBiSE11YW5OY0lqdGNibHh1S0daMWJtTjBhVzl1S0NrZ2UxeHVJQ0F2THlCdFlXdGxJSE4xY21VZ2RHaHBjeUJ5ZFc1eklHbHVjMmxrWlNCaElIZGxZbmR2Y210bGNseHVJQ0JwWmlBb1hHNGdJQ0FnZEhsd1pXOW1JRmR2Y210bGNrZHNiMkpoYkZOamIzQmxJRDA5UFNCY0luVnVaR1ZtYVc1bFpGd2lJSHg4WEc0Z0lDQWdJWE5sYkdZZ2ZIeGNiaUFnSUNBaEtITmxiR1lnYVc1emRHRnVZMlZ2WmlCWGIzSnJaWEpIYkc5aVlXeFRZMjl3WlNsY2JpQWdLU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtGd2lWR2hwY3lCelkzSnBjSFFnWTJGdUlHOXViSGtnYkc5aFpHVmtJR2x1SUdFZ2QyVmlkMjl5YTJWeVhDSXBPMXh1SUNCOVhHNGdJQzhxS2x4dUlDQWdLaUJEYjI1dVpXTjBhVzl1SUc5aWFtVmpkQ0J3Y205MmFXUmxaQ0IwYnlCMGFHVWdVbEJESUdOdmJuTjBjblZqZEc5eUxGeHVJQ0FnS2lCd2JIVm5hVzRnYzJsMFpTQnBiWEJzWlcxbGJuUmhkR2x2YmlCbWIzSWdkR2hsSUhkbFlpMWlZWE5sWkNCbGJuWnBjbTl1YldWdWRDNWNiaUFnSUNvZ1IyeHZZbUZzSUhkcGJHd2dZbVVnZEdobGJpQmpiR1ZoY21Wa0lIUnZJSEJ5WlhabGJuUWdaWGh3YjNOMWNtVWdhVzUwYnlCMGFHVmNiaUFnSUNvZ1YyOXlhMlZ5TENCemJ5QjNaU0J3ZFhRZ2RHaHBjeUJzYjJOaGJDQmpiMjV1WldOMGFXOXVJRzlpYW1WamRDQnBiblJ2SUdFZ1kyeHZjM1Z5WlZ4dUlDQWdLaTljYmlBZ1kyeGhjM01nUTI5dWJtVmpkR2x2YmlCbGVIUmxibVJ6SUUxbGMzTmhaMlZGYldsMGRHVnlJSHRjYmlBZ0lDQmpiMjV6ZEhKMVkzUnZjaWhqYjI1bWFXY3BJSHRjYmlBZ0lDQWdJSE4xY0dWeUtHTnZibVpwWnlBbUppQmpiMjVtYVdjdVpHVmlkV2NwTzF4dUlDQWdJQ0FnZEdocGN5NWpiMjVtYVdjZ1BTQmpiMjVtYVdjZ2ZId2dlMzA3WEc0Z0lDQWdmVnh1SUNBZ0lHTnZibTVsWTNRb0tTQjdYRzRnSUNBZ0lDQnpaV3htTG1Ga1pFVjJaVzUwVEdsemRHVnVaWElvWENKdFpYTnpZV2RsWENJc0lHVWdQVDRnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbDltYVhKbEtHVXVaR0YwWVM1MGVYQmxMQ0JsTG1SaGRHRXBPMXh1SUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0IwYUdsekxtVnRhWFFvZTF4dUlDQWdJQ0FnSUNCMGVYQmxPaUJjSW1sdWFYUnBZV3hwZW1Wa1hDSXNYRzRnSUNBZ0lDQWdJR052Ym1acFp6b2dkR2hwY3k1amIyNW1hV2RjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJSDFjYmlBZ0lDQmthWE5qYjI1dVpXTjBLQ2tnZTF4dUlDQWdJQ0FnZEdocGN5NWZabWx5WlNoY0ltSmxabTl5WlVScGMyTnZibTVsWTNSY0lpazdYRzRnSUNBZ0lDQnpaV3htTG1Oc2IzTmxLQ2s3WEc0Z0lDQWdJQ0IwYUdsekxsOW1hWEpsS0Z3aVpHbHpZMjl1Ym1WamRHVmtYQ0lwTzF4dUlDQWdJSDFjYmlBZ0lDQmxiV2wwS0dSaGRHRXBJSHRjYmlBZ0lDQWdJR3hsZENCMGNtRnVjMlpsY21GaWJHVnpJRDBnZFc1a1pXWnBibVZrTzF4dUlDQWdJQ0FnYVdZZ0tHUmhkR0V1WDE5MGNtRnVjMlpsY21GaWJHVnpYMThwSUh0Y2JpQWdJQ0FnSUNBZ2RISmhibk5tWlhKaFlteGxjeUE5SUdSaGRHRXVYMTkwY21GdWMyWmxjbUZpYkdWelgxODdYRzRnSUNBZ0lDQWdJR1JsYkdWMFpTQmtZWFJoTGw5ZmRISmhibk5tWlhKaFlteGxjMTlmTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnYzJWc1ppNXdiM04wVFdWemMyRm5aU2hrWVhSaExDQjBjbUZ1YzJabGNtRmliR1Z6S1R0Y2JpQWdJQ0I5WEc0Z0lDQWdZWE41Ym1NZ1pYaGxZM1YwWlNoamIyUmxLU0I3WEc0Z0lDQWdJQ0JwWmlBb1kyOWtaUzUwZVhCbElEMDlQU0JjSW5KbGNYVnBjbVZ0Wlc1MGMxd2lLU0I3WEc0Z0lDQWdJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tGeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE1nSmlaY2JpQWdJQ0FnSUNBZ0lDQWdJQ2hCY25KaGVTNXBjMEZ5Y21GNUtHTnZaR1V1Y21WeGRXbHlaVzFsYm5SektTQjhmRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQjBlWEJsYjJZZ1kyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhNZ1BUMDlJRndpYzNSeWFXNW5YQ0lwWEc0Z0lDQWdJQ0FnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvSVVGeWNtRjVMbWx6UVhKeVlYa29ZMjlrWlM1eVpYRjFhWEpsYldWdWRITXBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE1nUFNCYlkyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhOZE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z1kyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMlJsTG5KbGNYVnBjbVZ0Wlc1MGMxdHBYUzUwYjB4dmQyVnlRMkZ6WlNncExtVnVaSE5YYVhSb0tGd2lMbU56YzF3aUtTQjhmRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE5iYVYwdWMzUmhjblJ6VjJsMGFDaGNJbU56Y3pwY0lpbGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRndpZFc1aFlteGxJSFJ2SUdsdGNHOXlkQ0JqYzNNZ2FXNGdZU0IzWldKM2IzSnJaWEpjSWp0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjlrWlM1eVpYRjFhWEpsYldWdWRITmJhVjB1ZEc5TWIzZGxja05oYzJVb0tTNWxibVJ6VjJsMGFDaGNJaTVxYzF3aUtTQjhmRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE5iYVYwdWMzUmhjblJ6VjJsMGFDaGNJbXB6T2x3aUtWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHTnZaR1V1Y21WeGRXbHlaVzFsYm5SelcybGRMbk4wWVhKMGMxZHBkR2dvWENKcWN6cGNJaWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjlrWlM1eVpYRjFhWEpsYldWdWRITmJhVjBnUFNCamIyUmxMbkpsY1hWcGNtVnRaVzUwYzF0cFhTNXpiR2xqWlNnektUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsdGNHOXlkRk5qY21sd2RITW9ZMjlrWlM1eVpYRjFhWEpsYldWdWRITmJhVjBwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1kyOWtaUzV5WlhGMWFYSmxiV1Z1ZEhOYmFWMHVjM1JoY25SelYybDBhQ2hjSW1oMGRIQmNJaWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbHRjRzl5ZEZOamNtbHdkSE1vWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE5iYVYwcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9ZMjlrWlM1eVpYRjFhWEpsYldWdWRITmJhVjB1YzNSaGNuUnpWMmwwYUNoY0ltTmhZMmhsT2x3aUtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTHk5cFoyNXZjbVVnWTJGamFHVmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGd2lWVzV3Y205alpYTnpaV1FnY21WeGRXbHlaVzFsYm5SeklIVnliRG9nWENJZ0t5QmpiMlJsTG5KbGNYVnBjbVZ0Wlc1MGMxdHBYVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZEdoeWIzY2dYQ0ptWVdsc1pXUWdkRzhnYVcxd2IzSjBJSEpsY1hWcGNtVmtJSE5qY21sd2RITTZJRndpSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyUmxMbkpsY1hWcGNtVnRaVzUwY3k1MGIxTjBjbWx1WnlncE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmU0JqWVhSamFDQW9aU2tnZTF4dUlDQWdJQ0FnSUNBZ0lIUm9jbTkzSUdVN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMGdaV3h6WlNCcFppQW9ZMjlrWlM1MGVYQmxJRDA5UFNCY0luTmpjbWx3ZEZ3aUtTQjdYRzRnSUNBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdZMjlrWlM1eVpYRjFhWEpsYldWdWRITWdKaVpjYmlBZ0lDQWdJQ0FnSUNBZ0lDaEJjbkpoZVM1cGMwRnljbUY1S0dOdlpHVXVjbVZ4ZFdseVpXMWxiblJ6S1NCOGZGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGVYQmxiMllnWTI5a1pTNXlaWEYxYVhKbGJXVnVkSE1nUFQwOUlGd2ljM1J5YVc1blhDSXBYRzRnSUNBZ0lDQWdJQ0FnS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCcFppQW9RWEp5WVhrdWFYTkJjbkpoZVNoamIyUmxMbkpsY1hWcGNtVnRaVzUwY3lrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnBJRDBnTURzZ2FTQThJR052WkdVdWNtVnhkV2x5WlcxbGJuUnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnBiWEJ2Y25SVFkzSnBjSFJ6S0dOdlpHVXVjbVZ4ZFdseVpXMWxiblJ6VzJsZEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXMXdiM0owVTJOeWFYQjBjeWhqYjJSbExuSmxjWFZwY21WdFpXNTBjeWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lIMGdZMkYwWTJnZ0tHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ1hDSm1ZV2xzWldRZ2RHOGdhVzF3YjNKMElISmxjWFZwY21Wa0lITmpjbWx3ZEhNNklGd2lJQ3RjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjJSbExuSmxjWFZwY21WdFpXNTBjeTUwYjFOMGNtbHVaeWdwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQmxkbUZzS0dOdlpHVXVZMjl1ZEdWdWRDazdYRzRnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtVnljbTl5S0dVdWJXVnpjMkZuWlN3Z1pTNXpkR0ZqYXlrN1hHNGdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ1pUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ1hDSjFibk4xY0hCdmNuUmxaQ0JqYjJSbElIUjVjR1V1WENJN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCcFppQW9ZMjlrWlM1MGVYQmxJRDA5UFNCY0luSmxjWFZwY21WdFpXNTBjMXdpS1NCN1hHNGdJQ0FnSUNBZ0lITmxiR1l1Y0c5emRFMWxjM05oWjJVb2UxeHVJQ0FnSUNBZ0lDQWdJSFI1Y0dVNklGd2lZMkZqYUdWU1pYRjFhWEpsYldWdWRITmNJaXhjYmlBZ0lDQWdJQ0FnSUNCeVpYRjFhWEpsYldWdWRITTZJR052WkdVdWNtVnhkV2x5WlcxbGJuUnpYRzRnSUNBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0JqYjI1emRDQmpiMjVtYVdjZ1BTQjdYRzRnSUNBZ2RIbHdaVG9nWENKM1pXSXRkMjl5YTJWeVhDSXNYRzRnSUNBZ1pHVmthV05oZEdWa1gzUm9jbVZoWkRvZ2RISjFaU3hjYmlBZ0lDQmhiR3h2ZDE5bGVHVmpkWFJwYjI0NklIUnlkV1VzWEc0Z0lDQWdiR0Z1WnpvZ1hDSnFZWFpoYzJOeWFYQjBYQ0lzWEc0Z0lDQWdZWEJwWDNabGNuTnBiMjQ2SUVGUVNWOVdSVkpUU1U5T1hHNGdJSDA3WEc0Z0lHTnZibk4wSUdOdmJtNGdQU0J1WlhjZ1EyOXVibVZqZEdsdmJpaGpiMjVtYVdjcE8xeHVJQ0JqYjI1dUxtOXVLRndpWTI5dWJtVmpkRkpRUTF3aUxDQmtZWFJoSUQwK0lIdGNiaUFnSUNCamIyNXVaV04wVWxCREtHTnZibTRzSUU5aWFtVmpkQzVoYzNOcFoyNG9aR0YwWVM1amIyNW1hV2NzSUdOdmJtWnBaeWtwTzF4dUlDQjlLVHRjYmlBZ1kyOXViaTVqYjI1dVpXTjBLQ2s3WEc0Z0lITmxiR1l1Y0c5emRFMWxjM05oWjJVb2UxeHVJQ0FnSUhSNWNHVTZJRndpZDI5eWEyVnlMWEpsWVdSNVhDSmNiaUFnZlNrN1hHNTlLU2dwTzF4dUlsMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk95SXNJbk52ZFhKalpWSnZiM1FpT2lJaWZRPT1cXFxcbi8vIyBzb3VyY2VVUkw9d2VicGFjay1pbnRlcm5hbDovLy8uL3NyYy9wbHVnaW4ud2Vid29ya2VyLmpzXFxcXG5cXFwiKTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvcGx1Z2luQ29yZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vc3JjL3BsdWdpbkNvcmUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogY29ubmVjdFJQQyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuZXZhbChcXFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcXFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFxcXFxcImNvbm5lY3RSUENcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb25uZWN0UlBDOyB9KTtcXFxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcnBjX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JwYy5qcyAqLyBcXFxcXFxcIi4vc3JjL3JwYy5qc1xcXFxcXFwiKTtcXFxcbi8qKlxcXFxuICogQ29yZSBwbHVnaW4gc2NyaXB0IGxvYWRlZCBpbnRvIHRoZSBwbHVnaW4gcHJvY2Vzcy90aHJlYWQuXFxcXG4gKlxcXFxuICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbi1zaXRlIEFQSSBnbG9iYWwgbWV0aG9kcy5cXFxcbiAqL1xcXFxuXFxcXG5mdW5jdGlvbiBjb25uZWN0UlBDKGNvbm5lY3Rpb24sIGNvbmZpZykge1xcXFxuICBjb25maWcgPSBjb25maWcgfHwge307XFxcXG4gIGNvbnN0IGNvZGVjcyA9IHt9O1xcXFxuICBjb25zdCBycGMgPSBuZXcgX3JwY19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXFxcXFwiUlBDXFxcXFxcXCJdKGNvbm5lY3Rpb24sIGNvbmZpZywgY29kZWNzKTtcXFxcbiAgcnBjLm9uKFxcXFxcXFwiZ2V0SW50ZXJmYWNlXFxcXFxcXCIsIGZ1bmN0aW9uICgpIHtcXFxcbiAgICBsYXVuY2hDb25uZWN0ZWQoKTtcXFxcbiAgfSk7XFxcXG4gIHJwYy5vbihcXFxcXFxcInJlbW90ZVJlYWR5XFxcXFxcXCIsIGZ1bmN0aW9uICgpIHtcXFxcbiAgICBjb25zdCBhcGkgPSBycGMuZ2V0UmVtb3RlKCkgfHwge307XFxcXG5cXFxcbiAgICBpZiAoYXBpLmV4cG9ydCkge1xcXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwiYGV4cG9ydGAgaXMgYSByZXNlcnZlZCBmdW5jdGlvbiBuYW1lXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGlmIChhcGkub25sb2FkKSB7XFxcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJgb25sb2FkYCBpcyBhIHJlc2VydmVkIGZ1bmN0aW9uIG5hbWVcXFxcXFxcIik7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgaWYgKGFwaS5kaXNwb3NlKSB7XFxcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJgZGlzcG9zZWAgaXMgYSByZXNlcnZlZCBmdW5jdGlvbiBuYW1lXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGFwaS5yZWdpc3RlckNvZGVjID0gZnVuY3Rpb24gKGNvbmZpZykge1xcXFxuICAgICAgaWYgKCFjb25maWdbXFxcXFxcXCJuYW1lXFxcXFxcXCJdIHx8ICFjb25maWdbXFxcXFxcXCJlbmNvZGVyXFxcXFxcXCJdICYmICFjb25maWdbXFxcXFxcXCJkZWNvZGVyXFxcXFxcXCJdKSB7XFxcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIkludmFsaWQgY29kZWMgZm9ybWF0LCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBwcm92aWRlIGEgbmFtZSwgdHlwZSwgZW5jb2RlciBhbmQgZGVjb2Rlci5cXFxcXFxcIik7XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICBpZiAoY29uZmlnLnR5cGUpIHtcXFxcbiAgICAgICAgICBmb3IgKGxldCBrIG9mIE9iamVjdC5rZXlzKGNvZGVjcykpIHtcXFxcbiAgICAgICAgICAgIGlmIChjb2RlY3Nba10udHlwZSA9PT0gY29uZmlnLnR5cGUgfHwgayA9PT0gY29uZmlnLm5hbWUpIHtcXFxcbiAgICAgICAgICAgICAgZGVsZXRlIGNvZGVjc1trXTtcXFxcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxcXFxcXFwiUmVtb3ZlIGR1cGxpY2F0ZWQgY29kZWM6IFxcXFxcXFwiICsgayk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgY29kZWNzW2NvbmZpZ1tcXFxcXFxcIm5hbWVcXFxcXFxcIl1dID0gY29uZmlnO1xcXFxuICAgICAgfVxcXFxuICAgIH07XFxcXG5cXFxcbiAgICBhcGkuZGlzcG9zZU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcXFxcbiAgICAgIHJwYy5kaXNwb3NlT2JqZWN0KG9iaik7XFxcXG4gICAgfTtcXFxcblxcXFxuICAgIGFwaS5leHBvcnQgPSBmdW5jdGlvbiAoX2ludGVyZmFjZSwgY29uZmlnKSB7XFxcXG4gICAgICBycGMuc2V0SW50ZXJmYWNlKF9pbnRlcmZhY2UsIGNvbmZpZyk7XFxcXG4gICAgfTtcXFxcblxcXFxuICAgIGFwaS5vbkxvYWQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xcXFxuICAgICAgaGFuZGxlciA9IGNoZWNrSGFuZGxlcihoYW5kbGVyKTtcXFxcblxcXFxuICAgICAgaWYgKGNvbm5lY3RlZCkge1xcXFxuICAgICAgICBoYW5kbGVyKCk7XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICBjb25uZWN0ZWRIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xcXFxuICAgICAgfVxcXFxuICAgIH07XFxcXG5cXFxcbiAgICBhcGkuZGlzcG9zZSA9IGZ1bmN0aW9uIChfaW50ZXJmYWNlKSB7XFxcXG4gICAgICBycGMuZGlzY29ubmVjdCgpO1xcXFxuICAgIH07XFxcXG5cXFxcbiAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xcXFxuICAgICAgc2VsZi5hcGkgPSBhcGk7XFxcXG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcXFxcbiAgICAgICAgdHlwZTogXFxcXFxcXCJpbWpveV9yZW1vdGVfYXBpX3JlYWR5XFxcXFxcXCJcXFxcbiAgICAgIH0pO1xcXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdykge1xcXFxuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFxcXFxcXFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVxcXFxcXFwiLCB7XFxcXG4gICAgICAgIGRldGFpbDogYXBpXFxcXG4gICAgICB9KSk7XFxcXG4gICAgfVxcXFxuICB9KTtcXFxcbiAgbGV0IGNvbm5lY3RlZCA9IGZhbHNlO1xcXFxuICBjb25zdCBjb25uZWN0ZWRIYW5kbGVycyA9IFtdO1xcXFxuXFxcXG4gIGNvbnN0IGxhdW5jaENvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcXFxcbiAgICBpZiAoIWNvbm5lY3RlZCkge1xcXFxuICAgICAgY29ubmVjdGVkID0gdHJ1ZTtcXFxcbiAgICAgIGxldCBoYW5kbGVyO1xcXFxuXFxcXG4gICAgICB3aGlsZSAoaGFuZGxlciA9IGNvbm5lY3RlZEhhbmRsZXJzLnBvcCgpKSB7XFxcXG4gICAgICAgIGhhbmRsZXIoKTtcXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG4gIH07XFxcXG5cXFxcbiAgY29uc3QgY2hlY2tIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcXFxcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGhhbmRsZXI7XFxcXG5cXFxcbiAgICBpZiAodHlwZSAhPT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiKSB7XFxcXG4gICAgICBjb25zdCBtc2cgPSBcXFxcXFxcIkEgZnVuY3Rpb24gbWF5IG9ubHkgYmUgc3Vic3JpYmVkIHRvIHRoZSBldmVudCwgXFxcXFxcXCIgKyB0eXBlICsgXFxcXFxcXCIgd2FzIHByb3ZpZGVkIGluc3RlYWRcXFxcXFxcIjtcXFxcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHJldHVybiBoYW5kbGVyO1xcXFxuICB9O1xcXFxuXFxcXG4gIHJldHVybiBycGM7XFxcXG59Ly8jIHNvdXJjZVVSTD1bbW9kdWxlXVxcXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lMaTl6Y21NdmNHeDFaMmx1UTI5eVpTNXFjeTVxY3lJc0luTnZkWEpqWlhNaU9sc2lkMlZpY0dGamF6b3ZMMmx0YW05NVVsQkRMeTR2YzNKakwzQnNkV2RwYmtOdmNtVXVhbk0vWVRneE5DSmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUl2S2lwY2JpQXFJRU52Y21VZ2NHeDFaMmx1SUhOamNtbHdkQ0JzYjJGa1pXUWdhVzUwYnlCMGFHVWdjR3gxWjJsdUlIQnliMk5sYzNNdmRHaHlaV0ZrTGx4dUlDcGNiaUFxSUVsdWFYUnBZV3hwZW1WeklIUm9aU0J3YkhWbmFXNHRjMmwwWlNCQlVFa2daMnh2WW1Gc0lHMWxkR2h2WkhNdVhHNGdLaTljYm1sdGNHOXlkQ0I3SUZKUVF5QjlJR1p5YjIwZ1hDSXVMM0p3WXk1cWMxd2lPMXh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWTI5dWJtVmpkRkpRUXloamIyNXVaV04wYVc5dUxDQmpiMjVtYVdjcElIdGNiaUFnWTI5dVptbG5JRDBnWTI5dVptbG5JSHg4SUh0OU8xeHVJQ0JqYjI1emRDQmpiMlJsWTNNZ1BTQjdmVHRjYmx4dUlDQmpiMjV6ZENCeWNHTWdQU0J1WlhjZ1VsQkRLR052Ym01bFkzUnBiMjRzSUdOdmJtWnBaeXdnWTI5a1pXTnpLVHRjYmlBZ2NuQmpMbTl1S0Z3aVoyVjBTVzUwWlhKbVlXTmxYQ0lzSUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUd4aGRXNWphRU52Ym01bFkzUmxaQ2dwTzF4dUlDQjlLVHRjYmx4dUlDQnljR011YjI0b1hDSnlaVzF2ZEdWU1pXRmtlVndpTENCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNCamIyNXpkQ0JoY0drZ1BTQnljR011WjJWMFVtVnRiM1JsS0NrZ2ZId2dlMzA3WEc0Z0lDQWdhV1lnS0dGd2FTNWxlSEJ2Y25RcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loY0ltQmxlSEJ2Y25SZ0lHbHpJR0VnY21WelpYSjJaV1FnWm5WdVkzUnBiMjRnYm1GdFpWd2lLVHRjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLR0Z3YVM1dmJteHZZV1FwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhjSW1CdmJteHZZV1JnSUdseklHRWdjbVZ6WlhKMlpXUWdablZ1WTNScGIyNGdibUZ0WlZ3aUtUdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tHRndhUzVrYVhOd2IzTmxLU0I3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9YQ0pnWkdsemNHOXpaV0FnYVhNZ1lTQnlaWE5sY25abFpDQm1kVzVqZEdsdmJpQnVZVzFsWENJcE8xeHVJQ0FnSUgxY2JpQWdJQ0JoY0drdWNtVm5hWE4wWlhKRGIyUmxZeUE5SUdaMWJtTjBhVzl1S0dOdmJtWnBaeWtnZTF4dUlDQWdJQ0FnYVdZZ0tDRmpiMjVtYVdkYlhDSnVZVzFsWENKZElIeDhJQ2doWTI5dVptbG5XMXdpWlc1amIyUmxjbHdpWFNBbUppQWhZMjl1Wm1sblcxd2laR1ZqYjJSbGNsd2lYU2twSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0Z4dUlDQWdJQ0FnSUNBZ0lGd2lTVzUyWVd4cFpDQmpiMlJsWXlCbWIzSnRZWFFzSUhCc1pXRnpaU0J0WVd0bElITjFjbVVnZVc5MUlIQnliM1pwWkdVZ1lTQnVZVzFsTENCMGVYQmxMQ0JsYm1OdlpHVnlJR0Z1WkNCa1pXTnZaR1Z5TGx3aVhHNGdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWTI5dVptbG5MblI1Y0dVcElIdGNiaUFnSUNBZ0lDQWdJQ0JtYjNJZ0tHeGxkQ0JySUc5bUlFOWlhbVZqZEM1clpYbHpLR052WkdWamN5a3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hqYjJSbFkzTmJhMTB1ZEhsd1pTQTlQVDBnWTI5dVptbG5MblI1Y0dVZ2ZId2dheUE5UFQwZ1kyOXVabWxuTG01aGJXVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdaR1ZzWlhSbElHTnZaR1ZqYzF0clhUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjMjlzWlM1M1lYSnVLRndpVW1WdGIzWmxJR1IxY0d4cFkyRjBaV1FnWTI5a1pXTTZJRndpSUNzZ2F5azdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUdOdlpHVmpjMXRqYjI1bWFXZGJYQ0p1WVcxbFhDSmRYU0E5SUdOdmJtWnBaenRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlPMXh1SUNBZ0lHRndhUzVrYVhOd2IzTmxUMkpxWldOMElEMGdablZ1WTNScGIyNG9iMkpxS1NCN1hHNGdJQ0FnSUNCeWNHTXVaR2x6Y0c5elpVOWlhbVZqZENodlltb3BPMXh1SUNBZ0lIMDdYRzRnSUNBZ1lYQnBMbVY0Y0c5eWRDQTlJR1oxYm1OMGFXOXVLRjlwYm5SbGNtWmhZMlVzSUdOdmJtWnBaeWtnZTF4dUlDQWdJQ0FnY25CakxuTmxkRWx1ZEdWeVptRmpaU2hmYVc1MFpYSm1ZV05sTENCamIyNW1hV2NwTzF4dUlDQWdJSDA3WEc0Z0lDQWdZWEJwTG05dVRHOWhaQ0E5SUdaMWJtTjBhVzl1S0doaGJtUnNaWElwSUh0Y2JpQWdJQ0FnSUdoaGJtUnNaWElnUFNCamFHVmphMGhoYm1Sc1pYSW9hR0Z1Wkd4bGNpazdYRzRnSUNBZ0lDQnBaaUFvWTI5dWJtVmpkR1ZrS1NCN1hHNGdJQ0FnSUNBZ0lHaGhibVJzWlhJb0tUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lHTnZibTVsWTNSbFpFaGhibVJzWlhKekxuQjFjMmdvYUdGdVpHeGxjaWs3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVHRjYmlBZ0lDQmhjR2t1WkdsemNHOXpaU0E5SUdaMWJtTjBhVzl1S0Y5cGJuUmxjbVpoWTJVcElIdGNiaUFnSUNBZ0lISndZeTVrYVhOamIyNXVaV04wS0NrN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUdsbUlDaGNiaUFnSUNBZ0lIUjVjR1Z2WmlCWGIzSnJaWEpIYkc5aVlXeFRZMjl3WlNBaFBUMGdYQ0oxYm1SbFptbHVaV1JjSWlBbUpseHVJQ0FnSUNBZ2MyVnNaaUJwYm5OMFlXNWpaVzltSUZkdmNtdGxja2RzYjJKaGJGTmpiM0JsWEc0Z0lDQWdLU0I3WEc0Z0lDQWdJQ0J6Wld4bUxtRndhU0E5SUdGd2FUdGNiaUFnSUNBZ0lITmxiR1l1Y0c5emRFMWxjM05oWjJVb2UxeHVJQ0FnSUNBZ0lDQjBlWEJsT2lCY0ltbHRhbTk1WDNKbGJXOTBaVjloY0dsZmNtVmhaSGxjSWx4dUlDQWdJQ0FnZlNrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoMGVYQmxiMllnZDJsdVpHOTNLU0I3WEc0Z0lDQWdJQ0IzYVc1a2IzY3VaR2x6Y0dGMFkyaEZkbVZ1ZENoY2JpQWdJQ0FnSUNBZ2JtVjNJRU4xYzNSdmJVVjJaVzUwS0Z3aWFXMXFiM2xmY21WdGIzUmxYMkZ3YVY5eVpXRmtlVndpTENCN0lHUmxkR0ZwYkRvZ1lYQnBJSDBwWEc0Z0lDQWdJQ0FwTzF4dUlDQWdJSDFjYmlBZ2ZTazdYRzVjYmlBZ2JHVjBJR052Ym01bFkzUmxaQ0E5SUdaaGJITmxPMXh1SUNCamIyNXpkQ0JqYjI1dVpXTjBaV1JJWVc1a2JHVnljeUE5SUZ0ZE8xeHVYRzRnSUdOdmJuTjBJR3hoZFc1amFFTnZibTVsWTNSbFpDQTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJR2xtSUNnaFkyOXVibVZqZEdWa0tTQjdYRzRnSUNBZ0lDQmpiMjV1WldOMFpXUWdQU0IwY25WbE8xeHVYRzRnSUNBZ0lDQnNaWFFnYUdGdVpHeGxjanRjYmlBZ0lDQWdJSGRvYVd4bElDZ29hR0Z1Wkd4bGNpQTlJR052Ym01bFkzUmxaRWhoYm1Sc1pYSnpMbkJ2Y0NncEtTa2dlMXh1SUNBZ0lDQWdJQ0JvWVc1a2JHVnlLQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNCOU8xeHVYRzRnSUdOdmJuTjBJR05vWldOclNHRnVaR3hsY2lBOUlHWjFibU4wYVc5dUtHaGhibVJzWlhJcElIdGNiaUFnSUNCamIyNXpkQ0IwZVhCbElEMGdkSGx3Wlc5bUlHaGhibVJzWlhJN1hHNGdJQ0FnYVdZZ0tIUjVjR1VnSVQwOUlGd2lablZ1WTNScGIyNWNJaWtnZTF4dUlDQWdJQ0FnWTI5dWMzUWdiWE5uSUQxY2JpQWdJQ0FnSUNBZ1hDSkJJR1oxYm1OMGFXOXVJRzFoZVNCdmJteDVJR0psSUhOMVluTnlhV0psWkNCMGJ5QjBhR1VnWlhabGJuUXNJRndpSUN0Y2JpQWdJQ0FnSUNBZ2RIbHdaU0FyWEc0Z0lDQWdJQ0FnSUZ3aUlIZGhjeUJ3Y205MmFXUmxaQ0JwYm5OMFpXRmtYQ0k3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9iWE5uS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdjbVYwZFhKdUlHaGhibVJzWlhJN1hHNGdJSDA3WEc1Y2JpQWdjbVYwZFhKdUlISndZenRjYm4xY2JpSmRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN096czdPMEZCUzBFN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCU1VFN1FVRkRRVHRCUVVOQk8wRkJSRUU3UVVGSFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVVkJPMEZCUTBFN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZGUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVsQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSnpiM1Z5WTJWU2IyOTBJam9pSW4wPVxcXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrLWludGVybmFsOi8vLy4vc3JjL3BsdWdpbkNvcmUuanNcXFxcblxcXCIpO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL3NyYy9ycGMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vc3JjL3JwYy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEFQSV9WRVJTSU9OLCBSUEMgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbmV2YWwoXFxcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJBUElfVkVSU0lPTlxcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFQSV9WRVJTSU9OOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJSUENcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSUEM7IH0pO1xcXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy5qcyAqLyBcXFxcXFxcIi4vc3JjL3V0aWxzLmpzXFxcXFxcXCIpO1xcXFxuLyoqXFxcXG4gKiBDb250YWlucyB0aGUgUlBDIG9iamVjdCB1c2VkIGJvdGggYnkgdGhlIGFwcGxpY2F0aW9uXFxcXG4gKiBzaXRlLCBhbmQgYnkgZWFjaCBwbHVnaW5cXFxcbiAqL1xcXFxuXFxcXG5jb25zdCBBUElfVkVSU0lPTiA9IFxcXFxcXFwiMC4yLjNcXFxcXFxcIjtcXFxcbmNvbnN0IEFycmF5QnVmZmVyVmlldyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IFVpbnQ4QXJyYXkoKSkpLmNvbnN0cnVjdG9yO1xcXFxuXFxcXG5mdW5jdGlvbiBfYXBwZW5kQnVmZmVyKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcXFxcbiAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcXFxcbiAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIxKSwgMCk7XFxcXG4gIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMiksIGJ1ZmZlcjEuYnl0ZUxlbmd0aCk7XFxcXG4gIHJldHVybiB0bXAuYnVmZmVyO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBpbmRleE9iamVjdChvYmosIGlzKSB7XFxcXG4gIGlmICh0eXBlb2YgaXMgPT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIikgcmV0dXJuIGluZGV4T2JqZWN0KG9iaiwgaXMuc3BsaXQoXFxcXFxcXCIuXFxcXFxcXCIpKTtlbHNlIGlmIChpcy5sZW5ndGggPT0gMCkgcmV0dXJuIG9iajtlbHNlIHJldHVybiBpbmRleE9iamVjdChvYmpbaXNbMF1dLCBpcy5zbGljZSgxKSk7XFxcXG59XFxcXG4vKipcXFxcbiAqIFJQQyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbmdsZSBzaXRlIGluIHRoZVxcXFxuICogY29tbXVuaWNhdGlvbiBwcm90b2NvbCBiZXR3ZWVuIHRoZSBhcHBsaWNhdGlvbiBhbmQgdGhlIHBsdWdpblxcXFxuICpcXFxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uIGEgc3BlY2lhbCBvYmplY3QgYWxsb3dpbmcgdG8gc2VuZFxcXFxuICogYW5kIHJlY2VpdmUgbWVzc2FnZXMgZnJvbSB0aGUgb3Bwb3NpdGUgc2l0ZSAoYmFzaWNhbGx5IGl0XFxcXG4gKiBzaG91bGQgb25seSBwcm92aWRlIHNlbmQoKSBhbmQgb25NZXNzYWdlKCkgbWV0aG9kcylcXFxcbiAqL1xcXFxuXFxcXG5cXFxcbmNsYXNzIFJQQyBleHRlbmRzIF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXFxcXFwiTWVzc2FnZUVtaXR0ZXJcXFxcXFxcIl0ge1xcXFxuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBjb25maWcsIGNvZGVjcykge1xcXFxuICAgIHN1cGVyKGNvbmZpZyAmJiBjb25maWcuZGVidWcpO1xcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xcXFxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xcXFxuICAgIHRoaXMuX2NvZGVjcyA9IGNvZGVjcyB8fCB7fTtcXFxcbiAgICB0aGlzLl9vYmplY3Rfc3RvcmUgPSB7fTtcXFxcbiAgICB0aGlzLl9tZXRob2Rfd2Vha21hcCA9IG5ldyBXZWFrTWFwKCk7XFxcXG4gICAgdGhpcy5fb2JqZWN0X3dlYWttYXAgPSBuZXcgV2Vha01hcCgpO1xcXFxuICAgIHRoaXMuX2xvY2FsX2FwaSA9IG51bGw7IC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhbiBleGVjdXRlIGZ1bmN0aW9uXFxcXG5cXFxcbiAgICBjb25zdCBuYW1lID0gdGhpcy5jb25maWcubmFtZTtcXFxcblxcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZXhlY3V0ZSA9IHRoaXMuX2Nvbm5lY3Rpb24uZXhlY3V0ZSB8fCBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbm5lY3Rpb24uZXhlY3V0ZSBub3QgaW1wbGVtZW50ZWQgKGluIFxcXFxcXFwiJHtuYW1lfVxcXFxcXFwiKWApO1xcXFxuICAgIH07XFxcXG5cXFxcbiAgICB0aGlzLl9zdG9yZSA9IG5ldyBSZWZlcmVuY2VTdG9yZSgpO1xcXFxuICAgIHRoaXMuX21ldGhvZF9yZWZzID0gbmV3IFJlZmVyZW5jZVN0b3JlKCk7XFxcXG5cXFxcbiAgICB0aGlzLl9tZXRob2RfcmVmcy5vblJlYWR5KCgpID0+IHtcXFxcbiAgICAgIHRoaXMuX2ZpcmUoXFxcXFxcXCJyZW1vdGVJZGxlXFxcXFxcXCIpO1xcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgdGhpcy5fbWV0aG9kX3JlZnMub25CdXN5KCgpID0+IHtcXFxcbiAgICAgIHRoaXMuX2ZpcmUoXFxcXFxcXCJyZW1vdGVCdXN5XFxcXFxcXCIpO1xcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgdGhpcy5fc2V0dXBNZXNzYWdlSGFubGRlcnMoKTtcXFxcbiAgfVxcXFxuXFxcXG4gIGluaXQoKSB7XFxcXG4gICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHtcXFxcbiAgICAgIHR5cGU6IFxcXFxcXFwiaW5pdGlhbGl6ZWRcXFxcXFxcIixcXFxcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXFxcXG4gICAgICBwZWVyX2lkOiB0aGlzLl9jb25uZWN0aW9uLnBlZXJfaWRcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2V0IGEgaGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbiByZWNlaXZlZCBhIHJlc3BvbmNlIGZyb20gdGhlXFxcXG4gICAqIHJlbW90ZSBzaXRlIHJlcG9ydGluZyB0aGF0IHRoZSBwcmV2aW91c2x5IHByb3ZpZGVkIGludGVyZmFjZVxcXFxuICAgKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2V0IGFzIHJlbW90ZSBmb3IgdGhhdCBzaXRlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBnZXRSZW1vdGVDYWxsU3RhY2soKSB7XFxcXG4gICAgcmV0dXJuIHRoaXMuX21ldGhvZF9yZWZzLmdldFN0YWNrKCk7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHNldCBvZiByZW1vdGUgaW50ZXJmYWNlIG1ldGhvZHNcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBnZXRSZW1vdGUoKSB7XFxcXG4gICAgcmV0dXJuIHRoaXMuX3JlbW90ZV9pbnRlcmZhY2U7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNldHMgdGhlIGludGVyZmFjZSBvZiB0aGlzIHNpdGUgbWFraW5nIGl0IGF2YWlsYWJsZSB0byB0aGVcXFxcbiAgICogcmVtb3RlIHNpdGUgYnkgc2VuZGluZyBhIG1lc3NhZ2Ugd2l0aCBhIHNldCBvZiBtZXRob2RzIG5hbWVzXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBfaW50ZXJmYWNlIHRvIHNldFxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIHNldEludGVyZmFjZShfaW50ZXJmYWNlLCBjb25maWcpIHtcXFxcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XFxcXG4gICAgdGhpcy5jb25maWcubmFtZSA9IGNvbmZpZy5uYW1lIHx8IHRoaXMuY29uZmlnLm5hbWU7XFxcXG4gICAgdGhpcy5jb25maWcuZGVzY3JpcHRpb24gPSBjb25maWcuZGVzY3JpcHRpb24gfHwgdGhpcy5jb25maWcuZGVzY3JpcHRpb247XFxcXG5cXFxcbiAgICBpZiAodGhpcy5jb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnMpIHtcXFxcbiAgICAgIGZvciAobGV0IGZ1bmNfbmFtZSBvZiB0aGlzLmNvbmZpZy5mb3J3YXJkaW5nX2Z1bmN0aW9ucykge1xcXFxuICAgICAgICBjb25zdCBfcmVtb3RlID0gdGhpcy5fcmVtb3RlX2ludGVyZmFjZTtcXFxcblxcXFxuICAgICAgICBpZiAoX3JlbW90ZVtmdW5jX25hbWVdKSB7XFxcXG4gICAgICAgICAgaWYgKF9pbnRlcmZhY2UuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xcXFxuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlW2Z1bmNfbmFtZV0pIHtcXFxcbiAgICAgICAgICAgICAgX2ludGVyZmFjZVtmdW5jX25hbWVdID0gKC4uLmFyZ3MpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBfcmVtb3RlW2Z1bmNfbmFtZV0oLi4uYXJncyk7XFxcXG4gICAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgfSBlbHNlIGlmIChfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xcXFxuICAgICAgICAgICAgaWYgKCFfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtmdW5jX25hbWVdKSB7XFxcXG4gICAgICAgICAgICAgIF9pbnRlcmZhY2UuY29uc3RydWN0b3IucHJvdG90eXBlW2Z1bmNfbmFtZV0gPSAoLi4uYXJncykgPT4ge1xcXFxuICAgICAgICAgICAgICAgIF9yZW1vdGVbZnVuY19uYW1lXSguLi5hcmdzKTtcXFxcbiAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG5cXFxcbiAgICB0aGlzLl9sb2NhbF9hcGkgPSBfaW50ZXJmYWNlO1xcXFxuXFxcXG4gICAgdGhpcy5fZmlyZShcXFxcXFxcImludGVyZmFjZUF2YWlsYWJsZVxcXFxcXFwiKTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2VuZHMgdGhlIGFjdHVhbCBpbnRlcmZhY2UgdG8gdGhlIHJlbW90ZSBzaXRlIHVwb24gaXQgd2FzXFxcXG4gICAqIHVwZGF0ZWQgb3IgYnkgYSBzcGVjaWFsIHJlcXVlc3Qgb2YgdGhlIHJlbW90ZSBzaXRlXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgc2VuZEludGVyZmFjZSgpIHtcXFxcbiAgICBpZiAoIXRoaXMuX2xvY2FsX2FwaSkge1xcXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwiaW50ZXJmYWNlIGlzIG5vdCBzZXQuXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHRoaXMuX2VuY29kZSh0aGlzLl9sb2NhbF9hcGksIHRydWUpLnRoZW4oYXBpID0+IHtcXFxcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICAgIHR5cGU6IFxcXFxcXFwic2V0SW50ZXJmYWNlXFxcXFxcXCIsXFxcXG4gICAgICAgIGFwaTogYXBpXFxcXG4gICAgICB9KTtcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxuXFxcXG4gIF9kaXNwb3NlT2JqZWN0KG9iamVjdElkKSB7XFxcXG4gICAgaWYgKHRoaXMuX29iamVjdF9zdG9yZVtvYmplY3RJZF0pIHtcXFxcbiAgICAgIGRlbGV0ZSB0aGlzLl9vYmplY3Rfc3RvcmVbb2JqZWN0SWRdO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCAoaWQ9JHtvYmplY3RJZH0pIG5vdCBmb3VuZC5gKTtcXFxcbiAgICB9XFxcXG4gIH1cXFxcblxcXFxuICBkaXNwb3NlT2JqZWN0KG9iaikge1xcXFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxcXG4gICAgICBpZiAodGhpcy5fb2JqZWN0X3dlYWttYXAuaGFzKG9iaikpIHtcXFxcbiAgICAgICAgY29uc3Qgb2JqZWN0SWQgPSB0aGlzLl9vYmplY3Rfd2Vha21hcC5nZXQob2JqKTtcXFxcblxcXFxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLm9uY2UoXFxcXFxcXCJkaXNwb3NlZFxcXFxcXFwiLCBkYXRhID0+IHtcXFxcbiAgICAgICAgICBpZiAoZGF0YS5lcnJvcikgcmVqZWN0KG5ldyBFcnJvcihkYXRhLmVycm9yKSk7ZWxzZSByZXNvbHZlKCk7XFxcXG4gICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICAgICAgdHlwZTogXFxcXFxcXCJkaXNwb3NlT2JqZWN0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgb2JqZWN0X2lkOiBvYmplY3RJZFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIkludmFsaWQgb2JqZWN0XFxcXFxcXCIpO1xcXFxuICAgICAgfVxcXFxuICAgIH0pO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBIYW5kbGVzIGEgbWVzc2FnZSBmcm9tIHRoZSByZW1vdGUgc2l0ZVxcXFxuICAgKi9cXFxcbiAgLy8gdmFyIGNhbGxiYWNrX3JlZyA9IG5ldyBSZWdFeHAoXFxcXFxcXCJvbnVwZGF0ZXxydW4kXFxcXFxcXCIpXFxcXG5cXFxcblxcXFxuICBfc2V0dXBNZXNzYWdlSGFubGRlcnMoKSB7XFxcXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcXFxcXFxcImluaXRcXFxcXFxcIiwgdGhpcy5pbml0KTtcXFxcblxcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXFxcXFxcXCJleGVjdXRlXFxcXFxcXCIsIGRhdGEgPT4ge1xcXFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2Nvbm5lY3Rpb24uZXhlY3V0ZShkYXRhLmNvZGUpKS50aGVuKCgpID0+IHtcXFxcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHtcXFxcbiAgICAgICAgICB0eXBlOiBcXFxcXFxcImV4ZWN1dGVkXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICB9KS5jYXRjaChlID0+IHtcXFxcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcXFxcblxcXFxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoe1xcXFxuICAgICAgICAgIHR5cGU6IFxcXFxcXFwiZXhlY3V0ZWRcXFxcXFxcIixcXFxcbiAgICAgICAgICBlcnJvcjogU3RyaW5nKGUpXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgfSk7XFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFxcXFxcXFwibWV0aG9kXFxcXFxcXCIsIGFzeW5jIGRhdGEgPT4ge1xcXFxuICAgICAgbGV0IHJlc29sdmUsIHJlamVjdCwgbWV0aG9kLCBhcmdzLCByZXN1bHQ7XFxcXG5cXFxcbiAgICAgIHRyeSB7XFxcXG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcXFxcbiAgICAgICAgICBbcmVzb2x2ZSwgcmVqZWN0XSA9IGF3YWl0IHRoaXMuX3Vud3JhcChkYXRhLnByb21pc2UsIGZhbHNlKTtcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGNvbnN0IF9pbnRlcmZhY2UgPSB0aGlzLl9vYmplY3Rfc3RvcmVbZGF0YS5vYmplY3RfaWRdO1xcXFxuICAgICAgICBtZXRob2QgPSBpbmRleE9iamVjdChfaW50ZXJmYWNlLCBkYXRhLm5hbWUpO1xcXFxuICAgICAgICBhcmdzID0gYXdhaXQgdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XFxcXG5cXFxcbiAgICAgICAgaWYgKGRhdGEucHJvbWlzZSkge1xcXFxuICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShfaW50ZXJmYWNlLCBhcmdzKTtcXFxcblxcXFxuICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlIHx8IG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXFxcXFxcXCJBc3luY0Z1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XFxcXG4gICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgbWV0aG9kLmFwcGx5KF9pbnRlcmZhY2UsIGFyZ3MpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXFxcbiAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLmNvbmZpZy5uYW1lLCBlcnIpO1xcXFxuXFxcXG4gICAgICAgIGlmIChyZWplY3QpIHtcXFxcbiAgICAgICAgICByZWplY3QoZXJyKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcXFxcXFxcImNhbGxiYWNrXFxcXFxcXCIsIGFzeW5jIGRhdGEgPT4ge1xcXFxuICAgICAgbGV0IHJlc29sdmUsIHJlamVjdCwgbWV0aG9kLCBhcmdzLCByZXN1bHQ7XFxcXG5cXFxcbiAgICAgIHRyeSB7XFxcXG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcXFxcbiAgICAgICAgICBbcmVzb2x2ZSwgcmVqZWN0XSA9IGF3YWl0IHRoaXMuX3Vud3JhcChkYXRhLnByb21pc2UsIGZhbHNlKTtcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcXFxcbiAgICAgICAgICBtZXRob2QgPSB0aGlzLl9zdG9yZS5mZXRjaChkYXRhLmlkKTtcXFxcbiAgICAgICAgICBhcmdzID0gYXdhaXQgdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XFxcXG5cXFxcbiAgICAgICAgICBpZiAoIW1ldGhvZCkge1xcXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwiQ2FsbGJhY2sgZnVuY3Rpb24gY2FuIG9ubHkgY2FsbGVkIG9uY2UsIGlmIHlvdSB3YW50IHRvIGNhbGwgYSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgdGltZXMsIHBsZWFzZSBtYWtlIGl0IGFzIGEgcGx1Z2luIGFwaSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vaW1qb3kuaW8vZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XFxcXG5cXFxcbiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fCBtZXRob2QuY29uc3RydWN0b3IgJiYgbWV0aG9kLmNvbnN0cnVjdG9yLm5hbWUgPT09IFxcXFxcXFwiQXN5bmNGdW5jdGlvblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xcXFxuICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgIG1ldGhvZCA9IHRoaXMuX3N0b3JlLmZldGNoKGRhdGEuaWQpO1xcXFxuICAgICAgICAgIGFyZ3MgPSBhd2FpdCB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcXFxcblxcXFxuICAgICAgICAgIGlmICghbWV0aG9kKSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJQbGVhc2Ugbm90aWNlIHRoYXQgY2FsbGJhY2sgZnVuY3Rpb24gY2FuIG9ubHkgY2FsbGVkIG9uY2UsIGlmIHlvdSB3YW50IHRvIGNhbGwgYSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgdGltZXMsIHBsZWFzZSBtYWtlIGl0IGFzIGEgcGx1Z2luIGFwaSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vaW1qb3kuaW8vZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcXFxuICAgICAgICBjb25zb2xlLmVycm9yKHRoaXMuY29uZmlnLm5hbWUsIGVycik7XFxcXG5cXFxcbiAgICAgICAgaWYgKHJlamVjdCkge1xcXFxuICAgICAgICAgIHJlamVjdChlcnIpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9XFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFxcXFxcXFwiZGlzcG9zZU9iamVjdFxcXFxcXFwiLCBkYXRhID0+IHtcXFxcbiAgICAgIHRyeSB7XFxcXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VPYmplY3QoZGF0YS5vYmplY3RfaWQpO1xcXFxuXFxcXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICAgICAgdHlwZTogXFxcXFxcXCJkaXNwb3NlZFxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xcXFxuXFxcXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICAgICAgdHlwZTogXFxcXFxcXCJkaXNwb3NlZFxcXFxcXFwiLFxcXFxuICAgICAgICAgIGVycm9yOiBTdHJpbmcoZSlcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICB9XFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFxcXFxcXFwic2V0SW50ZXJmYWNlXFxcXFxcXCIsIGRhdGEgPT4ge1xcXFxuICAgICAgdGhpcy5fc2V0UmVtb3RlSW50ZXJmYWNlKGRhdGEuYXBpKTtcXFxcbiAgICB9KTtcXFxcblxcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXFxcXFxcXCJnZXRJbnRlcmZhY2VcXFxcXFxcIiwgKCkgPT4ge1xcXFxuICAgICAgdGhpcy5fZmlyZShcXFxcXFxcImdldEludGVyZmFjZVxcXFxcXFwiKTtcXFxcblxcXFxuICAgICAgaWYgKHRoaXMuX2xvY2FsX2FwaSkge1xcXFxuICAgICAgICB0aGlzLnNlbmRJbnRlcmZhY2UoKTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHRoaXMub25jZShcXFxcXFxcImludGVyZmFjZUF2YWlsYWJsZVxcXFxcXFwiLCAoKSA9PiB7XFxcXG4gICAgICAgICAgdGhpcy5zZW5kSW50ZXJmYWNlKCk7XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcXFxcXFxcImludGVyZmFjZVNldEFzUmVtb3RlXFxcXFxcXCIsICgpID0+IHtcXFxcbiAgICAgIHRoaXMuX2ZpcmUoXFxcXFxcXCJpbnRlcmZhY2VTZXRBc1JlbW90ZVxcXFxcXFwiKTtcXFxcbiAgICB9KTtcXFxcblxcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXFxcXFxcXCJkaXNjb25uZWN0XFxcXFxcXCIsICgpID0+IHtcXFxcbiAgICAgIHRoaXMuX2ZpcmUoXFxcXFxcXCJiZWZvcmVEaXNjb25uZWN0XFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcXFxcblxcXFxuICAgICAgdGhpcy5fZmlyZShcXFxcXFxcImRpc2Nvbm5lY3RlZFxcXFxcXFwiKTtcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2VuZHMgYSByZXF1ZXN0cyB0byB0aGUgcmVtb3RlIHNpdGUgYXNraW5nIGl0IHRvIHByb3ZpZGUgaXRzXFxcXG4gICAqIGN1cnJlbnQgaW50ZXJmYWNlXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgcmVxdWVzdFJlbW90ZSgpIHtcXFxcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoe1xcXFxuICAgICAgdHlwZTogXFxcXFxcXCJnZXRJbnRlcmZhY2VcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICB9XFxcXG5cXFxcbiAgX25kYXJyYXkodHlwZWRBcnJheSwgc2hhcGUsIGR0eXBlKSB7XFxcXG4gICAgdmFyIF9kdHlwZSA9IF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXFxcXFwidHlwZWRBcnJheVRvRHR5cGVcXFxcXFxcIl1bdHlwZWRBcnJheS5jb25zdHJ1Y3Rvci5uYW1lXTtcXFxcblxcXFxuICAgIGlmIChkdHlwZSAmJiBkdHlwZSAhPT0gX2R0eXBlKSB7XFxcXG4gICAgICB0aHJvdyBcXFxcXFxcImR0eXBlIGRvZXNuJ3QgbWF0Y2ggdGhlIHR5cGUgb2YgdGhlIGFycmF5OiBcXFxcXFxcIiArIF9kdHlwZSArIFxcXFxcXFwiICE9IFxcXFxcXFwiICsgZHR5cGU7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgc2hhcGUgPSBzaGFwZSB8fCBbdHlwZWRBcnJheS5sZW5ndGhdO1xcXFxuICAgIHJldHVybiB7XFxcXG4gICAgICBfcnR5cGU6IFxcXFxcXFwibmRhcnJheVxcXFxcXFwiLFxcXFxuICAgICAgX3J2YWx1ZTogdHlwZWRBcnJheS5idWZmZXIsXFxcXG4gICAgICBfcnNoYXBlOiBzaGFwZSxcXFxcbiAgICAgIF9yZHR5cGU6IF9kdHlwZVxcXFxuICAgIH07XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNldHMgdGhlIG5ldyByZW1vdGUgaW50ZXJmYWNlIHByb3ZpZGVkIGJ5IHRoZSBvdGhlciBzaXRlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGxpc3Qgb2YgZnVuY3Rpb24gbmFtZXNcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfc2V0UmVtb3RlSW50ZXJmYWNlKGFwaSkge1xcXFxuICAgIHRoaXMuX2RlY29kZShhcGkpLnRoZW4oaW50ZiA9PiB7XFxcXG4gICAgICB0aGlzLl9yZW1vdGVfaW50ZXJmYWNlID0gaW50ZjtcXFxcblxcXFxuICAgICAgdGhpcy5fZmlyZShcXFxcXFxcInJlbW90ZVJlYWR5XFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgICB0aGlzLl9yZXBvcnRSZW1vdGVTZXQoKTtcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogR2VuZXJhdGVzIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gYSBzaW5nbGUgcmVtb3RlXFxcXG4gICAqIG1ldGhvZC4gV2hlbiB0aGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCwgaXQgd2lsbCBzZW5kIHRoZVxcXFxuICAgKiBjb3JyZXNwb25kaW5nIG1lc3NhZ2UgdG8gdGhlIHJlbW90ZSBzaXRlIGFza2luZyBpdCB0byBleGVjdXRlXFxcXG4gICAqIHRoZSBwYXJ0aWN1bGFyIG1ldGhvZCBvZiBpdHMgaW50ZXJmYWNlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSByZW1vdGUgbWV0aG9kXFxcXG4gICAqXFxcXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCByZW1vdGUgbWV0aG9kXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgX2dlblJlbW90ZU1ldGhvZCh0YXJnZXRJZCwgbmFtZSwgb2JqZWN0SWQpIHtcXFxcbiAgICB2YXIgbWUgPSB0aGlzO1xcXFxuXFxcXG4gICAgdmFyIHJlbW90ZU1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcXFxcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxcXG4gICAgICAgIGxldCBpZCA9IG51bGw7XFxcXG5cXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICBpZCA9IG1lLl9tZXRob2RfcmVmcy5wdXQob2JqZWN0SWQgPyBvYmplY3RJZCArIFxcXFxcXFwiL1xcXFxcXFwiICsgbmFtZSA6IG5hbWUpO1xcXFxuXFxcXG4gICAgICAgICAgdmFyIHdyYXBwZWRfcmVzb2x2ZSA9IGZ1bmN0aW9uICgpIHtcXFxcbiAgICAgICAgICAgIGlmIChpZCAhPT0gbnVsbCkgbWUuX21ldGhvZF9yZWZzLmZldGNoKGlkKTtcXFxcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxcXG4gICAgICAgICAgfTtcXFxcblxcXFxuICAgICAgICAgIHZhciB3cmFwcGVkX3JlamVjdCA9IGZ1bmN0aW9uICgpIHtcXFxcbiAgICAgICAgICAgIGlmIChpZCAhPT0gbnVsbCkgbWUuX21ldGhvZF9yZWZzLmZldGNoKGlkKTtcXFxcbiAgICAgICAgICAgIHJldHVybiByZWplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXFxcbiAgICAgICAgICB9O1xcXFxuXFxcXG4gICAgICAgICAgY29uc3QgZW5jb2RlZFByb21pc2UgPSBhd2FpdCBtZS5fd3JhcChbd3JhcHBlZF9yZXNvbHZlLCB3cmFwcGVkX3JlamVjdF0pOyAvLyBzdG9yZSB0aGUga2V5IGlkIGZvciByZW1vdmluZyB0aGVtIGZyb20gdGhlIHJlZmVyZW5jZSBzdG9yZSB0b2dldGhlclxcXFxuXFxcXG4gICAgICAgICAgd3JhcHBlZF9yZXNvbHZlLl9fcHJvbWlzZV9wYWlyID0gZW5jb2RlZFByb21pc2VbMV0uX3J2YWx1ZTtcXFxcbiAgICAgICAgICB3cmFwcGVkX3JlamVjdC5fX3Byb21pc2VfcGFpciA9IGVuY29kZWRQcm9taXNlWzBdLl9ydmFsdWU7XFxcXG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xcXFxuXFxcXG4gICAgICAgICAgaWYgKG5hbWUgPT09IFxcXFxcXFwicmVnaXN0ZXJcXFxcXFxcIiB8fCBuYW1lID09PSBcXFxcXFxcImV4cG9ydFxcXFxcXFwiIHx8IG5hbWUgPT09IFxcXFxcXFwib25cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgYXJncyA9IGF3YWl0IG1lLl93cmFwKGFyZ3MsIHRydWUpO1xcXFxuICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBhcmdzID0gYXdhaXQgbWUuX3dyYXAoYXJncyk7XFxcXG4gICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBhcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcXFxcblxcXFxuICAgICAgICAgIG1lLl9jb25uZWN0aW9uLmVtaXQoe1xcXFxuICAgICAgICAgICAgdHlwZTogXFxcXFxcXCJtZXRob2RcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHRhcmdldF9pZDogdGFyZ2V0SWQsXFxcXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxcXFxuICAgICAgICAgICAgb2JqZWN0X2lkOiBvYmplY3RJZCxcXFxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXFxcXG4gICAgICAgICAgICBwcm9taXNlOiBlbmNvZGVkUHJvbWlzZVxcXFxuICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpO1xcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgaWYgKGlkKSBtZS5fbWV0aG9kX3JlZnMuZmV0Y2goaWQpO1xcXFxuICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGV4ZWN0dWUgcmVtb3RlIG1ldGhvZCAoaW50ZXJmYWNlOiAke29iamVjdElkIHx8IG1lLmlkfSwgbWV0aG9kOiAke25hbWV9KSwgZXJyb3I6ICR7ZX1gKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfSk7XFxcXG4gICAgfTtcXFxcblxcXFxuICAgIHJlbW90ZU1ldGhvZC5fX3JlbW90ZV9tZXRob2QgPSB0cnVlO1xcXFxuICAgIHJldHVybiByZW1vdGVNZXRob2Q7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFNlbmRzIGEgcmVzcG9uY2UgcmVwb3J0aW5nIHRoYXQgaW50ZXJmYWNlIGp1c3QgcHJvdmlkZWQgYnkgdGhlXFxcXG4gICAqIHJlbW90ZSBzaXRlIHdhcyBzdWNjZXNzZnVsbHkgc2V0IGJ5IHRoaXMgc2l0ZSBhcyByZW1vdGVcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfcmVwb3J0UmVtb3RlU2V0KCkge1xcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICB0eXBlOiBcXFxcXFxcImludGVyZmFjZVNldEFzUmVtb3RlXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogUHJlcGFyZXMgdGhlIHByb3ZpZGVkIHNldCBvZiByZW1vdGUgbWV0aG9kIGFyZ3VtZW50cyBmb3JcXFxcbiAgICogc2VuZGluZyB0byB0aGUgcmVtb3RlIHNpdGUsIHJlcGxhY2VzIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGhcXFxcbiAgICogaWRlbnRpZmllcnNcXFxcbiAgICpcXFxcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyB0byB3cmFwXFxcXG4gICAqXFxcXG4gICAqIEByZXR1cm5zIHtBcnJheX0gd3JhcHBlZCBhcmd1bWVudHNcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBhc3luYyBfZW5jb2RlKGFPYmplY3QsIGFzSW50ZXJmYWNlLCBvYmplY3RJZCkge1xcXFxuICAgIGNvbnN0IGFUeXBlID0gdHlwZW9mIGFPYmplY3Q7XFxcXG5cXFxcbiAgICBpZiAoYVR5cGUgPT09IFxcXFxcXFwibnVtYmVyXFxcXFxcXCIgfHwgYVR5cGUgPT09IFxcXFxcXFwic3RyaW5nXFxcXFxcXCIgfHwgYVR5cGUgPT09IFxcXFxcXFwiYm9vbGVhblxcXFxcXFwiIHx8IGFPYmplY3QgPT09IG51bGwgfHwgYU9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IGFPYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xcXFxuICAgICAgcmV0dXJuIGFPYmplY3Q7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgbGV0IGJPYmplY3Q7XFxcXG5cXFxcbiAgICBpZiAodHlwZW9mIGFPYmplY3QgPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgaWYgKGFzSW50ZXJmYWNlKSB7XFxcXG4gICAgICAgIGlmICghb2JqZWN0SWQpIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIm9iamVjdElkIGlzIG5vdCBzcGVjaWZpZWQuXFxcXFxcXCIpO1xcXFxuICAgICAgICBiT2JqZWN0ID0ge1xcXFxuICAgICAgICAgIF9ydHlwZTogXFxcXFxcXCJpbnRlcmZhY2VcXFxcXFxcIixcXFxcbiAgICAgICAgICBfcnRhcmdldF9pZDogdGhpcy5fY29ubmVjdGlvbi5wZWVyX2lkLFxcXFxuICAgICAgICAgIF9yaW50Zjogb2JqZWN0SWQsXFxcXG4gICAgICAgICAgX3J2YWx1ZTogYXNJbnRlcmZhY2VcXFxcbiAgICAgICAgfTtcXFxcblxcXFxuICAgICAgICB0aGlzLl9tZXRob2Rfd2Vha21hcC5zZXQoYU9iamVjdCwgYk9iamVjdCk7XFxcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX21ldGhvZF93ZWFrbWFwLmhhcyhhT2JqZWN0KSkge1xcXFxuICAgICAgICBiT2JqZWN0ID0gdGhpcy5fbWV0aG9kX3dlYWttYXAuZ2V0KGFPYmplY3QpO1xcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgY29uc3QgY2lkID0gdGhpcy5fc3RvcmUucHV0KGFPYmplY3QpO1xcXFxuXFxcXG4gICAgICAgIGJPYmplY3QgPSB7XFxcXG4gICAgICAgICAgX3J0eXBlOiBcXFxcXFxcImNhbGxiYWNrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgX3J0YXJnZXRfaWQ6IHRoaXMuX2Nvbm5lY3Rpb24ucGVlcl9pZCxcXFxcbiAgICAgICAgICBfcm5hbWU6IGFPYmplY3QuY29uc3RydWN0b3IgJiYgYU9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lIHx8IGNpZCxcXFxcbiAgICAgICAgICBfcnZhbHVlOiBjaWRcXFxcbiAgICAgICAgfTtcXFxcbiAgICAgIH1cXFxcblxcXFxuICAgICAgcmV0dXJuIGJPYmplY3Q7XFxcXG4gICAgfSAvLyBza2lwIGlmIGFscmVhZHkgZW5jb2RlZFxcXFxuXFxcXG5cXFxcbiAgICBpZiAoYU9iamVjdC5jb25zdHJ1Y3RvciBpbnN0YW5jZW9mIE9iamVjdCAmJiBhT2JqZWN0Ll9ydHlwZSkge1xcXFxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBpbnRlcmZhY2UgZnVuY3Rpb25zIGFyZSBlbmNvZGVkXFxcXG4gICAgICBpZiAoYU9iamVjdC5fcmludGYpIHtcXFxcbiAgICAgICAgY29uc3QgdGVtcCA9IGFPYmplY3QuX3J0eXBlO1xcXFxuICAgICAgICBkZWxldGUgYU9iamVjdC5fcnR5cGU7XFxcXG4gICAgICAgIGJPYmplY3QgPSBhd2FpdCB0aGlzLl9lbmNvZGUoYU9iamVjdCwgYXNJbnRlcmZhY2UsIG9iamVjdElkKTtcXFxcbiAgICAgICAgYk9iamVjdC5fcnR5cGUgPSB0ZW1wO1xcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XFxcXG4gICAgICB9XFxcXG5cXFxcbiAgICAgIHJldHVybiBiT2JqZWN0O1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTtcXFxcbiAgICBjb25zdCBfdHJhbnNmZXIgPSBhT2JqZWN0Ll90cmFuc2ZlcjtcXFxcbiAgICBjb25zdCBpc2FycmF5ID0gQXJyYXkuaXNBcnJheShhT2JqZWN0KTtcXFxcblxcXFxuICAgIGZvciAobGV0IHRwIG9mIE9iamVjdC5rZXlzKHRoaXMuX2NvZGVjcykpIHtcXFxcbiAgICAgIGNvbnN0IGNvZGVjID0gdGhpcy5fY29kZWNzW3RwXTtcXFxcblxcXFxuICAgICAgaWYgKGNvZGVjLmVuY29kZXIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIGNvZGVjLnR5cGUpIHtcXFxcbiAgICAgICAgLy8gVE9ETzogd2hhdCBpZiBtdWx0aXBsZSBlbmNvZGVycyBmb3VuZFxcXFxuICAgICAgICBjb25zdCBlbmNvZGVkT2JqID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGNvZGVjLmVuY29kZXIoYU9iamVjdCkpO1xcXFxuICAgICAgICBpZiAoZW5jb2RlZE9iaiAmJiAhZW5jb2RlZE9iai5fcnR5cGUpIGVuY29kZWRPYmouX3J0eXBlID0gY29kZWMubmFtZTsgLy8gZW5jb2RlIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGludGVyZmFjZSBvYmplY3RcXFxcblxcXFxuICAgICAgICBpZiAoZW5jb2RlZE9iaiAmJiBlbmNvZGVkT2JqLl9yaW50Zikge1xcXFxuICAgICAgICAgIGNvbnN0IHRlbXAgPSBlbmNvZGVkT2JqLl9ydHlwZTtcXFxcbiAgICAgICAgICBkZWxldGUgZW5jb2RlZE9iai5fcnR5cGU7XFxcXG4gICAgICAgICAgZW5jb2RlZE9iaiA9IGF3YWl0IHRoaXMuX2VuY29kZShlbmNvZGVkT2JqLCBhc0ludGVyZmFjZSwgb2JqZWN0SWQpO1xcXFxuICAgICAgICAgIGVuY29kZWRPYmouX3J0eXBlID0gdGVtcDtcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGJPYmplY3QgPSBlbmNvZGVkT2JqO1xcXFxuICAgICAgICByZXR1cm4gYk9iamVjdDtcXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG5cXFxcbiAgICBpZiAoXFxcXG4gICAgLypnbG9iYWwgdGYqL1xcXFxuICAgIHR5cGVvZiB0ZiAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiB0Zi5UZW5zb3IgJiYgYU9iamVjdCBpbnN0YW5jZW9mIHRmLlRlbnNvcikge1xcXFxuICAgICAgY29uc3Qgdl9idWZmZXIgPSBhT2JqZWN0LmRhdGFTeW5jKCk7XFxcXG5cXFxcbiAgICAgIGlmIChhT2JqZWN0Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcXFxcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHZfYnVmZmVyLmJ1ZmZlcik7XFxcXG4gICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll90cmFuc2ZlcjtcXFxcbiAgICAgIH1cXFxcblxcXFxuICAgICAgYk9iamVjdCA9IHtcXFxcbiAgICAgICAgX3J0eXBlOiBcXFxcXFxcIm5kYXJyYXlcXFxcXFxcIixcXFxcbiAgICAgICAgX3J2YWx1ZTogdl9idWZmZXIuYnVmZmVyLFxcXFxuICAgICAgICBfcnNoYXBlOiBhT2JqZWN0LnNoYXBlLFxcXFxuICAgICAgICBfcmR0eXBlOiBhT2JqZWN0LmR0eXBlXFxcXG4gICAgICB9O1xcXFxuICAgIH0gZWxzZSBpZiAoXFxcXG4gICAgLypnbG9iYWwgbmoqL1xcXFxuICAgIHR5cGVvZiBuaiAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiBuai5OZEFycmF5ICYmIGFPYmplY3QgaW5zdGFuY2VvZiBuai5OZEFycmF5KSB7XFxcXG4gICAgICB2YXIgZHR5cGUgPSBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcInR5cGVkQXJyYXlUb0R0eXBlXFxcXFxcXCJdW2FPYmplY3Quc2VsZWN0aW9uLmRhdGEuY29uc3RydWN0b3IubmFtZV07XFxcXG5cXFxcbiAgICAgIGlmIChhT2JqZWN0Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcXFxcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGFPYmplY3Quc2VsZWN0aW9uLmRhdGEuYnVmZmVyKTtcXFxcbiAgICAgICAgZGVsZXRlIGFPYmplY3QuX3RyYW5zZmVyO1xcXFxuICAgICAgfVxcXFxuXFxcXG4gICAgICBiT2JqZWN0ID0ge1xcXFxuICAgICAgICBfcnR5cGU6IFxcXFxcXFwibmRhcnJheVxcXFxcXFwiLFxcXFxuICAgICAgICBfcnZhbHVlOiBhT2JqZWN0LnNlbGVjdGlvbi5kYXRhLmJ1ZmZlcixcXFxcbiAgICAgICAgX3JzaGFwZTogYU9iamVjdC5zaGFwZSxcXFxcbiAgICAgICAgX3JkdHlwZTogZHR5cGVcXFxcbiAgICAgIH07XFxcXG4gICAgfSBlbHNlIGlmIChhT2JqZWN0IGluc3RhbmNlb2YgRXJyb3IpIHtcXFxcbiAgICAgIGNvbnNvbGUuZXJyb3IoYU9iamVjdCk7XFxcXG4gICAgICBiT2JqZWN0ID0ge1xcXFxuICAgICAgICBfcnR5cGU6IFxcXFxcXFwiZXJyb3JcXFxcXFxcIixcXFxcbiAgICAgICAgX3J2YWx1ZTogYU9iamVjdC50b1N0cmluZygpXFxcXG4gICAgICB9O1xcXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIEZpbGUpIHtcXFxcbiAgICAgIGJPYmplY3QgPSB7XFxcXG4gICAgICAgIF9ydHlwZTogXFxcXFxcXCJmaWxlXFxcXFxcXCIsXFxcXG4gICAgICAgIF9ydmFsdWU6IGFPYmplY3QsXFxcXG4gICAgICAgIF9ycGF0aDogYU9iamVjdC5fcGF0aCB8fCBhT2JqZWN0LndlYmtpdFJlbGF0aXZlUGF0aFxcXFxuICAgICAgfTtcXFxcbiAgICB9IC8vIHNlbmQgb2JqZWN0cyBzdXBwb3J0ZWQgYnkgc3RydWN0dXJlIGNsb25lIGFsZ29yaXRobVxcXFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfV29ya2Vyc19BUEkvU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG1cXFxcbiAgICBlbHNlIGlmIChhT2JqZWN0ICE9PSBPYmplY3QoYU9iamVjdCkgfHwgYU9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4gfHwgYU9iamVjdCBpbnN0YW5jZW9mIFN0cmluZyB8fCBhT2JqZWN0IGluc3RhbmNlb2YgRGF0ZSB8fCBhT2JqZWN0IGluc3RhbmNlb2YgUmVnRXhwIHx8IGFPYmplY3QgaW5zdGFuY2VvZiBJbWFnZURhdGEgfHwgdHlwZW9mIEZpbGVMaXN0ICE9PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiICYmIGFPYmplY3QgaW5zdGFuY2VvZiBGaWxlTGlzdCkge1xcXFxuICAgICAgICBiT2JqZWN0ID0gYU9iamVjdDsgLy8gVE9ETzogYXZvaWQgb2JqZWN0IHN1Y2ggYXMgRHluYW1pY1BsdWdpbiBpbnN0YW5jZS5cXFxcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIEZpbGUpIHtcXFxcbiAgICAgICAgYk9iamVjdCA9IHtcXFxcbiAgICAgICAgICBfcnR5cGU6IFxcXFxcXFwiZmlsZVxcXFxcXFwiLFxcXFxuICAgICAgICAgIF9ybmFtZTogYU9iamVjdC5uYW1lLFxcXFxuICAgICAgICAgIF9ybWltZTogYU9iamVjdC50eXBlLFxcXFxuICAgICAgICAgIF9ydmFsdWU6IGFPYmplY3QsXFxcXG4gICAgICAgICAgX3JwYXRoOiBhT2JqZWN0Ll9wYXRoIHx8IGFPYmplY3Qud2Via2l0UmVsYXRpdmVQYXRoXFxcXG4gICAgICAgIH07XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QgaW5zdGFuY2VvZiBCbG9iKSB7XFxcXG4gICAgICAgIGJPYmplY3QgPSB7XFxcXG4gICAgICAgICAgX3J0eXBlOiBcXFxcXFxcImJsb2JcXFxcXFxcIixcXFxcbiAgICAgICAgICBfcnZhbHVlOiBhT2JqZWN0XFxcXG4gICAgICAgIH07XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclZpZXcpIHtcXFxcbiAgICAgICAgaWYgKGFPYmplY3QuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xcXFxuICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChhT2JqZWN0LmJ1ZmZlcik7XFxcXG4gICAgICAgICAgZGVsZXRlIGFPYmplY3QuX3RyYW5zZmVyO1xcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgY29uc3QgZHR5cGUgPSBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcInR5cGVkQXJyYXlUb0R0eXBlXFxcXFxcXCJdW2FPYmplY3QuY29uc3RydWN0b3IubmFtZV07XFxcXG4gICAgICAgIGJPYmplY3QgPSB7XFxcXG4gICAgICAgICAgX3J0eXBlOiBcXFxcXFxcInR5cGVkYXJyYXlcXFxcXFxcIixcXFxcbiAgICAgICAgICBfcnZhbHVlOiBhT2JqZWN0LmJ1ZmZlcixcXFxcbiAgICAgICAgICBfcmR0eXBlOiBkdHlwZVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0IGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcXFxcbiAgICAgICAgaWYgKGFPYmplY3QuX3RyYW5zZmVyIHx8IF90cmFuc2Zlcikge1xcXFxuICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChhT2JqZWN0LmJ1ZmZlcik7XFxcXG4gICAgICAgICAgZGVsZXRlIGFPYmplY3QuX3RyYW5zZmVyO1xcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgYk9iamVjdCA9IHtcXFxcbiAgICAgICAgICBfcnR5cGU6IFxcXFxcXFwibWVtb3J5dmlld1xcXFxcXFwiLFxcXFxuICAgICAgICAgIF9ydmFsdWU6IGFPYmplY3QuYnVmZmVyXFxcXG4gICAgICAgIH07XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QgaW5zdGFuY2VvZiBTZXQpIHtcXFxcbiAgICAgICAgYk9iamVjdCA9IHtcXFxcbiAgICAgICAgICBfcnR5cGU6IFxcXFxcXFwic2V0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgX3J2YWx1ZTogYXdhaXQgdGhpcy5fZW5jb2RlKEFycmF5LmZyb20oYU9iamVjdCksIGFzSW50ZXJmYWNlKVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0IGluc3RhbmNlb2YgTWFwKSB7XFxcXG4gICAgICAgIGJPYmplY3QgPSB7XFxcXG4gICAgICAgICAgX3J0eXBlOiBcXFxcXFxcIm9yZGVyZWRtYXBcXFxcXFxcIixcXFxcbiAgICAgICAgICBfcnZhbHVlOiBhd2FpdCB0aGlzLl9lbmNvZGUoQXJyYXkuZnJvbShhT2JqZWN0KSwgYXNJbnRlcmZhY2UpXFxcXG4gICAgICAgIH07XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuY29uc3RydWN0b3IgaW5zdGFuY2VvZiBPYmplY3QgfHwgQXJyYXkuaXNBcnJheShhT2JqZWN0KSkge1xcXFxuICAgICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XFxcXG4gICAgICAgIGxldCBrZXlzOyAvLyBhbiBvYmplY3QvYXJyYXlcXFxcblxcXFxuICAgICAgICBpZiAoYU9iamVjdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IEFycmF5LmlzQXJyYXkoYU9iamVjdCkpIHtcXFxcbiAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoYU9iamVjdCk7XFxcXG4gICAgICAgIH0gLy8gYSBjbGFzc1xcXFxuICAgICAgICBlbHNlIGlmIChhT2JqZWN0LmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xcXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwiUGxlYXNlIGluc3RhbnRpYXRlIHRoZSBjbGFzcyBiZWZvcmUgZXhwb3J0dGluZyBpdC5cXFxcXFxcIik7XFxcXG4gICAgICAgICAgfSAvLyBpbnN0YW5jZSBvZiBhIGNsYXNzXFxcXG4gICAgICAgICAgZWxzZSBpZiAoYU9iamVjdC5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcXFxcbiAgICAgICAgICAgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihhT2JqZWN0KSkuY29uY2F0KE9iamVjdC5rZXlzKGFPYmplY3QpKTsgLy8gVE9ETzogdXNlIGEgcHJveHkgb2JqZWN0IHRvIHJlcHJlc2VudCB0aGUgYWN0dWFsIG9iamVjdFxcXFxuICAgICAgICAgICAgICAvLyBhbHdheXMgZW5jb2RlIGNsYXNzIGluc3RhbmNlIGFzIGludGVyZmFjZVxcXFxuXFxcXG4gICAgICAgICAgICAgIGFzSW50ZXJmYWNlID0gdHJ1ZTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxcXFxcXFwiVW5zdXBwb3J0ZWQgaW50ZXJmYWNlIHR5cGVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICB9IC8vIGVuY29kZSBpbnRlcmZhY2VzXFxcXG5cXFxcblxcXFxuICAgICAgICBpZiAoYU9iamVjdC5fcmludGYgfHwgYXNJbnRlcmZhY2UpIHtcXFxcbiAgICAgICAgICBpZiAoIW9iamVjdElkKSB7XFxcXG4gICAgICAgICAgICBvYmplY3RJZCA9IE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFxcXFxcInJhbmRJZFxcXFxcXFwiXSkoKTtcXFxcbiAgICAgICAgICAgIHRoaXMuX29iamVjdF9zdG9yZVtvYmplY3RJZF0gPSBhT2JqZWN0O1xcXFxuICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgIGZvciAobGV0IGsgb2Yga2V5cykge1xcXFxuICAgICAgICAgICAgaWYgKGsgPT09IFxcXFxcXFwiY29uc3RydWN0b3JcXFxcXFxcIikgY29udGludWU7XFxcXG5cXFxcbiAgICAgICAgICAgIGlmIChrLnN0YXJ0c1dpdGgoXFxcXFxcXCJfXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICBiT2JqZWN0W2tdID0gYXdhaXQgdGhpcy5fZW5jb2RlKGFPYmplY3Rba10sIHR5cGVvZiBhc0ludGVyZmFjZSA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIiA/IGFzSW50ZXJmYWNlICsgXFxcXFxcXCIuXFxcXFxcXCIgKyBrIDogaywgb2JqZWN0SWQpO1xcXFxuICAgICAgICAgIH0gLy8gb2JqZWN0IGlkIGZvciBkaXNwb3NlIHRoZSBvYmplY3QgcmVtb3RlbHlcXFxcblxcXFxuXFxcXG4gICAgICAgICAgYk9iamVjdC5fcmludGYgPSBvYmplY3RJZDsgLy8gcmVtb3ZlIGludGVyZmFjZSB3aGVuIGNsb3NlZFxcXFxuXFxcXG4gICAgICAgICAgaWYgKGFPYmplY3Qub24gJiYgdHlwZW9mIGFPYmplY3Qub24gPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgYU9iamVjdC5vbihcXFxcXFxcImNsb3NlXFxcXFxcXCIsICgpID0+IHtcXFxcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX29iamVjdF9zdG9yZVtvYmplY3RJZF07XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgZm9yIChsZXQgayBvZiBrZXlzKSB7XFxcXG4gICAgICAgICAgICBpZiAoW1xcXFxcXFwiaGFzT3duUHJvcGVydHlcXFxcXFxcIiwgXFxcXFxcXCJjb25zdHJ1Y3RvclxcXFxcXFwiXS5pbmNsdWRlcyhrKSkgY29udGludWU7XFxcXG4gICAgICAgICAgICBiT2JqZWN0W2tdID0gYXdhaXQgdGhpcy5fZW5jb2RlKGFPYmplY3Rba10pO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfSAvLyBmb3IgZXhhbXBsZSwgYnJvd3NlckZTIG9iamVjdFxcXFxuXFxcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhT2JqZWN0ID09PSBcXFxcXFxcIm9iamVjdFxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoYU9iamVjdCkpLmNvbmNhdChPYmplY3Qua2V5cyhhT2JqZWN0KSk7XFxcXG4gICAgICAgIGNvbnN0IG9iamVjdElkID0gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXFxcXFwicmFuZElkXFxcXFxcXCJdKSgpO1xcXFxuXFxcXG4gICAgICAgIGZvciAobGV0IGsgb2Yga2V5cykge1xcXFxuICAgICAgICAgIGlmIChbXFxcXFxcXCJoYXNPd25Qcm9wZXJ0eVxcXFxcXFwiLCBcXFxcXFxcImNvbnN0cnVjdG9yXFxcXFxcXCJdLmluY2x1ZGVzKGspKSBjb250aW51ZTsgLy8gZW5jb2RlIGFzIGludGVyZmFjZVxcXFxuXFxcXG4gICAgICAgICAgYk9iamVjdFtrXSA9IGF3YWl0IHRoaXMuX2VuY29kZShhT2JqZWN0W2tdLCBrLCBiT2JqZWN0KTtcXFxcbiAgICAgICAgfSAvLyBvYmplY3QgaWQsIHVzZWQgZm9yIGRpc3Bvc2UgdGhlIG9iamVjdFxcXFxuXFxcXG5cXFxcbiAgICAgICAgYk9iamVjdC5fcmludGYgPSBvYmplY3RJZDtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHRocm93IFxcXFxcXFwiaW1qb3ktcnBjOiBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6XFxcXFxcXCIgKyBhT2JqZWN0O1xcXFxuICAgICAgfVxcXFxuXFxcXG4gICAgaWYgKHRyYW5zZmVyYWJsZXMubGVuZ3RoID4gMCkge1xcXFxuICAgICAgYk9iamVjdC5fX3RyYW5zZmVyYWJsZXNfXyA9IHRyYW5zZmVyYWJsZXM7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgaWYgKCFiT2JqZWN0KSB7XFxcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJGYWlsZWQgdG8gZW5jb2RlIG9iamVjdFxcXFxcXFwiKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICByZXR1cm4gYk9iamVjdDtcXFxcbiAgfVxcXFxuXFxcXG4gIGFzeW5jIF9kZWNvZGUoYU9iamVjdCwgd2l0aFByb21pc2UpIHtcXFxcbiAgICBpZiAoIWFPYmplY3QpIHtcXFxcbiAgICAgIHJldHVybiBhT2JqZWN0O1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHZhciBiT2JqZWN0LCB2LCBrO1xcXFxuXFxcXG4gICAgaWYgKGFPYmplY3RbXFxcXFxcXCJfcnR5cGVcXFxcXFxcIl0pIHtcXFxcbiAgICAgIGlmICh0aGlzLl9jb2RlY3NbYU9iamVjdC5fcnR5cGVdICYmIHRoaXMuX2NvZGVjc1thT2JqZWN0Ll9ydHlwZV0uZGVjb2Rlcikge1xcXFxuICAgICAgICBpZiAoYU9iamVjdC5fcmludGYpIHtcXFxcbiAgICAgICAgICBjb25zdCB0ZW1wID0gYU9iamVjdC5fcnR5cGU7XFxcXG4gICAgICAgICAgZGVsZXRlIGFPYmplY3QuX3J0eXBlO1xcXFxuICAgICAgICAgIGFPYmplY3QgPSBhd2FpdCB0aGlzLl9kZWNvZGUoYU9iamVjdCwgd2l0aFByb21pc2UpO1xcXFxuICAgICAgICAgIGFPYmplY3QuX3J0eXBlID0gdGVtcDtcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGJPYmplY3QgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUodGhpcy5fY29kZWNzW2FPYmplY3QuX3J0eXBlXS5kZWNvZGVyKGFPYmplY3QpKTtcXFxcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFxcXFxcXFwiY2FsbGJhY2tcXFxcXFxcIikge1xcXFxuICAgICAgICBiT2JqZWN0ID0gdGhpcy5fZ2VuUmVtb3RlQ2FsbGJhY2soYU9iamVjdC5fcnRhcmdldF9pZCwgYU9iamVjdC5fcnZhbHVlLCB3aXRoUHJvbWlzZSk7XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcImludGVyZmFjZVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGJPYmplY3QgPSB0aGlzLl9nZW5SZW1vdGVNZXRob2QoYU9iamVjdC5fcnRhcmdldF9pZCwgYU9iamVjdC5fcnZhbHVlLCBhT2JqZWN0Ll9yaW50Zik7XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcIm5kYXJyYXlcXFxcXFxcIikge1xcXFxuICAgICAgICAvKmdsb2JhbCBuaiB0ZiovXFxcXG4gICAgICAgIC8vY3JlYXRlIGJ1aWxkIGFycmF5L3RlbnNvciBpZiB1c2VkIGluIHRoZSBwbHVnaW5cXFxcbiAgICAgICAgaWYgKHR5cGVvZiBuaiAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiBuai5hcnJheSkge1xcXFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFPYmplY3QuX3J2YWx1ZSkpIHtcXFxcbiAgICAgICAgICAgIGFPYmplY3QuX3J2YWx1ZSA9IGFPYmplY3QuX3J2YWx1ZS5yZWR1Y2UoX2FwcGVuZEJ1ZmZlcik7XFxcXG4gICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgYk9iamVjdCA9IG5qLmFycmF5KG5ldyBVaW50OChhT2JqZWN0Ll9ydmFsdWUpLCBhT2JqZWN0Ll9yZHR5cGUpLnJlc2hhcGUoYU9iamVjdC5fcnNoYXBlKTtcXFxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGYgIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgdGYuVGVuc29yKSB7XFxcXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYU9iamVjdC5fcnZhbHVlKSkge1xcXFxuICAgICAgICAgICAgYU9iamVjdC5fcnZhbHVlID0gYU9iamVjdC5fcnZhbHVlLnJlZHVjZShfYXBwZW5kQnVmZmVyKTtcXFxcbiAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICBjb25zdCBhcnJheXR5cGUgPSBldmFsKF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXFxcXFwiZHR5cGVUb1R5cGVkQXJyYXlcXFxcXFxcIl1bYU9iamVjdC5fcmR0eXBlXSk7XFxcXG4gICAgICAgICAgYk9iamVjdCA9IHRmLnRlbnNvcihuZXcgYXJyYXl0eXBlKGFPYmplY3QuX3J2YWx1ZSksIGFPYmplY3QuX3JzaGFwZSwgYU9iamVjdC5fcmR0eXBlKTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAvL2tlZXAgaXQgYXMgcmVndWxhciBpZiB0cmFuc2ZlcmVkIHRvIHRoZSBtYWluIGFwcFxcXFxuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcImVycm9yXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgYk9iamVjdCA9IG5ldyBFcnJvcihhT2JqZWN0Ll9ydmFsdWUpO1xcXFxuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXFxcXFxcXCJmaWxlXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgaWYgKGFPYmplY3QuX3J2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpIHtcXFxcbiAgICAgICAgICBiT2JqZWN0ID0gYU9iamVjdC5fcnZhbHVlOyAvL3BhdGNoIF9wYXRoXFxcXG5cXFxcbiAgICAgICAgICBiT2JqZWN0Ll9wYXRoID0gYU9iamVjdC5fcnBhdGg7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgYk9iamVjdCA9IG5ldyBGaWxlKFthT2JqZWN0Ll9ydmFsdWVdLCBhT2JqZWN0Ll9ybmFtZSwge1xcXFxuICAgICAgICAgICAgdHlwZTogYU9iamVjdC5fcm1pbWVcXFxcbiAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICBiT2JqZWN0Ll9wYXRoID0gYU9iamVjdC5fcnBhdGg7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFxcXFxcXFwidHlwZWRhcnJheVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGNvbnN0IGFycmF5dHlwZSA9IGV2YWwoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcXFxcXCJkdHlwZVRvVHlwZWRBcnJheVxcXFxcXFwiXVthT2JqZWN0Ll9yZHR5cGVdKTtcXFxcbiAgICAgICAgaWYgKCFhcnJheXR5cGUpIHRocm93IG5ldyBFcnJvcihcXFxcXFxcInVuc3VwcG9ydGVkIGR0eXBlOiBcXFxcXFxcIiArIGFPYmplY3QuX3JkdHlwZSk7XFxcXG4gICAgICAgIGJPYmplY3QgPSBuZXcgYXJyYXl0eXBlKGFPYmplY3QuX3J2YWx1ZSk7XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcIm1lbW9yeXZpZXdcXFxcXFxcIikge1xcXFxuICAgICAgICBiT2JqZWN0ID0gbmV3IERhdGFWaWV3KGFPYmplY3QuX3J2YWx1ZSk7XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcImJsb2JcXFxcXFxcIikge1xcXFxuICAgICAgICBpZiAoYU9iamVjdC5fcnZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xcXFxuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0Ll9ydmFsdWU7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgYk9iamVjdCA9IG5ldyBCbG9iKFthT2JqZWN0Ll9ydmFsdWVdLCB7XFxcXG4gICAgICAgICAgICB0eXBlOiBhT2JqZWN0Ll9ybWltZVxcXFxuICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcIm9yZGVyZWRtYXBcXFxcXFxcIikge1xcXFxuICAgICAgICBiT2JqZWN0ID0gbmV3IE1hcCgoYXdhaXQgdGhpcy5fZGVjb2RlKGFPYmplY3QuX3J2YWx1ZSwgd2l0aFByb21pc2UpKSk7XFxcXG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcXFxcXFxcInNldFxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGJPYmplY3QgPSBuZXcgU2V0KChhd2FpdCB0aGlzLl9kZWNvZGUoYU9iamVjdC5fcnZhbHVlLCB3aXRoUHJvbWlzZSkpKTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIGludGVyZmFjZSBmdW5jdGlvbnMgYXJlIGRlY29kZWRcXFxcbiAgICAgICAgaWYgKGFPYmplY3QuX3JpbnRmKSB7XFxcXG4gICAgICAgICAgY29uc3QgdGVtcCA9IGFPYmplY3QuX3J0eXBlO1xcXFxuICAgICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll9ydHlwZTtcXFxcbiAgICAgICAgICBhT2JqZWN0ID0gYXdhaXQgdGhpcy5fZGVjb2RlKGFPYmplY3QsIHdpdGhQcm9taXNlKTtcXFxcbiAgICAgICAgICBhT2JqZWN0Ll9ydHlwZSA9IHRlbXA7XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICBiT2JqZWN0ID0gYU9iamVjdDtcXFxcbiAgICAgIH1cXFxcbiAgICB9IGVsc2UgaWYgKGFPYmplY3QuY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCBBcnJheS5pc0FycmF5KGFPYmplY3QpKSB7XFxcXG4gICAgICB2YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkoYU9iamVjdCk7XFxcXG4gICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XFxcXG5cXFxcbiAgICAgIGZvciAoayBpbiBhT2JqZWN0KSB7XFxcXG4gICAgICAgIGlmIChpc2FycmF5IHx8IGFPYmplY3QuaGFzT3duUHJvcGVydHkoaykpIHtcXFxcbiAgICAgICAgICB2ID0gYU9iamVjdFtrXTtcXFxcbiAgICAgICAgICBiT2JqZWN0W2tdID0gYXdhaXQgdGhpcy5fZGVjb2RlKHYsIHdpdGhQcm9taXNlKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfVxcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICBiT2JqZWN0ID0gYU9iamVjdDtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBpZiAoYk9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XFxcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJGYWlsZWQgdG8gZGVjb2RlIG9iamVjdFxcXFxcXFwiKTtcXFxcbiAgICB9IC8vIHN0b3JlIHRoZSBvYmplY3QgaWQgZm9yIGRpc3Bvc2VcXFxcblxcXFxuXFxcXG4gICAgaWYgKGFPYmplY3QuX3JpbnRmKSB7XFxcXG4gICAgICB0aGlzLl9vYmplY3Rfd2Vha21hcC5zZXQoYk9iamVjdCwgYU9iamVjdC5fcmludGYpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHJldHVybiBiT2JqZWN0O1xcXFxuICB9XFxcXG5cXFxcbiAgYXN5bmMgX3dyYXAoYXJncywgYXNJbnRlcmZhY2UpIHtcXFxcbiAgICB2YXIgd3JhcHBlZCA9IGF3YWl0IHRoaXMuX2VuY29kZShhcmdzLCBhc0ludGVyZmFjZSk7XFxcXG4gICAgcmV0dXJuIHdyYXBwZWQ7XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFVud3JhcHMgdGhlIHNldCBvZiBhcmd1bWVudHMgZGVsaXZlcmVkIGZyb20gdGhlIHJlbW90ZSBzaXRlLFxcXFxuICAgKiByZXBsYWNlcyBhbGwgY2FsbGJhY2sgaWRlbnRpZmllcnMgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHdpbGxcXFxcbiAgICogaW5pdGlhdGUgc2VuZGluZyB0aGF0IGNhbGxiYWNrIGlkZW50aWZpZXIgYmFjayB0byBvdGhlciBzaXRlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIHRvIHVud3JhcFxcXFxuICAgKlxcXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhQcm9taXNlIGlzIHRydWUgbWVhbnMgdGhpcyB0aGUgY2FsbGJhY2sgc2hvdWxkIGNvbnRhaW4gYSBwcm9taXNlXFxcXG4gICAqXFxcXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdW53cmFwcGVkIGFyZ3NcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBhc3luYyBfdW53cmFwKGFyZ3MsIHdpdGhQcm9taXNlKSB7XFxcXG4gICAgdmFyIHJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlY29kZShhcmdzLCB3aXRoUHJvbWlzZSk7XFxcXG4gICAgcmV0dXJuIHJlc3VsdDtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogR2VuZXJhdGVzIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gYSBzaW5nbGUgcmVtb3RlXFxcXG4gICAqIGNhbGxiYWNrLiBXaGVuIHRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgY2FsbGVkLCBpdCB3aWxsIHNlbmRcXFxcbiAgICogdGhlIGNvcnJlc3BvbmRpbmcgbWVzc2FnZSB0byB0aGUgcmVtb3RlIHNpdGUgYXNraW5nIGl0IHRvXFxcXG4gICAqIGV4ZWN1dGUgdGhlIHBhcnRpY3VsYXIgY2FsbGJhY2sgcHJldmlvdXNseSBzYXZlZCBkdXJpbmcgYSBjYWxsXFxcXG4gICAqIGJ5IHRoZSByZW1vdGUgc2l0ZSBhIG1ldGhvZCBmcm9tIHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBzaXRlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBvZiB0aGUgcmVtb3RlIGNhbGxiYWNrIHRvIGV4ZWN1dGVcXFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ051bSBhcmd1bWVudCBpbmRleCBvZiB0aGUgY2FsbGJhY2tcXFxcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aXRoUHJvbWlzZSBpcyB0cnVlIG1lYW5zIHRoaXMgdGhlIGNhbGxiYWNrIHNob3VsZCBjb250YWluIGEgcHJvbWlzZVxcXFxuICAgKlxcXFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgcmVtb3RlIGNhbGxiYWNrXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgX2dlblJlbW90ZUNhbGxiYWNrKHRhcmdldElkLCBjaWQsIHdpdGhQcm9taXNlKSB7XFxcXG4gICAgdmFyIG1lID0gdGhpcztcXFxcbiAgICB2YXIgcmVtb3RlQ2FsbGJhY2s7XFxcXG5cXFxcbiAgICBpZiAod2l0aFByb21pc2UpIHtcXFxcbiAgICAgIHJlbW90ZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xcXFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xcXFxuICAgICAgICAgIHZhciBhcmdzID0gYXdhaXQgbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XFxcXG4gICAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBhcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcXFxcbiAgICAgICAgICBjb25zdCBlbmNvZGVkUHJvbWlzZSA9IGF3YWl0IG1lLl93cmFwKFtyZXNvbHZlLCByZWplY3RdKTsgLy8gc3RvcmUgdGhlIGtleSBpZCBmb3IgcmVtb3ZpbmcgdGhlbSBmcm9tIHRoZSByZWZlcmVuY2Ugc3RvcmUgdG9nZXRoZXJcXFxcblxcXFxuICAgICAgICAgIHJlc29sdmUuX19wcm9taXNlX3BhaXIgPSBlbmNvZGVkUHJvbWlzZVsxXS5fcnZhbHVlO1xcXFxuICAgICAgICAgIHJlamVjdC5fX3Byb21pc2VfcGFpciA9IGVuY29kZWRQcm9taXNlWzBdLl9ydmFsdWU7XFxcXG5cXFxcbiAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgbWUuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICAgICAgICAgIHR5cGU6IFxcXFxcXFwiY2FsbGJhY2tcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgdGFyZ2V0X2lkOiB0YXJnZXRJZCxcXFxcbiAgICAgICAgICAgICAgaWQ6IGNpZCxcXFxcbiAgICAgICAgICAgICAgYXJnczogYXJncyxcXFxcbiAgICAgICAgICAgICAgcHJvbWlzZTogZW5jb2RlZFByb21pc2VcXFxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpO1xcXFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGV4ZWN0dWUgcmVtb3RlIGNhbGxiYWNrICggaWQ6ICR7Y2lkfSkuYCk7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgIH07XFxcXG5cXFxcbiAgICAgIHJldHVybiByZW1vdGVDYWxsYmFjaztcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgcmVtb3RlQ2FsbGJhY2sgPSBhc3luYyBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICAgIHZhciBhcmdzID0gYXdhaXQgbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XFxcXG4gICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcXFxcbiAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMpIGRlbGV0ZSBhcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xcXFxuICAgICAgICByZXR1cm4gbWUuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICAgICAgdHlwZTogXFxcXFxcXCJjYWxsYmFja1xcXFxcXFwiLFxcXFxuICAgICAgICAgIHRhcmdldF9pZDogdGFyZ2V0SWQsXFxcXG4gICAgICAgICAgaWQ6IGNpZCxcXFxcbiAgICAgICAgICBhcmdzOiBhcmdzXFxcXG4gICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpO1xcXFxuICAgICAgfTtcXFxcblxcXFxuICAgICAgcmV0dXJuIHJlbW90ZUNhbGxiYWNrO1xcXFxuICAgIH1cXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogU2VuZHMgdGhlIG5vdGlmaWNhdGlvbiBtZXNzYWdlIGFuZCBicmVha3MgdGhlIGNvbm5lY3Rpb25cXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBkaXNjb25uZWN0KCkge1xcXFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XFxcXG4gICAgICB0eXBlOiBcXFxcXFxcImRpc2Nvbm5lY3RcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XFxcXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcXFxcbiAgICB9LCAyMDAwKTtcXFxcbiAgfVxcXFxuXFxcXG59XFxcXG4vKipcXFxcbiAqIFJlZmVyZW5jZVN0b3JlIGlzIGEgc3BlY2lhbCBvYmplY3Qgd2hpY2ggc3RvcmVzIG90aGVyIG9iamVjdHNcXFxcbiAqIGFuZCBwcm92aWRlcyB0aGUgcmVmZXJlbmNlcyAobnVtYmVyKSBpbnN0ZWFkLiBUaGlzIHJlZmVyZW5jZVxcXFxuICogbWF5IHRoZW4gYmUgc2VudCBvdmVyIGEganNvbi1iYXNlZCBjb21tdW5pY2F0aW9uIGNoYW5uZWwgKElQQ1xcXFxuICogdG8gYW5vdGhlciBOb2RlLmpzIHByb2Nlc3Mgb3IgYSBtZXNzYWdlIHRvIHRoZSBXb3JrZXIpLiBPdGhlclxcXFxuICogc2l0ZSBtYXkgdGhlbiBwcm92aWRlIHRoZSByZWZlcmVuY2UgaW4gdGhlIHJlc3BvbmNlIG1lc3NhZ2VcXFxcbiAqIGltcGx5aW5nIHRoZSBnaXZlbiBvYmplY3Qgc2hvdWxkIGJlIGFjdGl2YXRlZC5cXFxcbiAqXFxcXG4gKiBQcmltYXJ5IHVzYWdlIGZvciB0aGUgUmVmZXJlbmNlU3RvcmUgaXMgYSBzdG9yYWdlIGZvciB0aGVcXFxcbiAqIGNhbGxiYWNrcywgd2hpY2ggdGhlcmVmb3JlIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGluaXRpYXRlIGFcXFxcbiAqIGNhbGxiYWNrIGV4ZWN1dGlvbiBieSB0aGUgb3Bwb3NpdGUgc2l0ZSAod2hpY2ggbm9ybWFsbHkgY2Fubm90XFxcXG4gKiBkaXJlY3RseSBleGVjdXRlIGZ1bmN0aW9ucyBvdmVyIHRoZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwpLlxcXFxuICpcXFxcbiAqIEVhY2ggc3RvcmVkIG9iamVjdCBjYW4gb25seSBiZSBmZXRjaGVkIG9uY2UgYW5kIGlzIG5vdFxcXFxuICogYXZhaWxhYmxlIGZvciB0aGUgc2Vjb25kIHRpbWUuIEVhY2ggc3RvcmVkIG9iamVjdCBtdXN0IGJlXFxcXG4gKiBmZXRjaGVkLCBzaW5jZSBvdGhlcndpc2UgaXQgd2lsbCByZW1haW4gc3RvcmVkIGZvcmV2ZXIgYW5kXFxcXG4gKiBjb25zdW1lIG1lbW9yeS5cXFxcbiAqXFxcXG4gKiBTdG9yZWQgb2JqZWN0IGluZGVjZXMgYXJlIHNpbXBseSB0aGUgbnVtYmVycywgd2hpY2ggYXJlIGhvd2V2ZXJcXFxcbiAqIHJlbGVhc2VkIGFsb25nIHdpdGggdGhlIG9iamVjdHMsIGFuZCBhcmUgbGF0ZXIgcmV1c2VkIGFnYWluIChpblxcXFxuICogb3JkZXIgdG8gcG9zdHBvbmUgdGhlIG92ZXJmbG93LCB3aGljaCBzaG91bGQgbm90IGxpa2VseSBoYXBwZW4sXFxcXG4gKiBidXQgYW55d2F5KS5cXFxcbiAqL1xcXFxuXFxcXG5jbGFzcyBSZWZlcmVuY2VTdG9yZSB7XFxcXG4gIGNvbnN0cnVjdG9yKCkge1xcXFxuICAgIHRoaXMuX3N0b3JlID0ge307IC8vIHN0b3JlZCBvYmplY3RcXFxcblxcXFxuICAgIHRoaXMuX2luZGljZXMgPSBbMF07IC8vIHNtYWxsZXN0IGF2YWlsYWJsZSBpbmRpY2VzXFxcXG5cXFxcbiAgICB0aGlzLl9yZWFkeUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fTtcXFxcblxcXFxuICAgIHRoaXMuX2J1c3lIYW5kbGVyID0gZnVuY3Rpb24gKCkge307XFxcXG5cXFxcbiAgICB0aGlzLl9yZWFkeUhhbmRsZXIoKTtcXFxcbiAgfVxcXFxuICAvKipcXFxcbiAgICogY2FsbCBoYW5kbGVyIHdoZW4gdGhlIHN0b3JlIGlzIGVtcHR5XFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7RlVOQ1RJT059IGlkIG9mIGEgaGFuZGxlclxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIG9uUmVhZHkocmVhZHlIYW5kbGVyKSB7XFxcXG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyID0gcmVhZHlIYW5kbGVyIHx8IGZ1bmN0aW9uICgpIHt9O1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBjYWxsIGhhbmRsZXIgd2hlbiB0aGUgc3RvcmUgaXMgbm90IGVtcHR5XFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7RlVOQ1RJT059IGlkIG9mIGEgaGFuZGxlclxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIG9uQnVzeShidXN5SGFuZGxlcikge1xcXFxuICAgIHRoaXMuX2J1c3lIYW5kbGVyID0gYnVzeUhhbmRsZXIgfHwgZnVuY3Rpb24gKCkge307XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBzdG9yZVxcXFxuICAgKlxcXFxuICAgKi9cXFxcblxcXFxuXFxcXG4gIGdldFN0YWNrKCkge1xcXFxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdG9yZSkubGVuZ3RoO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBAZnVuY3Rpb24gX2dlbklkKCkgZ2VuZXJhdGVzIHRoZSBuZXcgcmVmZXJlbmNlIGlkXFxcXG4gICAqXFxcXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHNtYWxsZXN0IGF2YWlsYWJsZSBpZCBhbmQgcmVzZXJ2ZXMgaXRcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBfZ2VuSWQoKSB7XFxcXG4gICAgdmFyIGlkO1xcXFxuXFxcXG4gICAgaWYgKHRoaXMuX2luZGljZXMubGVuZ3RoID09PSAxKSB7XFxcXG4gICAgICBpZCA9IHRoaXMuX2luZGljZXNbMF0rKztcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgaWQgPSB0aGlzLl9pbmRpY2VzLnNoaWZ0KCk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgcmV0dXJuIGlkO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gcmVmZXJlbmNlIGlkIHNvIHRoYXQgaXQgd2lsbCBiZSBhdmFpbGFibGUgYnlcXFxcbiAgICogYW5vdGhlciBvYmplY3Qgc3RvcmVkXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCB0byByZWxlYXNlXFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgX3JlbGVhc2VJZChpZCkge1xcXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgaWYgKGlkIDwgdGhpcy5faW5kaWNlc1tpXSkge1xcXFxuICAgICAgICB0aGlzLl9pbmRpY2VzLnNwbGljZShpLCAwLCBpZCk7XFxcXG5cXFxcbiAgICAgICAgYnJlYWs7XFxcXG4gICAgICB9XFxcXG4gICAgfSAvLyBjbGVhbmluZy11cCB0aGUgc2VxdWVuY2UgdGFpbFxcXFxuXFxcXG5cXFxcbiAgICBmb3IgKGkgPSB0aGlzLl9pbmRpY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxcXG4gICAgICBpZiAodGhpcy5faW5kaWNlc1tpXSAtIDEgPT09IHRoaXMuX2luZGljZXNbaSAtIDFdKSB7XFxcXG4gICAgICAgIHRoaXMuX2luZGljZXMucG9wKCk7XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICBicmVhaztcXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG4gIH1cXFxcbiAgLyoqXFxcXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSByZWZlcm5jZSBpZCBpbnN0ZWFkXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdG8gc3RvcmVcXFxcbiAgICpcXFxcbiAgICogQHJldHVybnMge051bWJlcn0gcmVmZXJlbmNlIGlkIG9mIHRoZSBzdG9yZWQgb2JqZWN0XFxcXG4gICAqL1xcXFxuXFxcXG5cXFxcbiAgcHV0KG9iaikge1xcXFxuICAgIGlmICh0aGlzLl9idXN5SGFuZGxlciAmJiBPYmplY3Qua2V5cyh0aGlzLl9zdG9yZSkubGVuZ3RoID09PSAwKSB7XFxcXG4gICAgICB0aGlzLl9idXN5SGFuZGxlcigpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHZhciBpZCA9IHRoaXMuX2dlbklkKCk7XFxcXG5cXFxcbiAgICB0aGlzLl9zdG9yZVtpZF0gPSBvYmo7XFxcXG4gICAgcmV0dXJuIGlkO1xcXFxuICB9XFxcXG4gIC8qKlxcXFxuICAgKiBSZXRyaWV2ZXMgcHJldmlvdXNseSBzdG9yZWQgb2JqZWN0IGFuZCByZWxlYXNlcyBpdHMgcmVmZXJlbmNlXFxcXG4gICAqXFxcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBvZiBhbiBvYmplY3QgdG8gcmV0cmlldmVcXFxcbiAgICovXFxcXG5cXFxcblxcXFxuICBmZXRjaChpZCkge1xcXFxuICAgIHZhciBvYmogPSB0aGlzLl9zdG9yZVtpZF07XFxcXG5cXFxcbiAgICBpZiAob2JqICYmICFvYmouX19yZW1vdGVfbWV0aG9kKSB7XFxcXG4gICAgICBkZWxldGUgdGhpcy5fc3RvcmVbaWRdO1xcXFxuXFxcXG4gICAgICB0aGlzLl9yZWxlYXNlSWQoaWQpO1xcXFxuXFxcXG4gICAgICBpZiAodGhpcy5fcmVhZHlIYW5kbGVyICYmIE9iamVjdC5rZXlzKHRoaXMuX3N0b3JlKS5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgdGhpcy5fcmVhZHlIYW5kbGVyKCk7XFxcXG4gICAgICB9XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgaWYgKG9iaiAmJiBvYmouX19wcm9taXNlX3BhaXIpIHtcXFxcbiAgICAgIHRoaXMuZmV0Y2gob2JqLl9fcHJvbWlzZV9wYWlyKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICByZXR1cm4gb2JqO1xcXFxuICB9XFxcXG5cXFxcbn0vLyMgc291cmNlVVJMPVttb2R1bGVdXFxcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaUxpOXpjbU12Y25CakxtcHpMbXB6SWl3aWMyOTFjbU5sY3lJNld5SjNaV0p3WVdOck9pOHZhVzFxYjNsU1VFTXZMaTl6Y21NdmNuQmpMbXB6UHpNMU5XWWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpTHlvcVhHNGdLaUJEYjI1MFlXbHVjeUIwYUdVZ1VsQkRJRzlpYW1WamRDQjFjMlZrSUdKdmRHZ2dZbmtnZEdobElHRndjR3hwWTJGMGFXOXVYRzRnS2lCemFYUmxMQ0JoYm1RZ1lua2daV0ZqYUNCd2JIVm5hVzVjYmlBcUwxeHVhVzF3YjNKMElIdGNiaUFnY21GdVpFbGtMRnh1SUNCMGVYQmxaRUZ5Y21GNVZHOUVkSGx3WlN4Y2JpQWdaSFI1Y0dWVWIxUjVjR1ZrUVhKeVlYa3NYRzRnSUUxbGMzTmhaMlZGYldsMGRHVnlYRzU5SUdaeWIyMGdYQ0l1TDNWMGFXeHpMbXB6WENJN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCQlVFbGZWa1ZTVTBsUFRpQTlJRndpTUM0eUxqTmNJanRjYmx4dVkyOXVjM1FnUVhKeVlYbENkV1ptWlhKV2FXVjNJRDBnVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bUtGeHVJQ0JQWW1wbFkzUXVaMlYwVUhKdmRHOTBlWEJsVDJZb2JtVjNJRlZwYm5RNFFYSnlZWGtvS1NsY2Jpa3VZMjl1YzNSeWRXTjBiM0k3WEc1Y2JtWjFibU4wYVc5dUlGOWhjSEJsYm1SQ2RXWm1aWElvWW5WbVptVnlNU3dnWW5WbVptVnlNaWtnZTF4dUlDQmpiMjV6ZENCMGJYQWdQU0J1WlhjZ1ZXbHVkRGhCY25KaGVTaGlkV1ptWlhJeExtSjVkR1ZNWlc1bmRHZ2dLeUJpZFdabVpYSXlMbUo1ZEdWTVpXNW5kR2dwTzF4dUlDQjBiWEF1YzJWMEtHNWxkeUJWYVc1ME9FRnljbUY1S0dKMVptWmxjakVwTENBd0tUdGNiaUFnZEcxd0xuTmxkQ2h1WlhjZ1ZXbHVkRGhCY25KaGVTaGlkV1ptWlhJeUtTd2dZblZtWm1WeU1TNWllWFJsVEdWdVozUm9LVHRjYmlBZ2NtVjBkWEp1SUhSdGNDNWlkV1ptWlhJN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdsdVpHVjRUMkpxWldOMEtHOWlhaXdnYVhNcElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCcGN5QTlQU0JjSW5OMGNtbHVaMXdpS1NCeVpYUjFjbTRnYVc1a1pYaFBZbXBsWTNRb2IySnFMQ0JwY3k1emNHeHBkQ2hjSWk1Y0lpa3BPMXh1SUNCbGJITmxJR2xtSUNocGN5NXNaVzVuZEdnZ1BUMGdNQ2tnY21WMGRYSnVJRzlpYWp0Y2JpQWdaV3h6WlNCeVpYUjFjbTRnYVc1a1pYaFBZbXBsWTNRb2IySnFXMmx6V3pCZFhTd2dhWE11YzJ4cFkyVW9NU2twTzF4dWZWeHVYRzR2S2lwY2JpQXFJRkpRUXlCdlltcGxZM1FnY21Wd2NtVnpaVzUwY3lCaElITnBibWRzWlNCemFYUmxJR2x1SUhSb1pWeHVJQ29nWTI5dGJYVnVhV05oZEdsdmJpQndjbTkwYjJOdmJDQmlaWFIzWldWdUlIUm9aU0JoY0hCc2FXTmhkR2x2YmlCaGJtUWdkR2hsSUhCc2RXZHBibHh1SUNwY2JpQXFJRUJ3WVhKaGJTQjdUMkpxWldOMGZTQmpiMjV1WldOMGFXOXVJR0VnYzNCbFkybGhiQ0J2WW1wbFkzUWdZV3hzYjNkcGJtY2dkRzhnYzJWdVpGeHVJQ29nWVc1a0lISmxZMlZwZG1VZ2JXVnpjMkZuWlhNZ1puSnZiU0IwYUdVZ2IzQndiM05wZEdVZ2MybDBaU0FvWW1GemFXTmhiR3g1SUdsMFhHNGdLaUJ6YUc5MWJHUWdiMjVzZVNCd2NtOTJhV1JsSUhObGJtUW9LU0JoYm1RZ2IyNU5aWE56WVdkbEtDa2diV1YwYUc5a2N5bGNiaUFxTDF4dVpYaHdiM0owSUdOc1lYTnpJRkpRUXlCbGVIUmxibVJ6SUUxbGMzTmhaMlZGYldsMGRHVnlJSHRjYmlBZ1kyOXVjM1J5ZFdOMGIzSW9ZMjl1Ym1WamRHbHZiaXdnWTI5dVptbG5MQ0JqYjJSbFkzTXBJSHRjYmlBZ0lDQnpkWEJsY2loamIyNW1hV2NnSmlZZ1kyOXVabWxuTG1SbFluVm5LVHRjYmlBZ0lDQjBhR2x6TGw5amIyNXVaV04wYVc5dUlEMGdZMjl1Ym1WamRHbHZianRjYmlBZ0lDQjBhR2x6TG1OdmJtWnBaeUE5SUdOdmJtWnBaeUI4ZkNCN2ZUdGNiaUFnSUNCMGFHbHpMbDlqYjJSbFkzTWdQU0JqYjJSbFkzTWdmSHdnZTMwN1hHNGdJQ0FnZEdocGN5NWZiMkpxWldOMFgzTjBiM0psSUQwZ2UzMDdYRzRnSUNBZ2RHaHBjeTVmYldWMGFHOWtYM2RsWVd0dFlYQWdQU0J1WlhjZ1YyVmhhMDFoY0NncE8xeHVJQ0FnSUhSb2FYTXVYMjlpYW1WamRGOTNaV0ZyYldGd0lEMGdibVYzSUZkbFlXdE5ZWEFvS1R0Y2JpQWdJQ0IwYUdsekxsOXNiMk5oYkY5aGNHa2dQU0J1ZFd4c08xeHVJQ0FnSUM4dklHMWhhMlVnYzNWeVpTQjBhR1Z5WlNCcGN5QmhiaUJsZUdWamRYUmxJR1oxYm1OMGFXOXVYRzRnSUNBZ1kyOXVjM1FnYm1GdFpTQTlJSFJvYVhNdVkyOXVabWxuTG01aGJXVTdYRzRnSUNBZ2RHaHBjeTVmWTI5dWJtVmpkR2x2Ymk1bGVHVmpkWFJsSUQxY2JpQWdJQ0FnSUhSb2FYTXVYMk52Ym01bFkzUnBiMjR1WlhobFkzVjBaU0I4ZkZ4dUlDQWdJQ0FnWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loZ1kyOXVibVZqZEdsdmJpNWxlR1ZqZFhSbElHNXZkQ0JwYlhCc1pXMWxiblJsWkNBb2FXNGdYQ0lrZTI1aGJXVjlYQ0lwWUNrN1hHNGdJQ0FnSUNCOU8xeHVJQ0FnSUhSb2FYTXVYM04wYjNKbElEMGdibVYzSUZKbFptVnlaVzVqWlZOMGIzSmxLQ2s3WEc0Z0lDQWdkR2hwY3k1ZmJXVjBhRzlrWDNKbFpuTWdQU0J1WlhjZ1VtVm1aWEpsYm1ObFUzUnZjbVVvS1R0Y2JpQWdJQ0IwYUdsekxsOXRaWFJvYjJSZmNtVm1jeTV2YmxKbFlXUjVLQ2dwSUQwK0lIdGNiaUFnSUNBZ0lIUm9hWE11WDJacGNtVW9YQ0p5WlcxdmRHVkpaR3hsWENJcE8xeHVJQ0FnSUgwcE8xeHVJQ0FnSUhSb2FYTXVYMjFsZEdodlpGOXlaV1p6TG05dVFuVnplU2dvS1NBOVBpQjdYRzRnSUNBZ0lDQjBhR2x6TGw5bWFYSmxLRndpY21WdGIzUmxRblZ6ZVZ3aUtUdGNiaUFnSUNCOUtUdGNiaUFnSUNCMGFHbHpMbDl6WlhSMWNFMWxjM05oWjJWSVlXNXNaR1Z5Y3lncE8xeHVJQ0I5WEc1Y2JpQWdhVzVwZENncElIdGNiaUFnSUNCMGFHbHpMbDlqYjI1dVpXTjBhVzl1TG1WdGFYUW9lMXh1SUNBZ0lDQWdkSGx3WlRvZ1hDSnBibWwwYVdGc2FYcGxaRndpTEZ4dUlDQWdJQ0FnWTI5dVptbG5PaUIwYUdsekxtTnZibVpwWnl4Y2JpQWdJQ0FnSUhCbFpYSmZhV1E2SUhSb2FYTXVYMk52Ym01bFkzUnBiMjR1Y0dWbGNsOXBaRnh1SUNBZ0lIMHBPMXh1SUNCOVhHNGdJQzhxS2x4dUlDQWdLaUJUWlhRZ1lTQm9ZVzVrYkdWeUlIUnZJR0psSUdOaGJHeGxaQ0IzYUdWdUlISmxZMlZwZG1Wa0lHRWdjbVZ6Y0c5dVkyVWdabkp2YlNCMGFHVmNiaUFnSUNvZ2NtVnRiM1JsSUhOcGRHVWdjbVZ3YjNKMGFXNW5JSFJvWVhRZ2RHaGxJSEJ5WlhacGIzVnpiSGtnY0hKdmRtbGtaV1FnYVc1MFpYSm1ZV05sWEc0Z0lDQXFJR2hoY3lCaVpXVnVJSE4xWTJObGMzTm1kV3hzZVNCelpYUWdZWE1nY21WdGIzUmxJR1p2Y2lCMGFHRjBJSE5wZEdWY2JpQWdJQ3BjYmlBZ0lDb2dRSEJoY21GdElIdEdkVzVqZEdsdmJuMGdhR0Z1Wkd4bGNseHVJQ0FnS2k5Y2JseHVJQ0JuWlhSU1pXMXZkR1ZEWVd4c1UzUmhZMnNvS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdVgyMWxkR2h2WkY5eVpXWnpMbWRsZEZOMFlXTnJLQ2s3WEc0Z0lIMWNibHh1SUNBdktpcGNiaUFnSUNvZ1FISmxkSFZ5Ym5NZ2UwOWlhbVZqZEgwZ2MyVjBJRzltSUhKbGJXOTBaU0JwYm5SbGNtWmhZMlVnYldWMGFHOWtjMXh1SUNBZ0tpOWNiaUFnWjJWMFVtVnRiM1JsS0NrZ2UxeHVJQ0FnSUhKbGRIVnliaUIwYUdsekxsOXlaVzF2ZEdWZmFXNTBaWEptWVdObE8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRk5sZEhNZ2RHaGxJR2x1ZEdWeVptRmpaU0J2WmlCMGFHbHpJSE5wZEdVZ2JXRnJhVzVuSUdsMElHRjJZV2xzWVdKc1pTQjBieUIwYUdWY2JpQWdJQ29nY21WdGIzUmxJSE5wZEdVZ1lua2djMlZ1WkdsdVp5QmhJRzFsYzNOaFoyVWdkMmwwYUNCaElITmxkQ0J2WmlCdFpYUm9iMlJ6SUc1aGJXVnpYRzRnSUNBcVhHNGdJQ0FxSUVCd1lYSmhiU0I3VDJKcVpXTjBmU0JmYVc1MFpYSm1ZV05sSUhSdklITmxkRnh1SUNBZ0tpOWNiaUFnYzJWMFNXNTBaWEptWVdObEtGOXBiblJsY21aaFkyVXNJR052Ym1acFp5a2dlMXh1SUNBZ0lHTnZibVpwWnlBOUlHTnZibVpwWnlCOGZDQjdmVHRjYmlBZ0lDQjBhR2x6TG1OdmJtWnBaeTV1WVcxbElEMGdZMjl1Wm1sbkxtNWhiV1VnZkh3Z2RHaHBjeTVqYjI1bWFXY3VibUZ0WlR0Y2JpQWdJQ0IwYUdsekxtTnZibVpwWnk1a1pYTmpjbWx3ZEdsdmJpQTlJR052Ym1acFp5NWtaWE5qY21sd2RHbHZiaUI4ZkNCMGFHbHpMbU52Ym1acFp5NWtaWE5qY21sd2RHbHZianRjYmlBZ0lDQnBaaUFvZEdocGN5NWpiMjVtYVdjdVptOXlkMkZ5WkdsdVoxOW1kVzVqZEdsdmJuTXBJSHRjYmlBZ0lDQWdJR1p2Y2lBb2JHVjBJR1oxYm1OZmJtRnRaU0J2WmlCMGFHbHpMbU52Ym1acFp5NW1iM0ozWVhKa2FXNW5YMloxYm1OMGFXOXVjeWtnZTF4dUlDQWdJQ0FnSUNCamIyNXpkQ0JmY21WdGIzUmxJRDBnZEdocGN5NWZjbVZ0YjNSbFgybHVkR1Z5Wm1GalpUdGNiaUFnSUNBZ0lDQWdhV1lnS0Y5eVpXMXZkR1ZiWm5WdVkxOXVZVzFsWFNrZ2UxeHVJQ0FnSUNBZ0lDQWdJR2xtSUNoZmFXNTBaWEptWVdObExtTnZibk4wY25WamRHOXlJRDA5UFNCUFltcGxZM1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNnaFgybHVkR1Z5Wm1GalpWdG1kVzVqWDI1aGJXVmRLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRjlwYm5SbGNtWmhZMlZiWm5WdVkxOXVZVzFsWFNBOUlDZ3VMaTVoY21kektTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWDNKbGJXOTBaVnRtZFc1algyNWhiV1ZkS0M0dUxtRnlaM01wTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0I5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1gybHVkR1Z5Wm1GalpTNWpiMjV6ZEhKMVkzUnZjaTVqYjI1emRISjFZM1J2Y2lBOVBUMGdSblZ1WTNScGIyNHBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2doWDJsdWRHVnlabUZqWlM1amIyNXpkSEoxWTNSdmNpNXdjbTkwYjNSNWNHVmJablZ1WTE5dVlXMWxYU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JmYVc1MFpYSm1ZV05sTG1OdmJuTjBjblZqZEc5eUxuQnliM1J2ZEhsd1pWdG1kVzVqWDI1aGJXVmRJRDBnS0M0dUxtRnlaM01wSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmZjbVZ0YjNSbFcyWjFibU5mYm1GdFpWMG9MaTR1WVhKbmN5azdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMDdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNBZ0lIUm9hWE11WDJ4dlkyRnNYMkZ3YVNBOUlGOXBiblJsY21aaFkyVTdYRzRnSUNBZ2RHaHBjeTVmWm1seVpTaGNJbWx1ZEdWeVptRmpaVUYyWVdsc1lXSnNaVndpS1R0Y2JpQWdmVnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQlRaVzVrY3lCMGFHVWdZV04wZFdGc0lHbHVkR1Z5Wm1GalpTQjBieUIwYUdVZ2NtVnRiM1JsSUhOcGRHVWdkWEJ2YmlCcGRDQjNZWE5jYmlBZ0lDb2dkWEJrWVhSbFpDQnZjaUJpZVNCaElITndaV05wWVd3Z2NtVnhkV1Z6ZENCdlppQjBhR1VnY21WdGIzUmxJSE5wZEdWY2JpQWdJQ292WEc0Z0lITmxibVJKYm5SbGNtWmhZMlVvS1NCN1hHNGdJQ0FnYVdZZ0tDRjBhR2x6TGw5c2IyTmhiRjloY0drcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loY0ltbHVkR1Z5Wm1GalpTQnBjeUJ1YjNRZ2MyVjBMbHdpS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdkR2hwY3k1ZlpXNWpiMlJsS0hSb2FYTXVYMnh2WTJGc1gyRndhU3dnZEhKMVpTa3VkR2hsYmloaGNHa2dQVDRnZTF4dUlDQWdJQ0FnZEdocGN5NWZZMjl1Ym1WamRHbHZiaTVsYldsMEtIc2dkSGx3WlRvZ1hDSnpaWFJKYm5SbGNtWmhZMlZjSWl3Z1lYQnBPaUJoY0drZ2ZTazdYRzRnSUNBZ2ZTazdYRzRnSUgxY2JseHVJQ0JmWkdsemNHOXpaVTlpYW1WamRDaHZZbXBsWTNSSlpDa2dlMXh1SUNBZ0lHbG1JQ2gwYUdsekxsOXZZbXBsWTNSZmMzUnZjbVZiYjJKcVpXTjBTV1JkS1NCN1hHNGdJQ0FnSUNCa1pXeGxkR1VnZEdocGN5NWZiMkpxWldOMFgzTjBiM0psVzI5aWFtVmpkRWxrWFR0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtHQlBZbXBsWTNRZ0tHbGtQU1I3YjJKcVpXTjBTV1I5S1NCdWIzUWdabTkxYm1RdVlDazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdaR2x6Y0c5elpVOWlhbVZqZENodlltb3BJSHRjYmlBZ0lDQnlaWFIxY200Z2JtVjNJRkJ5YjIxcGMyVW9LSEpsYzI5c2RtVXNJSEpsYW1WamRDa2dQVDRnZTF4dUlDQWdJQ0FnYVdZZ0tIUm9hWE11WDI5aWFtVmpkRjkzWldGcmJXRndMbWhoY3lodlltb3BLU0I3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJRzlpYW1WamRFbGtJRDBnZEdocGN5NWZiMkpxWldOMFgzZGxZV3R0WVhBdVoyVjBLRzlpYWlrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WDJOdmJtNWxZM1JwYjI0dWIyNWpaU2hjSW1ScGMzQnZjMlZrWENJc0lHUmhkR0VnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJR2xtSUNoa1lYUmhMbVZ5Y205eUtTQnlaV3BsWTNRb2JtVjNJRVZ5Y205eUtHUmhkR0V1WlhKeWIzSXBLVHRjYmlBZ0lDQWdJQ0FnSUNCbGJITmxJSEpsYzI5c2RtVW9LVHRjYmlBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WDJOdmJtNWxZM1JwYjI0dVpXMXBkQ2g3WEc0Z0lDQWdJQ0FnSUNBZ2RIbHdaVG9nWENKa2FYTndiM05sVDJKcVpXTjBYQ0lzWEc0Z0lDQWdJQ0FnSUNBZ2IySnFaV04wWDJsa09pQnZZbXBsWTNSSlpGeHVJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpaGNJa2x1ZG1Gc2FXUWdiMkpxWldOMFhDSXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHBPMXh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUVoaGJtUnNaWE1nWVNCdFpYTnpZV2RsSUdaeWIyMGdkR2hsSUhKbGJXOTBaU0J6YVhSbFhHNGdJQ0FxTDF4dUlDQXZMeUIyWVhJZ1kyRnNiR0poWTJ0ZmNtVm5JRDBnYm1WM0lGSmxaMFY0Y0NoY0ltOXVkWEJrWVhSbGZISjFiaVJjSWlsY2JpQWdYM05sZEhWd1RXVnpjMkZuWlVoaGJteGtaWEp6S0NrZ2UxeHVJQ0FnSUhSb2FYTXVYMk52Ym01bFkzUnBiMjR1YjI0b1hDSnBibWwwWENJc0lIUm9hWE11YVc1cGRDazdYRzRnSUNBZ2RHaHBjeTVmWTI5dWJtVmpkR2x2Ymk1dmJpaGNJbVY0WldOMWRHVmNJaXdnWkdGMFlTQTlQaUI3WEc0Z0lDQWdJQ0JRY205dGFYTmxMbkpsYzI5c2RtVW9kR2hwY3k1ZlkyOXVibVZqZEdsdmJpNWxlR1ZqZFhSbEtHUmhkR0V1WTI5a1pTa3BYRzRnSUNBZ0lDQWdJQzUwYUdWdUtDZ3BJRDArSUh0Y2JpQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5amIyNXVaV04wYVc5dUxtVnRhWFFvZXlCMGVYQmxPaUJjSW1WNFpXTjFkR1ZrWENJZ2ZTazdYRzRnSUNBZ0lDQWdJSDBwWEc0Z0lDQWdJQ0FnSUM1allYUmphQ2hsSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0JqYjI1emIyeGxMbVZ5Y205eUtHVXBPMXh1SUNBZ0lDQWdJQ0FnSUhSb2FYTXVYMk52Ym01bFkzUnBiMjR1WlcxcGRDaDdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGVYQmxPaUJjSW1WNFpXTjFkR1ZrWENJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JsY25KdmNqb2dVM1J5YVc1bktHVXBYRzRnSUNBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnSUNBZ0lIMHBPMXh1SUNBZ0lIMHBPMXh1WEc0Z0lDQWdkR2hwY3k1ZlkyOXVibVZqZEdsdmJpNXZiaWhjSW0xbGRHaHZaRndpTENCaGMzbHVZeUJrWVhSaElEMCtJSHRjYmlBZ0lDQWdJR3hsZENCeVpYTnZiSFpsTENCeVpXcGxZM1FzSUcxbGRHaHZaQ3dnWVhKbmN5d2djbVZ6ZFd4ME8xeHVJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tHUmhkR0V1Y0hKdmJXbHpaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lGdHlaWE52YkhabExDQnlaV3BsWTNSZElEMGdZWGRoYVhRZ2RHaHBjeTVmZFc1M2NtRndLR1JoZEdFdWNISnZiV2x6WlN3Z1ptRnNjMlVwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUY5cGJuUmxjbVpoWTJVZ1BTQjBhR2x6TGw5dlltcGxZM1JmYzNSdmNtVmJaR0YwWVM1dlltcGxZM1JmYVdSZE8xeHVJQ0FnSUNBZ0lDQnRaWFJvYjJRZ1BTQnBibVJsZUU5aWFtVmpkQ2hmYVc1MFpYSm1ZV05sTENCa1lYUmhMbTVoYldVcE8xeHVJQ0FnSUNBZ0lDQmhjbWR6SUQwZ1lYZGhhWFFnZEdocGN5NWZkVzUzY21Gd0tHUmhkR0V1WVhKbmN5d2dkSEoxWlNrN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hrWVhSaExuQnliMjFwYzJVcElIdGNiaUFnSUNBZ0lDQWdJQ0J5WlhOMWJIUWdQU0J0WlhSb2IyUXVZWEJ3Ykhrb1gybHVkR1Z5Wm1GalpTd2dZWEpuY3lrN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdjbVZ6ZFd4MElHbHVjM1JoYm1ObGIyWWdVSEp2YldselpTQjhmRnh1SUNBZ0lDQWdJQ0FnSUNBZ0tHMWxkR2h2WkM1amIyNXpkSEoxWTNSdmNpQW1KaUJ0WlhSb2IyUXVZMjl1YzNSeWRXTjBiM0l1Ym1GdFpTQTlQVDBnWENKQmMzbHVZMFoxYm1OMGFXOXVYQ0lwWEc0Z0lDQWdJQ0FnSUNBZ0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYTjFiSFF1ZEdobGJpaHlaWE52YkhabEtTNWpZWFJqYUNoeVpXcGxZM1FwTzF4dUlDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhOdmJIWmxLSEpsYzNWc2RDazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lHMWxkR2h2WkM1aGNIQnNlU2hmYVc1MFpYSm1ZV05sTENCaGNtZHpLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlNCallYUmphQ0FvWlhKeUtTQjdYRzRnSUNBZ0lDQWdJR052Ym5OdmJHVXVaWEp5YjNJb2RHaHBjeTVqYjI1bWFXY3VibUZ0WlN3Z1pYSnlLVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tISmxhbVZqZENrZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsYW1WamRDaGxjbklwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlNrN1hHNWNiaUFnSUNCMGFHbHpMbDlqYjI1dVpXTjBhVzl1TG05dUtGd2lZMkZzYkdKaFkydGNJaXdnWVhONWJtTWdaR0YwWVNBOVBpQjdYRzRnSUNBZ0lDQnNaWFFnY21WemIyeDJaU3dnY21WcVpXTjBMQ0J0WlhSb2IyUXNJR0Z5WjNNc0lISmxjM1ZzZER0Y2JpQWdJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQWdJR2xtSUNoa1lYUmhMbkJ5YjIxcGMyVXBJSHRjYmlBZ0lDQWdJQ0FnSUNCYmNtVnpiMngyWlN3Z2NtVnFaV04wWFNBOUlHRjNZV2wwSUhSb2FYTXVYM1Z1ZDNKaGNDaGtZWFJoTG5CeWIyMXBjMlVzSUdaaGJITmxLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCcFppQW9aR0YwWVM1d2NtOXRhWE5sS1NCN1hHNGdJQ0FnSUNBZ0lDQWdiV1YwYUc5a0lEMGdkR2hwY3k1ZmMzUnZjbVV1Wm1WMFkyZ29aR0YwWVM1cFpDazdYRzRnSUNBZ0lDQWdJQ0FnWVhKbmN5QTlJR0YzWVdsMElIUm9hWE11WDNWdWQzSmhjQ2hrWVhSaExtRnlaM01zSUhSeWRXVXBPMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDZ2hiV1YwYUc5a0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRndpUTJGc2JHSmhZMnNnWm5WdVkzUnBiMjRnWTJGdUlHOXViSGtnWTJGc2JHVmtJRzl1WTJVc0lHbG1JSGx2ZFNCM1lXNTBJSFJ2SUdOaGJHd2dZU0JtZFc1amRHbHZiaUJtYjNJZ2JYVnNkR2x3YkdVZ2RHbHRaWE1zSUhCc1pXRnpaU0J0WVd0bElHbDBJR0Z6SUdFZ2NHeDFaMmx1SUdGd2FTQm1kVzVqZEdsdmJpNGdVMlZsSUdoMGRIQnpPaTh2YVcxcWIza3VhVzh2Wkc5amN5Qm1iM0lnYlc5eVpTQmtaWFJoYVd4ekxsd2lYRzRnSUNBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCeVpYTjFiSFFnUFNCdFpYUm9iMlF1WVhCd2JIa29iblZzYkN3Z1lYSm5jeWs3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVnpkV3gwSUdsdWMzUmhibU5sYjJZZ1VISnZiV2x6WlNCOGZGeHVJQ0FnSUNBZ0lDQWdJQ0FnS0cxbGRHaHZaQzVqYjI1emRISjFZM1J2Y2lBbUppQnRaWFJvYjJRdVkyOXVjM1J5ZFdOMGIzSXVibUZ0WlNBOVBUMGdYQ0pCYzNsdVkwWjFibU4wYVc5dVhDSXBYRzRnSUNBZ0lDQWdJQ0FnS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUXVkR2hsYmloeVpYTnZiSFpsS1M1allYUmphQ2h5WldwbFkzUXBPMXh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWE52YkhabEtISmxjM1ZzZENrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUcxbGRHaHZaQ0E5SUhSb2FYTXVYM04wYjNKbExtWmxkR05vS0dSaGRHRXVhV1FwTzF4dUlDQWdJQ0FnSUNBZ0lHRnlaM01nUFNCaGQyRnBkQ0IwYUdsekxsOTFibmR5WVhBb1pHRjBZUzVoY21kekxDQjBjblZsS1R0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvSVcxbGRHaHZaQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCY0lsQnNaV0Z6WlNCdWIzUnBZMlVnZEdoaGRDQmpZV3hzWW1GamF5Qm1kVzVqZEdsdmJpQmpZVzRnYjI1c2VTQmpZV3hzWldRZ2IyNWpaU3dnYVdZZ2VXOTFJSGRoYm5RZ2RHOGdZMkZzYkNCaElHWjFibU4wYVc5dUlHWnZjaUJ0ZFd4MGFYQnNaU0IwYVcxbGN5d2djR3hsWVhObElHMWhhMlVnYVhRZ1lYTWdZU0J3YkhWbmFXNGdZWEJwSUdaMWJtTjBhVzl1TGlCVFpXVWdhSFIwY0hNNkx5OXBiV3B2ZVM1cGJ5OWtiMk56SUdadmNpQnRiM0psSUdSbGRHRnBiSE11WENKY2JpQWdJQ0FnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJRzFsZEdodlpDNWhjSEJzZVNodWRXeHNMQ0JoY21kektUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmU0JqWVhSamFDQW9aWEp5S1NCN1hHNGdJQ0FnSUNBZ0lHTnZibk52YkdVdVpYSnliM0lvZEdocGN5NWpiMjVtYVdjdWJtRnRaU3dnWlhKeUtUdGNiaUFnSUNBZ0lDQWdhV1lnS0hKbGFtVmpkQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lISmxhbVZqZENobGNuSXBPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU2s3WEc0Z0lDQWdkR2hwY3k1ZlkyOXVibVZqZEdsdmJpNXZiaWhjSW1ScGMzQnZjMlZQWW1wbFkzUmNJaXdnWkdGMFlTQTlQaUI3WEc0Z0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TGw5a2FYTndiM05sVDJKcVpXTjBLR1JoZEdFdWIySnFaV04wWDJsa0tUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1ZlkyOXVibVZqZEdsdmJpNWxiV2wwS0h0Y2JpQWdJQ0FnSUNBZ0lDQjBlWEJsT2lCY0ltUnBjM0J2YzJWa1hDSmNiaUFnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0I5SUdOaGRHTm9JQ2hsS1NCN1hHNGdJQ0FnSUNBZ0lHTnZibk52YkdVdVpYSnliM0lvWlNrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WDJOdmJtNWxZM1JwYjI0dVpXMXBkQ2g3WEc0Z0lDQWdJQ0FnSUNBZ2RIbHdaVG9nWENKa2FYTndiM05sWkZ3aUxGeHVJQ0FnSUNBZ0lDQWdJR1Z5Y205eU9pQlRkSEpwYm1jb1pTbGNiaUFnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU2s3WEc0Z0lDQWdkR2hwY3k1ZlkyOXVibVZqZEdsdmJpNXZiaWhjSW5ObGRFbHVkR1Z5Wm1GalpWd2lMQ0JrWVhSaElEMCtJSHRjYmlBZ0lDQWdJSFJvYVhNdVgzTmxkRkpsYlc5MFpVbHVkR1Z5Wm1GalpTaGtZWFJoTG1Gd2FTazdYRzRnSUNBZ2ZTazdYRzRnSUNBZ2RHaHBjeTVmWTI5dWJtVmpkR2x2Ymk1dmJpaGNJbWRsZEVsdWRHVnlabUZqWlZ3aUxDQW9LU0E5UGlCN1hHNGdJQ0FnSUNCMGFHbHpMbDltYVhKbEtGd2laMlYwU1c1MFpYSm1ZV05sWENJcE8xeHVJQ0FnSUNBZ2FXWWdLSFJvYVhNdVgyeHZZMkZzWDJGd2FTa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxuTmxibVJKYm5SbGNtWmhZMlVvS1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXViMjVqWlNoY0ltbHVkR1Z5Wm1GalpVRjJZV2xzWVdKc1pWd2lMQ0FvS1NBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnZEdocGN5NXpaVzVrU1c1MFpYSm1ZV05sS0NrN1hHNGdJQ0FnSUNBZ0lIMHBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHBPMXh1SUNBZ0lIUm9hWE11WDJOdmJtNWxZM1JwYjI0dWIyNG9YQ0pwYm5SbGNtWmhZMlZUWlhSQmMxSmxiVzkwWlZ3aUxDQW9LU0E5UGlCN1hHNGdJQ0FnSUNCMGFHbHpMbDltYVhKbEtGd2lhVzUwWlhKbVlXTmxVMlYwUVhOU1pXMXZkR1ZjSWlrN1hHNGdJQ0FnZlNrN1hHNGdJQ0FnZEdocGN5NWZZMjl1Ym1WamRHbHZiaTV2YmloY0ltUnBjMk52Ym01bFkzUmNJaXdnS0NrZ1BUNGdlMXh1SUNBZ0lDQWdkR2hwY3k1ZlptbHlaU2hjSW1KbFptOXlaVVJwYzJOdmJtNWxZM1JjSWlrN1hHNGdJQ0FnSUNCMGFHbHpMbDlqYjI1dVpXTjBhVzl1TG1ScGMyTnZibTVsWTNRb0tUdGNiaUFnSUNBZ0lIUm9hWE11WDJacGNtVW9YQ0prYVhOamIyNXVaV04wWldSY0lpazdYRzRnSUNBZ2ZTazdYRzRnSUgxY2JseHVJQ0F2S2lwY2JpQWdJQ29nVTJWdVpITWdZU0J5WlhGMVpYTjBjeUIwYnlCMGFHVWdjbVZ0YjNSbElITnBkR1VnWVhOcmFXNW5JR2wwSUhSdklIQnliM1pwWkdVZ2FYUnpYRzRnSUNBcUlHTjFjbkpsYm5RZ2FXNTBaWEptWVdObFhHNGdJQ0FxTDF4dUlDQnlaWEYxWlhOMFVtVnRiM1JsS0NrZ2UxeHVJQ0FnSUhSb2FYTXVYMk52Ym01bFkzUnBiMjR1WlcxcGRDaDdJSFI1Y0dVNklGd2laMlYwU1c1MFpYSm1ZV05sWENJZ2ZTazdYRzRnSUgxY2JseHVJQ0JmYm1SaGNuSmhlU2gwZVhCbFpFRnljbUY1TENCemFHRndaU3dnWkhSNWNHVXBJSHRjYmlBZ0lDQjJZWElnWDJSMGVYQmxJRDBnZEhsd1pXUkJjbkpoZVZSdlJIUjVjR1ZiZEhsd1pXUkJjbkpoZVM1amIyNXpkSEoxWTNSdmNpNXVZVzFsWFR0Y2JpQWdJQ0JwWmlBb1pIUjVjR1VnSmlZZ1pIUjVjR1VnSVQwOUlGOWtkSGx3WlNrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnWENKa2RIbHdaU0JrYjJWemJpZDBJRzFoZEdOb0lIUm9aU0IwZVhCbElHOW1JSFJvWlNCaGNuSmhlVG9nWENJZ0sxeHVJQ0FnSUNBZ0lDQmZaSFI1Y0dVZ0sxeHVJQ0FnSUNBZ0lDQmNJaUFoUFNCY0lpQXJYRzRnSUNBZ0lDQWdJR1IwZVhCbE8xeHVJQ0FnSUgxY2JpQWdJQ0J6YUdGd1pTQTlJSE5vWVhCbElIeDhJRnQwZVhCbFpFRnljbUY1TG14bGJtZDBhRjA3WEc0Z0lDQWdjbVYwZFhKdUlIdGNiaUFnSUNBZ0lGOXlkSGx3WlRvZ1hDSnVaR0Z5Y21GNVhDSXNYRzRnSUNBZ0lDQmZjblpoYkhWbE9pQjBlWEJsWkVGeWNtRjVMbUoxWm1abGNpeGNiaUFnSUNBZ0lGOXljMmhoY0dVNklITm9ZWEJsTEZ4dUlDQWdJQ0FnWDNKa2RIbHdaVG9nWDJSMGVYQmxYRzRnSUNBZ2ZUdGNiaUFnZlZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJUWlhSeklIUm9aU0J1WlhjZ2NtVnRiM1JsSUdsdWRHVnlabUZqWlNCd2NtOTJhV1JsWkNCaWVTQjBhR1VnYjNSb1pYSWdjMmwwWlZ4dUlDQWdLbHh1SUNBZ0tpQkFjR0Z5WVcwZ2UwRnljbUY1ZlNCdVlXMWxjeUJzYVhOMElHOW1JR1oxYm1OMGFXOXVJRzVoYldWelhHNGdJQ0FxTDF4dUlDQmZjMlYwVW1WdGIzUmxTVzUwWlhKbVlXTmxLR0Z3YVNrZ2UxeHVJQ0FnSUhSb2FYTXVYMlJsWTI5a1pTaGhjR2twTG5Sb1pXNG9hVzUwWmlBOVBpQjdYRzRnSUNBZ0lDQjBhR2x6TGw5eVpXMXZkR1ZmYVc1MFpYSm1ZV05sSUQwZ2FXNTBaanRjYmlBZ0lDQWdJSFJvYVhNdVgyWnBjbVVvWENKeVpXMXZkR1ZTWldGa2VWd2lLVHRjYmlBZ0lDQWdJSFJvYVhNdVgzSmxjRzl5ZEZKbGJXOTBaVk5sZENncE8xeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRWRsYm1WeVlYUmxjeUIwYUdVZ2QzSmhjSEJsWkNCbWRXNWpkR2x2YmlCamIzSnlaWE53YjI1a2FXNW5JSFJ2SUdFZ2MybHVaMnhsSUhKbGJXOTBaVnh1SUNBZ0tpQnRaWFJvYjJRdUlGZG9aVzRnZEdobElHZGxibVZ5WVhSbFpDQm1kVzVqZEdsdmJpQnBjeUJqWVd4c1pXUXNJR2wwSUhkcGJHd2djMlZ1WkNCMGFHVmNiaUFnSUNvZ1kyOXljbVZ6Y0c5dVpHbHVaeUJ0WlhOellXZGxJSFJ2SUhSb1pTQnlaVzF2ZEdVZ2MybDBaU0JoYzJ0cGJtY2dhWFFnZEc4Z1pYaGxZM1YwWlZ4dUlDQWdLaUIwYUdVZ2NHRnlkR2xqZFd4aGNpQnRaWFJvYjJRZ2IyWWdhWFJ6SUdsdWRHVnlabUZqWlZ4dUlDQWdLbHh1SUNBZ0tpQkFjR0Z5WVcwZ2UxTjBjbWx1WjMwZ2JtRnRaU0J2WmlCMGFHVWdjbVZ0YjNSbElHMWxkR2h2WkZ4dUlDQWdLbHh1SUNBZ0tpQkFjbVYwZFhKdWN5QjdSblZ1WTNScGIyNTlJSGR5WVhCd1pXUWdjbVZ0YjNSbElHMWxkR2h2WkZ4dUlDQWdLaTljYmlBZ1gyZGxibEpsYlc5MFpVMWxkR2h2WkNoMFlYSm5aWFJKWkN3Z2JtRnRaU3dnYjJKcVpXTjBTV1FwSUh0Y2JpQWdJQ0IyWVhJZ2JXVWdQU0IwYUdsek8xeHVJQ0FnSUhaaGNpQnlaVzF2ZEdWTlpYUm9iMlFnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCdVpYY2dVSEp2YldselpTaGhjM2x1WXlBb2NtVnpiMngyWlN3Z2NtVnFaV04wS1NBOVBpQjdYRzRnSUNBZ0lDQWdJR3hsZENCcFpDQTlJRzUxYkd3N1hHNGdJQ0FnSUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FXUWdQU0J0WlM1ZmJXVjBhRzlrWDNKbFpuTXVjSFYwS0c5aWFtVmpkRWxrSUQ4Z2IySnFaV04wU1dRZ0t5QmNJaTljSWlBcklHNWhiV1VnT2lCdVlXMWxLVHRjYmlBZ0lDQWdJQ0FnSUNCMllYSWdkM0poY0hCbFpGOXlaWE52YkhabElEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvYVdRZ0lUMDlJRzUxYkd3cElHMWxMbDl0WlhSb2IyUmZjbVZtY3k1bVpYUmphQ2hwWkNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdjbVZ6YjJ4MlpTNWhjSEJzZVNoMGFHbHpMQ0JoY21kMWJXVnVkSE1wTzF4dUlDQWdJQ0FnSUNBZ0lIMDdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlIZHlZWEJ3WldSZmNtVnFaV04wSUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9hV1FnSVQwOUlHNTFiR3dwSUcxbExsOXRaWFJvYjJSZmNtVm1jeTVtWlhSamFDaHBaQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2NtVnFaV04wTG1Gd2NHeDVLSFJvYVhNc0lHRnlaM1Z0Wlc1MGN5azdYRzRnSUNBZ0lDQWdJQ0FnZlR0Y2JseHVJQ0FnSUNBZ0lDQWdJR052Ym5OMElHVnVZMjlrWldSUWNtOXRhWE5sSUQwZ1lYZGhhWFFnYldVdVgzZHlZWEFvVzF4dUlDQWdJQ0FnSUNBZ0lDQWdkM0poY0hCbFpGOXlaWE52YkhabExGeHVJQ0FnSUNBZ0lDQWdJQ0FnZDNKaGNIQmxaRjl5WldwbFkzUmNiaUFnSUNBZ0lDQWdJQ0JkS1R0Y2JseHVJQ0FnSUNBZ0lDQWdJQzh2SUhOMGIzSmxJSFJvWlNCclpYa2dhV1FnWm05eUlISmxiVzkyYVc1bklIUm9aVzBnWm5KdmJTQjBhR1VnY21WbVpYSmxibU5sSUhOMGIzSmxJSFJ2WjJWMGFHVnlYRzRnSUNBZ0lDQWdJQ0FnZDNKaGNIQmxaRjl5WlhOdmJIWmxMbDlmY0hKdmJXbHpaVjl3WVdseUlEMGdaVzVqYjJSbFpGQnliMjFwYzJWYk1WMHVYM0oyWVd4MVpUdGNiaUFnSUNBZ0lDQWdJQ0IzY21Gd2NHVmtYM0psYW1WamRDNWZYM0J5YjIxcGMyVmZjR0ZwY2lBOUlHVnVZMjlrWldSUWNtOXRhWE5sV3pCZExsOXlkbUZzZFdVN1hHNWNiaUFnSUNBZ0lDQWdJQ0IyWVhJZ1lYSm5jeUE5SUVGeWNtRjVMbkJ5YjNSdmRIbHdaUzV6YkdsalpTNWpZV3hzS0dGeVozVnRaVzUwY3lrN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0c1aGJXVWdQVDA5SUZ3aWNtVm5hWE4wWlhKY0lpQjhmQ0J1WVcxbElEMDlQU0JjSW1WNGNHOXlkRndpSUh4OElHNWhiV1VnUFQwOUlGd2liMjVjSWlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWVhKbmN5QTlJR0YzWVdsMElHMWxMbDkzY21Gd0tHRnlaM01zSUhSeWRXVXBPMXh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmhjbWR6SUQwZ1lYZGhhWFFnYldVdVgzZHlZWEFvWVhKbmN5azdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lIWmhjaUIwY21GdWMyWmxjbUZpYkdWeklEMGdZWEpuY3k1ZlgzUnlZVzV6Wm1WeVlXSnNaWE5mWHp0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZEhKaGJuTm1aWEpoWW14bGN5a2daR1ZzWlhSbElHRnlaM011WDE5MGNtRnVjMlpsY21GaWJHVnpYMTg3WEc0Z0lDQWdJQ0FnSUNBZ2JXVXVYMk52Ym01bFkzUnBiMjR1WlcxcGRDaGNiaUFnSUNBZ0lDQWdJQ0FnSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZEhsd1pUb2dYQ0p0WlhSb2IyUmNJaXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdkR0Z5WjJWMFgybGtPaUIwWVhKblpYUkpaQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdibUZ0WlRvZ2JtRnRaU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdiMkpxWldOMFgybGtPaUJ2WW1wbFkzUkpaQ3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdZWEpuY3pvZ1lYSm5jeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdjSEp2YldselpUb2daVzVqYjJSbFpGQnliMjFwYzJWY2JpQWdJQ0FnSUNBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjBjbUZ1YzJabGNtRmliR1Z6WEc0Z0lDQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdmU0JqWVhSamFDQW9aU2tnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2hwWkNrZ2JXVXVYMjFsZEdodlpGOXlaV1p6TG1abGRHTm9LR2xrS1R0Y2JpQWdJQ0FnSUNBZ0lDQnlaV3BsWTNRb1hHNGdJQ0FnSUNBZ0lDQWdJQ0JnUm1GcGJHVmtJSFJ2SUdWNFpXTjBkV1VnY21WdGIzUmxJRzFsZEdodlpDQW9hVzUwWlhKbVlXTmxPaUFrZTI5aWFtVmpkRWxrSUh4OFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUcxbExtbGtmU3dnYldWMGFHOWtPaUFrZTI1aGJXVjlLU3dnWlhKeWIzSTZJQ1I3WlgxZ1hHNGdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlNrN1hHNGdJQ0FnZlR0Y2JpQWdJQ0J5WlcxdmRHVk5aWFJvYjJRdVgxOXlaVzF2ZEdWZmJXVjBhRzlrSUQwZ2RISjFaVHRjYmlBZ0lDQnlaWFIxY200Z2NtVnRiM1JsVFdWMGFHOWtPMXh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUZObGJtUnpJR0VnY21WemNHOXVZMlVnY21Wd2IzSjBhVzVuSUhSb1lYUWdhVzUwWlhKbVlXTmxJR3AxYzNRZ2NISnZkbWxrWldRZ1lua2dkR2hsWEc0Z0lDQXFJSEpsYlc5MFpTQnphWFJsSUhkaGN5QnpkV05qWlhOelpuVnNiSGtnYzJWMElHSjVJSFJvYVhNZ2MybDBaU0JoY3lCeVpXMXZkR1ZjYmlBZ0lDb3ZYRzRnSUY5eVpYQnZjblJTWlcxdmRHVlRaWFFvS1NCN1hHNGdJQ0FnZEdocGN5NWZZMjl1Ym1WamRHbHZiaTVsYldsMEtIc2dkSGx3WlRvZ1hDSnBiblJsY21aaFkyVlRaWFJCYzFKbGJXOTBaVndpSUgwcE8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRkJ5WlhCaGNtVnpJSFJvWlNCd2NtOTJhV1JsWkNCelpYUWdiMllnY21WdGIzUmxJRzFsZEdodlpDQmhjbWQxYldWdWRITWdabTl5WEc0Z0lDQXFJSE5sYm1ScGJtY2dkRzhnZEdobElISmxiVzkwWlNCemFYUmxMQ0J5WlhCc1lXTmxjeUJoYkd3Z2RHaGxJR05oYkd4aVlXTnJjeUIzYVhSb1hHNGdJQ0FxSUdsa1pXNTBhV1pwWlhKelhHNGdJQ0FxWEc0Z0lDQXFJRUJ3WVhKaGJTQjdRWEp5WVhsOUlHRnlaM01nZEc4Z2QzSmhjRnh1SUNBZ0tseHVJQ0FnS2lCQWNtVjBkWEp1Y3lCN1FYSnlZWGw5SUhkeVlYQndaV1FnWVhKbmRXMWxiblJ6WEc0Z0lDQXFMMXh1SUNCaGMzbHVZeUJmWlc1amIyUmxLR0ZQWW1wbFkzUXNJR0Z6U1c1MFpYSm1ZV05sTENCdlltcGxZM1JKWkNrZ2UxeHVJQ0FnSUdOdmJuTjBJR0ZVZVhCbElEMGdkSGx3Wlc5bUlHRlBZbXBsWTNRN1hHNGdJQ0FnYVdZZ0tGeHVJQ0FnSUNBZ1lWUjVjR1VnUFQwOUlGd2liblZ0WW1WeVhDSWdmSHhjYmlBZ0lDQWdJR0ZVZVhCbElEMDlQU0JjSW5OMGNtbHVaMXdpSUh4OFhHNGdJQ0FnSUNCaFZIbHdaU0E5UFQwZ1hDSmliMjlzWldGdVhDSWdmSHhjYmlBZ0lDQWdJR0ZQWW1wbFkzUWdQVDA5SUc1MWJHd2dmSHhjYmlBZ0lDQWdJR0ZQWW1wbFkzUWdQVDA5SUhWdVpHVm1hVzVsWkNCOGZGeHVJQ0FnSUNBZ1lVOWlhbVZqZENCcGJuTjBZVzVqWlc5bUlFRnljbUY1UW5WbVptVnlYRzRnSUNBZ0tTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1lVOWlhbVZqZER0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JzWlhRZ1lrOWlhbVZqZER0Y2JpQWdJQ0JwWmlBb2RIbHdaVzltSUdGUFltcGxZM1FnUFQwOUlGd2lablZ1WTNScGIyNWNJaWtnZTF4dUlDQWdJQ0FnYVdZZ0tHRnpTVzUwWlhKbVlXTmxLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDZ2hiMkpxWldOMFNXUXBJSFJvY205M0lHNWxkeUJGY25KdmNpaGNJbTlpYW1WamRFbGtJR2x6SUc1dmRDQnpjR1ZqYVdacFpXUXVYQ0lwTzF4dUlDQWdJQ0FnSUNCaVQySnFaV04wSUQwZ2UxeHVJQ0FnSUNBZ0lDQWdJRjl5ZEhsd1pUb2dYQ0pwYm5SbGNtWmhZMlZjSWl4Y2JpQWdJQ0FnSUNBZ0lDQmZjblJoY21kbGRGOXBaRG9nZEdocGN5NWZZMjl1Ym1WamRHbHZiaTV3WldWeVgybGtMRnh1SUNBZ0lDQWdJQ0FnSUY5eWFXNTBaam9nYjJKcVpXTjBTV1FzWEc0Z0lDQWdJQ0FnSUNBZ1gzSjJZV3gxWlRvZ1lYTkpiblJsY21aaFkyVmNiaUFnSUNBZ0lDQWdmVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWZiV1YwYUc5a1gzZGxZV3R0WVhBdWMyVjBLR0ZQWW1wbFkzUXNJR0pQWW1wbFkzUXBPMXh1SUNBZ0lDQWdmU0JsYkhObElHbG1JQ2gwYUdsekxsOXRaWFJvYjJSZmQyVmhhMjFoY0M1b1lYTW9ZVTlpYW1WamRDa3BJSHRjYmlBZ0lDQWdJQ0FnWWs5aWFtVmpkQ0E5SUhSb2FYTXVYMjFsZEdodlpGOTNaV0ZyYldGd0xtZGxkQ2hoVDJKcVpXTjBLVHRjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJR052Ym5OMElHTnBaQ0E5SUhSb2FYTXVYM04wYjNKbExuQjFkQ2hoVDJKcVpXTjBLVHRjYmlBZ0lDQWdJQ0FnWWs5aWFtVmpkQ0E5SUh0Y2JpQWdJQ0FnSUNBZ0lDQmZjblI1Y0dVNklGd2lZMkZzYkdKaFkydGNJaXhjYmlBZ0lDQWdJQ0FnSUNCZmNuUmhjbWRsZEY5cFpEb2dkR2hwY3k1ZlkyOXVibVZqZEdsdmJpNXdaV1Z5WDJsa0xGeHVJQ0FnSUNBZ0lDQWdJRjl5Ym1GdFpUb2dLR0ZQWW1wbFkzUXVZMjl1YzNSeWRXTjBiM0lnSmlZZ1lVOWlhbVZqZEM1amIyNXpkSEoxWTNSdmNpNXVZVzFsS1NCOGZDQmphV1FzWEc0Z0lDQWdJQ0FnSUNBZ1gzSjJZV3gxWlRvZ1kybGtYRzRnSUNBZ0lDQWdJSDA3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0J5WlhSMWNtNGdZazlpYW1WamREdGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5QnphMmx3SUdsbUlHRnNjbVZoWkhrZ1pXNWpiMlJsWkZ4dUlDQWdJR2xtSUNoaFQySnFaV04wTG1OdmJuTjBjblZqZEc5eUlHbHVjM1JoYm1ObGIyWWdUMkpxWldOMElDWW1JR0ZQWW1wbFkzUXVYM0owZVhCbEtTQjdYRzRnSUNBZ0lDQXZMeUJ0WVd0bElITjFjbVVnZEdobElHbHVkR1Z5Wm1GalpTQm1kVzVqZEdsdmJuTWdZWEpsSUdWdVkyOWtaV1JjYmlBZ0lDQWdJR2xtSUNoaFQySnFaV04wTGw5eWFXNTBaaWtnZTF4dUlDQWdJQ0FnSUNCamIyNXpkQ0IwWlcxd0lEMGdZVTlpYW1WamRDNWZjblI1Y0dVN1hHNGdJQ0FnSUNBZ0lHUmxiR1YwWlNCaFQySnFaV04wTGw5eWRIbHdaVHRjYmx4dUlDQWdJQ0FnSUNCaVQySnFaV04wSUQwZ1lYZGhhWFFnZEdocGN5NWZaVzVqYjJSbEtHRlBZbXBsWTNRc0lHRnpTVzUwWlhKbVlXTmxMQ0J2WW1wbFkzUkpaQ2s3WEc0Z0lDQWdJQ0FnSUdKUFltcGxZM1F1WDNKMGVYQmxJRDBnZEdWdGNEdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lHSlBZbXBsWTNRZ1BTQmhUMkpxWldOME8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2NtVjBkWEp1SUdKUFltcGxZM1E3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZMjl1YzNRZ2RISmhibk5tWlhKaFlteGxjeUE5SUZ0ZE8xeHVJQ0FnSUdOdmJuTjBJRjkwY21GdWMyWmxjaUE5SUdGUFltcGxZM1F1WDNSeVlXNXpabVZ5TzF4dUlDQWdJR052Ym5OMElHbHpZWEp5WVhrZ1BTQkJjbkpoZVM1cGMwRnljbUY1S0dGUFltcGxZM1FwTzF4dVhHNGdJQ0FnWm05eUlDaHNaWFFnZEhBZ2IyWWdUMkpxWldOMExtdGxlWE1vZEdocGN5NWZZMjlrWldOektTa2dlMXh1SUNBZ0lDQWdZMjl1YzNRZ1kyOWtaV01nUFNCMGFHbHpMbDlqYjJSbFkzTmJkSEJkTzF4dUlDQWdJQ0FnYVdZZ0tHTnZaR1ZqTG1WdVkyOWtaWElnSmlZZ1lVOWlhbVZqZENCcGJuTjBZVzVqWlc5bUlHTnZaR1ZqTG5SNWNHVXBJSHRjYmlBZ0lDQWdJQ0FnTHk4Z1ZFOUVUem9nZDJoaGRDQnBaaUJ0ZFd4MGFYQnNaU0JsYm1OdlpHVnljeUJtYjNWdVpGeHVJQ0FnSUNBZ0lDQmpiMjV6ZENCbGJtTnZaR1ZrVDJKcUlEMGdZWGRoYVhRZ1VISnZiV2x6WlM1eVpYTnZiSFpsS0dOdlpHVmpMbVZ1WTI5a1pYSW9ZVTlpYW1WamRDa3BPMXh1SUNBZ0lDQWdJQ0JwWmlBb1pXNWpiMlJsWkU5aWFpQW1KaUFoWlc1amIyUmxaRTlpYWk1ZmNuUjVjR1VwSUdWdVkyOWtaV1JQWW1vdVgzSjBlWEJsSUQwZ1kyOWtaV011Ym1GdFpUdGNiaUFnSUNBZ0lDQWdMeThnWlc1amIyUmxJSFJvWlNCbWRXNWpkR2x2Ym5NZ2FXNGdkR2hsSUdsdWRHVnlabUZqWlNCdlltcGxZM1JjYmlBZ0lDQWdJQ0FnYVdZZ0tHVnVZMjlrWldSUFltb2dKaVlnWlc1amIyUmxaRTlpYWk1ZmNtbHVkR1lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCMFpXMXdJRDBnWlc1amIyUmxaRTlpYWk1ZmNuUjVjR1U3WEc0Z0lDQWdJQ0FnSUNBZ1pHVnNaWFJsSUdWdVkyOWtaV1JQWW1vdVgzSjBlWEJsTzF4dUlDQWdJQ0FnSUNBZ0lHVnVZMjlrWldSUFltb2dQU0JoZDJGcGRDQjBhR2x6TGw5bGJtTnZaR1VvWlc1amIyUmxaRTlpYWl3Z1lYTkpiblJsY21aaFkyVXNJRzlpYW1WamRFbGtLVHRjYmlBZ0lDQWdJQ0FnSUNCbGJtTnZaR1ZrVDJKcUxsOXlkSGx3WlNBOUlIUmxiWEE3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ1lrOWlhbVZqZENBOUlHVnVZMjlrWldSUFltbzdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmlUMkpxWldOME8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUdsbUlDaGNiaUFnSUNBZ0lDOHFaMnh2WW1Gc0lIUm1LaTljYmlBZ0lDQWdJSFI1Y0dWdlppQjBaaUFoUFQwZ1hDSjFibVJsWm1sdVpXUmNJaUFtSmx4dUlDQWdJQ0FnZEdZdVZHVnVjMjl5SUNZbVhHNGdJQ0FnSUNCaFQySnFaV04wSUdsdWMzUmhibU5sYjJZZ2RHWXVWR1Z1YzI5eVhHNGdJQ0FnS1NCN1hHNGdJQ0FnSUNCamIyNXpkQ0IyWDJKMVptWmxjaUE5SUdGUFltcGxZM1F1WkdGMFlWTjVibU1vS1R0Y2JpQWdJQ0FnSUdsbUlDaGhUMkpxWldOMExsOTBjbUZ1YzJabGNpQjhmQ0JmZEhKaGJuTm1aWElwSUh0Y2JpQWdJQ0FnSUNBZ2RISmhibk5tWlhKaFlteGxjeTV3ZFhOb0tIWmZZblZtWm1WeUxtSjFabVpsY2lrN1hHNGdJQ0FnSUNBZ0lHUmxiR1YwWlNCaFQySnFaV04wTGw5MGNtRnVjMlpsY2p0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUdKUFltcGxZM1FnUFNCN1hHNGdJQ0FnSUNBZ0lGOXlkSGx3WlRvZ1hDSnVaR0Z5Y21GNVhDSXNYRzRnSUNBZ0lDQWdJRjl5ZG1Gc2RXVTZJSFpmWW5WbVptVnlMbUoxWm1abGNpeGNiaUFnSUNBZ0lDQWdYM0p6YUdGd1pUb2dZVTlpYW1WamRDNXphR0Z3WlN4Y2JpQWdJQ0FnSUNBZ1gzSmtkSGx3WlRvZ1lVOWlhbVZqZEM1a2RIbHdaVnh1SUNBZ0lDQWdmVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLRnh1SUNBZ0lDQWdMeXBuYkc5aVlXd2dibW9xTDF4dUlDQWdJQ0FnZEhsd1pXOW1JRzVxSUNFOVBTQmNJblZ1WkdWbWFXNWxaRndpSUNZbVhHNGdJQ0FnSUNCdWFpNU9aRUZ5Y21GNUlDWW1YRzRnSUNBZ0lDQmhUMkpxWldOMElHbHVjM1JoYm1ObGIyWWdibW91VG1SQmNuSmhlVnh1SUNBZ0lDa2dlMXh1SUNBZ0lDQWdkbUZ5SUdSMGVYQmxJRDBnZEhsd1pXUkJjbkpoZVZSdlJIUjVjR1ZiWVU5aWFtVmpkQzV6Wld4bFkzUnBiMjR1WkdGMFlTNWpiMjV6ZEhKMVkzUnZjaTV1WVcxbFhUdGNiaUFnSUNBZ0lHbG1JQ2hoVDJKcVpXTjBMbDkwY21GdWMyWmxjaUI4ZkNCZmRISmhibk5tWlhJcElIdGNiaUFnSUNBZ0lDQWdkSEpoYm5ObVpYSmhZbXhsY3k1d2RYTm9LR0ZQWW1wbFkzUXVjMlZzWldOMGFXOXVMbVJoZEdFdVluVm1abVZ5S1R0Y2JpQWdJQ0FnSUNBZ1pHVnNaWFJsSUdGUFltcGxZM1F1WDNSeVlXNXpabVZ5TzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnWWs5aWFtVmpkQ0E5SUh0Y2JpQWdJQ0FnSUNBZ1gzSjBlWEJsT2lCY0ltNWtZWEp5WVhsY0lpeGNiaUFnSUNBZ0lDQWdYM0oyWVd4MVpUb2dZVTlpYW1WamRDNXpaV3hsWTNScGIyNHVaR0YwWVM1aWRXWm1aWElzWEc0Z0lDQWdJQ0FnSUY5eWMyaGhjR1U2SUdGUFltcGxZM1F1YzJoaGNHVXNYRzRnSUNBZ0lDQWdJRjl5WkhSNWNHVTZJR1IwZVhCbFhHNGdJQ0FnSUNCOU8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb1lVOWlhbVZqZENCcGJuTjBZVzVqWlc5bUlFVnljbTl5S1NCN1hHNGdJQ0FnSUNCamIyNXpiMnhsTG1WeWNtOXlLR0ZQWW1wbFkzUXBPMXh1SUNBZ0lDQWdZazlpYW1WamRDQTlJSHNnWDNKMGVYQmxPaUJjSW1WeWNtOXlYQ0lzSUY5eWRtRnNkV1U2SUdGUFltcGxZM1F1ZEc5VGRISnBibWNvS1NCOU8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RIbHdaVzltSUVacGJHVWdJVDA5SUZ3aWRXNWtaV1pwYm1Wa1hDSWdKaVlnWVU5aWFtVmpkQ0JwYm5OMFlXNWpaVzltSUVacGJHVXBJSHRjYmlBZ0lDQWdJR0pQWW1wbFkzUWdQU0I3WEc0Z0lDQWdJQ0FnSUY5eWRIbHdaVG9nWENKbWFXeGxYQ0lzWEc0Z0lDQWdJQ0FnSUY5eWRtRnNkV1U2SUdGUFltcGxZM1FzWEc0Z0lDQWdJQ0FnSUY5eWNHRjBhRG9nWVU5aWFtVmpkQzVmY0dGMGFDQjhmQ0JoVDJKcVpXTjBMbmRsWW10cGRGSmxiR0YwYVhabFVHRjBhRnh1SUNBZ0lDQWdmVHRjYmlBZ0lDQjlYRzRnSUNBZ0x5OGdjMlZ1WkNCdlltcGxZM1J6SUhOMWNIQnZjblJsWkNCaWVTQnpkSEoxWTNSMWNtVWdZMnh2Ym1VZ1lXeG5iM0pwZEdodFhHNGdJQ0FnTHk4Z2FIUjBjSE02THk5a1pYWmxiRzl3WlhJdWJXOTZhV3hzWVM1dmNtY3ZaVzR0VlZNdlpHOWpjeTlYWldJdlFWQkpMMWRsWWw5WGIzSnJaWEp6WDBGUVNTOVRkSEoxWTNSMWNtVmtYMk5zYjI1bFgyRnNaMjl5YVhSb2JWeHVJQ0FnSUdWc2MyVWdhV1lnS0Z4dUlDQWdJQ0FnWVU5aWFtVmpkQ0FoUFQwZ1QySnFaV04wS0dGUFltcGxZM1FwSUh4OFhHNGdJQ0FnSUNCaFQySnFaV04wSUdsdWMzUmhibU5sYjJZZ1FtOXZiR1ZoYmlCOGZGeHVJQ0FnSUNBZ1lVOWlhbVZqZENCcGJuTjBZVzVqWlc5bUlGTjBjbWx1WnlCOGZGeHVJQ0FnSUNBZ1lVOWlhbVZqZENCcGJuTjBZVzVqWlc5bUlFUmhkR1VnZkh4Y2JpQWdJQ0FnSUdGUFltcGxZM1FnYVc1emRHRnVZMlZ2WmlCU1pXZEZlSEFnZkh4Y2JpQWdJQ0FnSUdGUFltcGxZM1FnYVc1emRHRnVZMlZ2WmlCSmJXRm5aVVJoZEdFZ2ZIeGNiaUFnSUNBZ0lDaDBlWEJsYjJZZ1JtbHNaVXhwYzNRZ0lUMDlJRndpZFc1a1pXWnBibVZrWENJZ0ppWWdZVTlpYW1WamRDQnBibk4wWVc1alpXOW1JRVpwYkdWTWFYTjBLVnh1SUNBZ0lDa2dlMXh1SUNBZ0lDQWdZazlpYW1WamRDQTlJR0ZQWW1wbFkzUTdYRzRnSUNBZ0lDQXZMeUJVVDBSUE9pQmhkbTlwWkNCdlltcGxZM1FnYzNWamFDQmhjeUJFZVc1aGJXbGpVR3gxWjJsdUlHbHVjM1JoYm1ObExseHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RIbHdaVzltSUVacGJHVWdJVDA5SUZ3aWRXNWtaV1pwYm1Wa1hDSWdKaVlnWVU5aWFtVmpkQ0JwYm5OMFlXNWpaVzltSUVacGJHVXBJSHRjYmlBZ0lDQWdJR0pQWW1wbFkzUWdQU0I3WEc0Z0lDQWdJQ0FnSUY5eWRIbHdaVG9nWENKbWFXeGxYQ0lzWEc0Z0lDQWdJQ0FnSUY5eWJtRnRaVG9nWVU5aWFtVmpkQzV1WVcxbExGeHVJQ0FnSUNBZ0lDQmZjbTFwYldVNklHRlBZbXBsWTNRdWRIbHdaU3hjYmlBZ0lDQWdJQ0FnWDNKMllXeDFaVG9nWVU5aWFtVmpkQ3hjYmlBZ0lDQWdJQ0FnWDNKd1lYUm9PaUJoVDJKcVpXTjBMbDl3WVhSb0lIeDhJR0ZQWW1wbFkzUXVkMlZpYTJsMFVtVnNZWFJwZG1WUVlYUm9YRzRnSUNBZ0lDQjlPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9ZVTlpYW1WamRDQnBibk4wWVc1alpXOW1JRUpzYjJJcElIdGNiaUFnSUNBZ0lHSlBZbXBsWTNRZ1BTQjdJRjl5ZEhsd1pUb2dYQ0ppYkc5aVhDSXNJRjl5ZG1Gc2RXVTZJR0ZQWW1wbFkzUWdmVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLR0ZQWW1wbFkzUWdhVzV6ZEdGdVkyVnZaaUJCY25KaGVVSjFabVpsY2xacFpYY3BJSHRjYmlBZ0lDQWdJR2xtSUNoaFQySnFaV04wTGw5MGNtRnVjMlpsY2lCOGZDQmZkSEpoYm5ObVpYSXBJSHRjYmlBZ0lDQWdJQ0FnZEhKaGJuTm1aWEpoWW14bGN5NXdkWE5vS0dGUFltcGxZM1F1WW5WbVptVnlLVHRjYmlBZ0lDQWdJQ0FnWkdWc1pYUmxJR0ZQWW1wbFkzUXVYM1J5WVc1elptVnlPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdZMjl1YzNRZ1pIUjVjR1VnUFNCMGVYQmxaRUZ5Y21GNVZHOUVkSGx3WlZ0aFQySnFaV04wTG1OdmJuTjBjblZqZEc5eUxtNWhiV1ZkTzF4dUlDQWdJQ0FnWWs5aWFtVmpkQ0E5SUh0Y2JpQWdJQ0FnSUNBZ1gzSjBlWEJsT2lCY0luUjVjR1ZrWVhKeVlYbGNJaXhjYmlBZ0lDQWdJQ0FnWDNKMllXeDFaVG9nWVU5aWFtVmpkQzVpZFdabVpYSXNYRzRnSUNBZ0lDQWdJRjl5WkhSNWNHVTZJR1IwZVhCbFhHNGdJQ0FnSUNCOU8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb1lVOWlhbVZqZENCcGJuTjBZVzVqWlc5bUlFUmhkR0ZXYVdWM0tTQjdYRzRnSUNBZ0lDQnBaaUFvWVU5aWFtVmpkQzVmZEhKaGJuTm1aWElnZkh3Z1gzUnlZVzV6Wm1WeUtTQjdYRzRnSUNBZ0lDQWdJSFJ5WVc1elptVnlZV0pzWlhNdWNIVnphQ2hoVDJKcVpXTjBMbUoxWm1abGNpazdYRzRnSUNBZ0lDQWdJR1JsYkdWMFpTQmhUMkpxWldOMExsOTBjbUZ1YzJabGNqdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lHSlBZbXBsWTNRZ1BTQjdJRjl5ZEhsd1pUb2dYQ0p0WlcxdmNubDJhV1YzWENJc0lGOXlkbUZzZFdVNklHRlBZbXBsWTNRdVluVm1abVZ5SUgwN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoaFQySnFaV04wSUdsdWMzUmhibU5sYjJZZ1UyVjBLU0I3WEc0Z0lDQWdJQ0JpVDJKcVpXTjBJRDBnZTF4dUlDQWdJQ0FnSUNCZmNuUjVjR1U2SUZ3aWMyVjBYQ0lzWEc0Z0lDQWdJQ0FnSUY5eWRtRnNkV1U2SUdGM1lXbDBJSFJvYVhNdVgyVnVZMjlrWlNoQmNuSmhlUzVtY205dEtHRlBZbXBsWTNRcExDQmhjMGx1ZEdWeVptRmpaU2xjYmlBZ0lDQWdJSDA3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2hoVDJKcVpXTjBJR2x1YzNSaGJtTmxiMllnVFdGd0tTQjdYRzRnSUNBZ0lDQmlUMkpxWldOMElEMGdlMXh1SUNBZ0lDQWdJQ0JmY25SNWNHVTZJRndpYjNKa1pYSmxaRzFoY0Z3aUxGeHVJQ0FnSUNBZ0lDQmZjblpoYkhWbE9pQmhkMkZwZENCMGFHbHpMbDlsYm1OdlpHVW9RWEp5WVhrdVpuSnZiU2hoVDJKcVpXTjBLU3dnWVhOSmJuUmxjbVpoWTJVcFhHNGdJQ0FnSUNCOU8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb1hHNGdJQ0FnSUNCaFQySnFaV04wTG1OdmJuTjBjblZqZEc5eUlHbHVjM1JoYm1ObGIyWWdUMkpxWldOMElIeDhYRzRnSUNBZ0lDQkJjbkpoZVM1cGMwRnljbUY1S0dGUFltcGxZM1FwWEc0Z0lDQWdLU0I3WEc0Z0lDQWdJQ0JpVDJKcVpXTjBJRDBnYVhOaGNuSmhlU0EvSUZ0ZElEb2dlMzA3WEc0Z0lDQWdJQ0JzWlhRZ2EyVjVjenRjYmlBZ0lDQWdJQzh2SUdGdUlHOWlhbVZqZEM5aGNuSmhlVnh1SUNBZ0lDQWdhV1lnS0dGUFltcGxZM1F1WTI5dWMzUnlkV04wYjNJZ1BUMDlJRTlpYW1WamRDQjhmQ0JCY25KaGVTNXBjMEZ5Y21GNUtHRlBZbXBsWTNRcEtTQjdYRzRnSUNBZ0lDQWdJR3RsZVhNZ1BTQlBZbXBsWTNRdWEyVjVjeWhoVDJKcVpXTjBLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJQzh2SUdFZ1kyeGhjM05jYmlBZ0lDQWdJR1ZzYzJVZ2FXWWdLR0ZQWW1wbFkzUXVZMjl1YzNSeWRXTjBiM0lnUFQwOUlFWjFibU4wYVc5dUtTQjdYRzRnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpaGNJbEJzWldGelpTQnBibk4wWVc1MGFXRjBaU0IwYUdVZ1kyeGhjM01nWW1WbWIzSmxJR1Y0Y0c5eWRIUnBibWNnYVhRdVhDSXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdMeThnYVc1emRHRnVZMlVnYjJZZ1lTQmpiR0Z6YzF4dUlDQWdJQ0FnWld4elpTQnBaaUFvWVU5aWFtVmpkQzVqYjI1emRISjFZM1J2Y2k1amIyNXpkSEoxWTNSdmNpQTlQVDBnUm5WdVkzUnBiMjRwSUh0Y2JpQWdJQ0FnSUNBZ2EyVjVjeUE5SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0Z4dUlDQWdJQ0FnSUNBZ0lFOWlhbVZqZEM1blpYUlFjbTkwYjNSNWNHVlBaaWhoVDJKcVpXTjBLVnh1SUNBZ0lDQWdJQ0FwTG1OdmJtTmhkQ2hQWW1wbFkzUXVhMlY1Y3loaFQySnFaV04wS1NrN1hHNGdJQ0FnSUNBZ0lDOHZJRlJQUkU4NklIVnpaU0JoSUhCeWIzaDVJRzlpYW1WamRDQjBieUJ5WlhCeVpYTmxiblFnZEdobElHRmpkSFZoYkNCdlltcGxZM1JjYmlBZ0lDQWdJQ0FnTHk4Z1lXeDNZWGx6SUdWdVkyOWtaU0JqYkdGemN5QnBibk4wWVc1alpTQmhjeUJwYm5SbGNtWmhZMlZjYmlBZ0lDQWdJQ0FnWVhOSmJuUmxjbVpoWTJVZ1BTQjBjblZsTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dSWEp5YjNJb1hDSlZibk4xY0hCdmNuUmxaQ0JwYm5SbGNtWmhZMlVnZEhsd1pWd2lLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJQzh2SUdWdVkyOWtaU0JwYm5SbGNtWmhZMlZ6WEc0Z0lDQWdJQ0JwWmlBb1lVOWlhbVZqZEM1ZmNtbHVkR1lnZkh3Z1lYTkpiblJsY21aaFkyVXBJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tDRnZZbXBsWTNSSlpDa2dlMXh1SUNBZ0lDQWdJQ0FnSUc5aWFtVmpkRWxrSUQwZ2NtRnVaRWxrS0NrN1hHNGdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZmIySnFaV04wWDNOMGIzSmxXMjlpYW1WamRFbGtYU0E5SUdGUFltcGxZM1E3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2F5QnZaaUJyWlhsektTQjdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHc2dQVDA5SUZ3aVkyOXVjM1J5ZFdOMGIzSmNJaWtnWTI5dWRHbHVkV1U3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLR3N1YzNSaGNuUnpWMmwwYUNoY0lsOWNJaWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQmlUMkpxWldOMFcydGRJRDBnWVhkaGFYUWdkR2hwY3k1ZlpXNWpiMlJsS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdZVTlpYW1WamRGdHJYU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lIUjVjR1Z2WmlCaGMwbHVkR1Z5Wm1GalpTQTlQVDBnWENKemRISnBibWRjSWlBL0lHRnpTVzUwWlhKbVlXTmxJQ3NnWENJdVhDSWdLeUJySURvZ2F5eGNiaUFnSUNBZ0lDQWdJQ0FnSUc5aWFtVmpkRWxrWEc0Z0lDQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0F2THlCdlltcGxZM1FnYVdRZ1ptOXlJR1JwYzNCdmMyVWdkR2hsSUc5aWFtVmpkQ0J5WlcxdmRHVnNlVnh1SUNBZ0lDQWdJQ0JpVDJKcVpXTjBMbDl5YVc1MFppQTlJRzlpYW1WamRFbGtPMXh1SUNBZ0lDQWdJQ0F2THlCeVpXMXZkbVVnYVc1MFpYSm1ZV05sSUhkb1pXNGdZMnh2YzJWa1hHNGdJQ0FnSUNBZ0lHbG1JQ2hoVDJKcVpXTjBMbTl1SUNZbUlIUjVjR1Z2WmlCaFQySnFaV04wTG05dUlEMDlQU0JjSW1aMWJtTjBhVzl1WENJcElIdGNiaUFnSUNBZ0lDQWdJQ0JoVDJKcVpXTjBMbTl1S0Z3aVkyeHZjMlZjSWl3Z0tDa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdaR1ZzWlhSbElIUm9hWE11WDI5aWFtVmpkRjl6ZEc5eVpWdHZZbXBsWTNSSlpGMDdYRzRnSUNBZ0lDQWdJQ0FnZlNrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lHWnZjaUFvYkdWMElHc2diMllnYTJWNWN5a2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaGJYQ0pvWVhOUGQyNVFjbTl3WlhKMGVWd2lMQ0JjSW1OdmJuTjBjblZqZEc5eVhDSmRMbWx1WTJ4MVpHVnpLR3NwS1NCamIyNTBhVzUxWlR0Y2JpQWdJQ0FnSUNBZ0lDQmlUMkpxWldOMFcydGRJRDBnWVhkaGFYUWdkR2hwY3k1ZlpXNWpiMlJsS0dGUFltcGxZM1JiYTEwcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQXZMeUJtYjNJZ1pYaGhiWEJzWlN3Z1luSnZkM05sY2taVElHOWlhbVZqZEZ4dUlDQWdJSDBnWld4elpTQnBaaUFvZEhsd1pXOW1JR0ZQWW1wbFkzUWdQVDA5SUZ3aWIySnFaV04wWENJcElIdGNiaUFnSUNBZ0lHTnZibk4wSUd0bGVYTWdQU0JQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsT1lXMWxjeWhjYmlBZ0lDQWdJQ0FnVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bUtHRlBZbXBsWTNRcFhHNGdJQ0FnSUNBcExtTnZibU5oZENoUFltcGxZM1F1YTJWNWN5aGhUMkpxWldOMEtTazdYRzRnSUNBZ0lDQmpiMjV6ZENCdlltcGxZM1JKWkNBOUlISmhibVJKWkNncE8xeHVYRzRnSUNBZ0lDQm1iM0lnS0d4bGRDQnJJRzltSUd0bGVYTXBJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tGdGNJbWhoYzA5M2JsQnliM0JsY25SNVhDSXNJRndpWTI5dWMzUnlkV04wYjNKY0lsMHVhVzVqYkhWa1pYTW9heWtwSUdOdmJuUnBiblZsTzF4dUlDQWdJQ0FnSUNBdkx5QmxibU52WkdVZ1lYTWdhVzUwWlhKbVlXTmxYRzRnSUNBZ0lDQWdJR0pQWW1wbFkzUmJhMTBnUFNCaGQyRnBkQ0IwYUdsekxsOWxibU52WkdVb1lVOWlhbVZqZEZ0clhTd2dheXdnWWs5aWFtVmpkQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0F2THlCdlltcGxZM1FnYVdRc0lIVnpaV1FnWm05eUlHUnBjM0J2YzJVZ2RHaGxJRzlpYW1WamRGeHVJQ0FnSUNBZ1lrOWlhbVZqZEM1ZmNtbHVkR1lnUFNCdlltcGxZM1JKWkR0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdkR2h5YjNjZ1hDSnBiV3B2ZVMxeWNHTTZJRlZ1YzNWd2NHOXlkR1ZrSUdSaGRHRWdkSGx3WlRwY0lpQXJJR0ZQWW1wbFkzUTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLSFJ5WVc1elptVnlZV0pzWlhNdWJHVnVaM1JvSUQ0Z01Da2dlMXh1SUNBZ0lDQWdZazlpYW1WamRDNWZYM1J5WVc1elptVnlZV0pzWlhOZlh5QTlJSFJ5WVc1elptVnlZV0pzWlhNN1hHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNnaFlrOWlhbVZqZENrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0Z3aVJtRnBiR1ZrSUhSdklHVnVZMjlrWlNCdlltcGxZM1JjSWlrN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQmlUMkpxWldOME8xeHVJQ0I5WEc1Y2JpQWdZWE41Ym1NZ1gyUmxZMjlrWlNoaFQySnFaV04wTENCM2FYUm9VSEp2YldselpTa2dlMXh1SUNBZ0lHbG1JQ2doWVU5aWFtVmpkQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR0ZQWW1wbFkzUTdYRzRnSUNBZ2ZWeHVJQ0FnSUhaaGNpQmlUMkpxWldOMExDQjJMQ0JyTzF4dUlDQWdJR2xtSUNoaFQySnFaV04wVzF3aVgzSjBlWEJsWENKZEtTQjdYRzRnSUNBZ0lDQnBaaUFvWEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMk52WkdWamMxdGhUMkpxWldOMExsOXlkSGx3WlYwZ0ppWmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZlkyOWtaV056VzJGUFltcGxZM1F1WDNKMGVYQmxYUzVrWldOdlpHVnlYRzRnSUNBZ0lDQXBJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tHRlBZbXBsWTNRdVgzSnBiblJtS1NCN1hHNGdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2RHVnRjQ0E5SUdGUFltcGxZM1F1WDNKMGVYQmxPMXh1SUNBZ0lDQWdJQ0FnSUdSbGJHVjBaU0JoVDJKcVpXTjBMbDl5ZEhsd1pUdGNiaUFnSUNBZ0lDQWdJQ0JoVDJKcVpXTjBJRDBnWVhkaGFYUWdkR2hwY3k1ZlpHVmpiMlJsS0dGUFltcGxZM1FzSUhkcGRHaFFjbTl0YVhObEtUdGNiaUFnSUNBZ0lDQWdJQ0JoVDJKcVpXTjBMbDl5ZEhsd1pTQTlJSFJsYlhBN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdZazlpYW1WamRDQTlJR0YzWVdsMElGQnliMjFwYzJVdWNtVnpiMngyWlNoY2JpQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5amIyUmxZM05iWVU5aWFtVmpkQzVmY25SNWNHVmRMbVJsWTI5a1pYSW9ZVTlpYW1WamRDbGNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvWVU5aWFtVmpkQzVmY25SNWNHVWdQVDA5SUZ3aVkyRnNiR0poWTJ0Y0lpa2dlMXh1SUNBZ0lDQWdJQ0JpVDJKcVpXTjBJRDBnZEdocGN5NWZaMlZ1VW1WdGIzUmxRMkZzYkdKaFkyc29YRzRnSUNBZ0lDQWdJQ0FnWVU5aWFtVmpkQzVmY25SaGNtZGxkRjlwWkN4Y2JpQWdJQ0FnSUNBZ0lDQmhUMkpxWldOMExsOXlkbUZzZFdVc1hHNGdJQ0FnSUNBZ0lDQWdkMmwwYUZCeWIyMXBjMlZjYmlBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1lVOWlhbVZqZEM1ZmNuUjVjR1VnUFQwOUlGd2lhVzUwWlhKbVlXTmxYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ1lrOWlhbVZqZENBOUlIUm9hWE11WDJkbGJsSmxiVzkwWlUxbGRHaHZaQ2hjYmlBZ0lDQWdJQ0FnSUNCaFQySnFaV04wTGw5eWRHRnlaMlYwWDJsa0xGeHVJQ0FnSUNBZ0lDQWdJR0ZQWW1wbFkzUXVYM0oyWVd4MVpTeGNiaUFnSUNBZ0lDQWdJQ0JoVDJKcVpXTjBMbDl5YVc1MFpseHVJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdmU0JsYkhObElHbG1JQ2hoVDJKcVpXTjBMbDl5ZEhsd1pTQTlQVDBnWENKdVpHRnljbUY1WENJcElIdGNiaUFnSUNBZ0lDQWdMeXBuYkc5aVlXd2dibW9nZEdZcUwxeHVJQ0FnSUNBZ0lDQXZMMk55WldGMFpTQmlkV2xzWkNCaGNuSmhlUzkwWlc1emIzSWdhV1lnZFhObFpDQnBiaUIwYUdVZ2NHeDFaMmx1WEc0Z0lDQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ2Jtb2dJVDA5SUZ3aWRXNWtaV1pwYm1Wa1hDSWdKaVlnYm1vdVlYSnlZWGtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvUVhKeVlYa3VhWE5CY25KaGVTaGhUMkpxWldOMExsOXlkbUZzZFdVcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCaFQySnFaV04wTGw5eWRtRnNkV1VnUFNCaFQySnFaV04wTGw5eWRtRnNkV1V1Y21Wa2RXTmxLRjloY0hCbGJtUkNkV1ptWlhJcE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNCaVQySnFaV04wSUQwZ2JtcGNiaUFnSUNBZ0lDQWdJQ0FnSUM1aGNuSmhlU2h1WlhjZ1ZXbHVkRGdvWVU5aWFtVmpkQzVmY25aaGJIVmxLU3dnWVU5aWFtVmpkQzVmY21SMGVYQmxLVnh1SUNBZ0lDQWdJQ0FnSUNBZ0xuSmxjMmhoY0dVb1lVOWlhbVZqZEM1ZmNuTm9ZWEJsS1R0Y2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaDBlWEJsYjJZZ2RHWWdJVDA5SUZ3aWRXNWtaV1pwYm1Wa1hDSWdKaVlnZEdZdVZHVnVjMjl5S1NCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0VGeWNtRjVMbWx6UVhKeVlYa29ZVTlpYW1WamRDNWZjblpoYkhWbEtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1lVOWlhbVZqZEM1ZmNuWmhiSFZsSUQwZ1lVOWlhbVZqZEM1ZmNuWmhiSFZsTG5KbFpIVmpaU2hmWVhCd1pXNWtRblZtWm1WeUtUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWVhKeVlYbDBlWEJsSUQwZ1pYWmhiQ2hrZEhsd1pWUnZWSGx3WldSQmNuSmhlVnRoVDJKcVpXTjBMbDl5WkhSNWNHVmRLVHRjYmlBZ0lDQWdJQ0FnSUNCaVQySnFaV04wSUQwZ2RHWXVkR1Z1YzI5eUtGeHVJQ0FnSUNBZ0lDQWdJQ0FnYm1WM0lHRnljbUY1ZEhsd1pTaGhUMkpxWldOMExsOXlkbUZzZFdVcExGeHVJQ0FnSUNBZ0lDQWdJQ0FnWVU5aWFtVmpkQzVmY25Ob1lYQmxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1lVOWlhbVZqZEM1ZmNtUjBlWEJsWEc0Z0lDQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0F2TDJ0bFpYQWdhWFFnWVhNZ2NtVm5kV3hoY2lCcFppQjBjbUZ1YzJabGNtVmtJSFJ2SUhSb1pTQnRZV2x1SUdGd2NGeHVJQ0FnSUNBZ0lDQWdJR0pQWW1wbFkzUWdQU0JoVDJKcVpXTjBPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0dGUFltcGxZM1F1WDNKMGVYQmxJRDA5UFNCY0ltVnljbTl5WENJcElIdGNiaUFnSUNBZ0lDQWdZazlpYW1WamRDQTlJRzVsZHlCRmNuSnZjaWhoVDJKcVpXTjBMbDl5ZG1Gc2RXVXBPMXh1SUNBZ0lDQWdmU0JsYkhObElHbG1JQ2hoVDJKcVpXTjBMbDl5ZEhsd1pTQTlQVDBnWENKbWFXeGxYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLR0ZQWW1wbFkzUXVYM0oyWVd4MVpTQnBibk4wWVc1alpXOW1JRVpwYkdVcElIdGNiaUFnSUNBZ0lDQWdJQ0JpVDJKcVpXTjBJRDBnWVU5aWFtVmpkQzVmY25aaGJIVmxPMXh1SUNBZ0lDQWdJQ0FnSUM4dmNHRjBZMmdnWDNCaGRHaGNiaUFnSUNBZ0lDQWdJQ0JpVDJKcVpXTjBMbDl3WVhSb0lEMGdZVTlpYW1WamRDNWZjbkJoZEdnN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdZazlpYW1WamRDQTlJRzVsZHlCR2FXeGxLRnRoVDJKcVpXTjBMbDl5ZG1Gc2RXVmRMQ0JoVDJKcVpXTjBMbDl5Ym1GdFpTd2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RIbHdaVG9nWVU5aWFtVmpkQzVmY20xcGJXVmNiaUFnSUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUNBZ0lDQmlUMkpxWldOMExsOXdZWFJvSUQwZ1lVOWlhbVZqZEM1ZmNuQmhkR2c3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1lVOWlhbVZqZEM1ZmNuUjVjR1VnUFQwOUlGd2lkSGx3WldSaGNuSmhlVndpS1NCN1hHNGdJQ0FnSUNBZ0lHTnZibk4wSUdGeWNtRjVkSGx3WlNBOUlHVjJZV3dvWkhSNWNHVlViMVI1Y0dWa1FYSnlZWGxiWVU5aWFtVmpkQzVmY21SMGVYQmxYU2s3WEc0Z0lDQWdJQ0FnSUdsbUlDZ2hZWEp5WVhsMGVYQmxLVnh1SUNBZ0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhjSW5WdWMzVndjRzl5ZEdWa0lHUjBlWEJsT2lCY0lpQXJJR0ZQWW1wbFkzUXVYM0prZEhsd1pTazdYRzRnSUNBZ0lDQWdJR0pQWW1wbFkzUWdQU0J1WlhjZ1lYSnlZWGwwZVhCbEtHRlBZbXBsWTNRdVgzSjJZV3gxWlNrN1hHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHRlBZbXBsWTNRdVgzSjBlWEJsSUQwOVBTQmNJbTFsYlc5eWVYWnBaWGRjSWlrZ2UxeHVJQ0FnSUNBZ0lDQmlUMkpxWldOMElEMGdibVYzSUVSaGRHRldhV1YzS0dGUFltcGxZM1F1WDNKMllXeDFaU2s3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0dGUFltcGxZM1F1WDNKMGVYQmxJRDA5UFNCY0ltSnNiMkpjSWlrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWVU5aWFtVmpkQzVmY25aaGJIVmxJR2x1YzNSaGJtTmxiMllnUW14dllpa2dlMXh1SUNBZ0lDQWdJQ0FnSUdKUFltcGxZM1FnUFNCaFQySnFaV04wTGw5eWRtRnNkV1U3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ1lrOWlhbVZqZENBOUlHNWxkeUJDYkc5aUtGdGhUMkpxWldOMExsOXlkbUZzZFdWZExDQjdJSFI1Y0dVNklHRlBZbXBsWTNRdVgzSnRhVzFsSUgwcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR0ZQWW1wbFkzUXVYM0owZVhCbElEMDlQU0JjSW05eVpHVnlaV1J0WVhCY0lpa2dlMXh1SUNBZ0lDQWdJQ0JpVDJKcVpXTjBJRDBnYm1WM0lFMWhjQ2hoZDJGcGRDQjBhR2x6TGw5a1pXTnZaR1VvWVU5aWFtVmpkQzVmY25aaGJIVmxMQ0IzYVhSb1VISnZiV2x6WlNrcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaGhUMkpxWldOMExsOXlkSGx3WlNBOVBUMGdYQ0p6WlhSY0lpa2dlMXh1SUNBZ0lDQWdJQ0JpVDJKcVpXTjBJRDBnYm1WM0lGTmxkQ2hoZDJGcGRDQjBhR2x6TGw5a1pXTnZaR1VvWVU5aWFtVmpkQzVmY25aaGJIVmxMQ0IzYVhSb1VISnZiV2x6WlNrcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0x5OGdiV0ZyWlNCemRYSmxJR0ZzYkNCMGFHVWdhVzUwWlhKbVlXTmxJR1oxYm1OMGFXOXVjeUJoY21VZ1pHVmpiMlJsWkZ4dUlDQWdJQ0FnSUNCcFppQW9ZVTlpYW1WamRDNWZjbWx1ZEdZcElIdGNiaUFnSUNBZ0lDQWdJQ0JqYjI1emRDQjBaVzF3SUQwZ1lVOWlhbVZqZEM1ZmNuUjVjR1U3WEc0Z0lDQWdJQ0FnSUNBZ1pHVnNaWFJsSUdGUFltcGxZM1F1WDNKMGVYQmxPMXh1SUNBZ0lDQWdJQ0FnSUdGUFltcGxZM1FnUFNCaGQyRnBkQ0IwYUdsekxsOWtaV052WkdVb1lVOWlhbVZqZEN3Z2QybDBhRkJ5YjIxcGMyVXBPMXh1SUNBZ0lDQWdJQ0FnSUdGUFltcGxZM1F1WDNKMGVYQmxJRDBnZEdWdGNEdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JpVDJKcVpXTjBJRDBnWVU5aWFtVmpkRHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLR0ZQWW1wbFkzUXVZMjl1YzNSeWRXTjBiM0lnUFQwOUlFOWlhbVZqZENCOGZDQkJjbkpoZVM1cGMwRnljbUY1S0dGUFltcGxZM1FwS1NCN1hHNGdJQ0FnSUNCMllYSWdhWE5oY25KaGVTQTlJRUZ5Y21GNUxtbHpRWEp5WVhrb1lVOWlhbVZqZENrN1hHNGdJQ0FnSUNCaVQySnFaV04wSUQwZ2FYTmhjbkpoZVNBL0lGdGRJRG9nZTMwN1hHNGdJQ0FnSUNCbWIzSWdLR3NnYVc0Z1lVOWlhbVZqZENrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvYVhOaGNuSmhlU0I4ZkNCaFQySnFaV04wTG1oaGMwOTNibEJ5YjNCbGNuUjVLR3NwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkaUE5SUdGUFltcGxZM1JiYTEwN1hHNGdJQ0FnSUNBZ0lDQWdZazlpYW1WamRGdHJYU0E5SUdGM1lXbDBJSFJvYVhNdVgyUmxZMjlrWlNoMkxDQjNhWFJvVUhKdmJXbHpaU2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdZazlpYW1WamRDQTlJR0ZQWW1wbFkzUTdYRzRnSUNBZ2ZWeHVJQ0FnSUdsbUlDaGlUMkpxWldOMElEMDlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhjSWtaaGFXeGxaQ0IwYnlCa1pXTnZaR1VnYjJKcVpXTjBYQ0lwTzF4dUlDQWdJSDFjYmlBZ0lDQXZMeUJ6ZEc5eVpTQjBhR1VnYjJKcVpXTjBJR2xrSUdadmNpQmthWE53YjNObFhHNGdJQ0FnYVdZZ0tHRlBZbXBsWTNRdVgzSnBiblJtS1NCN1hHNGdJQ0FnSUNCMGFHbHpMbDl2WW1wbFkzUmZkMlZoYTIxaGNDNXpaWFFvWWs5aWFtVmpkQ3dnWVU5aWFtVmpkQzVmY21sdWRHWXBPMXh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnWWs5aWFtVmpkRHRjYmlBZ2ZWeHVYRzRnSUdGemVXNWpJRjkzY21Gd0tHRnlaM01zSUdGelNXNTBaWEptWVdObEtTQjdYRzRnSUNBZ2RtRnlJSGR5WVhCd1pXUWdQU0JoZDJGcGRDQjBhR2x6TGw5bGJtTnZaR1VvWVhKbmN5d2dZWE5KYm5SbGNtWmhZMlVwTzF4dUlDQWdJSEpsZEhWeWJpQjNjbUZ3Y0dWa08xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRlZ1ZDNKaGNITWdkR2hsSUhObGRDQnZaaUJoY21kMWJXVnVkSE1nWkdWc2FYWmxjbVZrSUdaeWIyMGdkR2hsSUhKbGJXOTBaU0J6YVhSbExGeHVJQ0FnS2lCeVpYQnNZV05sY3lCaGJHd2dZMkZzYkdKaFkyc2dhV1JsYm5ScFptbGxjbk1nZDJsMGFDQmhJR1oxYm1OMGFXOXVJSGRvYVdOb0lIZHBiR3hjYmlBZ0lDb2dhVzVwZEdsaGRHVWdjMlZ1WkdsdVp5QjBhR0YwSUdOaGJHeGlZV05ySUdsa1pXNTBhV1pwWlhJZ1ltRmpheUIwYnlCdmRHaGxjaUJ6YVhSbFhHNGdJQ0FxWEc0Z0lDQXFJRUJ3WVhKaGJTQjdUMkpxWldOMGZTQmhjbWR6SUhSdklIVnVkM0poY0Z4dUlDQWdLbHh1SUNBZ0tpQkFjR0Z5WVcwZ2UwSnZiMnhsWVc1OUlIZHBkR2hRY205dGFYTmxJR2x6SUhSeWRXVWdiV1ZoYm5NZ2RHaHBjeUIwYUdVZ1kyRnNiR0poWTJzZ2MyaHZkV3hrSUdOdmJuUmhhVzRnWVNCd2NtOXRhWE5sWEc0Z0lDQXFYRzRnSUNBcUlFQnlaWFIxY201eklIdEJjbkpoZVgwZ2RXNTNjbUZ3Y0dWa0lHRnlaM05jYmlBZ0lDb3ZYRzRnSUdGemVXNWpJRjkxYm5keVlYQW9ZWEpuY3l3Z2QybDBhRkJ5YjIxcGMyVXBJSHRjYmlBZ0lDQjJZWElnY21WemRXeDBJRDBnWVhkaGFYUWdkR2hwY3k1ZlpHVmpiMlJsS0dGeVozTXNJSGRwZEdoUWNtOXRhWE5sS1R0Y2JpQWdJQ0J5WlhSMWNtNGdjbVZ6ZFd4ME8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRWRsYm1WeVlYUmxjeUIwYUdVZ2QzSmhjSEJsWkNCbWRXNWpkR2x2YmlCamIzSnlaWE53YjI1a2FXNW5JSFJ2SUdFZ2MybHVaMnhsSUhKbGJXOTBaVnh1SUNBZ0tpQmpZV3hzWW1GamF5NGdWMmhsYmlCMGFHVWdaMlZ1WlhKaGRHVmtJR1oxYm1OMGFXOXVJR2x6SUdOaGJHeGxaQ3dnYVhRZ2QybHNiQ0J6Wlc1a1hHNGdJQ0FxSUhSb1pTQmpiM0p5WlhOd2IyNWthVzVuSUcxbGMzTmhaMlVnZEc4Z2RHaGxJSEpsYlc5MFpTQnphWFJsSUdGemEybHVaeUJwZENCMGIxeHVJQ0FnS2lCbGVHVmpkWFJsSUhSb1pTQndZWEowYVdOMWJHRnlJR05oYkd4aVlXTnJJSEJ5WlhacGIzVnpiSGtnYzJGMlpXUWdaSFZ5YVc1bklHRWdZMkZzYkZ4dUlDQWdLaUJpZVNCMGFHVWdjbVZ0YjNSbElITnBkR1VnWVNCdFpYUm9iMlFnWm5KdmJTQjBhR1VnYVc1MFpYSm1ZV05sSUc5bUlIUm9hWE1nYzJsMFpWeHVJQ0FnS2x4dUlDQWdLaUJBY0dGeVlXMGdlMDUxYldKbGNuMGdhV1FnYjJZZ2RHaGxJSEpsYlc5MFpTQmpZV3hzWW1GamF5QjBieUJsZUdWamRYUmxYRzRnSUNBcUlFQndZWEpoYlNCN1RuVnRZbVZ5ZlNCaGNtZE9kVzBnWVhKbmRXMWxiblFnYVc1a1pYZ2diMllnZEdobElHTmhiR3hpWVdOclhHNGdJQ0FxSUVCd1lYSmhiU0I3UW05dmJHVmhibjBnZDJsMGFGQnliMjFwYzJVZ2FYTWdkSEoxWlNCdFpXRnVjeUIwYUdseklIUm9aU0JqWVd4c1ltRmpheUJ6YUc5MWJHUWdZMjl1ZEdGcGJpQmhJSEJ5YjIxcGMyVmNiaUFnSUNwY2JpQWdJQ29nUUhKbGRIVnlibk1nZTBaMWJtTjBhVzl1ZlNCM2NtRndjR1ZrSUhKbGJXOTBaU0JqWVd4c1ltRmphMXh1SUNBZ0tpOWNiaUFnWDJkbGJsSmxiVzkwWlVOaGJHeGlZV05yS0hSaGNtZGxkRWxrTENCamFXUXNJSGRwZEdoUWNtOXRhWE5sS1NCN1hHNGdJQ0FnZG1GeUlHMWxJRDBnZEdocGN6dGNiaUFnSUNCMllYSWdjbVZ0YjNSbFEyRnNiR0poWTJzN1hHNGdJQ0FnYVdZZ0tIZHBkR2hRY205dGFYTmxLU0I3WEc0Z0lDQWdJQ0J5WlcxdmRHVkRZV3hzWW1GamF5QTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYm1WM0lGQnliMjFwYzJVb1lYTjVibU1nS0hKbGMyOXNkbVVzSUhKbGFtVmpkQ2tnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJSFpoY2lCaGNtZHpJRDBnWVhkaGFYUWdiV1V1WDNkeVlYQW9RWEp5WVhrdWNISnZkRzkwZVhCbExuTnNhV05sTG1OaGJHd29ZWEpuZFcxbGJuUnpLU2s3WEc0Z0lDQWdJQ0FnSUNBZ2RtRnlJSFJ5WVc1elptVnlZV0pzWlhNZ1BTQmhjbWR6TGw5ZmRISmhibk5tWlhKaFlteGxjMTlmTzF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2gwY21GdWMyWmxjbUZpYkdWektTQmtaV3hsZEdVZ1lYSm5jeTVmWDNSeVlXNXpabVZ5WVdKc1pYTmZYenRjYmx4dUlDQWdJQ0FnSUNBZ0lHTnZibk4wSUdWdVkyOWtaV1JRY205dGFYTmxJRDBnWVhkaGFYUWdiV1V1WDNkeVlYQW9XM0psYzI5c2RtVXNJSEpsYW1WamRGMHBPMXh1SUNBZ0lDQWdJQ0FnSUM4dklITjBiM0psSUhSb1pTQnJaWGtnYVdRZ1ptOXlJSEpsYlc5MmFXNW5JSFJvWlcwZ1puSnZiU0IwYUdVZ2NtVm1aWEpsYm1ObElITjBiM0psSUhSdloyVjBhR1Z5WEc0Z0lDQWdJQ0FnSUNBZ2NtVnpiMngyWlM1ZlgzQnliMjFwYzJWZmNHRnBjaUE5SUdWdVkyOWtaV1JRY205dGFYTmxXekZkTGw5eWRtRnNkV1U3WEc0Z0lDQWdJQ0FnSUNBZ2NtVnFaV04wTGw5ZmNISnZiV2x6WlY5d1lXbHlJRDBnWlc1amIyUmxaRkJ5YjIxcGMyVmJNRjB1WDNKMllXeDFaVHRjYmlBZ0lDQWdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2JXVXVYMk52Ym01bFkzUnBiMjR1WlcxcGRDaGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUjVjR1U2SUZ3aVkyRnNiR0poWTJ0Y0lpeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBZWEpuWlhSZmFXUTZJSFJoY21kbGRFbGtMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xrT2lCamFXUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZWEpuY3pvZ1lYSm5jeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J3Y205dGFYTmxPaUJsYm1OdlpHVmtVSEp2YldselpWeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGNtRnVjMlpsY21GaWJHVnpYRzRnSUNBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsYW1WamRDaGdSbUZwYkdWa0lIUnZJR1Y0WldOMGRXVWdjbVZ0YjNSbElHTmhiR3hpWVdOcklDZ2dhV1E2SUNSN1kybGtmU2t1WUNrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUgwN1hHNGdJQ0FnSUNCeVpYUjFjbTRnY21WdGIzUmxRMkZzYkdKaFkyczdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUhKbGJXOTBaVU5oYkd4aVlXTnJJRDBnWVhONWJtTWdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQmhjbWR6SUQwZ1lYZGhhWFFnYldVdVgzZHlZWEFvUVhKeVlYa3VjSEp2ZEc5MGVYQmxMbk5zYVdObExtTmhiR3dvWVhKbmRXMWxiblJ6S1NrN1hHNGdJQ0FnSUNBZ0lIWmhjaUIwY21GdWMyWmxjbUZpYkdWeklEMGdZWEpuY3k1ZlgzUnlZVzV6Wm1WeVlXSnNaWE5mWHp0Y2JpQWdJQ0FnSUNBZ2FXWWdLSFJ5WVc1elptVnlZV0pzWlhNcElHUmxiR1YwWlNCaGNtZHpMbDlmZEhKaGJuTm1aWEpoWW14bGMxOWZPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiV1V1WDJOdmJtNWxZM1JwYjI0dVpXMXBkQ2hjYmlBZ0lDQWdJQ0FnSUNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwZVhCbE9pQmNJbU5oYkd4aVlXTnJYQ0lzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjBZWEpuWlhSZmFXUTZJSFJoY21kbGRFbGtMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2FXUTZJR05wWkN4Y2JpQWdJQ0FnSUNBZ0lDQWdJR0Z5WjNNNklHRnlaM05jYmlBZ0lDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNBZ0lDQWdJSFJ5WVc1elptVnlZV0pzWlhOY2JpQWdJQ0FnSUNBZ0tUdGNiaUFnSUNBZ0lIMDdYRzRnSUNBZ0lDQnlaWFIxY200Z2NtVnRiM1JsUTJGc2JHSmhZMnM3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUZObGJtUnpJSFJvWlNCdWIzUnBabWxqWVhScGIyNGdiV1Z6YzJGblpTQmhibVFnWW5KbFlXdHpJSFJvWlNCamIyNXVaV04wYVc5dVhHNGdJQ0FxTDF4dUlDQmthWE5qYjI1dVpXTjBLQ2tnZTF4dUlDQWdJSFJvYVhNdVgyTnZibTVsWTNScGIyNHVaVzFwZENoN0lIUjVjR1U2SUZ3aVpHbHpZMjl1Ym1WamRGd2lJSDBwTzF4dUlDQWdJSE5sZEZScGJXVnZkWFFvS0NrZ1BUNGdlMXh1SUNBZ0lDQWdkR2hwY3k1ZlkyOXVibVZqZEdsdmJpNWthWE5qYjI1dVpXTjBLQ2s3WEc0Z0lDQWdmU3dnTWpBd01DazdYRzRnSUgxY2JuMWNibHh1THlvcVhHNGdLaUJTWldabGNtVnVZMlZUZEc5eVpTQnBjeUJoSUhOd1pXTnBZV3dnYjJKcVpXTjBJSGRvYVdOb0lITjBiM0psY3lCdmRHaGxjaUJ2WW1wbFkzUnpYRzRnS2lCaGJtUWdjSEp2ZG1sa1pYTWdkR2hsSUhKbFptVnlaVzVqWlhNZ0tHNTFiV0psY2lrZ2FXNXpkR1ZoWkM0Z1ZHaHBjeUJ5WldabGNtVnVZMlZjYmlBcUlHMWhlU0IwYUdWdUlHSmxJSE5sYm5RZ2IzWmxjaUJoSUdwemIyNHRZbUZ6WldRZ1kyOXRiWFZ1YVdOaGRHbHZiaUJqYUdGdWJtVnNJQ2hKVUVOY2JpQXFJSFJ2SUdGdWIzUm9aWElnVG05a1pTNXFjeUJ3Y205alpYTnpJRzl5SUdFZ2JXVnpjMkZuWlNCMGJ5QjBhR1VnVjI5eWEyVnlLUzRnVDNSb1pYSmNiaUFxSUhOcGRHVWdiV0Y1SUhSb1pXNGdjSEp2ZG1sa1pTQjBhR1VnY21WbVpYSmxibU5sSUdsdUlIUm9aU0J5WlhOd2IyNWpaU0J0WlhOellXZGxYRzRnS2lCcGJYQnNlV2x1WnlCMGFHVWdaMmwyWlc0Z2IySnFaV04wSUhOb2IzVnNaQ0JpWlNCaFkzUnBkbUYwWldRdVhHNGdLbHh1SUNvZ1VISnBiV0Z5ZVNCMWMyRm5aU0JtYjNJZ2RHaGxJRkpsWm1WeVpXNWpaVk4wYjNKbElHbHpJR0VnYzNSdmNtRm5aU0JtYjNJZ2RHaGxYRzRnS2lCallXeHNZbUZqYTNNc0lIZG9hV05vSUhSb1pYSmxabTl5WlNCdFlXdGxjeUJwZENCd2IzTnphV0pzWlNCMGJ5QnBibWwwYVdGMFpTQmhYRzRnS2lCallXeHNZbUZqYXlCbGVHVmpkWFJwYjI0Z1lua2dkR2hsSUc5d2NHOXphWFJsSUhOcGRHVWdLSGRvYVdOb0lHNXZjbTFoYkd4NUlHTmhibTV2ZEZ4dUlDb2daR2x5WldOMGJIa2daWGhsWTNWMFpTQm1kVzVqZEdsdmJuTWdiM1psY2lCMGFHVWdZMjl0YlhWdWFXTmhkR2x2YmlCamFHRnVibVZzS1M1Y2JpQXFYRzRnS2lCRllXTm9JSE4wYjNKbFpDQnZZbXBsWTNRZ1kyRnVJRzl1YkhrZ1ltVWdabVYwWTJobFpDQnZibU5sSUdGdVpDQnBjeUJ1YjNSY2JpQXFJR0YyWVdsc1lXSnNaU0JtYjNJZ2RHaGxJSE5sWTI5dVpDQjBhVzFsTGlCRllXTm9JSE4wYjNKbFpDQnZZbXBsWTNRZ2JYVnpkQ0JpWlZ4dUlDb2dabVYwWTJobFpDd2djMmx1WTJVZ2IzUm9aWEozYVhObElHbDBJSGRwYkd3Z2NtVnRZV2x1SUhOMGIzSmxaQ0JtYjNKbGRtVnlJR0Z1WkZ4dUlDb2dZMjl1YzNWdFpTQnRaVzF2Y25rdVhHNGdLbHh1SUNvZ1UzUnZjbVZrSUc5aWFtVmpkQ0JwYm1SbFkyVnpJR0Z5WlNCemFXMXdiSGtnZEdobElHNTFiV0psY25Nc0lIZG9hV05vSUdGeVpTQm9iM2RsZG1WeVhHNGdLaUJ5Wld4bFlYTmxaQ0JoYkc5dVp5QjNhWFJvSUhSb1pTQnZZbXBsWTNSekxDQmhibVFnWVhKbElHeGhkR1Z5SUhKbGRYTmxaQ0JoWjJGcGJpQW9hVzVjYmlBcUlHOXlaR1Z5SUhSdklIQnZjM1J3YjI1bElIUm9aU0J2ZG1WeVpteHZkeXdnZDJocFkyZ2djMmh2ZFd4a0lHNXZkQ0JzYVd0bGJIa2dhR0Z3Y0dWdUxGeHVJQ29nWW5WMElHRnVlWGRoZVNrdVhHNGdLaTljYm1Oc1lYTnpJRkpsWm1WeVpXNWpaVk4wYjNKbElIdGNiaUFnWTI5dWMzUnlkV04wYjNJb0tTQjdYRzRnSUNBZ2RHaHBjeTVmYzNSdmNtVWdQU0I3ZlRzZ0x5OGdjM1J2Y21Wa0lHOWlhbVZqZEZ4dUlDQWdJSFJvYVhNdVgybHVaR2xqWlhNZ1BTQmJNRjA3SUM4dklITnRZV3hzWlhOMElHRjJZV2xzWVdKc1pTQnBibVJwWTJWelhHNGdJQ0FnZEdocGN5NWZjbVZoWkhsSVlXNWtiR1Z5SUQwZ1puVnVZM1JwYjI0b0tTQjdmVHRjYmlBZ0lDQjBhR2x6TGw5aWRYTjVTR0Z1Wkd4bGNpQTlJR1oxYm1OMGFXOXVLQ2tnZTMwN1hHNGdJQ0FnZEdocGN5NWZjbVZoWkhsSVlXNWtiR1Z5S0NrN1hHNGdJSDFjYmx4dUlDQXZLaXBjYmlBZ0lDb2dZMkZzYkNCb1lXNWtiR1Z5SUhkb1pXNGdkR2hsSUhOMGIzSmxJR2x6SUdWdGNIUjVYRzRnSUNBcVhHNGdJQ0FxSUVCd1lYSmhiU0I3UmxWT1ExUkpUMDU5SUdsa0lHOW1JR0VnYUdGdVpHeGxjbHh1SUNBZ0tpOWNiaUFnYjI1U1pXRmtlU2h5WldGa2VVaGhibVJzWlhJcElIdGNiaUFnSUNCMGFHbHpMbDl5WldGa2VVaGhibVJzWlhJZ1BTQnlaV0ZrZVVoaGJtUnNaWElnZkh3Z1puVnVZM1JwYjI0b0tTQjdmVHRjYmlBZ2ZWeHVYRzRnSUM4cUtseHVJQ0FnS2lCallXeHNJR2hoYm1Sc1pYSWdkMmhsYmlCMGFHVWdjM1J2Y21VZ2FYTWdibTkwSUdWdGNIUjVYRzRnSUNBcVhHNGdJQ0FxSUVCd1lYSmhiU0I3UmxWT1ExUkpUMDU5SUdsa0lHOW1JR0VnYUdGdVpHeGxjbHh1SUNBZ0tpOWNiaUFnYjI1Q2RYTjVLR0oxYzNsSVlXNWtiR1Z5S1NCN1hHNGdJQ0FnZEdocGN5NWZZblZ6ZVVoaGJtUnNaWElnUFNCaWRYTjVTR0Z1Wkd4bGNpQjhmQ0JtZFc1amRHbHZiaWdwSUh0OU8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJR2RsZENCMGFHVWdiR1Z1WjNSb0lHOW1JSFJvWlNCemRHOXlaVnh1SUNBZ0tseHVJQ0FnS2k5Y2JpQWdaMlYwVTNSaFkyc29LU0I3WEc0Z0lDQWdjbVYwZFhKdUlFOWlhbVZqZEM1clpYbHpLSFJvYVhNdVgzTjBiM0psS1M1c1pXNW5kR2c3WEc0Z0lIMWNibHh1SUNBdktpcGNiaUFnSUNvZ1FHWjFibU4wYVc5dUlGOW5aVzVKWkNncElHZGxibVZ5WVhSbGN5QjBhR1VnYm1WM0lISmxabVZ5Wlc1alpTQnBaRnh1SUNBZ0tseHVJQ0FnS2lCQWNtVjBkWEp1Y3lCN1RuVnRZbVZ5ZlNCemJXRnNiR1Z6ZENCaGRtRnBiR0ZpYkdVZ2FXUWdZVzVrSUhKbGMyVnlkbVZ6SUdsMFhHNGdJQ0FxTDF4dUlDQmZaMlZ1U1dRb0tTQjdYRzRnSUNBZ2RtRnlJR2xrTzF4dUlDQWdJR2xtSUNoMGFHbHpMbDlwYm1ScFkyVnpMbXhsYm1kMGFDQTlQVDBnTVNrZ2UxeHVJQ0FnSUNBZ2FXUWdQU0IwYUdsekxsOXBibVJwWTJWeld6QmRLeXM3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHbGtJRDBnZEdocGN5NWZhVzVrYVdObGN5NXphR2xtZENncE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRIVnliaUJwWkR0Y2JpQWdmVnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQlNaV3hsWVhObGN5QjBhR1VnWjJsMlpXNGdjbVZtWlhKbGJtTmxJR2xrSUhOdklIUm9ZWFFnYVhRZ2QybHNiQ0JpWlNCaGRtRnBiR0ZpYkdVZ1lubGNiaUFnSUNvZ1lXNXZkR2hsY2lCdlltcGxZM1FnYzNSdmNtVmtYRzRnSUNBcVhHNGdJQ0FxSUVCd1lYSmhiU0I3VG5WdFltVnlmU0JwWkNCMGJ5QnlaV3hsWVhObFhHNGdJQ0FxTDF4dUlDQmZjbVZzWldGelpVbGtLR2xrS1NCN1hHNGdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCMGFHbHpMbDlwYm1ScFkyVnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNCcFppQW9hV1FnUENCMGFHbHpMbDlwYm1ScFkyVnpXMmxkS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WDJsdVpHbGpaWE11YzNCc2FXTmxLR2tzSURBc0lHbGtLVHRjYmlBZ0lDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdZMnhsWVc1cGJtY3RkWEFnZEdobElITmxjWFZsYm1ObElIUmhhV3hjYmlBZ0lDQm1iM0lnS0drZ1BTQjBhR2x6TGw5cGJtUnBZMlZ6TG14bGJtZDBhQ0F0SURFN0lHa2dQajBnTURzZ2FTMHRLU0I3WEc0Z0lDQWdJQ0JwWmlBb2RHaHBjeTVmYVc1a2FXTmxjMXRwWFNBdElERWdQVDA5SUhSb2FYTXVYMmx1WkdsalpYTmJhU0F0SURGZEtTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdVgybHVaR2xqWlhNdWNHOXdLQ2s3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0JpY21WaGF6dGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQXZLaXBjYmlBZ0lDb2dVM1J2Y21WeklIUm9aU0JuYVhabGJpQnZZbXBsWTNRZ1lXNWtJSEpsZEhWeWJuTWdkR2hsSUhKbFptVnlibU5sSUdsa0lHbHVjM1JsWVdSY2JpQWdJQ3BjYmlBZ0lDb2dRSEJoY21GdElIdFBZbXBsWTNSOUlHOWlhaUIwYnlCemRHOXlaVnh1SUNBZ0tseHVJQ0FnS2lCQWNtVjBkWEp1Y3lCN1RuVnRZbVZ5ZlNCeVpXWmxjbVZ1WTJVZ2FXUWdiMllnZEdobElITjBiM0psWkNCdlltcGxZM1JjYmlBZ0lDb3ZYRzRnSUhCMWRDaHZZbW9wSUh0Y2JpQWdJQ0JwWmlBb2RHaHBjeTVmWW5WemVVaGhibVJzWlhJZ0ppWWdUMkpxWldOMExtdGxlWE1vZEdocGN5NWZjM1J2Y21VcExteGxibWQwYUNBOVBUMGdNQ2tnZTF4dUlDQWdJQ0FnZEdocGN5NWZZblZ6ZVVoaGJtUnNaWElvS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdkbUZ5SUdsa0lEMGdkR2hwY3k1ZloyVnVTV1FvS1R0Y2JpQWdJQ0IwYUdsekxsOXpkRzl5WlZ0cFpGMGdQU0J2WW1vN1hHNGdJQ0FnY21WMGRYSnVJR2xrTzF4dUlDQjlYRzVjYmlBZ0x5b3FYRzRnSUNBcUlGSmxkSEpwWlhabGN5QndjbVYyYVc5MWMyeDVJSE4wYjNKbFpDQnZZbXBsWTNRZ1lXNWtJSEpsYkdWaGMyVnpJR2wwY3lCeVpXWmxjbVZ1WTJWY2JpQWdJQ3BjYmlBZ0lDb2dRSEJoY21GdElIdE9kVzFpWlhKOUlHbGtJRzltSUdGdUlHOWlhbVZqZENCMGJ5QnlaWFJ5YVdWMlpWeHVJQ0FnS2k5Y2JpQWdabVYwWTJnb2FXUXBJSHRjYmlBZ0lDQjJZWElnYjJKcUlEMGdkR2hwY3k1ZmMzUnZjbVZiYVdSZE8xeHVJQ0FnSUdsbUlDaHZZbW9nSmlZZ0lXOWlhaTVmWDNKbGJXOTBaVjl0WlhSb2IyUXBJSHRjYmlBZ0lDQWdJR1JsYkdWMFpTQjBhR2x6TGw5emRHOXlaVnRwWkYwN1hHNGdJQ0FnSUNCMGFHbHpMbDl5Wld4bFlYTmxTV1FvYVdRcE8xeHVJQ0FnSUNBZ2FXWWdLSFJvYVhNdVgzSmxZV1I1U0dGdVpHeGxjaUFtSmlCUFltcGxZM1F1YTJWNWN5aDBhR2x6TGw5emRHOXlaU2t1YkdWdVozUm9JRDA5UFNBd0tTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdVgzSmxZV1I1U0dGdVpHeGxjaWdwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvYjJKcUlDWW1JRzlpYWk1ZlgzQnliMjFwYzJWZmNHRnBjaWtnZTF4dUlDQWdJQ0FnZEdocGN5NW1aWFJqYUNodlltb3VYMTl3Y205dGFYTmxYM0JoYVhJcE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdiMkpxTzF4dUlDQjlYRzU5WEc0aVhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdPenM3UVVGSlFUdEJRVTlCTzBGQlJVRTdRVUZEUVR0QlFVZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVZEJPMEZCUlVFN096czdPenM3T3pzN1FVRlJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlIwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRklRVHRCUVV0Qk8wRkJRMEU3T3pzN096czdPenRCUVZGQk8wRkJRMEU3UVVGRFFUdEJRVVZCT3pzN096dEJRVWRCTzBGQlEwRTdRVUZEUVR0QlFVVkJPenM3T3pzN096dEJRVTFCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUlVFN096czdPenRCUVVsQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJSVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVWkJPMEZCU1VFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVVZCT3pzN1FVRkhRVHRCUVVOQk8wRkJRMEU3UVVGRVFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUlVFN1FVRkJRVHRCUVVGQk8wRkJRMEU3UVVGRlFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUmtFN1FVRkpRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVsQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVWRCTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkpRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVkQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJSRUU3UVVGSFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkdRVHRCUVVsQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlJVRTdPenM3T3p0QlFVbEJPMEZCUTBFN1FVRkJRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkpRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCU2tFN1FVRk5RVHRCUVVWQk96czdPenM3TzBGQlMwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlJVRTdPenM3T3pzN096czdPenRCUVZWQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlMwRTdRVUZEUVR0QlFVVkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVNUJPMEZCVlVFN1FVRkRRVHRCUVVOQk8wRkJTVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkZRVHM3T3pzN08wRkJTVUU3UVVGRFFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVVkJPenM3T3pzN096czdPenRCUVZOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlVVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRktRVHRCUVVOQk8wRkJTMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVXBCTzBGQlRVRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVbEJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVwQk8wRkJUVUU3UVVGRFFUdEJRVU5CTzBGQlNVRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCU2tFN1FVRk5RVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJTRUU3UVVGTFFUdEJRVVZCTzBGQlVrRTdRVUZyUWtFN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVeEJPMEZCVDBFN1FVRkRRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZJUVR0QlFVdEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGR1FUdEJRVWxCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUmtFN1FVRkpRVHRCUVVsQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVWkJPMEZCUzBFN1FVRkRRVHRCUVVaQk8wRkJTMEU3UVVGSlFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVdEJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUjBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZKUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlIwRTdRVUZEUVR0QlFVdEJPMEZCUTBFN1FVRkxRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkhRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVdEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRVFUdEJRVWRCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJSVUU3T3pzN096czdPenM3T3pzN1FVRlhRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVVZCT3pzN096czdPenM3T3pzN096czdRVUZoUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVV4Qk8wRkJVMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVwQk8wRkJVVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVVkJPenM3T3p0QlFVZEJPMEZCUTBFN1FVRkJRVHRCUVVGQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCZERCQ1FUdEJRWGN3UWtFN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenRCUVhWQ1FUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZGUVRzN096czdPenRCUVV0Qk8wRkJRMEU3UVVGRFFUdEJRVVZCT3pzN096czdPMEZCUzBFN1FVRkRRVHRCUVVOQk8wRkJSVUU3T3pzN096dEJRVWxCTzBGQlEwRTdRVUZEUVR0QlFVVkJPenM3T3pzN08wRkJTMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVVZCT3pzN096czdPenRCUVUxQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVWQk96czdPenM3T3pzN1FVRlBRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVWQk96czdPenM3TzBGQlMwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFUbEhRU0lzSW5OdmRYSmpaVkp2YjNRaU9pSWlmUT09XFxcXG4vLyMgc291cmNlVVJMPXdlYnBhY2staW50ZXJuYWw6Ly8vLi9zcmMvcnBjLmpzXFxcXG5cXFwiKTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvdXRpbHMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9zcmMvdXRpbHMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHJhbmRJZCwgZHR5cGVUb1R5cGVkQXJyYXksIHR5cGVkQXJyYXlUb0R0eXBlLCBjYWNoZVJlcXVpcmVtZW50cywgc2V0dXBTZXJ2aWNlV29ya2VyLCB1cmxKb2luLCBNZXNzYWdlRW1pdHRlciAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuZXZhbChcXFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcXFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFxcXFxcInJhbmRJZFxcXFxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJhbmRJZDsgfSk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwiZHR5cGVUb1R5cGVkQXJyYXlcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkdHlwZVRvVHlwZWRBcnJheTsgfSk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwidHlwZWRBcnJheVRvRHR5cGVcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlZEFycmF5VG9EdHlwZTsgfSk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwiY2FjaGVSZXF1aXJlbWVudHNcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjYWNoZVJlcXVpcmVtZW50czsgfSk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwic2V0dXBTZXJ2aWNlV29ya2VyXFxcXFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2V0dXBTZXJ2aWNlV29ya2VyOyB9KTtcXFxcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcXFxcXCJ1cmxKb2luXFxcXFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXJsSm9pbjsgfSk7XFxcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXFxcXFwiTWVzc2FnZUVtaXR0ZXJcXFxcXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNZXNzYWdlRW1pdHRlcjsgfSk7XFxcXG5mdW5jdGlvbiByYW5kSWQoKSB7XFxcXG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgMTApICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxcXG59XFxcXG5jb25zdCBkdHlwZVRvVHlwZWRBcnJheSA9IHtcXFxcbiAgaW50ODogXFxcXFxcXCJJbnQ4QXJyYXlcXFxcXFxcIixcXFxcbiAgaW50MTY6IFxcXFxcXFwiSW50MTZBcnJheVxcXFxcXFwiLFxcXFxuICBpbnQzMjogXFxcXFxcXCJJbnQzMkFycmF5XFxcXFxcXCIsXFxcXG4gIHVpbnQ4OiBcXFxcXFxcIlVpbnQ4QXJyYXlcXFxcXFxcIixcXFxcbiAgdWludDE2OiBcXFxcXFxcIlVpbnQxNkFycmF5XFxcXFxcXCIsXFxcXG4gIHVpbnQzMjogXFxcXFxcXCJVaW50MzJBcnJheVxcXFxcXFwiLFxcXFxuICBmbG9hdDMyOiBcXFxcXFxcIkZsb2F0MzJBcnJheVxcXFxcXFwiLFxcXFxuICBmbG9hdDY0OiBcXFxcXFxcIkZsb2F0NjRBcnJheVxcXFxcXFwiLFxcXFxuICBhcnJheTogXFxcXFxcXCJBcnJheVxcXFxcXFwiXFxcXG59O1xcXFxuY29uc3QgdHlwZWRBcnJheVRvRHR5cGUgPSB7XFxcXG4gIEludDhBcnJheTogXFxcXFxcXCJpbnQ4XFxcXFxcXCIsXFxcXG4gIEludDE2QXJyYXk6IFxcXFxcXFwiaW50MTZcXFxcXFxcIixcXFxcbiAgSW50MzJBcnJheTogXFxcXFxcXCJpbnQzMlxcXFxcXFwiLFxcXFxuICBVaW50OEFycmF5OiBcXFxcXFxcInVpbnQ4XFxcXFxcXCIsXFxcXG4gIFVpbnQxNkFycmF5OiBcXFxcXFxcInVpbnQxNlxcXFxcXFwiLFxcXFxuICBVaW50MzJBcnJheTogXFxcXFxcXCJ1aW50MzJcXFxcXFxcIixcXFxcbiAgRmxvYXQzMkFycmF5OiBcXFxcXFxcImZsb2F0MzJcXFxcXFxcIixcXFxcbiAgRmxvYXQ2NEFycmF5OiBcXFxcXFxcImZsb2F0NjRcXFxcXFxcIixcXFxcbiAgQXJyYXk6IFxcXFxcXFwiYXJyYXlcXFxcXFxcIlxcXFxufTtcXFxcblxcXFxuZnVuY3Rpb24gY2FjaGVVcmxJblNlcnZpY2VXb3JrZXIodXJsKSB7XFxcXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XFxcXG4gICAgY29uc3QgbWVzc2FnZSA9IHtcXFxcbiAgICAgIGNvbW1hbmQ6IFxcXFxcXFwiYWRkXFxcXFxcXCIsXFxcXG4gICAgICB1cmw6IHVybFxcXFxuICAgIH07XFxcXG5cXFxcbiAgICBpZiAoIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyIHx8ICFuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3Rlcikge1xcXFxuICAgICAgcmVqZWN0KFxcXFxcXFwiU2VydmljZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZC5cXFxcXFxcIik7XFxcXG4gICAgICByZXR1cm47XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcXFxcblxcXFxuICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xcXFxuICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lcnJvcikge1xcXFxuICAgICAgICByZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5yZXN1bHQpO1xcXFxuICAgICAgfVxcXFxuICAgIH07XFxcXG5cXFxcbiAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xcXFxuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlci5wb3N0TWVzc2FnZShtZXNzYWdlLCBbbWVzc2FnZUNoYW5uZWwucG9ydDJdKTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgcmVqZWN0KFxcXFxcXFwiU2VydmljZSB3b3JrZXIgY29udHJvbGxlciBpcyBub3QgYXZhaWxhYmxlXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgfSk7XFxcXG59XFxcXG5cXFxcbmFzeW5jIGZ1bmN0aW9uIGNhY2hlUmVxdWlyZW1lbnRzKHJlcXVpcmVtZW50cykge1xcXFxuICBpZiAoIUFycmF5LmlzQXJyYXkocmVxdWlyZW1lbnRzKSkge1xcXFxuICAgIHJlcXVpcmVtZW50c20uY29kZS5yZXF1aXJlbWVudHMgPSBbcmVxdWlyZW1lbnRzXTtcXFxcbiAgfVxcXFxuXFxcXG4gIGlmIChyZXF1aXJlbWVudHMgJiYgcmVxdWlyZW1lbnRzLmxlbmd0aCA+IDApIHtcXFxcbiAgICBmb3IgKGxldCByZXEgb2YgcmVxdWlyZW1lbnRzKSB7XFxcXG4gICAgICAvL3JlbW92ZSBwcmVmaXhcXFxcbiAgICAgIGlmIChyZXEuc3RhcnRzV2l0aChcXFxcXFxcImpzOlxcXFxcXFwiKSkgcmVxID0gcmVxLnNsaWNlKDMpO1xcXFxuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFxcXFxcXFwiY3NzOlxcXFxcXFwiKSkgcmVxID0gcmVxLnNsaWNlKDQpO1xcXFxuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFxcXFxcXFwiY2FjaGU6XFxcXFxcXCIpKSByZXEgPSByZXEuc2xpY2UoNik7XFxcXG4gICAgICBpZiAoIXJlcS5zdGFydHNXaXRoKFxcXFxcXFwiaHR0cFxcXFxcXFwiKSkgY29udGludWU7XFxcXG4gICAgICBhd2FpdCBjYWNoZVVybEluU2VydmljZVdvcmtlcihyZXEpLmNhdGNoKGUgPT4ge1xcXFxuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xcXFxuICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICB9XFxcXG59XFxcXG5mdW5jdGlvbiBzZXR1cFNlcnZpY2VXb3JrZXIoYmFzZVVybCwgdGFyZ2V0T3JpZ2luLCBjYWNoZUNhbGxiYWNrKSB7XFxcXG4gIC8vIHJlZ2lzdGVyIHNlcnZpY2Ugd29ya2VyIGZvciBvZmZsaW5lIGFjY2Vzc1xcXFxuICBpZiAoXFxcXFxcXCJzZXJ2aWNlV29ya2VyXFxcXFxcXCIgaW4gbmF2aWdhdG9yKSB7XFxcXG4gICAgYmFzZVVybCA9IGJhc2VVcmwgfHwgXFxcXFxcXCIvXFxcXFxcXCI7XFxcXG4gICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIoYmFzZVVybCArIFxcXFxcXFwicGx1Z2luLXNlcnZpY2Utd29ya2VyLmpzXFxcXFxcXCIpLnRoZW4oZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbikge1xcXFxuICAgICAgLy8gUmVnaXN0cmF0aW9uIHdhcyBzdWNjZXNzZnVsXFxcXG4gICAgICBjb25zb2xlLmxvZyhcXFxcXFxcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwgd2l0aCBzY29wZTogXFxcXFxcXCIsIHJlZ2lzdHJhdGlvbi5zY29wZSk7XFxcXG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xcXFxuICAgICAgLy8gcmVnaXN0cmF0aW9uIGZhaWxlZCA6KFxcXFxuICAgICAgY29uc29sZS5sb2coXFxcXFxcXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQ6IFxcXFxcXFwiLCBlcnIpO1xcXFxuICAgIH0pO1xcXFxuICAgIHRhcmdldE9yaWdpbiA9IHRhcmdldE9yaWdpbiB8fCBcXFxcXFxcIipcXFxcXFxcIjtcXFxcbiAgICBjYWNoZUNhbGxiYWNrID0gY2FjaGVDYWxsYmFjayB8fCBjYWNoZVJlcXVpcmVtZW50cztcXFxcblxcXFxuICAgIGlmIChjYWNoZUNhbGxiYWNrICYmIHR5cGVvZiBjYWNoZUNhbGxiYWNrICE9PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcImNvbmZpZy5jYWNoZV9yZXF1aXJlbWVudHMgbXVzdCBiZSBhIGZ1bmN0aW9uXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXFxcXFwibWVzc2FnZVxcXFxcXFwiLCBmdW5jdGlvbiAoZSkge1xcXFxuICAgICAgaWYgKHRhcmdldE9yaWdpbiA9PT0gXFxcXFxcXCIqXFxcXFxcXCIgfHwgZS5vcmlnaW4gPT09IHRhcmdldE9yaWdpbikge1xcXFxuICAgICAgICBjb25zdCBtID0gZS5kYXRhO1xcXFxuXFxcXG4gICAgICAgIGlmIChtLnR5cGUgPT09IFxcXFxcXFwiY2FjaGVSZXF1aXJlbWVudHNcXFxcXFxcIikge1xcXFxuICAgICAgICAgIGNhY2hlQ2FsbGJhY2sobS5yZXF1aXJlbWVudHMpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9XFxcXG4gICAgfSk7XFxcXG4gIH1cXFxcbn0gLy8jU291cmNlIGh0dHBzOi8vYml0Lmx5LzJuZVdmSjJcXFxcblxcXFxuZnVuY3Rpb24gdXJsSm9pbiguLi5hcmdzKSB7XFxcXG4gIHJldHVybiBhcmdzLmpvaW4oXFxcXFxcXCIvXFxcXFxcXCIpLnJlcGxhY2UoL1tcXFxcXFxcXC9dKy9nLCBcXFxcXFxcIi9cXFxcXFxcIikucmVwbGFjZSgvXiguKyk6XFxcXFxcXFwvLywgXFxcXFxcXCIkMTovL1xcXFxcXFwiKS5yZXBsYWNlKC9eZmlsZTovLCBcXFxcXFxcImZpbGU6L1xcXFxcXFwiKS5yZXBsYWNlKC9cXFxcXFxcXC8oXFxcXFxcXFw/fCZ8I1teIV0pL2csIFxcXFxcXFwiJDFcXFxcXFxcIikucmVwbGFjZSgvXFxcXFxcXFw/L2csIFxcXFxcXFwiJlxcXFxcXFwiKS5yZXBsYWNlKFxcXFxcXFwiJlxcXFxcXFwiLCBcXFxcXFxcIj9cXFxcXFxcIik7XFxcXG59XFxcXG5jbGFzcyBNZXNzYWdlRW1pdHRlciB7XFxcXG4gIGNvbnN0cnVjdG9yKGRlYnVnKSB7XFxcXG4gICAgdGhpcy5fZXZlbnRfaGFuZGxlcnMgPSB7fTtcXFxcbiAgICB0aGlzLl9vbmNlX2hhbmRsZXJzID0ge307XFxcXG4gICAgdGhpcy5fZGVidWcgPSBkZWJ1ZztcXFxcbiAgfVxcXFxuXFxcXG4gIGVtaXQoKSB7XFxcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwiZW1pdCBpcyBub3QgaW1wbGVtZW50ZWRcXFxcXFxcIik7XFxcXG4gIH1cXFxcblxcXFxuICBvbihldmVudCwgaGFuZGxlcikge1xcXFxuICAgIGlmICghdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdKSB7XFxcXG4gICAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0gPSBbXTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcXFxcbiAgfVxcXFxuXFxcXG4gIG9uY2UoZXZlbnQsIGhhbmRsZXIpIHtcXFxcbiAgICBoYW5kbGVyLl9fX2V2ZW50X3J1bl9vbmNlID0gdHJ1ZTtcXFxcbiAgICB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyKTtcXFxcbiAgfVxcXFxuXFxcXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xcXFxuICAgIGlmICghZXZlbnQgJiYgIWhhbmRsZXIpIHtcXFxcbiAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnRzIGhhbmRsZXJzXFxcXG4gICAgICB0aGlzLl9ldmVudF9oYW5kbGVycyA9IHt9O1xcXFxuICAgIH0gZWxzZSBpZiAoZXZlbnQgJiYgIWhhbmRsZXIpIHtcXFxcbiAgICAgIC8vIHJlbW92ZSBhbGwgaGFubGRlcnMgZm9yIHRoZSBldmVudFxcXFxuICAgICAgaWYgKHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSkgdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdID0gW107XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgIC8vIHJlbW92ZSBhIHNwZWNpZmljIGhhbmRsZXJcXFxcbiAgICAgIGlmICh0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0pIHtcXFxcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdLmluZGV4T2YoaGFuZGxlcik7XFxcXG5cXFxcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XFxcXG4gICAgICAgICAgdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpZHgsIDEpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9XFxcXG4gICAgfVxcXFxuICB9XFxcXG5cXFxcbiAgX2ZpcmUoZXZlbnQsIGRhdGEpIHtcXFxcbiAgICBpZiAodGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdKSB7XFxcXG4gICAgICB2YXIgaSA9IHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XS5sZW5ndGg7XFxcXG5cXFxcbiAgICAgIHdoaWxlIChpLS0pIHtcXFxcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XVtpXTtcXFxcblxcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xcXFxuICAgICAgICB9IGZpbmFsbHkge1xcXFxuICAgICAgICAgIGlmIChoYW5kbGVyLl9fX2V2ZW50X3J1bl9vbmNlKSB7XFxcXG4gICAgICAgICAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0uc3BsaWNlKGksIDEpO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgfVxcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICBpZiAodGhpcy5fZGVidWcpIHtcXFxcbiAgICAgICAgY29uc29sZS53YXJuKFxcXFxcXFwidW5oYW5kbGVkIGV2ZW50XFxcXFxcXCIsIGV2ZW50LCBkYXRhKTtcXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG4gIH1cXFxcblxcXFxufS8vIyBzb3VyY2VVUkw9W21vZHVsZV1cXFxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pTGk5emNtTXZkWFJwYkhNdWFuTXVhbk1pTENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OXBiV3B2ZVZKUVF5OHVMM055WXk5MWRHbHNjeTVxY3o4d01qVmxJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1WNGNHOXlkQ0JtZFc1amRHbHZiaUJ5WVc1a1NXUW9LU0I3WEc0Z0lISmxkSFZ5YmlBb1hHNGdJQ0FnVFdGMGFDNXlZVzVrYjIwb0tWeHVJQ0FnSUNBZ0xuUnZVM1J5YVc1bktETTJLVnh1SUNBZ0lDQWdMbk4xWW5OMGNpZ3lMQ0F4TUNrZ0t5QnVaWGNnUkdGMFpTZ3BMbWRsZEZScGJXVW9LVnh1SUNBcE8xeHVmVnh1WEc1bGVIQnZjblFnWTI5dWMzUWdaSFI1Y0dWVWIxUjVjR1ZrUVhKeVlYa2dQU0I3WEc0Z0lHbHVkRGc2SUZ3aVNXNTBPRUZ5Y21GNVhDSXNYRzRnSUdsdWRERTJPaUJjSWtsdWRERTJRWEp5WVhsY0lpeGNiaUFnYVc1ME16STZJRndpU1c1ME16SkJjbkpoZVZ3aUxGeHVJQ0IxYVc1ME9Eb2dYQ0pWYVc1ME9FRnljbUY1WENJc1hHNGdJSFZwYm5ReE5qb2dYQ0pWYVc1ME1UWkJjbkpoZVZ3aUxGeHVJQ0IxYVc1ME16STZJRndpVldsdWRETXlRWEp5WVhsY0lpeGNiaUFnWm14dllYUXpNam9nWENKR2JHOWhkRE15UVhKeVlYbGNJaXhjYmlBZ1pteHZZWFEyTkRvZ1hDSkdiRzloZERZMFFYSnlZWGxjSWl4Y2JpQWdZWEp5WVhrNklGd2lRWEp5WVhsY0lseHVmVHRjYm1WNGNHOXlkQ0JqYjI1emRDQjBlWEJsWkVGeWNtRjVWRzlFZEhsd1pTQTlJSHRjYmlBZ1NXNTBPRUZ5Y21GNU9pQmNJbWx1ZERoY0lpeGNiaUFnU1c1ME1UWkJjbkpoZVRvZ1hDSnBiblF4Tmx3aUxGeHVJQ0JKYm5Rek1rRnljbUY1T2lCY0ltbHVkRE15WENJc1hHNGdJRlZwYm5RNFFYSnlZWGs2SUZ3aWRXbHVkRGhjSWl4Y2JpQWdWV2x1ZERFMlFYSnlZWGs2SUZ3aWRXbHVkREUyWENJc1hHNGdJRlZwYm5Rek1rRnljbUY1T2lCY0luVnBiblF6TWx3aUxGeHVJQ0JHYkc5aGRETXlRWEp5WVhrNklGd2labXh2WVhRek1sd2lMRnh1SUNCR2JHOWhkRFkwUVhKeVlYazZJRndpWm14dllYUTJORndpTEZ4dUlDQkJjbkpoZVRvZ1hDSmhjbkpoZVZ3aVhHNTlPMXh1WEc1bWRXNWpkR2x2YmlCallXTm9aVlZ5YkVsdVUyVnlkbWxqWlZkdmNtdGxjaWgxY213cElIdGNiaUFnY21WMGRYSnVJRzVsZHlCUWNtOXRhWE5sS0daMWJtTjBhVzl1S0hKbGMyOXNkbVVzSUhKbGFtVmpkQ2tnZTF4dUlDQWdJR052Ym5OMElHMWxjM05oWjJVZ1BTQjdYRzRnSUNBZ0lDQmpiMjF0WVc1a09pQmNJbUZrWkZ3aUxGeHVJQ0FnSUNBZ2RYSnNPaUIxY214Y2JpQWdJQ0I5TzF4dUlDQWdJR2xtSUNnaGJtRjJhV2RoZEc5eUxuTmxjblpwWTJWWGIzSnJaWElnZkh3Z0lXNWhkbWxuWVhSdmNpNXpaWEoyYVdObFYyOXlhMlZ5TG5KbFoybHpkR1Z5S1NCN1hHNGdJQ0FnSUNCeVpXcGxZM1FvWENKVFpYSjJhV05sSUhkdmNtdGxjaUJwY3lCdWIzUWdjM1Z3Y0c5eWRHVmtMbHdpS1R0Y2JpQWdJQ0FnSUhKbGRIVnlianRjYmlBZ0lDQjlYRzRnSUNBZ1kyOXVjM1FnYldWemMyRm5aVU5vWVc1dVpXd2dQU0J1WlhjZ1RXVnpjMkZuWlVOb1lXNXVaV3dvS1R0Y2JpQWdJQ0J0WlhOellXZGxRMmhoYm01bGJDNXdiM0owTVM1dmJtMWxjM05oWjJVZ1BTQm1kVzVqZEdsdmJpaGxkbVZ1ZENrZ2UxeHVJQ0FnSUNBZ2FXWWdLR1YyWlc1MExtUmhkR0VnSmlZZ1pYWmxiblF1WkdGMFlTNWxjbkp2Y2lrZ2UxeHVJQ0FnSUNBZ0lDQnlaV3BsWTNRb1pYWmxiblF1WkdGMFlTNWxjbkp2Y2lrN1hHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCeVpYTnZiSFpsS0dWMlpXNTBMbVJoZEdFZ0ppWWdaWFpsYm5RdVpHRjBZUzV5WlhOMWJIUXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMDdYRzVjYmlBZ0lDQnBaaUFvYm1GMmFXZGhkRzl5TG5ObGNuWnBZMlZYYjNKclpYSWdKaVlnYm1GMmFXZGhkRzl5TG5ObGNuWnBZMlZYYjNKclpYSXVZMjl1ZEhKdmJHeGxjaWtnZTF4dUlDQWdJQ0FnYm1GMmFXZGhkRzl5TG5ObGNuWnBZMlZYYjNKclpYSXVZMjl1ZEhKdmJHeGxjaTV3YjNOMFRXVnpjMkZuWlNodFpYTnpZV2RsTENCYlhHNGdJQ0FnSUNBZ0lHMWxjM05oWjJWRGFHRnVibVZzTG5CdmNuUXlYRzRnSUNBZ0lDQmRLVHRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2NtVnFaV04wS0Z3aVUyVnlkbWxqWlNCM2IzSnJaWElnWTI5dWRISnZiR3hsY2lCcGN5QnViM1FnWVhaaGFXeGhZbXhsWENJcE8xeHVJQ0FnSUgxY2JpQWdmU2s3WEc1OVhHNWNibVY0Y0c5eWRDQmhjM2x1WXlCbWRXNWpkR2x2YmlCallXTm9aVkpsY1hWcGNtVnRaVzUwY3loeVpYRjFhWEpsYldWdWRITXBJSHRjYmlBZ2FXWWdLQ0ZCY25KaGVTNXBjMEZ5Y21GNUtISmxjWFZwY21WdFpXNTBjeWtwSUh0Y2JpQWdJQ0J5WlhGMWFYSmxiV1Z1ZEhOdExtTnZaR1V1Y21WeGRXbHlaVzFsYm5SeklEMGdXM0psY1hWcGNtVnRaVzUwYzEwN1hHNGdJSDFjYmlBZ2FXWWdLSEpsY1hWcGNtVnRaVzUwY3lBbUppQnlaWEYxYVhKbGJXVnVkSE11YkdWdVozUm9JRDRnTUNrZ2UxeHVJQ0FnSUdadmNpQW9iR1YwSUhKbGNTQnZaaUJ5WlhGMWFYSmxiV1Z1ZEhNcElIdGNiaUFnSUNBZ0lDOHZjbVZ0YjNabElIQnlaV1pwZUZ4dUlDQWdJQ0FnYVdZZ0tISmxjUzV6ZEdGeWRITlhhWFJvS0Z3aWFuTTZYQ0lwS1NCeVpYRWdQU0J5WlhFdWMyeHBZMlVvTXlrN1hHNGdJQ0FnSUNCcFppQW9jbVZ4TG5OMFlYSjBjMWRwZEdnb1hDSmpjM002WENJcEtTQnlaWEVnUFNCeVpYRXVjMnhwWTJVb05DazdYRzRnSUNBZ0lDQnBaaUFvY21WeExuTjBZWEowYzFkcGRHZ29YQ0pqWVdOb1pUcGNJaWtwSUhKbGNTQTlJSEpsY1M1emJHbGpaU2cyS1R0Y2JpQWdJQ0FnSUdsbUlDZ2hjbVZ4TG5OMFlYSjBjMWRwZEdnb1hDSm9kSFJ3WENJcEtTQmpiMjUwYVc1MVpUdGNibHh1SUNBZ0lDQWdZWGRoYVhRZ1kyRmphR1ZWY214SmJsTmxjblpwWTJWWGIzSnJaWElvY21WeEtTNWpZWFJqYUNobElEMCtJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVsY25KdmNpaGxLVHRjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVmVnh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnYzJWMGRYQlRaWEoyYVdObFYyOXlhMlZ5S0dKaGMyVlZjbXdzSUhSaGNtZGxkRTl5YVdkcGJpd2dZMkZqYUdWRFlXeHNZbUZqYXlrZ2UxeHVJQ0F2THlCeVpXZHBjM1JsY2lCelpYSjJhV05sSUhkdmNtdGxjaUJtYjNJZ2IyWm1iR2x1WlNCaFkyTmxjM05jYmlBZ2FXWWdLRndpYzJWeWRtbGpaVmR2Y210bGNsd2lJR2x1SUc1aGRtbG5ZWFJ2Y2lrZ2UxeHVJQ0FnSUdKaGMyVlZjbXdnUFNCaVlYTmxWWEpzSUh4OElGd2lMMXdpTzF4dUlDQWdJRzVoZG1sbllYUnZjaTV6WlhKMmFXTmxWMjl5YTJWeUxuSmxaMmx6ZEdWeUtHSmhjMlZWY213Z0t5QmNJbkJzZFdkcGJpMXpaWEoyYVdObExYZHZjbXRsY2k1cWMxd2lLUzUwYUdWdUtGeHVJQ0FnSUNBZ1puVnVZM1JwYjI0b2NtVm5hWE4wY21GMGFXOXVLU0I3WEc0Z0lDQWdJQ0FnSUM4dklGSmxaMmx6ZEhKaGRHbHZiaUIzWVhNZ2MzVmpZMlZ6YzJaMWJGeHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExteHZaeWhjYmlBZ0lDQWdJQ0FnSUNCY0lsTmxjblpwWTJWWGIzSnJaWElnY21WbmFYTjBjbUYwYVc5dUlITjFZMk5sYzNObWRXd2dkMmwwYUNCelkyOXdaVG9nWENJc1hHNGdJQ0FnSUNBZ0lDQWdjbVZuYVhOMGNtRjBhVzl1TG5OamIzQmxYRzRnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0I5TEZ4dUlDQWdJQ0FnWm5WdVkzUnBiMjRvWlhKeUtTQjdYRzRnSUNBZ0lDQWdJQzh2SUhKbFoybHpkSEpoZEdsdmJpQm1ZV2xzWldRZ09paGNiaUFnSUNBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvWENKVFpYSjJhV05sVjI5eWEyVnlJSEpsWjJsemRISmhkR2x2YmlCbVlXbHNaV1E2SUZ3aUxDQmxjbklwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ2s3WEc0Z0lDQWdkR0Z5WjJWMFQzSnBaMmx1SUQwZ2RHRnlaMlYwVDNKcFoybHVJSHg4SUZ3aUtsd2lPMXh1SUNBZ0lHTmhZMmhsUTJGc2JHSmhZMnNnUFNCallXTm9aVU5oYkd4aVlXTnJJSHg4SUdOaFkyaGxVbVZ4ZFdseVpXMWxiblJ6TzF4dUlDQWdJR2xtSUNoallXTm9aVU5oYkd4aVlXTnJJQ1ltSUhSNWNHVnZaaUJqWVdOb1pVTmhiR3hpWVdOcklDRTlQU0JjSW1aMWJtTjBhVzl1WENJcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loY0ltTnZibVpwWnk1allXTm9aVjl5WlhGMWFYSmxiV1Z1ZEhNZ2JYVnpkQ0JpWlNCaElHWjFibU4wYVc5dVhDSXBPMXh1SUNBZ0lIMWNiaUFnSUNCM2FXNWtiM2N1WVdSa1JYWmxiblJNYVhOMFpXNWxjaWhjSW0xbGMzTmhaMlZjSWl3Z1puVnVZM1JwYjI0b1pTa2dlMXh1SUNBZ0lDQWdhV1lnS0hSaGNtZGxkRTl5YVdkcGJpQTlQVDBnWENJcVhDSWdmSHdnWlM1dmNtbG5hVzRnUFQwOUlIUmhjbWRsZEU5eWFXZHBiaWtnZTF4dUlDQWdJQ0FnSUNCamIyNXpkQ0J0SUQwZ1pTNWtZWFJoTzF4dUlDQWdJQ0FnSUNCcFppQW9iUzUwZVhCbElEMDlQU0JjSW1OaFkyaGxVbVZ4ZFdseVpXMWxiblJ6WENJcElIdGNiaUFnSUNBZ0lDQWdJQ0JqWVdOb1pVTmhiR3hpWVdOcktHMHVjbVZ4ZFdseVpXMWxiblJ6S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1OVhHNWNiaTh2STFOdmRYSmpaU0JvZEhSd2N6b3ZMMkpwZEM1c2VTOHlibVZYWmtveVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z2RYSnNTbTlwYmlndUxpNWhjbWR6S1NCN1hHNGdJSEpsZEhWeWJpQmhjbWR6WEc0Z0lDQWdMbXB2YVc0b1hDSXZYQ0lwWEc0Z0lDQWdMbkpsY0d4aFkyVW9MMXRjWEM5ZEt5OW5MQ0JjSWk5Y0lpbGNiaUFnSUNBdWNtVndiR0ZqWlNndlhpZ3VLeWs2WEZ3dkx5d2dYQ0lrTVRvdkwxd2lLVnh1SUNBZ0lDNXlaWEJzWVdObEtDOWVabWxzWlRvdkxDQmNJbVpwYkdVNkwxd2lLVnh1SUNBZ0lDNXlaWEJzWVdObEtDOWNYQzhvWEZ3L2ZDWjhJMXRlSVYwcEwyY3NJRndpSkRGY0lpbGNiaUFnSUNBdWNtVndiR0ZqWlNndlhGdy9MMmNzSUZ3aUpsd2lLVnh1SUNBZ0lDNXlaWEJzWVdObEtGd2lKbHdpTENCY0lqOWNJaWs3WEc1OVhHNWNibVY0Y0c5eWRDQmpiR0Z6Y3lCTlpYTnpZV2RsUlcxcGRIUmxjaUI3WEc0Z0lHTnZibk4wY25WamRHOXlLR1JsWW5WbktTQjdYRzRnSUNBZ2RHaHBjeTVmWlhabGJuUmZhR0Z1Wkd4bGNuTWdQU0I3ZlR0Y2JpQWdJQ0IwYUdsekxsOXZibU5sWDJoaGJtUnNaWEp6SUQwZ2UzMDdYRzRnSUNBZ2RHaHBjeTVmWkdWaWRXY2dQU0JrWldKMVp6dGNiaUFnZlZ4dUlDQmxiV2wwS0NrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhjSW1WdGFYUWdhWE1nYm05MElHbHRjR3hsYldWdWRHVmtYQ0lwTzF4dUlDQjlYRzRnSUc5dUtHVjJaVzUwTENCb1lXNWtiR1Z5S1NCN1hHNGdJQ0FnYVdZZ0tDRjBhR2x6TGw5bGRtVnVkRjlvWVc1a2JHVnljMXRsZG1WdWRGMHBJSHRjYmlBZ0lDQWdJSFJvYVhNdVgyVjJaVzUwWDJoaGJtUnNaWEp6VzJWMlpXNTBYU0E5SUZ0ZE8xeHVJQ0FnSUgxY2JpQWdJQ0IwYUdsekxsOWxkbVZ1ZEY5b1lXNWtiR1Z5YzF0bGRtVnVkRjB1Y0hWemFDaG9ZVzVrYkdWeUtUdGNiaUFnZlZ4dUlDQnZibU5sS0dWMlpXNTBMQ0JvWVc1a2JHVnlLU0I3WEc0Z0lDQWdhR0Z1Wkd4bGNpNWZYMTlsZG1WdWRGOXlkVzVmYjI1alpTQTlJSFJ5ZFdVN1hHNGdJQ0FnZEdocGN5NXZiaWhsZG1WdWRDd2dhR0Z1Wkd4bGNpazdYRzRnSUgxY2JpQWdiMlptS0dWMlpXNTBMQ0JvWVc1a2JHVnlLU0I3WEc0Z0lDQWdhV1lnS0NGbGRtVnVkQ0FtSmlBaGFHRnVaR3hsY2lrZ2UxeHVJQ0FnSUNBZ0x5OGdjbVZ0YjNabElHRnNiQ0JsZG1WdWRITWdhR0Z1Wkd4bGNuTmNiaUFnSUNBZ0lIUm9hWE11WDJWMlpXNTBYMmhoYm1Sc1pYSnpJRDBnZTMwN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNobGRtVnVkQ0FtSmlBaGFHRnVaR3hsY2lrZ2UxeHVJQ0FnSUNBZ0x5OGdjbVZ0YjNabElHRnNiQ0JvWVc1c1pHVnljeUJtYjNJZ2RHaGxJR1YyWlc1MFhHNGdJQ0FnSUNCcFppQW9kR2hwY3k1ZlpYWmxiblJmYUdGdVpHeGxjbk5iWlhabGJuUmRLU0IwYUdsekxsOWxkbVZ1ZEY5b1lXNWtiR1Z5YzF0bGRtVnVkRjBnUFNCYlhUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnTHk4Z2NtVnRiM1psSUdFZ2MzQmxZMmxtYVdNZ2FHRnVaR3hsY2x4dUlDQWdJQ0FnYVdZZ0tIUm9hWE11WDJWMlpXNTBYMmhoYm1Sc1pYSnpXMlYyWlc1MFhTa2dlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQnBaSGdnUFNCMGFHbHpMbDlsZG1WdWRGOW9ZVzVrYkdWeWMxdGxkbVZ1ZEYwdWFXNWtaWGhQWmlob1lXNWtiR1Z5S1R0Y2JpQWdJQ0FnSUNBZ2FXWWdLR2xrZUNBK1BTQXdLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2RHaHBjeTVmWlhabGJuUmZhR0Z1Wkd4bGNuTmJaWFpsYm5SZExuTndiR2xqWlNocFpIZ3NJREVwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQjlYRzRnSUY5bWFYSmxLR1YyWlc1MExDQmtZWFJoS1NCN1hHNGdJQ0FnYVdZZ0tIUm9hWE11WDJWMlpXNTBYMmhoYm1Sc1pYSnpXMlYyWlc1MFhTa2dlMXh1SUNBZ0lDQWdkbUZ5SUdrZ1BTQjBhR2x6TGw5bGRtVnVkRjlvWVc1a2JHVnljMXRsZG1WdWRGMHViR1Z1WjNSb08xeHVJQ0FnSUNBZ2QyaHBiR1VnS0drdExTa2dlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQm9ZVzVrYkdWeUlEMGdkR2hwY3k1ZlpYWmxiblJmYUdGdVpHeGxjbk5iWlhabGJuUmRXMmxkTzF4dUlDQWdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0FnSUdoaGJtUnNaWElvWkdGMFlTazdYRzRnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtVnljbTl5S0dVcE8xeHVJQ0FnSUNBZ0lDQjlJR1pwYm1Gc2JIa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaG9ZVzVrYkdWeUxsOWZYMlYyWlc1MFgzSjFibDl2Ym1ObEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbDlsZG1WdWRGOW9ZVzVrYkdWeWMxdGxkbVZ1ZEYwdWMzQnNhV05sS0drc0lERXBPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0JwWmlBb2RHaHBjeTVmWkdWaWRXY3BJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMyOXNaUzUzWVhKdUtGd2lkVzVvWVc1a2JHVmtJR1YyWlc1MFhDSXNJR1YyWlc1MExDQmtZWFJoS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMWNibjFjYmlKZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkxRVHRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJWRUU3UVVGWFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVlJCTzBGQlEwRTdRVUZYUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJSa0U3UVVGRFFUdEJRVWRCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGSFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlJVRTdRVUZEUVR0QlFVbEJPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRlFUdEJRVU5CTzBGQlVVRTdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVhwRVFTSXNJbk52ZFhKalpWSnZiM1FpT2lJaWZRPT1cXFxcbi8vIyBzb3VyY2VVUkw9d2VicGFjay1pbnRlcm5hbDovLy8uL3NyYy91dGlscy5qc1xcXFxuXFxcIik7XFxuXFxuLyoqKi8gfSlcXG5cXG4vKioqKioqLyB9KTtcIiwgbnVsbCk7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/plugin.webworker.js\n");

/***/ }),

/***/ "./src/pluginCore.js":
/*!***************************!*\
  !*** ./src/pluginCore.js ***!
  \***************************/
/*! exports provided: connectRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connectRPC\", function() { return connectRPC; });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/**\n * Core plugin script loaded into the plugin process/thread.\n *\n * Initializes the plugin-site API global methods.\n */\n\nfunction connectRPC(connection, config) {\n  config = config || {};\n  const codecs = {};\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\n  rpc.on(\"getInterface\", function () {\n    launchConnected();\n  });\n  rpc.on(\"remoteReady\", function () {\n    const api = rpc.getRemote() || {};\n\n    if (api.export) {\n      throw new Error(\"`export` is a reserved function name\");\n    }\n\n    if (api.onload) {\n      throw new Error(\"`onload` is a reserved function name\");\n    }\n\n    if (api.dispose) {\n      throw new Error(\"`dispose` is a reserved function name\");\n    }\n\n    api.registerCodec = function (config) {\n      if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n        throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n      } else {\n        if (config.type) {\n          for (let k of Object.keys(codecs)) {\n            if (codecs[k].type === config.type || k === config.name) {\n              delete codecs[k];\n              console.warn(\"Remove duplicated codec: \" + k);\n            }\n          }\n        }\n\n        codecs[config[\"name\"]] = config;\n      }\n    };\n\n    api.disposeObject = function (obj) {\n      rpc.disposeObject(obj);\n    };\n\n    api.export = function (_interface, config) {\n      rpc.setInterface(_interface, config);\n    };\n\n    api.onLoad = function (handler) {\n      handler = checkHandler(handler);\n\n      if (connected) {\n        handler();\n      } else {\n        connectedHandlers.push(handler);\n      }\n    };\n\n    api.dispose = function (_interface) {\n      rpc.disconnect();\n    };\n\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n      self.api = api;\n      self.postMessage({\n        type: \"imjoy_remote_api_ready\"\n      });\n    } else if (typeof window) {\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: api\n      }));\n    }\n  });\n  let connected = false;\n  const connectedHandlers = [];\n\n  const launchConnected = function () {\n    if (!connected) {\n      connected = true;\n      let handler;\n\n      while (handler = connectedHandlers.pop()) {\n        handler();\n      }\n    }\n  };\n\n  const checkHandler = function (handler) {\n    const type = typeof handler;\n\n    if (type !== \"function\") {\n      const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\n      throw new Error(msg);\n    }\n\n    return handler;\n  };\n\n  return rpc;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luQ29yZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2ltam95UlBDLy4vc3JjL3BsdWdpbkNvcmUuanM/YTgxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcmUgcGx1Z2luIHNjcmlwdCBsb2FkZWQgaW50byB0aGUgcGx1Z2luIHByb2Nlc3MvdGhyZWFkLlxuICpcbiAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4tc2l0ZSBBUEkgZ2xvYmFsIG1ldGhvZHMuXG4gKi9cbmltcG9ydCB7IFJQQyB9IGZyb20gXCIuL3JwYy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdFJQQyhjb25uZWN0aW9uLCBjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25zdCBjb2RlY3MgPSB7fTtcblxuICBjb25zdCBycGMgPSBuZXcgUlBDKGNvbm5lY3Rpb24sIGNvbmZpZywgY29kZWNzKTtcbiAgcnBjLm9uKFwiZ2V0SW50ZXJmYWNlXCIsIGZ1bmN0aW9uKCkge1xuICAgIGxhdW5jaENvbm5lY3RlZCgpO1xuICB9KTtcblxuICBycGMub24oXCJyZW1vdGVSZWFkeVwiLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBhcGkgPSBycGMuZ2V0UmVtb3RlKCkgfHwge307XG4gICAgaWYgKGFwaS5leHBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBleHBvcnRgIGlzIGEgcmVzZXJ2ZWQgZnVuY3Rpb24gbmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5vbmxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBvbmxvYWRgIGlzIGEgcmVzZXJ2ZWQgZnVuY3Rpb24gbmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKGFwaS5kaXNwb3NlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGlzcG9zZWAgaXMgYSByZXNlcnZlZCBmdW5jdGlvbiBuYW1lXCIpO1xuICAgIH1cbiAgICBhcGkucmVnaXN0ZXJDb2RlYyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgaWYgKCFjb25maWdbXCJuYW1lXCJdIHx8ICghY29uZmlnW1wiZW5jb2RlclwiXSAmJiAhY29uZmlnW1wiZGVjb2RlclwiXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBjb2RlYyBmb3JtYXQsIHBsZWFzZSBtYWtlIHN1cmUgeW91IHByb3ZpZGUgYSBuYW1lLCB0eXBlLCBlbmNvZGVyIGFuZCBkZWNvZGVyLlwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgICBmb3IgKGxldCBrIG9mIE9iamVjdC5rZXlzKGNvZGVjcykpIHtcbiAgICAgICAgICAgIGlmIChjb2RlY3Nba10udHlwZSA9PT0gY29uZmlnLnR5cGUgfHwgayA9PT0gY29uZmlnLm5hbWUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGNvZGVjc1trXTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUmVtb3ZlIGR1cGxpY2F0ZWQgY29kZWM6IFwiICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvZGVjc1tjb25maWdbXCJuYW1lXCJdXSA9IGNvbmZpZztcbiAgICAgIH1cbiAgICB9O1xuICAgIGFwaS5kaXNwb3NlT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBycGMuZGlzcG9zZU9iamVjdChvYmopO1xuICAgIH07XG4gICAgYXBpLmV4cG9ydCA9IGZ1bmN0aW9uKF9pbnRlcmZhY2UsIGNvbmZpZykge1xuICAgICAgcnBjLnNldEludGVyZmFjZShfaW50ZXJmYWNlLCBjb25maWcpO1xuICAgIH07XG4gICAgYXBpLm9uTG9hZCA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIgPSBjaGVja0hhbmRsZXIoaGFuZGxlcik7XG4gICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbm5lY3RlZEhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBhcGkuZGlzcG9zZSA9IGZ1bmN0aW9uKF9pbnRlcmZhY2UpIHtcbiAgICAgIHJwYy5kaXNjb25uZWN0KCk7XG4gICAgfTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlXG4gICAgKSB7XG4gICAgICBzZWxmLmFwaSA9IGFwaTtcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcImltam95X3JlbW90ZV9hcGlfcmVhZHlcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93KSB7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFwiaW1qb3lfcmVtb3RlX2FwaV9yZWFkeVwiLCB7IGRldGFpbDogYXBpIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGNvbm5lY3RlZCA9IGZhbHNlO1xuICBjb25zdCBjb25uZWN0ZWRIYW5kbGVycyA9IFtdO1xuXG4gIGNvbnN0IGxhdW5jaENvbm5lY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghY29ubmVjdGVkKSB7XG4gICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgICBsZXQgaGFuZGxlcjtcbiAgICAgIHdoaWxlICgoaGFuZGxlciA9IGNvbm5lY3RlZEhhbmRsZXJzLnBvcCgpKSkge1xuICAgICAgICBoYW5kbGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNoZWNrSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGhhbmRsZXI7XG4gICAgaWYgKHR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgbXNnID1cbiAgICAgICAgXCJBIGZ1bmN0aW9uIG1heSBvbmx5IGJlIHN1YnNyaWJlZCB0byB0aGUgZXZlbnQsIFwiICtcbiAgICAgICAgdHlwZSArXG4gICAgICAgIFwiIHdhcyBwcm92aWRlZCBpbnN0ZWFkXCI7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH07XG5cbiAgcmV0dXJuIHJwYztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pluginCore.js\n");

/***/ }),

/***/ "./src/pluginIframe.js":
/*!*****************************!*\
  !*** ./src/pluginIframe.js ***!
  \*****************************/
/*! exports provided: Connection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Connection\", function() { return Connection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return setupIframe; });\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/**\n * Contains the routines loaded by the plugin iframe under web-browser\n * in case when worker failed to initialize\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\n\n\n // Create a new, plain <span> element\n\nfunction _htmlToElement(html) {\n  var template = document.createElement(\"template\");\n  html = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = html;\n  return template.content.firstChild;\n}\n\nvar _importScript = function (url) {\n  //url is URL of external file, implementationCode is the code\n  //to be called from the file, location is the location to\n  //insert the <script> element\n  return new Promise((resolve, reject) => {\n    var scriptTag = document.createElement(\"script\");\n    scriptTag.src = url;\n    scriptTag.type = \"text/javascript\";\n    scriptTag.onload = resolve;\n\n    scriptTag.onreadystatechange = function () {\n      if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n        resolve();\n      }\n    };\n\n    scriptTag.onerror = reject;\n    document.head.appendChild(scriptTag);\n  });\n}; // support importScripts outside web worker\n\n\nasync function importScripts() {\n  var args = Array.prototype.slice.call(arguments),\n      len = args.length,\n      i = 0;\n\n  for (; i < len; i++) {\n    await _importScript(args[i]);\n  }\n}\n\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\n  constructor(config) {\n    super(config && config.debug);\n    this.config = config || {};\n    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n  }\n\n  connect() {\n    this.config.target_origin = this.config.target_origin || \"*\"; // this will call handleEvent function\n\n    window.addEventListener(\"message\", this);\n    this.emit({\n      type: \"initialized\",\n      config: this.config,\n      origin: window.location.origin,\n      peer_id: this.peer_id\n    });\n\n    this._fire(\"connected\");\n  }\n\n  handleEvent(e) {\n    if (e.type === \"message\" && (this.config.target_origin === \"*\" || e.origin === this.config.target_origin)) {\n      if (e.data.peer_id === this.peer_id) {\n        this._fire(e.data.type, e.data);\n      } else if (this.config.debug) {\n        console.log(`connection peer id mismatch ${e.data.peer_id} !== ${this.peer_id}`);\n      }\n    }\n  }\n\n  disconnect() {\n    this._fire(\"beforeDisconnect\");\n\n    window.removeEventListener(\"message\", this);\n\n    this._fire(\"disconnected\");\n  }\n\n  emit(data) {\n    let transferables;\n\n    if (data.__transferables__) {\n      transferables = data.__transferables__;\n      delete data.__transferables__;\n    }\n\n    parent.postMessage(data, this.config.target_origin, transferables);\n  }\n\n  async execute(code) {\n    try {\n      if (code.type === \"requirements\") {\n        if (code.requirements && (Array.isArray(code.requirements) || typeof code.requirements === \"string\")) {\n          try {\n            var link_node;\n            code.requirements = typeof code.requirements === \"string\" ? [code.requirements] : code.requirements;\n\n            if (Array.isArray(code.requirements)) {\n              for (var i = 0; i < code.requirements.length; i++) {\n                if (code.requirements[i].toLowerCase().endsWith(\".css\") || code.requirements[i].startsWith(\"css:\")) {\n                  if (code.requirements[i].startsWith(\"css:\")) {\n                    code.requirements[i] = code.requirements[i].slice(4);\n                  }\n\n                  link_node = document.createElement(\"link\");\n                  link_node.rel = \"stylesheet\";\n                  link_node.href = code.requirements[i];\n                  document.head.appendChild(link_node);\n                } else if (code.requirements[i].toLowerCase().endsWith(\".js\") || code.requirements[i].startsWith(\"js:\")) {\n                  if (code.requirements[i].startsWith(\"js:\")) {\n                    code.requirements[i] = code.requirements[i].slice(3);\n                  }\n\n                  await importScripts(code.requirements[i]);\n                } else if (code.requirements[i].startsWith(\"http\")) {\n                  await importScripts(code.requirements[i]);\n                } else if (code.requirements[i].startsWith(\"cache:\")) {//ignore cache\n                } else {\n                  console.log(\"Unprocessed requirements url: \" + code.requirements[i]);\n                }\n              }\n            } else {\n              throw \"unsupported requirements definition\";\n            }\n          } catch (e) {\n            throw \"failed to import required scripts: \" + code.requirements.toString();\n          }\n        }\n      } else if (code.type === \"script\") {\n        if (code.src) {\n          var script_node = document.createElement(\"script\");\n          script_node.setAttribute(\"type\", code.attrs.type);\n          script_node.setAttribute(\"src\", code.src);\n          document.head.appendChild(script_node);\n        } else {\n          if (code.content && (!code.attrs.type || code.attrs.type === \"text/javascript\")) {\n            // document.addEventListener(\"DOMContentLoaded\", function(){\n            eval(code.content); // });\n          } else {\n            var node = document.createElement(\"script\");\n            node.setAttribute(\"type\", code.attrs.type);\n            node.appendChild(document.createTextNode(code.content));\n            document.body.appendChild(node);\n          }\n        }\n      } else if (code.type === \"style\") {\n        const style_node = document.createElement(\"style\");\n\n        if (code.src) {\n          style_node.src = code.src;\n        }\n\n        style_node.innerHTML = code.content;\n        document.head.appendChild(style_node);\n      } else if (code.type === \"link\") {\n        const link_node_ = document.createElement(\"link\");\n\n        if (code.rel) {\n          link_node_.rel = code.rel;\n        }\n\n        if (code.href) {\n          link_node_.href = code.href;\n        }\n\n        if (code.attrs && code.attrs.type) {\n          link_node_.type = code.attrs.type;\n        }\n\n        document.head.appendChild(link_node_);\n      } else if (code.type === \"html\") {\n        document.body.appendChild(_htmlToElement(code.content));\n      } else {\n        throw \"unsupported code type.\";\n      }\n\n      parent.postMessage({\n        type: \"executed\"\n      }, this.config.target_origin);\n    } catch (e) {\n      console.error(\"failed to execute scripts: \", code, e);\n      parent.postMessage({\n        type: \"executed\",\n        error: e.stack || String(e)\n      }, this.config.target_origin);\n    }\n  }\n\n}\nfunction setupIframe(config) {\n  config = config || {};\n  config.dedicated_thread = false;\n  config.lang = \"javascript\";\n  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n  const conn = new Connection(config);\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n  conn.connect();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luSWZyYW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9zcmMvcGx1Z2luSWZyYW1lLmpzPzI2NzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyB0aGUgcm91dGluZXMgbG9hZGVkIGJ5IHRoZSBwbHVnaW4gaWZyYW1lIHVuZGVyIHdlYi1icm93c2VyXG4gKiBpbiBjYXNlIHdoZW4gd29ya2VyIGZhaWxlZCB0byBpbml0aWFsaXplXG4gKlxuICogSW5pdGlhbGl6ZXMgdGhlIHdlYiBlbnZpcm9ubWVudCB2ZXJzaW9uIG9mIHRoZSBwbGF0Zm9ybS1kZXBlbmRlbnRcbiAqIGNvbm5lY3Rpb24gb2JqZWN0IGZvciB0aGUgcGx1Z2luIHNpdGVcbiAqL1xuaW1wb3J0IHsgY29ubmVjdFJQQyB9IGZyb20gXCIuL3BsdWdpbkNvcmUuanNcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OIH0gZnJvbSBcIi4vcnBjLmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlRW1pdHRlciwgcmFuZElkIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIENyZWF0ZSBhIG5ldywgcGxhaW4gPHNwYW4+IGVsZW1lbnRcbmZ1bmN0aW9uIF9odG1sVG9FbGVtZW50KGh0bWwpIHtcbiAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICBodG1sID0gaHRtbC50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZDtcbn1cblxudmFyIF9pbXBvcnRTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgLy91cmwgaXMgVVJMIG9mIGV4dGVybmFsIGZpbGUsIGltcGxlbWVudGF0aW9uQ29kZSBpcyB0aGUgY29kZVxuICAvL3RvIGJlIGNhbGxlZCBmcm9tIHRoZSBmaWxlLCBsb2NhdGlvbiBpcyB0aGUgbG9jYXRpb24gdG9cbiAgLy9pbnNlcnQgdGhlIDxzY3JpcHQ+IGVsZW1lbnRcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBzY3JpcHRUYWcuc3JjID0gdXJsO1xuICAgIHNjcmlwdFRhZy50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcbiAgICBzY3JpcHRUYWcub25sb2FkID0gcmVzb2x2ZTtcbiAgICBzY3JpcHRUYWcub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBcImxvYWRlZFwiIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNjcmlwdFRhZy5vbmVycm9yID0gcmVqZWN0O1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0VGFnKTtcbiAgfSk7XG59O1xuXG4vLyBzdXBwb3J0IGltcG9ydFNjcmlwdHMgb3V0c2lkZSB3ZWIgd29ya2VyXG5hc3luYyBmdW5jdGlvbiBpbXBvcnRTY3JpcHRzKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgbGVuID0gYXJncy5sZW5ndGgsXG4gICAgaSA9IDA7XG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhd2FpdCBfaW1wb3J0U2NyaXB0KGFyZ3NbaV0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uIGV4dGVuZHMgTWVzc2FnZUVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcihjb25maWcgJiYgY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLnBlZXJfaWQgPSByYW5kSWQoKTtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIHRoaXMuY29uZmlnLnRhcmdldF9vcmlnaW4gPSB0aGlzLmNvbmZpZy50YXJnZXRfb3JpZ2luIHx8IFwiKlwiO1xuICAgIC8vIHRoaXMgd2lsbCBjYWxsIGhhbmRsZUV2ZW50IGZ1bmN0aW9uXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMpO1xuICAgIHRoaXMuZW1pdCh7XG4gICAgICB0eXBlOiBcImluaXRpYWxpemVkXCIsXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgcGVlcl9pZDogdGhpcy5wZWVyX2lkXG4gICAgfSk7XG4gICAgdGhpcy5fZmlyZShcImNvbm5lY3RlZFwiKTtcbiAgfVxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgaWYgKFxuICAgICAgZS50eXBlID09PSBcIm1lc3NhZ2VcIiAmJlxuICAgICAgKHRoaXMuY29uZmlnLnRhcmdldF9vcmlnaW4gPT09IFwiKlwiIHx8XG4gICAgICAgIGUub3JpZ2luID09PSB0aGlzLmNvbmZpZy50YXJnZXRfb3JpZ2luKVxuICAgICkge1xuICAgICAgaWYgKGUuZGF0YS5wZWVyX2lkID09PSB0aGlzLnBlZXJfaWQpIHtcbiAgICAgICAgdGhpcy5fZmlyZShlLmRhdGEudHlwZSwgZS5kYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYGNvbm5lY3Rpb24gcGVlciBpZCBtaXNtYXRjaCAke2UuZGF0YS5wZWVyX2lkfSAhPT0gJHt0aGlzLnBlZXJfaWR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuX2ZpcmUoXCJiZWZvcmVEaXNjb25uZWN0XCIpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzKTtcbiAgICB0aGlzLl9maXJlKFwiZGlzY29ubmVjdGVkXCIpO1xuICB9XG4gIGVtaXQoZGF0YSkge1xuICAgIGxldCB0cmFuc2ZlcmFibGVzO1xuICAgIGlmIChkYXRhLl9fdHJhbnNmZXJhYmxlc19fKSB7XG4gICAgICB0cmFuc2ZlcmFibGVzID0gZGF0YS5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgIGRlbGV0ZSBkYXRhLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgIH1cbiAgICBwYXJlbnQucG9zdE1lc3NhZ2UoZGF0YSwgdGhpcy5jb25maWcudGFyZ2V0X29yaWdpbiwgdHJhbnNmZXJhYmxlcyk7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZShjb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChjb2RlLnR5cGUgPT09IFwicmVxdWlyZW1lbnRzXCIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzICYmXG4gICAgICAgICAgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbGlua19ub2RlO1xuICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHMgPVxuICAgICAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IFtjb2RlLnJlcXVpcmVtZW50c11cbiAgICAgICAgICAgICAgICA6IGNvZGUucmVxdWlyZW1lbnRzO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZS5yZXF1aXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmNzc1wiKSB8fFxuICAgICAgICAgICAgICAgICAgY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImNzczpcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY3NzOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGlua19ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICAgICAgICBsaW5rX25vZGUucmVsID0gXCJzdHlsZXNoZWV0XCI7XG4gICAgICAgICAgICAgICAgICBsaW5rX25vZGUuaHJlZiA9IGNvZGUucmVxdWlyZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rX25vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmpzXCIpIHx8XG4gICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwianM6XCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY29kZS5yZXF1aXJlbWVudHNbaV0uc3RhcnRzV2l0aChcImpzOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYXdhaXQgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgaW1wb3J0U2NyaXB0cyhjb2RlLnJlcXVpcmVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY2FjaGU6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAvL2lnbm9yZSBjYWNoZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgXCJVbnByb2Nlc3NlZCByZXF1aXJlbWVudHMgdXJsOiBcIiArIGNvZGUucmVxdWlyZW1lbnRzW2ldXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCByZXF1aXJlbWVudHMgZGVmaW5pdGlvblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IFwiZmFpbGVkIHRvIGltcG9ydCByZXF1aXJlZCBzY3JpcHRzOiBcIiArXG4gICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUudHlwZSA9PT0gXCJzY3JpcHRcIikge1xuICAgICAgICBpZiAoY29kZS5zcmMpIHtcbiAgICAgICAgICB2YXIgc2NyaXB0X25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgIHNjcmlwdF9ub2RlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgY29kZS5hdHRycy50eXBlKTtcbiAgICAgICAgICBzY3JpcHRfbm9kZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgY29kZS5zcmMpO1xuICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0X25vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvZGUuY29udGVudCAmJlxuICAgICAgICAgICAgKCFjb2RlLmF0dHJzLnR5cGUgfHwgY29kZS5hdHRycy50eXBlID09PSBcInRleHQvamF2YXNjcmlwdFwiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGV2YWwoY29kZS5jb250ZW50KTtcbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgY29kZS5hdHRycy50eXBlKTtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29kZS5jb250ZW50KSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwic3R5bGVcIikge1xuICAgICAgICBjb25zdCBzdHlsZV9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAoY29kZS5zcmMpIHtcbiAgICAgICAgICBzdHlsZV9ub2RlLnNyYyA9IGNvZGUuc3JjO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlX25vZGUuaW5uZXJIVE1MID0gY29kZS5jb250ZW50O1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlX25vZGUpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwibGlua1wiKSB7XG4gICAgICAgIGNvbnN0IGxpbmtfbm9kZV8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgICAgaWYgKGNvZGUucmVsKSB7XG4gICAgICAgICAgbGlua19ub2RlXy5yZWwgPSBjb2RlLnJlbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZS5ocmVmKSB7XG4gICAgICAgICAgbGlua19ub2RlXy5ocmVmID0gY29kZS5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlLmF0dHJzICYmIGNvZGUuYXR0cnMudHlwZSkge1xuICAgICAgICAgIGxpbmtfbm9kZV8udHlwZSA9IGNvZGUuYXR0cnMudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmtfbm9kZV8pO1xuICAgICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX2h0bWxUb0VsZW1lbnQoY29kZS5jb250ZW50KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcInVuc3VwcG9ydGVkIGNvZGUgdHlwZS5cIjtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXhlY3V0ZWRcIiB9LCB0aGlzLmNvbmZpZy50YXJnZXRfb3JpZ2luKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIGV4ZWN1dGUgc2NyaXB0czogXCIsIGNvZGUsIGUpO1xuICAgICAgcGFyZW50LnBvc3RNZXNzYWdlKFxuICAgICAgICB7IHR5cGU6IFwiZXhlY3V0ZWRcIiwgZXJyb3I6IGUuc3RhY2sgfHwgU3RyaW5nKGUpIH0sXG4gICAgICAgIHRoaXMuY29uZmlnLnRhcmdldF9vcmlnaW5cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwSWZyYW1lKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kZWRpY2F0ZWRfdGhyZWFkID0gZmFsc2U7XG4gIGNvbmZpZy5sYW5nID0gXCJqYXZhc2NyaXB0XCI7XG4gIGNvbmZpZy5hcGlfdmVyc2lvbiA9IEFQSV9WRVJTSU9OO1xuICBjb25zdCBjb25uID0gbmV3IENvbm5lY3Rpb24oY29uZmlnKTtcbiAgY29ubmVjdFJQQyhjb25uLCBjb25maWcpO1xuICBjb25uLmNvbm5lY3QoKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQXpKQTtBQTJKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pluginIframe.js\n");

/***/ }),

/***/ "./src/pluginWebPython.js":
/*!********************************!*\
  !*** ./src/pluginWebPython.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return setupWebPython; });\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _pluginIframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pluginIframe */ \"./src/pluginIframe.js\");\n/**\n * Contains the routines loaded by the plugin iframe under web-browser\n * in case when worker failed to initialize\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\n\n\n // Create a new, plain <span> element\n\nfunction _htmlToElement(html) {\n  var template = document.createElement(\"template\");\n  html = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = html;\n  return template.content.firstChild;\n}\n\nconst _importScript = function (url) {\n  //url is URL of external file, implementationCode is the code\n  //to be called from the file, location is the location to\n  //insert the <script> element\n  return new Promise((resolve, reject) => {\n    var scriptTag = document.createElement(\"script\");\n    scriptTag.src = url;\n    scriptTag.onload = resolve;\n\n    scriptTag.onreadystatechange = function () {\n      if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n        resolve();\n      }\n    };\n\n    scriptTag.onerror = reject;\n    document.head.appendChild(scriptTag);\n  });\n}; // support importScripts outside web worker\n\n\nasync function importScripts() {\n  var args = Array.prototype.slice.call(arguments),\n      len = args.length,\n      i = 0;\n\n  for (; i < len; i++) {\n    await _importScript(args[i]);\n  }\n}\n\nconst startup_script = `\nfrom js import api\nimport sys\nfrom types import ModuleType\nm = ModuleType(\"imjoy\")\nsys.modules[m.__name__] = m\nm.__file__ = m.__name__ + \".py\"\nm.api = api\n`;\nlet _export_plugin_api = null;\n\nconst execute_python_code = function (code) {\n  try {\n    if (!_export_plugin_api) {\n      _export_plugin_api = window.api.export;\n\n      window.api.export = function (p) {\n        if (typeof p === \"object\") {\n          const _api = {};\n\n          for (let k in p) {\n            if (!k.startsWith(\"_\")) {\n              _api[k] = p[k];\n            }\n          }\n\n          _export_plugin_api(_api);\n        } else if (typeof p === \"function\") {\n          const _api = {};\n          const getattr = window.pyodide.pyimport(\"getattr\");\n          const hasattr = window.pyodide.pyimport(\"hasattr\");\n\n          for (let k of Object.getOwnPropertyNames(p)) {\n            if (!k.startsWith(\"_\") && hasattr(p, k)) {\n              const func = getattr(p, k);\n\n              _api[k] = function () {\n                return func(...Array.prototype.slice.call(arguments));\n              };\n            }\n          }\n\n          _export_plugin_api(_api);\n        } else {\n          throw \"unsupported api export\";\n        }\n      };\n    }\n\n    window.pyodide.runPython(startup_script);\n    window.pyodide.runPython(code.content);\n  } catch (e) {\n    throw e;\n  }\n};\n\nfunction setupPyodide() {\n  return new Promise((resolve, reject) => {\n    window.languagePluginUrl = \"https://static.imjoy.io/pyodide/\";\n    importScripts(\"https://static.imjoy.io/pyodide/pyodide.js\").then(() => {\n      // hack for matplotlib etc.\n      window.iodide = {\n        output: {\n          element: function element(type) {\n            const div = document.createElement(type);\n            const output = document.getElementById(\"output\") || document.body;\n            output.appendChild(div);\n            return div;\n          }\n        }\n      };\n      window.languagePluginLoader.then(() => {\n        // pyodide is now ready to use...\n        console.log(window.pyodide.runPython(\"import sys\\nsys.version\"));\n        resolve();\n      }).catch(reject);\n    });\n  });\n} // connection object for the RPC constructor\n\n\nclass Connection extends _pluginIframe__WEBPACK_IMPORTED_MODULE_2__[\"Connection\"] {\n  constructor(config) {\n    super(config);\n  }\n\n  async execute(code) {\n    if (code.type === \"requirements\") {\n      if (code.requirements) {\n        code.requirements = typeof code.requirements === \"string\" ? [code.requirements] : code.requirements;\n\n        if (Array.isArray(code.requirements)) {\n          const python_packages = [];\n\n          for (var i = 0; i < code.requirements.length; i++) {\n            if (code.requirements[i].toLowerCase().endsWith(\".css\") || code.requirements[i].startsWith(\"css:\")) {\n              if (code.requirements[i].startsWith(\"css:\")) {\n                code.requirements[i] = code.requirements[i].slice(4);\n              }\n\n              link_node = document.createElement(\"link\");\n              link_node.rel = \"stylesheet\";\n              link_node.href = code.requirements[i];\n              document.head.appendChild(link_node);\n            } else if ( // code.requirements[i].toLowerCase().endsWith(\".js\") ||\n            code.requirements[i].startsWith(\"js:\")) {\n              if (code.requirements[i].startsWith(\"js:\")) {\n                code.requirements[i] = code.requirements[i].slice(3);\n              }\n\n              await importScripts(code.requirements[i]);\n            } else if (code.requirements[i].startsWith(\"cache:\")) {//ignore cache\n            } else if (code.requirements[i].toLowerCase().endsWith(\".js\") || code.requirements[i].startsWith(\"package:\")) {\n              if (code.requirements[i].startsWith(\"package:\")) {\n                code.requirements[i] = code.requirements[i].slice(8);\n              }\n\n              python_packages.push(code.requirements[i]);\n            } else if (code.requirements[i].startsWith(\"http:\") || code.requirements[i].startsWith(\"https:\")) {\n              console.log(\"Unprocessed requirements url: \" + code.requirements[i]);\n            } else {\n              python_packages.push(code.requirements[i]);\n            }\n          }\n\n          await window.pyodide.loadPackage(python_packages);\n        } else {\n          throw \"unsupported requirements definition\";\n        }\n      }\n    } else if (code.type === \"script\") {\n      if (code.src) {\n        var script_node = document.createElement(\"script\");\n        script_node.setAttribute(\"type\", code.attrs.type);\n        script_node.setAttribute(\"src\", code.src);\n        document.head.appendChild(script_node);\n      } else {\n        if (code.content && code.lang === \"python\") {\n          execute_python_code(code);\n        } else if (code.content && code.lang === \"javascript\") {\n          try {\n            eval(code.content);\n          } catch (e) {\n            console.error(e.message, e.stack);\n            throw e;\n          }\n        } else {\n          const node = document.createElement(\"script\");\n          node.setAttribute(\"type\", code.attrs.type);\n          node.appendChild(document.createTextNode(code.content));\n          document.body.appendChild(node);\n        }\n      }\n    } else if (code.type === \"style\") {\n      const style_node = document.createElement(\"style\");\n\n      if (code.src) {\n        style_node.src = code.src;\n      }\n\n      style_node.innerHTML = code.content;\n      document.head.appendChild(style_node);\n    } else if (code.type === \"link\") {\n      const link_node = document.createElement(\"link\");\n\n      if (code.rel) {\n        link_node.rel = code.rel;\n      }\n\n      if (code.href) {\n        link_node.href = code.href;\n      }\n\n      if (code.attrs && code.attrs.type) {\n        link_node.type = code.attrs.type;\n      }\n\n      document.head.appendChild(link_node);\n    } else if (code.type === \"html\") {\n      document.body.appendChild(_htmlToElement(code.content));\n    } else {\n      throw \"unsupported code type.\";\n    }\n  }\n\n}\n\nfunction setupWebPython(config) {\n  config = config || {};\n  config.debug = true;\n  config.dedicated_thread = false;\n  config.lang = \"python\";\n  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n  const conn = new Connection(config);\n  setupPyodide().then(() => {\n    Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n    conn.connect();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2luV2ViUHl0aG9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9zcmMvcGx1Z2luV2ViUHl0aG9uLmpzPzYwYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyB0aGUgcm91dGluZXMgbG9hZGVkIGJ5IHRoZSBwbHVnaW4gaWZyYW1lIHVuZGVyIHdlYi1icm93c2VyXG4gKiBpbiBjYXNlIHdoZW4gd29ya2VyIGZhaWxlZCB0byBpbml0aWFsaXplXG4gKlxuICogSW5pdGlhbGl6ZXMgdGhlIHdlYiBlbnZpcm9ubWVudCB2ZXJzaW9uIG9mIHRoZSBwbGF0Zm9ybS1kZXBlbmRlbnRcbiAqIGNvbm5lY3Rpb24gb2JqZWN0IGZvciB0aGUgcGx1Z2luIHNpdGVcbiAqL1xuaW1wb3J0IHsgY29ubmVjdFJQQyB9IGZyb20gXCIuL3BsdWdpbkNvcmUuanNcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OIH0gZnJvbSBcIi4vcnBjLmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0aW9uIGFzIElmcmFtZUNvbm5lY3Rpb24sIGV4ZWN1dGVDb2RlIH0gZnJvbSBcIi4vcGx1Z2luSWZyYW1lXCI7XG4vLyBDcmVhdGUgYSBuZXcsIHBsYWluIDxzcGFuPiBlbGVtZW50XG5mdW5jdGlvbiBfaHRtbFRvRWxlbWVudChodG1sKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgaHRtbCA9IGh0bWwudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG4gIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG59XG5cbmNvbnN0IF9pbXBvcnRTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgLy91cmwgaXMgVVJMIG9mIGV4dGVybmFsIGZpbGUsIGltcGxlbWVudGF0aW9uQ29kZSBpcyB0aGUgY29kZVxuICAvL3RvIGJlIGNhbGxlZCBmcm9tIHRoZSBmaWxlLCBsb2NhdGlvbiBpcyB0aGUgbG9jYXRpb24gdG9cbiAgLy9pbnNlcnQgdGhlIDxzY3JpcHQ+IGVsZW1lbnRcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBzY3JpcHRUYWcuc3JjID0gdXJsO1xuICAgIHNjcmlwdFRhZy5vbmxvYWQgPSByZXNvbHZlO1xuICAgIHNjcmlwdFRhZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwibG9hZGVkXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2NyaXB0VGFnLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRUYWcpO1xuICB9KTtcbn07XG5cbi8vIHN1cHBvcnQgaW1wb3J0U2NyaXB0cyBvdXRzaWRlIHdlYiB3b3JrZXJcblxuYXN5bmMgZnVuY3Rpb24gaW1wb3J0U2NyaXB0cygpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGxlbiA9IGFyZ3MubGVuZ3RoLFxuICAgIGkgPSAwO1xuICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXdhaXQgX2ltcG9ydFNjcmlwdChhcmdzW2ldKTtcbiAgfVxufVxuXG5jb25zdCBzdGFydHVwX3NjcmlwdCA9IGBcbmZyb20ganMgaW1wb3J0IGFwaVxuaW1wb3J0IHN5c1xuZnJvbSB0eXBlcyBpbXBvcnQgTW9kdWxlVHlwZVxubSA9IE1vZHVsZVR5cGUoXCJpbWpveVwiKVxuc3lzLm1vZHVsZXNbbS5fX25hbWVfX10gPSBtXG5tLl9fZmlsZV9fID0gbS5fX25hbWVfXyArIFwiLnB5XCJcbm0uYXBpID0gYXBpXG5gO1xuXG5sZXQgX2V4cG9ydF9wbHVnaW5fYXBpID0gbnVsbDtcbmNvbnN0IGV4ZWN1dGVfcHl0aG9uX2NvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFfZXhwb3J0X3BsdWdpbl9hcGkpIHtcbiAgICAgIF9leHBvcnRfcGx1Z2luX2FwaSA9IHdpbmRvdy5hcGkuZXhwb3J0O1xuICAgICAgd2luZG93LmFwaS5leHBvcnQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGNvbnN0IF9hcGkgPSB7fTtcbiAgICAgICAgICBmb3IgKGxldCBrIGluIHApIHtcbiAgICAgICAgICAgIGlmICghay5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICAgICAgICAgICBfYXBpW2tdID0gcFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX2V4cG9ydF9wbHVnaW5fYXBpKF9hcGkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBfYXBpID0ge307XG4gICAgICAgICAgY29uc3QgZ2V0YXR0ciA9IHdpbmRvdy5weW9kaWRlLnB5aW1wb3J0KFwiZ2V0YXR0clwiKTtcbiAgICAgICAgICBjb25zdCBoYXNhdHRyID0gd2luZG93LnB5b2RpZGUucHlpbXBvcnQoXCJoYXNhdHRyXCIpO1xuICAgICAgICAgIGZvciAobGV0IGsgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocCkpIHtcbiAgICAgICAgICAgIGlmICghay5zdGFydHNXaXRoKFwiX1wiKSAmJiBoYXNhdHRyKHAsIGspKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBnZXRhdHRyKHAsIGspO1xuICAgICAgICAgICAgICBfYXBpW2tdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9leHBvcnRfcGx1Z2luX2FwaShfYXBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcInVuc3VwcG9ydGVkIGFwaSBleHBvcnRcIjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgd2luZG93LnB5b2RpZGUucnVuUHl0aG9uKHN0YXJ0dXBfc2NyaXB0KTtcbiAgICB3aW5kb3cucHlvZGlkZS5ydW5QeXRob24oY29kZS5jb250ZW50KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldHVwUHlvZGlkZSgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3aW5kb3cubGFuZ3VhZ2VQbHVnaW5VcmwgPSBcImh0dHBzOi8vc3RhdGljLmltam95LmlvL3B5b2RpZGUvXCI7XG4gICAgaW1wb3J0U2NyaXB0cyhcImh0dHBzOi8vc3RhdGljLmltam95LmlvL3B5b2RpZGUvcHlvZGlkZS5qc1wiKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIGhhY2sgZm9yIG1hdHBsb3RsaWIgZXRjLlxuICAgICAgd2luZG93LmlvZGlkZSA9IHtcbiAgICAgICAgb3V0cHV0OiB7XG4gICAgICAgICAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudCh0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXRcIikgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIG91dHB1dC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5sYW5ndWFnZVBsdWdpbkxvYWRlclxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgLy8gcHlvZGlkZSBpcyBub3cgcmVhZHkgdG8gdXNlLi4uXG4gICAgICAgICAgY29uc29sZS5sb2cod2luZG93LnB5b2RpZGUucnVuUHl0aG9uKFwiaW1wb3J0IHN5c1xcbnN5cy52ZXJzaW9uXCIpKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9KTtcbn1cbi8vIGNvbm5lY3Rpb24gb2JqZWN0IGZvciB0aGUgUlBDIGNvbnN0cnVjdG9yXG5jbGFzcyBDb25uZWN0aW9uIGV4dGVuZHMgSWZyYW1lQ29ubmVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKGNvbmZpZyk7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZShjb2RlKSB7XG4gICAgaWYgKGNvZGUudHlwZSA9PT0gXCJyZXF1aXJlbWVudHNcIikge1xuICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzKSB7XG4gICAgICAgIGNvZGUucmVxdWlyZW1lbnRzID1cbiAgICAgICAgICB0eXBlb2YgY29kZS5yZXF1aXJlbWVudHMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gW2NvZGUucmVxdWlyZW1lbnRzXVxuICAgICAgICAgICAgOiBjb2RlLnJlcXVpcmVtZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29kZS5yZXF1aXJlbWVudHMpKSB7XG4gICAgICAgICAgY29uc3QgcHl0aG9uX3BhY2thZ2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlLnJlcXVpcmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmNzc1wiKSB8fFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY3NzOlwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY3NzOlwiKSkge1xuICAgICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldID0gY29kZS5yZXF1aXJlbWVudHNbaV0uc2xpY2UoNCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGlua19ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICAgIGxpbmtfbm9kZS5yZWwgPSBcInN0eWxlc2hlZXRcIjtcbiAgICAgICAgICAgICAgbGlua19ub2RlLmhyZWYgPSBjb2RlLnJlcXVpcmVtZW50c1tpXTtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rX25vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgLy8gY29kZS5yZXF1aXJlbWVudHNbaV0udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcIi5qc1wiKSB8fFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwianM6XCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJqczpcIikpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF3YWl0IGltcG9ydFNjcmlwdHMoY29kZS5yZXF1aXJlbWVudHNbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiY2FjaGU6XCIpKSB7XG4gICAgICAgICAgICAgIC8vaWdub3JlIGNhY2hlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLmpzXCIpIHx8XG4gICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJwYWNrYWdlOlwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwicGFja2FnZTpcIikpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXSA9IGNvZGUucmVxdWlyZW1lbnRzW2ldLnNsaWNlKDgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHB5dGhvbl9wYWNrYWdlcy5wdXNoKGNvZGUucmVxdWlyZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIGNvZGUucmVxdWlyZW1lbnRzW2ldLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSB8fFxuICAgICAgICAgICAgICBjb2RlLnJlcXVpcmVtZW50c1tpXS5zdGFydHNXaXRoKFwiaHR0cHM6XCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCJVbnByb2Nlc3NlZCByZXF1aXJlbWVudHMgdXJsOiBcIiArIGNvZGUucmVxdWlyZW1lbnRzW2ldXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBweXRob25fcGFja2FnZXMucHVzaChjb2RlLnJlcXVpcmVtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHdpbmRvdy5weW9kaWRlLmxvYWRQYWNrYWdlKHB5dGhvbl9wYWNrYWdlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCByZXF1aXJlbWVudHMgZGVmaW5pdGlvblwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgIGlmIChjb2RlLnNyYykge1xuICAgICAgICB2YXIgc2NyaXB0X25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBzY3JpcHRfbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIGNvZGUuYXR0cnMudHlwZSk7XG4gICAgICAgIHNjcmlwdF9ub2RlLnNldEF0dHJpYnV0ZShcInNyY1wiLCBjb2RlLnNyYyk7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0X25vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvZGUuY29udGVudCAmJiBjb2RlLmxhbmcgPT09IFwicHl0aG9uXCIpIHtcbiAgICAgICAgICBleGVjdXRlX3B5dGhvbl9jb2RlKGNvZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUuY29udGVudCAmJiBjb2RlLmxhbmcgPT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2YWwoY29kZS5jb250ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSwgZS5zdGFjayk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgY29kZS5hdHRycy50eXBlKTtcbiAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvZGUuY29udGVudCkpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvZGUudHlwZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICBjb25zdCBzdHlsZV9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgaWYgKGNvZGUuc3JjKSB7XG4gICAgICAgIHN0eWxlX25vZGUuc3JjID0gY29kZS5zcmM7XG4gICAgICB9XG4gICAgICBzdHlsZV9ub2RlLmlubmVySFRNTCA9IGNvZGUuY29udGVudDtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVfbm9kZSk7XG4gICAgfSBlbHNlIGlmIChjb2RlLnR5cGUgPT09IFwibGlua1wiKSB7XG4gICAgICBjb25zdCBsaW5rX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgIGlmIChjb2RlLnJlbCkge1xuICAgICAgICBsaW5rX25vZGUucmVsID0gY29kZS5yZWw7XG4gICAgICB9XG4gICAgICBpZiAoY29kZS5ocmVmKSB7XG4gICAgICAgIGxpbmtfbm9kZS5ocmVmID0gY29kZS5ocmVmO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUuYXR0cnMgJiYgY29kZS5hdHRycy50eXBlKSB7XG4gICAgICAgIGxpbmtfbm9kZS50eXBlID0gY29kZS5hdHRycy50eXBlO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rX25vZGUpO1xuICAgIH0gZWxzZSBpZiAoY29kZS50eXBlID09PSBcImh0bWxcIikge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfaHRtbFRvRWxlbWVudChjb2RlLmNvbnRlbnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBjb2RlIHR5cGUuXCI7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwV2ViUHl0aG9uKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kZWJ1ZyA9IHRydWU7XG4gIGNvbmZpZy5kZWRpY2F0ZWRfdGhyZWFkID0gZmFsc2U7XG4gIGNvbmZpZy5sYW5nID0gXCJweXRob25cIjtcbiAgY29uZmlnLmFwaV92ZXJzaW9uID0gQVBJX1ZFUlNJT047XG4gIGNvbnN0IGNvbm4gPSBuZXcgQ29ubmVjdGlvbihjb25maWcpO1xuICBzZXR1cFB5b2RpZGUoKS50aGVuKCgpID0+IHtcbiAgICBjb25uZWN0UlBDKGNvbm4sIGNvbmZpZyk7XG4gICAgY29ubi5jb25uZWN0KCk7XG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUFBO0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFEQTtBQVdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNHQTtBQUNBO0FBNEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pluginWebPython.js\n");

/***/ }),

/***/ "./src/rpc.js":
/*!********************!*\
  !*** ./src/rpc.js ***!
  \********************/
/*! exports provided: API_VERSION, RPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return RPC; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\nconst API_VERSION = \"0.2.3\";\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction indexObject(obj, is) {\n  if (typeof is == \"string\") return indexObject(obj, is.split(\".\"));else if (is.length == 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\n}\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\n\n\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n  constructor(connection, config, codecs) {\n    super(config && config.debug);\n    this._connection = connection;\n    this.config = config || {};\n    this._codecs = codecs || {};\n    this._object_store = {};\n    this._method_weakmap = new WeakMap();\n    this._object_weakmap = new WeakMap();\n    this._local_api = null; // make sure there is an execute function\n\n    const name = this.config.name;\n\n    this._connection.execute = this._connection.execute || function () {\n      throw new Error(`connection.execute not implemented (in \"${name}\")`);\n    };\n\n    this._store = new ReferenceStore();\n    this._method_refs = new ReferenceStore();\n\n    this._method_refs.onReady(() => {\n      this._fire(\"remoteIdle\");\n    });\n\n    this._method_refs.onBusy(() => {\n      this._fire(\"remoteBusy\");\n    });\n\n    this._setupMessageHanlders();\n  }\n\n  init() {\n    this._connection.emit({\n      type: \"initialized\",\n      config: this.config,\n      peer_id: this._connection.peer_id\n    });\n  }\n  /**\n   * Set a handler to be called when received a responce from the\n   * remote site reporting that the previously provided interface\n   * has been successfully set as remote for that site\n   *\n   * @param {Function} handler\n   */\n\n\n  getRemoteCallStack() {\n    return this._method_refs.getStack();\n  }\n  /**\n   * @returns {Object} set of remote interface methods\n   */\n\n\n  getRemote() {\n    return this._remote_interface;\n  }\n  /**\n   * Sets the interface of this site making it available to the\n   * remote site by sending a message with a set of methods names\n   *\n   * @param {Object} _interface to set\n   */\n\n\n  setInterface(_interface, config) {\n    config = config || {};\n    this.config.name = config.name || this.config.name;\n    this.config.description = config.description || this.config.description;\n\n    if (this.config.forwarding_functions) {\n      for (let func_name of this.config.forwarding_functions) {\n        const _remote = this._remote_interface;\n\n        if (_remote[func_name]) {\n          if (_interface.constructor === Object) {\n            if (!_interface[func_name]) {\n              _interface[func_name] = (...args) => {\n                _remote[func_name](...args);\n              };\n            }\n          } else if (_interface.constructor.constructor === Function) {\n            if (!_interface.constructor.prototype[func_name]) {\n              _interface.constructor.prototype[func_name] = (...args) => {\n                _remote[func_name](...args);\n              };\n            }\n          }\n        }\n      }\n    }\n\n    this._local_api = _interface;\n\n    this._fire(\"interfaceAvailable\");\n  }\n  /**\n   * Sends the actual interface to the remote site upon it was\n   * updated or by a special request of the remote site\n   */\n\n\n  sendInterface() {\n    if (!this._local_api) {\n      throw new Error(\"interface is not set.\");\n    }\n\n    this._encode(this._local_api, true).then(api => {\n      this._connection.emit({\n        type: \"setInterface\",\n        api: api\n      });\n    });\n  }\n\n  _disposeObject(objectId) {\n    if (this._object_store[objectId]) {\n      delete this._object_store[objectId];\n    } else {\n      throw new Error(`Object (id=${objectId}) not found.`);\n    }\n  }\n\n  disposeObject(obj) {\n    return new Promise((resolve, reject) => {\n      if (this._object_weakmap.has(obj)) {\n        const objectId = this._object_weakmap.get(obj);\n\n        this._connection.once(\"disposed\", data => {\n          if (data.error) reject(new Error(data.error));else resolve();\n        });\n\n        this._connection.emit({\n          type: \"disposeObject\",\n          object_id: objectId\n        });\n      } else {\n        throw new Error(\"Invalid object\");\n      }\n    });\n  }\n  /**\n   * Handles a message from the remote site\n   */\n  // var callback_reg = new RegExp(\"onupdate|run$\")\n\n\n  _setupMessageHanlders() {\n    this._connection.on(\"init\", this.init);\n\n    this._connection.on(\"execute\", data => {\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\n        this._connection.emit({\n          type: \"executed\"\n        });\n      }).catch(e => {\n        console.error(e);\n\n        this._connection.emit({\n          type: \"executed\",\n          error: String(e)\n        });\n      });\n    });\n\n    this._connection.on(\"method\", async data => {\n      let resolve, reject, method, args, result;\n\n      try {\n        if (data.promise) {\n          [resolve, reject] = await this._unwrap(data.promise, false);\n        }\n\n        const _interface = this._object_store[data.object_id];\n        method = indexObject(_interface, data.name);\n        args = await this._unwrap(data.args, true);\n\n        if (data.promise) {\n          result = method.apply(_interface, args);\n\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n            result.then(resolve).catch(reject);\n          } else {\n            resolve(result);\n          }\n        } else {\n          method.apply(_interface, args);\n        }\n      } catch (err) {\n        console.error(this.config.name, err);\n\n        if (reject) {\n          reject(err);\n        }\n      }\n    });\n\n    this._connection.on(\"callback\", async data => {\n      let resolve, reject, method, args, result;\n\n      try {\n        if (data.promise) {\n          [resolve, reject] = await this._unwrap(data.promise, false);\n        }\n\n        if (data.promise) {\n          method = this._store.fetch(data.id);\n          args = await this._unwrap(data.args, true);\n\n          if (!method) {\n            throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n          }\n\n          result = method.apply(null, args);\n\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n            result.then(resolve).catch(reject);\n          } else {\n            resolve(result);\n          }\n        } else {\n          method = this._store.fetch(data.id);\n          args = await this._unwrap(data.args, true);\n\n          if (!method) {\n            throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n          }\n\n          method.apply(null, args);\n        }\n      } catch (err) {\n        console.error(this.config.name, err);\n\n        if (reject) {\n          reject(err);\n        }\n      }\n    });\n\n    this._connection.on(\"disposeObject\", data => {\n      try {\n        this._disposeObject(data.object_id);\n\n        this._connection.emit({\n          type: \"disposed\"\n        });\n      } catch (e) {\n        console.error(e);\n\n        this._connection.emit({\n          type: \"disposed\",\n          error: String(e)\n        });\n      }\n    });\n\n    this._connection.on(\"setInterface\", data => {\n      this._setRemoteInterface(data.api);\n    });\n\n    this._connection.on(\"getInterface\", () => {\n      this._fire(\"getInterface\");\n\n      if (this._local_api) {\n        this.sendInterface();\n      } else {\n        this.once(\"interfaceAvailable\", () => {\n          this.sendInterface();\n        });\n      }\n    });\n\n    this._connection.on(\"interfaceSetAsRemote\", () => {\n      this._fire(\"interfaceSetAsRemote\");\n    });\n\n    this._connection.on(\"disconnect\", () => {\n      this._fire(\"beforeDisconnect\");\n\n      this._connection.disconnect();\n\n      this._fire(\"disconnected\");\n    });\n  }\n  /**\n   * Sends a requests to the remote site asking it to provide its\n   * current interface\n   */\n\n\n  requestRemote() {\n    this._connection.emit({\n      type: \"getInterface\"\n    });\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    var _dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"][typedArray.constructor.name];\n\n    if (dtype && dtype !== _dtype) {\n      throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n    }\n\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray.buffer,\n      _rshape: shape,\n      _rdtype: _dtype\n    };\n  }\n  /**\n   * Sets the new remote interface provided by the other site\n   *\n   * @param {Array} names list of function names\n   */\n\n\n  _setRemoteInterface(api) {\n    this._decode(api).then(intf => {\n      this._remote_interface = intf;\n\n      this._fire(\"remoteReady\");\n\n      this._reportRemoteSet();\n    });\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * method. When the generated function is called, it will send the\n   * corresponding message to the remote site asking it to execute\n   * the particular method of its interface\n   *\n   * @param {String} name of the remote method\n   *\n   * @returns {Function} wrapped remote method\n   */\n\n\n  _genRemoteMethod(targetId, name, objectId) {\n    var me = this;\n\n    var remoteMethod = function () {\n      return new Promise(async (resolve, reject) => {\n        let id = null;\n\n        try {\n          id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\n\n          var wrapped_resolve = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return resolve.apply(this, arguments);\n          };\n\n          var wrapped_reject = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return reject.apply(this, arguments);\n          };\n\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\n\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\n          var args = Array.prototype.slice.call(arguments);\n\n          if (name === \"register\" || name === \"export\" || name === \"on\") {\n            args = await me._wrap(args, true);\n          } else {\n            args = await me._wrap(args);\n          }\n\n          var transferables = args.__transferables__;\n          if (transferables) delete args.__transferables__;\n\n          me._connection.emit({\n            type: \"method\",\n            target_id: targetId,\n            name: name,\n            object_id: objectId,\n            args: args,\n            promise: encodedPromise\n          }, transferables);\n        } catch (e) {\n          if (id) me._method_refs.fetch(id);\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\n        }\n      });\n    };\n\n    remoteMethod.__remote_method = true;\n    return remoteMethod;\n  }\n  /**\n   * Sends a responce reporting that interface just provided by the\n   * remote site was successfully set by this site as remote\n   */\n\n\n  _reportRemoteSet() {\n    this._connection.emit({\n      type: \"interfaceSetAsRemote\"\n    });\n  }\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n\n\n  async _encode(aObject, asInterface, objectId) {\n    const aType = typeof aObject;\n\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\n      return aObject;\n    }\n\n    let bObject;\n\n    if (typeof aObject === \"function\") {\n      if (asInterface) {\n        if (!objectId) throw new Error(\"objectId is not specified.\");\n        bObject = {\n          _rtype: \"interface\",\n          _rtarget_id: this._connection.peer_id,\n          _rintf: objectId,\n          _rvalue: asInterface\n        };\n\n        this._method_weakmap.set(aObject, bObject);\n      } else if (this._method_weakmap.has(aObject)) {\n        bObject = this._method_weakmap.get(aObject);\n      } else {\n        const cid = this._store.put(aObject);\n\n        bObject = {\n          _rtype: \"callback\",\n          _rtarget_id: this._connection.peer_id,\n          _rname: aObject.constructor && aObject.constructor.name || cid,\n          _rvalue: cid\n        };\n      }\n\n      return bObject;\n    } // skip if already encoded\n\n\n    if (aObject.constructor instanceof Object && aObject._rtype) {\n      // make sure the interface functions are encoded\n      if (aObject._rintf) {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        bObject = await this._encode(aObject, asInterface, objectId);\n        bObject._rtype = temp;\n      } else {\n        bObject = aObject;\n      }\n\n      return bObject;\n    }\n\n    const transferables = [];\n    const _transfer = aObject._transfer;\n    const isarray = Array.isArray(aObject);\n\n    for (let tp of Object.keys(this._codecs)) {\n      const codec = this._codecs[tp];\n\n      if (codec.encoder && aObject instanceof codec.type) {\n        // TODO: what if multiple encoders found\n        const encodedObj = await Promise.resolve(codec.encoder(aObject));\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\n\n        if (encodedObj && encodedObj._rintf) {\n          const temp = encodedObj._rtype;\n          delete encodedObj._rtype;\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\n          encodedObj._rtype = temp;\n        }\n\n        bObject = encodedObj;\n        return bObject;\n      }\n    }\n\n    if (\n    /*global tf*/\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\n      const v_buffer = aObject.dataSync();\n\n      if (aObject._transfer || _transfer) {\n        transferables.push(v_buffer.buffer);\n        delete aObject._transfer;\n      }\n\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: v_buffer.buffer,\n        _rshape: aObject.shape,\n        _rdtype: aObject.dtype\n      };\n    } else if (\n    /*global nj*/\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\n      var dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"][aObject.selection.data.constructor.name];\n\n      if (aObject._transfer || _transfer) {\n        transferables.push(aObject.selection.data.buffer);\n        delete aObject._transfer;\n      }\n\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: aObject.selection.data.buffer,\n        _rshape: aObject.shape,\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof Error) {\n      console.error(aObject);\n      bObject = {\n        _rtype: \"error\",\n        _rvalue: aObject.toString()\n      };\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n      bObject = {\n        _rtype: \"file\",\n        _rvalue: aObject,\n        _rpath: aObject._path || aObject.webkitRelativePath\n      };\n    } // send objects supported by structure clone algorithm\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList) {\n        bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\n      } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n        bObject = {\n          _rtype: \"file\",\n          _rname: aObject.name,\n          _rmime: aObject.type,\n          _rvalue: aObject,\n          _rpath: aObject._path || aObject.webkitRelativePath\n        };\n      } else if (aObject instanceof Blob) {\n        bObject = {\n          _rtype: \"blob\",\n          _rvalue: aObject\n        };\n      } else if (aObject instanceof ArrayBufferView) {\n        if (aObject._transfer || _transfer) {\n          transferables.push(aObject.buffer);\n          delete aObject._transfer;\n        }\n\n        const dtype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"][aObject.constructor.name];\n        bObject = {\n          _rtype: \"typedarray\",\n          _rvalue: aObject.buffer,\n          _rdtype: dtype\n        };\n      } else if (aObject instanceof DataView) {\n        if (aObject._transfer || _transfer) {\n          transferables.push(aObject.buffer);\n          delete aObject._transfer;\n        }\n\n        bObject = {\n          _rtype: \"memoryview\",\n          _rvalue: aObject.buffer\n        };\n      } else if (aObject instanceof Set) {\n        bObject = {\n          _rtype: \"set\",\n          _rvalue: await this._encode(Array.from(aObject), asInterface)\n        };\n      } else if (aObject instanceof Map) {\n        bObject = {\n          _rtype: \"orderedmap\",\n          _rvalue: await this._encode(Array.from(aObject), asInterface)\n        };\n      } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n        bObject = isarray ? [] : {};\n        let keys; // an object/array\n\n        if (aObject.constructor === Object || Array.isArray(aObject)) {\n          keys = Object.keys(aObject);\n        } // a class\n        else if (aObject.constructor === Function) {\n            throw new Error(\"Please instantiate the class before exportting it.\");\n          } // instance of a class\n          else if (aObject.constructor.constructor === Function) {\n              keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\n              // always encode class instance as interface\n\n              asInterface = true;\n            } else {\n              throw Error(\"Unsupported interface type\");\n            } // encode interfaces\n\n\n        if (aObject._rintf || asInterface) {\n          if (!objectId) {\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n            this._object_store[objectId] = aObject;\n          }\n\n          for (let k of keys) {\n            if (k === \"constructor\") continue;\n\n            if (k.startsWith(\"_\")) {\n              continue;\n            }\n\n            bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\n          } // object id for dispose the object remotely\n\n\n          bObject._rintf = objectId; // remove interface when closed\n\n          if (aObject.on && typeof aObject.on === \"function\") {\n            aObject.on(\"close\", () => {\n              delete this._object_store[objectId];\n            });\n          }\n        } else {\n          for (let k of keys) {\n            if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue;\n            bObject[k] = await this._encode(aObject[k]);\n          }\n        } // for example, browserFS object\n\n      } else if (typeof aObject === \"object\") {\n        const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n        const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n\n        for (let k of keys) {\n          if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue; // encode as interface\n\n          bObject[k] = await this._encode(aObject[k], k, bObject);\n        } // object id, used for dispose the object\n\n\n        bObject._rintf = objectId;\n      } else {\n        throw \"imjoy-rpc: Unsupported data type:\" + aObject;\n      }\n\n    if (transferables.length > 0) {\n      bObject.__transferables__ = transferables;\n    }\n\n    if (!bObject) {\n      throw new Error(\"Failed to encode object\");\n    }\n\n    return bObject;\n  }\n\n  async _decode(aObject, withPromise) {\n    if (!aObject) {\n      return aObject;\n    }\n\n    var bObject, v, k;\n\n    if (aObject[\"_rtype\"]) {\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n        if (aObject._rintf) {\n          const temp = aObject._rtype;\n          delete aObject._rtype;\n          aObject = await this._decode(aObject, withPromise);\n          aObject._rtype = temp;\n        }\n\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n      } else if (aObject._rtype === \"callback\") {\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\n      } else if (aObject._rtype === \"interface\") {\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          const arraytype = eval(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype]);\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(aObject._rvalue);\n      } else if (aObject._rtype === \"file\") {\n        if (aObject._rvalue instanceof File) {\n          bObject = aObject._rvalue; //patch _path\n\n          bObject._path = aObject._rpath;\n        } else {\n          bObject = new File([aObject._rvalue], aObject._rname, {\n            type: aObject._rmime\n          });\n          bObject._path = aObject._rpath;\n        }\n      } else if (aObject._rtype === \"typedarray\") {\n        const arraytype = eval(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype]);\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n        bObject = new arraytype(aObject._rvalue);\n      } else if (aObject._rtype === \"memoryview\") {\n        bObject = new DataView(aObject._rvalue);\n      } else if (aObject._rtype === \"blob\") {\n        if (aObject._rvalue instanceof Blob) {\n          bObject = aObject._rvalue;\n        } else {\n          bObject = new Blob([aObject._rvalue], {\n            type: aObject._rmime\n          });\n        }\n      } else if (aObject._rtype === \"orderedmap\") {\n        bObject = new Map((await this._decode(aObject._rvalue, withPromise)));\n      } else if (aObject._rtype === \"set\") {\n        bObject = new Set((await this._decode(aObject._rvalue, withPromise)));\n      } else {\n        // make sure all the interface functions are decoded\n        if (aObject._rintf) {\n          const temp = aObject._rtype;\n          delete aObject._rtype;\n          aObject = await this._decode(aObject, withPromise);\n          aObject._rtype = temp;\n        }\n\n        bObject = aObject;\n      }\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n      var isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n\n      for (k in aObject) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          v = aObject[k];\n          bObject[k] = await this._decode(v, withPromise);\n        }\n      }\n    } else {\n      bObject = aObject;\n    }\n\n    if (bObject === undefined) {\n      throw new Error(\"Failed to decode object\");\n    } // store the object id for dispose\n\n\n    if (aObject._rintf) {\n      this._object_weakmap.set(bObject, aObject._rintf);\n    }\n\n    return bObject;\n  }\n\n  async _wrap(args, asInterface) {\n    var wrapped = await this._encode(args, asInterface);\n    return wrapped;\n  }\n  /**\n   * Unwraps the set of arguments delivered from the remote site,\n   * replaces all callback identifiers with a function which will\n   * initiate sending that callback identifier back to other site\n   *\n   * @param {Object} args to unwrap\n   *\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Array} unwrapped args\n   */\n\n\n  async _unwrap(args, withPromise) {\n    var result = await this._decode(args, withPromise);\n    return result;\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * callback. When the generated function is called, it will send\n   * the corresponding message to the remote site asking it to\n   * execute the particular callback previously saved during a call\n   * by the remote site a method from the interface of this site\n   *\n   * @param {Number} id of the remote callback to execute\n   * @param {Number} argNum argument index of the callback\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Function} wrapped remote callback\n   */\n\n\n  _genRemoteCallback(targetId, cid, withPromise) {\n    var me = this;\n    var remoteCallback;\n\n    if (withPromise) {\n      remoteCallback = function () {\n        return new Promise(async (resolve, reject) => {\n          var args = await me._wrap(Array.prototype.slice.call(arguments));\n          var transferables = args.__transferables__;\n          if (transferables) delete args.__transferables__;\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\n\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\n          reject.__promise_pair = encodedPromise[0]._rvalue;\n\n          try {\n            me._connection.emit({\n              type: \"callback\",\n              target_id: targetId,\n              id: cid,\n              args: args,\n              promise: encodedPromise\n            }, transferables);\n          } catch (e) {\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\n          }\n        });\n      };\n\n      return remoteCallback;\n    } else {\n      remoteCallback = async function () {\n        var args = await me._wrap(Array.prototype.slice.call(arguments));\n        var transferables = args.__transferables__;\n        if (transferables) delete args.__transferables__;\n        return me._connection.emit({\n          type: \"callback\",\n          target_id: targetId,\n          id: cid,\n          args: args\n        }, transferables);\n      };\n\n      return remoteCallback;\n    }\n  }\n  /**\n   * Sends the notification message and breaks the connection\n   */\n\n\n  disconnect() {\n    this._connection.emit({\n      type: \"disconnect\"\n    });\n\n    setTimeout(() => {\n      this._connection.disconnect();\n    }, 2000);\n  }\n\n}\n/**\n * ReferenceStore is a special object which stores other objects\n * and provides the references (number) instead. This reference\n * may then be sent over a json-based communication channel (IPC\n * to another Node.js process or a message to the Worker). Other\n * site may then provide the reference in the responce message\n * implying the given object should be activated.\n *\n * Primary usage for the ReferenceStore is a storage for the\n * callbacks, which therefore makes it possible to initiate a\n * callback execution by the opposite site (which normally cannot\n * directly execute functions over the communication channel).\n *\n * Each stored object can only be fetched once and is not\n * available for the second time. Each stored object must be\n * fetched, since otherwise it will remain stored forever and\n * consume memory.\n *\n * Stored object indeces are simply the numbers, which are however\n * released along with the objects, and are later reused again (in\n * order to postpone the overflow, which should not likely happen,\n * but anyway).\n */\n\nclass ReferenceStore {\n  constructor() {\n    this._store = {}; // stored object\n\n    this._indices = [0]; // smallest available indices\n\n    this._readyHandler = function () {};\n\n    this._busyHandler = function () {};\n\n    this._readyHandler();\n  }\n  /**\n   * call handler when the store is empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onReady(readyHandler) {\n    this._readyHandler = readyHandler || function () {};\n  }\n  /**\n   * call handler when the store is not empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onBusy(busyHandler) {\n    this._busyHandler = busyHandler || function () {};\n  }\n  /**\n   * get the length of the store\n   *\n   */\n\n\n  getStack() {\n    return Object.keys(this._store).length;\n  }\n  /**\n   * @function _genId() generates the new reference id\n   *\n   * @returns {Number} smallest available id and reserves it\n   */\n\n\n  _genId() {\n    var id;\n\n    if (this._indices.length === 1) {\n      id = this._indices[0]++;\n    } else {\n      id = this._indices.shift();\n    }\n\n    return id;\n  }\n  /**\n   * Releases the given reference id so that it will be available by\n   * another object stored\n   *\n   * @param {Number} id to release\n   */\n\n\n  _releaseId(id) {\n    for (var i = 0; i < this._indices.length; i++) {\n      if (id < this._indices[i]) {\n        this._indices.splice(i, 0, id);\n\n        break;\n      }\n    } // cleaning-up the sequence tail\n\n\n    for (i = this._indices.length - 1; i >= 0; i--) {\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\n        this._indices.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Stores the given object and returns the refernce id instead\n   *\n   * @param {Object} obj to store\n   *\n   * @returns {Number} reference id of the stored object\n   */\n\n\n  put(obj) {\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\n      this._busyHandler();\n    }\n\n    var id = this._genId();\n\n    this._store[id] = obj;\n    return id;\n  }\n  /**\n   * Retrieves previously stored object and releases its reference\n   *\n   * @param {Number} id of an object to retrieve\n   */\n\n\n  fetch(id) {\n    var obj = this._store[id];\n\n    if (obj && !obj.__remote_method) {\n      delete this._store[id];\n\n      this._releaseId(id);\n\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\n        this._readyHandler();\n      }\n    }\n\n    if (obj && obj.__promise_pair) {\n      this.fetch(obj.__promise_pair);\n    }\n\n    return obj;\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcnBjLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1qb3lSUEMvLi9zcmMvcnBjLmpzPzM1NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyB0aGUgUlBDIG9iamVjdCB1c2VkIGJvdGggYnkgdGhlIGFwcGxpY2F0aW9uXG4gKiBzaXRlLCBhbmQgYnkgZWFjaCBwbHVnaW5cbiAqL1xuaW1wb3J0IHtcbiAgcmFuZElkLFxuICB0eXBlZEFycmF5VG9EdHlwZSxcbiAgZHR5cGVUb1R5cGVkQXJyYXksXG4gIE1lc3NhZ2VFbWl0dGVyXG59IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTiA9IFwiMC4yLjNcIjtcblxuY29uc3QgQXJyYXlCdWZmZXJWaWV3ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKFxuICBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IFVpbnQ4QXJyYXkoKSlcbikuY29uc3RydWN0b3I7XG5cbmZ1bmN0aW9uIF9hcHBlbmRCdWZmZXIoYnVmZmVyMSwgYnVmZmVyMikge1xuICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheShidWZmZXIxLmJ5dGVMZW5ndGggKyBidWZmZXIyLmJ5dGVMZW5ndGgpO1xuICB0bXAuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcjEpLCAwKTtcbiAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIyKSwgYnVmZmVyMS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHRtcC5idWZmZXI7XG59XG5cbmZ1bmN0aW9uIGluZGV4T2JqZWN0KG9iaiwgaXMpIHtcbiAgaWYgKHR5cGVvZiBpcyA9PSBcInN0cmluZ1wiKSByZXR1cm4gaW5kZXhPYmplY3Qob2JqLCBpcy5zcGxpdChcIi5cIikpO1xuICBlbHNlIGlmIChpcy5sZW5ndGggPT0gMCkgcmV0dXJuIG9iajtcbiAgZWxzZSByZXR1cm4gaW5kZXhPYmplY3Qob2JqW2lzWzBdXSwgaXMuc2xpY2UoMSkpO1xufVxuXG4vKipcbiAqIFJQQyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbmdsZSBzaXRlIGluIHRoZVxuICogY29tbXVuaWNhdGlvbiBwcm90b2NvbCBiZXR3ZWVuIHRoZSBhcHBsaWNhdGlvbiBhbmQgdGhlIHBsdWdpblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uIGEgc3BlY2lhbCBvYmplY3QgYWxsb3dpbmcgdG8gc2VuZFxuICogYW5kIHJlY2VpdmUgbWVzc2FnZXMgZnJvbSB0aGUgb3Bwb3NpdGUgc2l0ZSAoYmFzaWNhbGx5IGl0XG4gKiBzaG91bGQgb25seSBwcm92aWRlIHNlbmQoKSBhbmQgb25NZXNzYWdlKCkgbWV0aG9kcylcbiAqL1xuZXhwb3J0IGNsYXNzIFJQQyBleHRlbmRzIE1lc3NhZ2VFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgY29uZmlnLCBjb2RlY3MpIHtcbiAgICBzdXBlcihjb25maWcgJiYgY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLl9jb2RlY3MgPSBjb2RlY3MgfHwge307XG4gICAgdGhpcy5fb2JqZWN0X3N0b3JlID0ge307XG4gICAgdGhpcy5fbWV0aG9kX3dlYWttYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX29iamVjdF93ZWFrbWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLl9sb2NhbF9hcGkgPSBudWxsO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhbiBleGVjdXRlIGZ1bmN0aW9uXG4gICAgY29uc3QgbmFtZSA9IHRoaXMuY29uZmlnLm5hbWU7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5leGVjdXRlID1cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZXhlY3V0ZSB8fFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29ubmVjdGlvbi5leGVjdXRlIG5vdCBpbXBsZW1lbnRlZCAoaW4gXCIke25hbWV9XCIpYCk7XG4gICAgICB9O1xuICAgIHRoaXMuX3N0b3JlID0gbmV3IFJlZmVyZW5jZVN0b3JlKCk7XG4gICAgdGhpcy5fbWV0aG9kX3JlZnMgPSBuZXcgUmVmZXJlbmNlU3RvcmUoKTtcbiAgICB0aGlzLl9tZXRob2RfcmVmcy5vblJlYWR5KCgpID0+IHtcbiAgICAgIHRoaXMuX2ZpcmUoXCJyZW1vdGVJZGxlXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuX21ldGhvZF9yZWZzLm9uQnVzeSgoKSA9PiB7XG4gICAgICB0aGlzLl9maXJlKFwicmVtb3RlQnVzeVwiKTtcbiAgICB9KTtcbiAgICB0aGlzLl9zZXR1cE1lc3NhZ2VIYW5sZGVycygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoe1xuICAgICAgdHlwZTogXCJpbml0aWFsaXplZFwiLFxuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIHBlZXJfaWQ6IHRoaXMuX2Nvbm5lY3Rpb24ucGVlcl9pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHJlY2VpdmVkIGEgcmVzcG9uY2UgZnJvbSB0aGVcbiAgICogcmVtb3RlIHNpdGUgcmVwb3J0aW5nIHRoYXQgdGhlIHByZXZpb3VzbHkgcHJvdmlkZWQgaW50ZXJmYWNlXG4gICAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZXQgYXMgcmVtb3RlIGZvciB0aGF0IHNpdGVcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cblxuICBnZXRSZW1vdGVDYWxsU3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGhvZF9yZWZzLmdldFN0YWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge09iamVjdH0gc2V0IG9mIHJlbW90ZSBpbnRlcmZhY2UgbWV0aG9kc1xuICAgKi9cbiAgZ2V0UmVtb3RlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW1vdGVfaW50ZXJmYWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGludGVyZmFjZSBvZiB0aGlzIHNpdGUgbWFraW5nIGl0IGF2YWlsYWJsZSB0byB0aGVcbiAgICogcmVtb3RlIHNpdGUgYnkgc2VuZGluZyBhIG1lc3NhZ2Ugd2l0aCBhIHNldCBvZiBtZXRob2RzIG5hbWVzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBfaW50ZXJmYWNlIHRvIHNldFxuICAgKi9cbiAgc2V0SW50ZXJmYWNlKF9pbnRlcmZhY2UsIGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmNvbmZpZy5uYW1lID0gY29uZmlnLm5hbWUgfHwgdGhpcy5jb25maWcubmFtZTtcbiAgICB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbiA9IGNvbmZpZy5kZXNjcmlwdGlvbiB8fCB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICBpZiAodGhpcy5jb25maWcuZm9yd2FyZGluZ19mdW5jdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGZ1bmNfbmFtZSBvZiB0aGlzLmNvbmZpZy5mb3J3YXJkaW5nX2Z1bmN0aW9ucykge1xuICAgICAgICBjb25zdCBfcmVtb3RlID0gdGhpcy5fcmVtb3RlX2ludGVyZmFjZTtcbiAgICAgICAgaWYgKF9yZW1vdGVbZnVuY19uYW1lXSkge1xuICAgICAgICAgIGlmIChfaW50ZXJmYWNlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghX2ludGVyZmFjZVtmdW5jX25hbWVdKSB7XG4gICAgICAgICAgICAgIF9pbnRlcmZhY2VbZnVuY19uYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgX3JlbW90ZVtmdW5jX25hbWVdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghX2ludGVyZmFjZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbZnVuY19uYW1lXSkge1xuICAgICAgICAgICAgICBfaW50ZXJmYWNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtmdW5jX25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBfcmVtb3RlW2Z1bmNfbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2xvY2FsX2FwaSA9IF9pbnRlcmZhY2U7XG4gICAgdGhpcy5fZmlyZShcImludGVyZmFjZUF2YWlsYWJsZVwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgYWN0dWFsIGludGVyZmFjZSB0byB0aGUgcmVtb3RlIHNpdGUgdXBvbiBpdCB3YXNcbiAgICogdXBkYXRlZCBvciBieSBhIHNwZWNpYWwgcmVxdWVzdCBvZiB0aGUgcmVtb3RlIHNpdGVcbiAgICovXG4gIHNlbmRJbnRlcmZhY2UoKSB7XG4gICAgaWYgKCF0aGlzLl9sb2NhbF9hcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVyZmFjZSBpcyBub3Qgc2V0LlwiKTtcbiAgICB9XG4gICAgdGhpcy5fZW5jb2RlKHRoaXMuX2xvY2FsX2FwaSwgdHJ1ZSkudGhlbihhcGkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHsgdHlwZTogXCJzZXRJbnRlcmZhY2VcIiwgYXBpOiBhcGkgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfZGlzcG9zZU9iamVjdChvYmplY3RJZCkge1xuICAgIGlmICh0aGlzLl9vYmplY3Rfc3RvcmVbb2JqZWN0SWRdKSB7XG4gICAgICBkZWxldGUgdGhpcy5fb2JqZWN0X3N0b3JlW29iamVjdElkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgKGlkPSR7b2JqZWN0SWR9KSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZU9iamVjdChvYmopIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX29iamVjdF93ZWFrbWFwLmhhcyhvYmopKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdElkID0gdGhpcy5fb2JqZWN0X3dlYWttYXAuZ2V0KG9iaik7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ub25jZShcImRpc3Bvc2VkXCIsIGRhdGEgPT4ge1xuICAgICAgICAgIGlmIChkYXRhLmVycm9yKSByZWplY3QobmV3IEVycm9yKGRhdGEuZXJyb3IpKTtcbiAgICAgICAgICBlbHNlIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XG4gICAgICAgICAgdHlwZTogXCJkaXNwb3NlT2JqZWN0XCIsXG4gICAgICAgICAgb2JqZWN0X2lkOiBvYmplY3RJZFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb2JqZWN0XCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBtZXNzYWdlIGZyb20gdGhlIHJlbW90ZSBzaXRlXG4gICAqL1xuICAvLyB2YXIgY2FsbGJhY2tfcmVnID0gbmV3IFJlZ0V4cChcIm9udXBkYXRlfHJ1biRcIilcbiAgX3NldHVwTWVzc2FnZUhhbmxkZXJzKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJpbml0XCIsIHRoaXMuaW5pdCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImV4ZWN1dGVcIiwgZGF0YSA9PiB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5fY29ubmVjdGlvbi5leGVjdXRlKGRhdGEuY29kZSkpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmVtaXQoeyB0eXBlOiBcImV4ZWN1dGVkXCIgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBcImV4ZWN1dGVkXCIsXG4gICAgICAgICAgICBlcnJvcjogU3RyaW5nKGUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcIm1ldGhvZFwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGxldCByZXNvbHZlLCByZWplY3QsIG1ldGhvZCwgYXJncywgcmVzdWx0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGRhdGEucHJvbWlzZSkge1xuICAgICAgICAgIFtyZXNvbHZlLCByZWplY3RdID0gYXdhaXQgdGhpcy5fdW53cmFwKGRhdGEucHJvbWlzZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9pbnRlcmZhY2UgPSB0aGlzLl9vYmplY3Rfc3RvcmVbZGF0YS5vYmplY3RfaWRdO1xuICAgICAgICBtZXRob2QgPSBpbmRleE9iamVjdChfaW50ZXJmYWNlLCBkYXRhLm5hbWUpO1xuICAgICAgICBhcmdzID0gYXdhaXQgdGhpcy5fdW53cmFwKGRhdGEuYXJncywgdHJ1ZSk7XG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcbiAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkoX2ludGVyZmFjZSwgYXJncyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZC5hcHBseShfaW50ZXJmYWNlLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZXJyKTtcbiAgICAgICAgaWYgKHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKFwiY2FsbGJhY2tcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0LCBtZXRob2QsIGFyZ3MsIHJlc3VsdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChkYXRhLnByb21pc2UpIHtcbiAgICAgICAgICBbcmVzb2x2ZSwgcmVqZWN0XSA9IGF3YWl0IHRoaXMuX3Vud3JhcChkYXRhLnByb21pc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5wcm9taXNlKSB7XG4gICAgICAgICAgbWV0aG9kID0gdGhpcy5fc3RvcmUuZmV0Y2goZGF0YS5pZCk7XG4gICAgICAgICAgYXJncyA9IGF3YWl0IHRoaXMuX3Vud3JhcChkYXRhLmFyZ3MsIHRydWUpO1xuICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGJhY2sgZnVuY3Rpb24gY2FuIG9ubHkgY2FsbGVkIG9uY2UsIGlmIHlvdSB3YW50IHRvIGNhbGwgYSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgdGltZXMsIHBsZWFzZSBtYWtlIGl0IGFzIGEgcGx1Z2luIGFwaSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vaW1qb3kuaW8vZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgICAgICAgKG1ldGhvZC5jb25zdHJ1Y3RvciAmJiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZCA9IHRoaXMuX3N0b3JlLmZldGNoKGRhdGEuaWQpO1xuICAgICAgICAgIGFyZ3MgPSBhd2FpdCB0aGlzLl91bndyYXAoZGF0YS5hcmdzLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIlBsZWFzZSBub3RpY2UgdGhhdCBjYWxsYmFjayBmdW5jdGlvbiBjYW4gb25seSBjYWxsZWQgb25jZSwgaWYgeW91IHdhbnQgdG8gY2FsbCBhIGZ1bmN0aW9uIGZvciBtdWx0aXBsZSB0aW1lcywgcGxlYXNlIG1ha2UgaXQgYXMgYSBwbHVnaW4gYXBpIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9pbWpveS5pby9kb2NzIGZvciBtb3JlIGRldGFpbHMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1ldGhvZC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5jb25maWcubmFtZSwgZXJyKTtcbiAgICAgICAgaWYgKHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImRpc3Bvc2VPYmplY3RcIiwgZGF0YSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9kaXNwb3NlT2JqZWN0KGRhdGEub2JqZWN0X2lkKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHtcbiAgICAgICAgICB0eXBlOiBcImRpc3Bvc2VkXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7XG4gICAgICAgICAgdHlwZTogXCJkaXNwb3NlZFwiLFxuICAgICAgICAgIGVycm9yOiBTdHJpbmcoZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcInNldEludGVyZmFjZVwiLCBkYXRhID0+IHtcbiAgICAgIHRoaXMuX3NldFJlbW90ZUludGVyZmFjZShkYXRhLmFwaSk7XG4gICAgfSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImdldEludGVyZmFjZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9maXJlKFwiZ2V0SW50ZXJmYWNlXCIpO1xuICAgICAgaWYgKHRoaXMuX2xvY2FsX2FwaSkge1xuICAgICAgICB0aGlzLnNlbmRJbnRlcmZhY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25jZShcImludGVyZmFjZUF2YWlsYWJsZVwiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZW5kSW50ZXJmYWNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oXCJpbnRlcmZhY2VTZXRBc1JlbW90ZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9maXJlKFwiaW50ZXJmYWNlU2V0QXNSZW1vdGVcIik7XG4gICAgfSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fZmlyZShcImJlZm9yZURpc2Nvbm5lY3RcIik7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuX2ZpcmUoXCJkaXNjb25uZWN0ZWRcIik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSByZXF1ZXN0cyB0byB0aGUgcmVtb3RlIHNpdGUgYXNraW5nIGl0IHRvIHByb3ZpZGUgaXRzXG4gICAqIGN1cnJlbnQgaW50ZXJmYWNlXG4gICAqL1xuICByZXF1ZXN0UmVtb3RlKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7IHR5cGU6IFwiZ2V0SW50ZXJmYWNlXCIgfSk7XG4gIH1cblxuICBfbmRhcnJheSh0eXBlZEFycmF5LCBzaGFwZSwgZHR5cGUpIHtcbiAgICB2YXIgX2R0eXBlID0gdHlwZWRBcnJheVRvRHR5cGVbdHlwZWRBcnJheS5jb25zdHJ1Y3Rvci5uYW1lXTtcbiAgICBpZiAoZHR5cGUgJiYgZHR5cGUgIT09IF9kdHlwZSkge1xuICAgICAgdGhyb3cgXCJkdHlwZSBkb2Vzbid0IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBhcnJheTogXCIgK1xuICAgICAgICBfZHR5cGUgK1xuICAgICAgICBcIiAhPSBcIiArXG4gICAgICAgIGR0eXBlO1xuICAgIH1cbiAgICBzaGFwZSA9IHNoYXBlIHx8IFt0eXBlZEFycmF5Lmxlbmd0aF07XG4gICAgcmV0dXJuIHtcbiAgICAgIF9ydHlwZTogXCJuZGFycmF5XCIsXG4gICAgICBfcnZhbHVlOiB0eXBlZEFycmF5LmJ1ZmZlcixcbiAgICAgIF9yc2hhcGU6IHNoYXBlLFxuICAgICAgX3JkdHlwZTogX2R0eXBlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuZXcgcmVtb3RlIGludGVyZmFjZSBwcm92aWRlZCBieSB0aGUgb3RoZXIgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBsaXN0IG9mIGZ1bmN0aW9uIG5hbWVzXG4gICAqL1xuICBfc2V0UmVtb3RlSW50ZXJmYWNlKGFwaSkge1xuICAgIHRoaXMuX2RlY29kZShhcGkpLnRoZW4oaW50ZiA9PiB7XG4gICAgICB0aGlzLl9yZW1vdGVfaW50ZXJmYWNlID0gaW50ZjtcbiAgICAgIHRoaXMuX2ZpcmUoXCJyZW1vdGVSZWFkeVwiKTtcbiAgICAgIHRoaXMuX3JlcG9ydFJlbW90ZVNldCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgd3JhcHBlZCBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIHJlbW90ZVxuICAgKiBtZXRob2QuIFdoZW4gdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHdpbGwgc2VuZCB0aGVcbiAgICogY29ycmVzcG9uZGluZyBtZXNzYWdlIHRvIHRoZSByZW1vdGUgc2l0ZSBhc2tpbmcgaXQgdG8gZXhlY3V0ZVxuICAgKiB0aGUgcGFydGljdWxhciBtZXRob2Qgb2YgaXRzIGludGVyZmFjZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgcmVtb3RlIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgcmVtb3RlIG1ldGhvZFxuICAgKi9cbiAgX2dlblJlbW90ZU1ldGhvZCh0YXJnZXRJZCwgbmFtZSwgb2JqZWN0SWQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZW1vdGVNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWQgPSBtZS5fbWV0aG9kX3JlZnMucHV0KG9iamVjdElkID8gb2JqZWN0SWQgKyBcIi9cIiArIG5hbWUgOiBuYW1lKTtcbiAgICAgICAgICB2YXIgd3JhcHBlZF9yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaWQgIT09IG51bGwpIG1lLl9tZXRob2RfcmVmcy5mZXRjaChpZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHdyYXBwZWRfcmVqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaWQgIT09IG51bGwpIG1lLl9tZXRob2RfcmVmcy5mZXRjaChpZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGVuY29kZWRQcm9taXNlID0gYXdhaXQgbWUuX3dyYXAoW1xuICAgICAgICAgICAgd3JhcHBlZF9yZXNvbHZlLFxuICAgICAgICAgICAgd3JhcHBlZF9yZWplY3RcbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIC8vIHN0b3JlIHRoZSBrZXkgaWQgZm9yIHJlbW92aW5nIHRoZW0gZnJvbSB0aGUgcmVmZXJlbmNlIHN0b3JlIHRvZ2V0aGVyXG4gICAgICAgICAgd3JhcHBlZF9yZXNvbHZlLl9fcHJvbWlzZV9wYWlyID0gZW5jb2RlZFByb21pc2VbMV0uX3J2YWx1ZTtcbiAgICAgICAgICB3cmFwcGVkX3JlamVjdC5fX3Byb21pc2VfcGFpciA9IGVuY29kZWRQcm9taXNlWzBdLl9ydmFsdWU7XG5cbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVnaXN0ZXJcIiB8fCBuYW1lID09PSBcImV4cG9ydFwiIHx8IG5hbWUgPT09IFwib25cIikge1xuICAgICAgICAgICAgYXJncyA9IGF3YWl0IG1lLl93cmFwKGFyZ3MsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzID0gYXdhaXQgbWUuX3dyYXAoYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcykgZGVsZXRlIGFyZ3MuX190cmFuc2ZlcmFibGVzX187XG4gICAgICAgICAgbWUuX2Nvbm5lY3Rpb24uZW1pdChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtZXRob2RcIixcbiAgICAgICAgICAgICAgdGFyZ2V0X2lkOiB0YXJnZXRJZCxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgb2JqZWN0X2lkOiBvYmplY3RJZCxcbiAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgcHJvbWlzZTogZW5jb2RlZFByb21pc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChpZCkgbWUuX21ldGhvZF9yZWZzLmZldGNoKGlkKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN0dWUgcmVtb3RlIG1ldGhvZCAoaW50ZXJmYWNlOiAke29iamVjdElkIHx8XG4gICAgICAgICAgICAgIG1lLmlkfSwgbWV0aG9kOiAke25hbWV9KSwgZXJyb3I6ICR7ZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZW1vdGVNZXRob2QuX19yZW1vdGVfbWV0aG9kID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVtb3RlTWV0aG9kO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVzcG9uY2UgcmVwb3J0aW5nIHRoYXQgaW50ZXJmYWNlIGp1c3QgcHJvdmlkZWQgYnkgdGhlXG4gICAqIHJlbW90ZSBzaXRlIHdhcyBzdWNjZXNzZnVsbHkgc2V0IGJ5IHRoaXMgc2l0ZSBhcyByZW1vdGVcbiAgICovXG4gIF9yZXBvcnRSZW1vdGVTZXQoKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5lbWl0KHsgdHlwZTogXCJpbnRlcmZhY2VTZXRBc1JlbW90ZVwiIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSBwcm92aWRlZCBzZXQgb2YgcmVtb3RlIG1ldGhvZCBhcmd1bWVudHMgZm9yXG4gICAqIHNlbmRpbmcgdG8gdGhlIHJlbW90ZSBzaXRlLCByZXBsYWNlcyBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoXG4gICAqIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdG8gd3JhcFxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHdyYXBwZWQgYXJndW1lbnRzXG4gICAqL1xuICBhc3luYyBfZW5jb2RlKGFPYmplY3QsIGFzSW50ZXJmYWNlLCBvYmplY3RJZCkge1xuICAgIGNvbnN0IGFUeXBlID0gdHlwZW9mIGFPYmplY3Q7XG4gICAgaWYgKFxuICAgICAgYVR5cGUgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgIGFUeXBlID09PSBcInN0cmluZ1wiIHx8XG4gICAgICBhVHlwZSA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAgIGFPYmplY3QgPT09IG51bGwgfHxcbiAgICAgIGFPYmplY3QgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgYU9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgKSB7XG4gICAgICByZXR1cm4gYU9iamVjdDtcbiAgICB9XG5cbiAgICBsZXQgYk9iamVjdDtcbiAgICBpZiAodHlwZW9mIGFPYmplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKGFzSW50ZXJmYWNlKSB7XG4gICAgICAgIGlmICghb2JqZWN0SWQpIHRocm93IG5ldyBFcnJvcihcIm9iamVjdElkIGlzIG5vdCBzcGVjaWZpZWQuXCIpO1xuICAgICAgICBiT2JqZWN0ID0ge1xuICAgICAgICAgIF9ydHlwZTogXCJpbnRlcmZhY2VcIixcbiAgICAgICAgICBfcnRhcmdldF9pZDogdGhpcy5fY29ubmVjdGlvbi5wZWVyX2lkLFxuICAgICAgICAgIF9yaW50Zjogb2JqZWN0SWQsXG4gICAgICAgICAgX3J2YWx1ZTogYXNJbnRlcmZhY2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbWV0aG9kX3dlYWttYXAuc2V0KGFPYmplY3QsIGJPYmplY3QpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9tZXRob2Rfd2Vha21hcC5oYXMoYU9iamVjdCkpIHtcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX21ldGhvZF93ZWFrbWFwLmdldChhT2JqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNpZCA9IHRoaXMuX3N0b3JlLnB1dChhT2JqZWN0KTtcbiAgICAgICAgYk9iamVjdCA9IHtcbiAgICAgICAgICBfcnR5cGU6IFwiY2FsbGJhY2tcIixcbiAgICAgICAgICBfcnRhcmdldF9pZDogdGhpcy5fY29ubmVjdGlvbi5wZWVyX2lkLFxuICAgICAgICAgIF9ybmFtZTogKGFPYmplY3QuY29uc3RydWN0b3IgJiYgYU9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lKSB8fCBjaWQsXG4gICAgICAgICAgX3J2YWx1ZTogY2lkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYk9iamVjdDtcbiAgICB9XG5cbiAgICAvLyBza2lwIGlmIGFscmVhZHkgZW5jb2RlZFxuICAgIGlmIChhT2JqZWN0LmNvbnN0cnVjdG9yIGluc3RhbmNlb2YgT2JqZWN0ICYmIGFPYmplY3QuX3J0eXBlKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIGludGVyZmFjZSBmdW5jdGlvbnMgYXJlIGVuY29kZWRcbiAgICAgIGlmIChhT2JqZWN0Ll9yaW50Zikge1xuICAgICAgICBjb25zdCB0ZW1wID0gYU9iamVjdC5fcnR5cGU7XG4gICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll9ydHlwZTtcblxuICAgICAgICBiT2JqZWN0ID0gYXdhaXQgdGhpcy5fZW5jb2RlKGFPYmplY3QsIGFzSW50ZXJmYWNlLCBvYmplY3RJZCk7XG4gICAgICAgIGJPYmplY3QuX3J0eXBlID0gdGVtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJPYmplY3Q7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdO1xuICAgIGNvbnN0IF90cmFuc2ZlciA9IGFPYmplY3QuX3RyYW5zZmVyO1xuICAgIGNvbnN0IGlzYXJyYXkgPSBBcnJheS5pc0FycmF5KGFPYmplY3QpO1xuXG4gICAgZm9yIChsZXQgdHAgb2YgT2JqZWN0LmtleXModGhpcy5fY29kZWNzKSkge1xuICAgICAgY29uc3QgY29kZWMgPSB0aGlzLl9jb2RlY3NbdHBdO1xuICAgICAgaWYgKGNvZGVjLmVuY29kZXIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIGNvZGVjLnR5cGUpIHtcbiAgICAgICAgLy8gVE9ETzogd2hhdCBpZiBtdWx0aXBsZSBlbmNvZGVycyBmb3VuZFxuICAgICAgICBjb25zdCBlbmNvZGVkT2JqID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGNvZGVjLmVuY29kZXIoYU9iamVjdCkpO1xuICAgICAgICBpZiAoZW5jb2RlZE9iaiAmJiAhZW5jb2RlZE9iai5fcnR5cGUpIGVuY29kZWRPYmouX3J0eXBlID0gY29kZWMubmFtZTtcbiAgICAgICAgLy8gZW5jb2RlIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGludGVyZmFjZSBvYmplY3RcbiAgICAgICAgaWYgKGVuY29kZWRPYmogJiYgZW5jb2RlZE9iai5fcmludGYpIHtcbiAgICAgICAgICBjb25zdCB0ZW1wID0gZW5jb2RlZE9iai5fcnR5cGU7XG4gICAgICAgICAgZGVsZXRlIGVuY29kZWRPYmouX3J0eXBlO1xuICAgICAgICAgIGVuY29kZWRPYmogPSBhd2FpdCB0aGlzLl9lbmNvZGUoZW5jb2RlZE9iaiwgYXNJbnRlcmZhY2UsIG9iamVjdElkKTtcbiAgICAgICAgICBlbmNvZGVkT2JqLl9ydHlwZSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgYk9iamVjdCA9IGVuY29kZWRPYmo7XG4gICAgICAgIHJldHVybiBiT2JqZWN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIC8qZ2xvYmFsIHRmKi9cbiAgICAgIHR5cGVvZiB0ZiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgdGYuVGVuc29yICYmXG4gICAgICBhT2JqZWN0IGluc3RhbmNlb2YgdGYuVGVuc29yXG4gICAgKSB7XG4gICAgICBjb25zdCB2X2J1ZmZlciA9IGFPYmplY3QuZGF0YVN5bmMoKTtcbiAgICAgIGlmIChhT2JqZWN0Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHZfYnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll90cmFuc2ZlcjtcbiAgICAgIH1cbiAgICAgIGJPYmplY3QgPSB7XG4gICAgICAgIF9ydHlwZTogXCJuZGFycmF5XCIsXG4gICAgICAgIF9ydmFsdWU6IHZfYnVmZmVyLmJ1ZmZlcixcbiAgICAgICAgX3JzaGFwZTogYU9iamVjdC5zaGFwZSxcbiAgICAgICAgX3JkdHlwZTogYU9iamVjdC5kdHlwZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLypnbG9iYWwgbmoqL1xuICAgICAgdHlwZW9mIG5qICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICBuai5OZEFycmF5ICYmXG4gICAgICBhT2JqZWN0IGluc3RhbmNlb2YgbmouTmRBcnJheVxuICAgICkge1xuICAgICAgdmFyIGR0eXBlID0gdHlwZWRBcnJheVRvRHR5cGVbYU9iamVjdC5zZWxlY3Rpb24uZGF0YS5jb25zdHJ1Y3Rvci5uYW1lXTtcbiAgICAgIGlmIChhT2JqZWN0Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGFPYmplY3Quc2VsZWN0aW9uLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgZGVsZXRlIGFPYmplY3QuX3RyYW5zZmVyO1xuICAgICAgfVxuICAgICAgYk9iamVjdCA9IHtcbiAgICAgICAgX3J0eXBlOiBcIm5kYXJyYXlcIixcbiAgICAgICAgX3J2YWx1ZTogYU9iamVjdC5zZWxlY3Rpb24uZGF0YS5idWZmZXIsXG4gICAgICAgIF9yc2hhcGU6IGFPYmplY3Quc2hhcGUsXG4gICAgICAgIF9yZHR5cGU6IGR0eXBlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYU9iamVjdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGFPYmplY3QpO1xuICAgICAgYk9iamVjdCA9IHsgX3J0eXBlOiBcImVycm9yXCIsIF9ydmFsdWU6IGFPYmplY3QudG9TdHJpbmcoKSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgIGJPYmplY3QgPSB7XG4gICAgICAgIF9ydHlwZTogXCJmaWxlXCIsXG4gICAgICAgIF9ydmFsdWU6IGFPYmplY3QsXG4gICAgICAgIF9ycGF0aDogYU9iamVjdC5fcGF0aCB8fCBhT2JqZWN0LndlYmtpdFJlbGF0aXZlUGF0aFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gc2VuZCBvYmplY3RzIHN1cHBvcnRlZCBieSBzdHJ1Y3R1cmUgY2xvbmUgYWxnb3JpdGhtXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobVxuICAgIGVsc2UgaWYgKFxuICAgICAgYU9iamVjdCAhPT0gT2JqZWN0KGFPYmplY3QpIHx8XG4gICAgICBhT2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbiB8fFxuICAgICAgYU9iamVjdCBpbnN0YW5jZW9mIFN0cmluZyB8fFxuICAgICAgYU9iamVjdCBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgIGFPYmplY3QgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAgIGFPYmplY3QgaW5zdGFuY2VvZiBJbWFnZURhdGEgfHxcbiAgICAgICh0eXBlb2YgRmlsZUxpc3QgIT09IFwidW5kZWZpbmVkXCIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIEZpbGVMaXN0KVxuICAgICkge1xuICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XG4gICAgICAvLyBUT0RPOiBhdm9pZCBvYmplY3Qgc3VjaCBhcyBEeW5hbWljUGx1Z2luIGluc3RhbmNlLlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgYU9iamVjdCBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgIGJPYmplY3QgPSB7XG4gICAgICAgIF9ydHlwZTogXCJmaWxlXCIsXG4gICAgICAgIF9ybmFtZTogYU9iamVjdC5uYW1lLFxuICAgICAgICBfcm1pbWU6IGFPYmplY3QudHlwZSxcbiAgICAgICAgX3J2YWx1ZTogYU9iamVjdCxcbiAgICAgICAgX3JwYXRoOiBhT2JqZWN0Ll9wYXRoIHx8IGFPYmplY3Qud2Via2l0UmVsYXRpdmVQYXRoXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYU9iamVjdCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgIGJPYmplY3QgPSB7IF9ydHlwZTogXCJibG9iXCIsIF9ydmFsdWU6IGFPYmplY3QgfTtcbiAgICB9IGVsc2UgaWYgKGFPYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAgIGlmIChhT2JqZWN0Ll90cmFuc2ZlciB8fCBfdHJhbnNmZXIpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGFPYmplY3QuYnVmZmVyKTtcbiAgICAgICAgZGVsZXRlIGFPYmplY3QuX3RyYW5zZmVyO1xuICAgICAgfVxuICAgICAgY29uc3QgZHR5cGUgPSB0eXBlZEFycmF5VG9EdHlwZVthT2JqZWN0LmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgICAgYk9iamVjdCA9IHtcbiAgICAgICAgX3J0eXBlOiBcInR5cGVkYXJyYXlcIixcbiAgICAgICAgX3J2YWx1ZTogYU9iamVjdC5idWZmZXIsXG4gICAgICAgIF9yZHR5cGU6IGR0eXBlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYU9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICBpZiAoYU9iamVjdC5fdHJhbnNmZXIgfHwgX3RyYW5zZmVyKSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChhT2JqZWN0LmJ1ZmZlcik7XG4gICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll90cmFuc2ZlcjtcbiAgICAgIH1cbiAgICAgIGJPYmplY3QgPSB7IF9ydHlwZTogXCJtZW1vcnl2aWV3XCIsIF9ydmFsdWU6IGFPYmplY3QuYnVmZmVyIH07XG4gICAgfSBlbHNlIGlmIChhT2JqZWN0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBiT2JqZWN0ID0ge1xuICAgICAgICBfcnR5cGU6IFwic2V0XCIsXG4gICAgICAgIF9ydmFsdWU6IGF3YWl0IHRoaXMuX2VuY29kZShBcnJheS5mcm9tKGFPYmplY3QpLCBhc0ludGVyZmFjZSlcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChhT2JqZWN0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBiT2JqZWN0ID0ge1xuICAgICAgICBfcnR5cGU6IFwib3JkZXJlZG1hcFwiLFxuICAgICAgICBfcnZhbHVlOiBhd2FpdCB0aGlzLl9lbmNvZGUoQXJyYXkuZnJvbShhT2JqZWN0KSwgYXNJbnRlcmZhY2UpXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhT2JqZWN0LmNvbnN0cnVjdG9yIGluc3RhbmNlb2YgT2JqZWN0IHx8XG4gICAgICBBcnJheS5pc0FycmF5KGFPYmplY3QpXG4gICAgKSB7XG4gICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgICBsZXQga2V5cztcbiAgICAgIC8vIGFuIG9iamVjdC9hcnJheVxuICAgICAgaWYgKGFPYmplY3QuY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCBBcnJheS5pc0FycmF5KGFPYmplY3QpKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhhT2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIC8vIGEgY2xhc3NcbiAgICAgIGVsc2UgaWYgKGFPYmplY3QuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBpbnN0YW50aWF0ZSB0aGUgY2xhc3MgYmVmb3JlIGV4cG9ydHRpbmcgaXQuXCIpO1xuICAgICAgfVxuICAgICAgLy8gaW5zdGFuY2Ugb2YgYSBjbGFzc1xuICAgICAgZWxzZSBpZiAoYU9iamVjdC5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFxuICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihhT2JqZWN0KVxuICAgICAgICApLmNvbmNhdChPYmplY3Qua2V5cyhhT2JqZWN0KSk7XG4gICAgICAgIC8vIFRPRE86IHVzZSBhIHByb3h5IG9iamVjdCB0byByZXByZXNlbnQgdGhlIGFjdHVhbCBvYmplY3RcbiAgICAgICAgLy8gYWx3YXlzIGVuY29kZSBjbGFzcyBpbnN0YW5jZSBhcyBpbnRlcmZhY2VcbiAgICAgICAgYXNJbnRlcmZhY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBpbnRlcmZhY2UgdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIC8vIGVuY29kZSBpbnRlcmZhY2VzXG4gICAgICBpZiAoYU9iamVjdC5fcmludGYgfHwgYXNJbnRlcmZhY2UpIHtcbiAgICAgICAgaWYgKCFvYmplY3RJZCkge1xuICAgICAgICAgIG9iamVjdElkID0gcmFuZElkKCk7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0X3N0b3JlW29iamVjdElkXSA9IGFPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgayBvZiBrZXlzKSB7XG4gICAgICAgICAgaWYgKGsgPT09IFwiY29uc3RydWN0b3JcIikgY29udGludWU7XG4gICAgICAgICAgaWYgKGsuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiT2JqZWN0W2tdID0gYXdhaXQgdGhpcy5fZW5jb2RlKFxuICAgICAgICAgICAgYU9iamVjdFtrXSxcbiAgICAgICAgICAgIHR5cGVvZiBhc0ludGVyZmFjZSA9PT0gXCJzdHJpbmdcIiA/IGFzSW50ZXJmYWNlICsgXCIuXCIgKyBrIDogayxcbiAgICAgICAgICAgIG9iamVjdElkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgaWQgZm9yIGRpc3Bvc2UgdGhlIG9iamVjdCByZW1vdGVseVxuICAgICAgICBiT2JqZWN0Ll9yaW50ZiA9IG9iamVjdElkO1xuICAgICAgICAvLyByZW1vdmUgaW50ZXJmYWNlIHdoZW4gY2xvc2VkXG4gICAgICAgIGlmIChhT2JqZWN0Lm9uICYmIHR5cGVvZiBhT2JqZWN0Lm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBhT2JqZWN0Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX29iamVjdF9zdG9yZVtvYmplY3RJZF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGsgb2Yga2V5cykge1xuICAgICAgICAgIGlmIChbXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdLmluY2x1ZGVzKGspKSBjb250aW51ZTtcbiAgICAgICAgICBiT2JqZWN0W2tdID0gYXdhaXQgdGhpcy5fZW5jb2RlKGFPYmplY3Rba10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBmb3IgZXhhbXBsZSwgYnJvd3NlckZTIG9iamVjdFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFPYmplY3QgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKGFPYmplY3QpXG4gICAgICApLmNvbmNhdChPYmplY3Qua2V5cyhhT2JqZWN0KSk7XG4gICAgICBjb25zdCBvYmplY3RJZCA9IHJhbmRJZCgpO1xuXG4gICAgICBmb3IgKGxldCBrIG9mIGtleXMpIHtcbiAgICAgICAgaWYgKFtcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl0uaW5jbHVkZXMoaykpIGNvbnRpbnVlO1xuICAgICAgICAvLyBlbmNvZGUgYXMgaW50ZXJmYWNlXG4gICAgICAgIGJPYmplY3Rba10gPSBhd2FpdCB0aGlzLl9lbmNvZGUoYU9iamVjdFtrXSwgaywgYk9iamVjdCk7XG4gICAgICB9XG4gICAgICAvLyBvYmplY3QgaWQsIHVzZWQgZm9yIGRpc3Bvc2UgdGhlIG9iamVjdFxuICAgICAgYk9iamVjdC5fcmludGYgPSBvYmplY3RJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJpbWpveS1ycGM6IFVuc3VwcG9ydGVkIGRhdGEgdHlwZTpcIiArIGFPYmplY3Q7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZmVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgYk9iamVjdC5fX3RyYW5zZmVyYWJsZXNfXyA9IHRyYW5zZmVyYWJsZXM7XG4gICAgfVxuICAgIGlmICghYk9iamVjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGVuY29kZSBvYmplY3RcIik7XG4gICAgfVxuICAgIHJldHVybiBiT2JqZWN0O1xuICB9XG5cbiAgYXN5bmMgX2RlY29kZShhT2JqZWN0LCB3aXRoUHJvbWlzZSkge1xuICAgIGlmICghYU9iamVjdCkge1xuICAgICAgcmV0dXJuIGFPYmplY3Q7XG4gICAgfVxuICAgIHZhciBiT2JqZWN0LCB2LCBrO1xuICAgIGlmIChhT2JqZWN0W1wiX3J0eXBlXCJdKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2NvZGVjc1thT2JqZWN0Ll9ydHlwZV0gJiZcbiAgICAgICAgdGhpcy5fY29kZWNzW2FPYmplY3QuX3J0eXBlXS5kZWNvZGVyXG4gICAgICApIHtcbiAgICAgICAgaWYgKGFPYmplY3QuX3JpbnRmKSB7XG4gICAgICAgICAgY29uc3QgdGVtcCA9IGFPYmplY3QuX3J0eXBlO1xuICAgICAgICAgIGRlbGV0ZSBhT2JqZWN0Ll9ydHlwZTtcbiAgICAgICAgICBhT2JqZWN0ID0gYXdhaXQgdGhpcy5fZGVjb2RlKGFPYmplY3QsIHdpdGhQcm9taXNlKTtcbiAgICAgICAgICBhT2JqZWN0Ll9ydHlwZSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgYk9iamVjdCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICB0aGlzLl9jb2RlY3NbYU9iamVjdC5fcnR5cGVdLmRlY29kZXIoYU9iamVjdClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiY2FsbGJhY2tcIikge1xuICAgICAgICBiT2JqZWN0ID0gdGhpcy5fZ2VuUmVtb3RlQ2FsbGJhY2soXG4gICAgICAgICAgYU9iamVjdC5fcnRhcmdldF9pZCxcbiAgICAgICAgICBhT2JqZWN0Ll9ydmFsdWUsXG4gICAgICAgICAgd2l0aFByb21pc2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IHRoaXMuX2dlblJlbW90ZU1ldGhvZChcbiAgICAgICAgICBhT2JqZWN0Ll9ydGFyZ2V0X2lkLFxuICAgICAgICAgIGFPYmplY3QuX3J2YWx1ZSxcbiAgICAgICAgICBhT2JqZWN0Ll9yaW50ZlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJuZGFycmF5XCIpIHtcbiAgICAgICAgLypnbG9iYWwgbmogdGYqL1xuICAgICAgICAvL2NyZWF0ZSBidWlsZCBhcnJheS90ZW5zb3IgaWYgdXNlZCBpbiB0aGUgcGx1Z2luXG4gICAgICAgIGlmICh0eXBlb2YgbmogIT09IFwidW5kZWZpbmVkXCIgJiYgbmouYXJyYXkpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhT2JqZWN0Ll9ydmFsdWUpKSB7XG4gICAgICAgICAgICBhT2JqZWN0Ll9ydmFsdWUgPSBhT2JqZWN0Ll9ydmFsdWUucmVkdWNlKF9hcHBlbmRCdWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiT2JqZWN0ID0gbmpcbiAgICAgICAgICAgIC5hcnJheShuZXcgVWludDgoYU9iamVjdC5fcnZhbHVlKSwgYU9iamVjdC5fcmR0eXBlKVxuICAgICAgICAgICAgLnJlc2hhcGUoYU9iamVjdC5fcnNoYXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGYgIT09IFwidW5kZWZpbmVkXCIgJiYgdGYuVGVuc29yKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYU9iamVjdC5fcnZhbHVlKSkge1xuICAgICAgICAgICAgYU9iamVjdC5fcnZhbHVlID0gYU9iamVjdC5fcnZhbHVlLnJlZHVjZShfYXBwZW5kQnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXJyYXl0eXBlID0gZXZhbChkdHlwZVRvVHlwZWRBcnJheVthT2JqZWN0Ll9yZHR5cGVdKTtcbiAgICAgICAgICBiT2JqZWN0ID0gdGYudGVuc29yKFxuICAgICAgICAgICAgbmV3IGFycmF5dHlwZShhT2JqZWN0Ll9ydmFsdWUpLFxuICAgICAgICAgICAgYU9iamVjdC5fcnNoYXBlLFxuICAgICAgICAgICAgYU9iamVjdC5fcmR0eXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2tlZXAgaXQgYXMgcmVndWxhciBpZiB0cmFuc2ZlcmVkIHRvIHRoZSBtYWluIGFwcFxuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgYk9iamVjdCA9IG5ldyBFcnJvcihhT2JqZWN0Ll9ydmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgaWYgKGFPYmplY3QuX3J2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICBiT2JqZWN0ID0gYU9iamVjdC5fcnZhbHVlO1xuICAgICAgICAgIC8vcGF0Y2ggX3BhdGhcbiAgICAgICAgICBiT2JqZWN0Ll9wYXRoID0gYU9iamVjdC5fcnBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYk9iamVjdCA9IG5ldyBGaWxlKFthT2JqZWN0Ll9ydmFsdWVdLCBhT2JqZWN0Ll9ybmFtZSwge1xuICAgICAgICAgICAgdHlwZTogYU9iamVjdC5fcm1pbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiT2JqZWN0Ll9wYXRoID0gYU9iamVjdC5fcnBhdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYU9iamVjdC5fcnR5cGUgPT09IFwidHlwZWRhcnJheVwiKSB7XG4gICAgICAgIGNvbnN0IGFycmF5dHlwZSA9IGV2YWwoZHR5cGVUb1R5cGVkQXJyYXlbYU9iamVjdC5fcmR0eXBlXSk7XG4gICAgICAgIGlmICghYXJyYXl0eXBlKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGR0eXBlOiBcIiArIGFPYmplY3QuX3JkdHlwZSk7XG4gICAgICAgIGJPYmplY3QgPSBuZXcgYXJyYXl0eXBlKGFPYmplY3QuX3J2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcIm1lbW9yeXZpZXdcIikge1xuICAgICAgICBiT2JqZWN0ID0gbmV3IERhdGFWaWV3KGFPYmplY3QuX3J2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcImJsb2JcIikge1xuICAgICAgICBpZiAoYU9iamVjdC5fcnZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgIGJPYmplY3QgPSBhT2JqZWN0Ll9ydmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYk9iamVjdCA9IG5ldyBCbG9iKFthT2JqZWN0Ll9ydmFsdWVdLCB7IHR5cGU6IGFPYmplY3QuX3JtaW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFPYmplY3QuX3J0eXBlID09PSBcIm9yZGVyZWRtYXBcIikge1xuICAgICAgICBiT2JqZWN0ID0gbmV3IE1hcChhd2FpdCB0aGlzLl9kZWNvZGUoYU9iamVjdC5fcnZhbHVlLCB3aXRoUHJvbWlzZSkpO1xuICAgICAgfSBlbHNlIGlmIChhT2JqZWN0Ll9ydHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICBiT2JqZWN0ID0gbmV3IFNldChhd2FpdCB0aGlzLl9kZWNvZGUoYU9iamVjdC5fcnZhbHVlLCB3aXRoUHJvbWlzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaW50ZXJmYWNlIGZ1bmN0aW9ucyBhcmUgZGVjb2RlZFxuICAgICAgICBpZiAoYU9iamVjdC5fcmludGYpIHtcbiAgICAgICAgICBjb25zdCB0ZW1wID0gYU9iamVjdC5fcnR5cGU7XG4gICAgICAgICAgZGVsZXRlIGFPYmplY3QuX3J0eXBlO1xuICAgICAgICAgIGFPYmplY3QgPSBhd2FpdCB0aGlzLl9kZWNvZGUoYU9iamVjdCwgd2l0aFByb21pc2UpO1xuICAgICAgICAgIGFPYmplY3QuX3J0eXBlID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBiT2JqZWN0ID0gYU9iamVjdDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFPYmplY3QuY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCBBcnJheS5pc0FycmF5KGFPYmplY3QpKSB7XG4gICAgICB2YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkoYU9iamVjdCk7XG4gICAgICBiT2JqZWN0ID0gaXNhcnJheSA/IFtdIDoge307XG4gICAgICBmb3IgKGsgaW4gYU9iamVjdCkge1xuICAgICAgICBpZiAoaXNhcnJheSB8fCBhT2JqZWN0Lmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgdiA9IGFPYmplY3Rba107XG4gICAgICAgICAgYk9iamVjdFtrXSA9IGF3YWl0IHRoaXMuX2RlY29kZSh2LCB3aXRoUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYk9iamVjdCA9IGFPYmplY3Q7XG4gICAgfVxuICAgIGlmIChiT2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgb2JqZWN0XCIpO1xuICAgIH1cbiAgICAvLyBzdG9yZSB0aGUgb2JqZWN0IGlkIGZvciBkaXNwb3NlXG4gICAgaWYgKGFPYmplY3QuX3JpbnRmKSB7XG4gICAgICB0aGlzLl9vYmplY3Rfd2Vha21hcC5zZXQoYk9iamVjdCwgYU9iamVjdC5fcmludGYpO1xuICAgIH1cbiAgICByZXR1cm4gYk9iamVjdDtcbiAgfVxuXG4gIGFzeW5jIF93cmFwKGFyZ3MsIGFzSW50ZXJmYWNlKSB7XG4gICAgdmFyIHdyYXBwZWQgPSBhd2FpdCB0aGlzLl9lbmNvZGUoYXJncywgYXNJbnRlcmZhY2UpO1xuICAgIHJldHVybiB3cmFwcGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFVud3JhcHMgdGhlIHNldCBvZiBhcmd1bWVudHMgZGVsaXZlcmVkIGZyb20gdGhlIHJlbW90ZSBzaXRlLFxuICAgKiByZXBsYWNlcyBhbGwgY2FsbGJhY2sgaWRlbnRpZmllcnMgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHdpbGxcbiAgICogaW5pdGlhdGUgc2VuZGluZyB0aGF0IGNhbGxiYWNrIGlkZW50aWZpZXIgYmFjayB0byBvdGhlciBzaXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIHRvIHVud3JhcFxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhQcm9taXNlIGlzIHRydWUgbWVhbnMgdGhpcyB0aGUgY2FsbGJhY2sgc2hvdWxkIGNvbnRhaW4gYSBwcm9taXNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdW53cmFwcGVkIGFyZ3NcbiAgICovXG4gIGFzeW5jIF91bndyYXAoYXJncywgd2l0aFByb21pc2UpIHtcbiAgICB2YXIgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVjb2RlKGFyZ3MsIHdpdGhQcm9taXNlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgd3JhcHBlZCBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIHJlbW90ZVxuICAgKiBjYWxsYmFjay4gV2hlbiB0aGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCwgaXQgd2lsbCBzZW5kXG4gICAqIHRoZSBjb3JyZXNwb25kaW5nIG1lc3NhZ2UgdG8gdGhlIHJlbW90ZSBzaXRlIGFza2luZyBpdCB0b1xuICAgKiBleGVjdXRlIHRoZSBwYXJ0aWN1bGFyIGNhbGxiYWNrIHByZXZpb3VzbHkgc2F2ZWQgZHVyaW5nIGEgY2FsbFxuICAgKiBieSB0aGUgcmVtb3RlIHNpdGUgYSBtZXRob2QgZnJvbSB0aGUgaW50ZXJmYWNlIG9mIHRoaXMgc2l0ZVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgb2YgdGhlIHJlbW90ZSBjYWxsYmFjayB0byBleGVjdXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdOdW0gYXJndW1lbnQgaW5kZXggb2YgdGhlIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFByb21pc2UgaXMgdHJ1ZSBtZWFucyB0aGlzIHRoZSBjYWxsYmFjayBzaG91bGQgY29udGFpbiBhIHByb21pc2VcbiAgICpcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSB3cmFwcGVkIHJlbW90ZSBjYWxsYmFja1xuICAgKi9cbiAgX2dlblJlbW90ZUNhbGxiYWNrKHRhcmdldElkLCBjaWQsIHdpdGhQcm9taXNlKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcmVtb3RlQ2FsbGJhY2s7XG4gICAgaWYgKHdpdGhQcm9taXNlKSB7XG4gICAgICByZW1vdGVDYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHZhciBhcmdzID0gYXdhaXQgbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBhcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSBkZWxldGUgYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcblxuICAgICAgICAgIGNvbnN0IGVuY29kZWRQcm9taXNlID0gYXdhaXQgbWUuX3dyYXAoW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICAgIC8vIHN0b3JlIHRoZSBrZXkgaWQgZm9yIHJlbW92aW5nIHRoZW0gZnJvbSB0aGUgcmVmZXJlbmNlIHN0b3JlIHRvZ2V0aGVyXG4gICAgICAgICAgcmVzb2x2ZS5fX3Byb21pc2VfcGFpciA9IGVuY29kZWRQcm9taXNlWzFdLl9ydmFsdWU7XG4gICAgICAgICAgcmVqZWN0Ll9fcHJvbWlzZV9wYWlyID0gZW5jb2RlZFByb21pc2VbMF0uX3J2YWx1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWUuX2Nvbm5lY3Rpb24uZW1pdChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgICB0YXJnZXRfaWQ6IHRhcmdldElkLFxuICAgICAgICAgICAgICAgIGlkOiBjaWQsXG4gICAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBlbmNvZGVkUHJvbWlzZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGV4ZWN0dWUgcmVtb3RlIGNhbGxiYWNrICggaWQ6ICR7Y2lkfSkuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW90ZUNhbGxiYWNrID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXdhaXQgbWUuX3dyYXAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gYXJncy5fX3RyYW5zZmVyYWJsZXNfXztcbiAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMpIGRlbGV0ZSBhcmdzLl9fdHJhbnNmZXJhYmxlc19fO1xuICAgICAgICByZXR1cm4gbWUuX2Nvbm5lY3Rpb24uZW1pdChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImNhbGxiYWNrXCIsXG4gICAgICAgICAgICB0YXJnZXRfaWQ6IHRhcmdldElkLFxuICAgICAgICAgICAgaWQ6IGNpZCxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyYW5zZmVyYWJsZXNcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVtb3RlQ2FsbGJhY2s7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZSBhbmQgYnJlYWtzIHRoZSBjb25uZWN0aW9uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZW1pdCh7IHR5cGU6IFwiZGlzY29ubmVjdFwiIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgfSwgMjAwMCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VTdG9yZSBpcyBhIHNwZWNpYWwgb2JqZWN0IHdoaWNoIHN0b3JlcyBvdGhlciBvYmplY3RzXG4gKiBhbmQgcHJvdmlkZXMgdGhlIHJlZmVyZW5jZXMgKG51bWJlcikgaW5zdGVhZC4gVGhpcyByZWZlcmVuY2VcbiAqIG1heSB0aGVuIGJlIHNlbnQgb3ZlciBhIGpzb24tYmFzZWQgY29tbXVuaWNhdGlvbiBjaGFubmVsIChJUENcbiAqIHRvIGFub3RoZXIgTm9kZS5qcyBwcm9jZXNzIG9yIGEgbWVzc2FnZSB0byB0aGUgV29ya2VyKS4gT3RoZXJcbiAqIHNpdGUgbWF5IHRoZW4gcHJvdmlkZSB0aGUgcmVmZXJlbmNlIGluIHRoZSByZXNwb25jZSBtZXNzYWdlXG4gKiBpbXBseWluZyB0aGUgZ2l2ZW4gb2JqZWN0IHNob3VsZCBiZSBhY3RpdmF0ZWQuXG4gKlxuICogUHJpbWFyeSB1c2FnZSBmb3IgdGhlIFJlZmVyZW5jZVN0b3JlIGlzIGEgc3RvcmFnZSBmb3IgdGhlXG4gKiBjYWxsYmFja3MsIHdoaWNoIHRoZXJlZm9yZSBtYWtlcyBpdCBwb3NzaWJsZSB0byBpbml0aWF0ZSBhXG4gKiBjYWxsYmFjayBleGVjdXRpb24gYnkgdGhlIG9wcG9zaXRlIHNpdGUgKHdoaWNoIG5vcm1hbGx5IGNhbm5vdFxuICogZGlyZWN0bHkgZXhlY3V0ZSBmdW5jdGlvbnMgb3ZlciB0aGUgY29tbXVuaWNhdGlvbiBjaGFubmVsKS5cbiAqXG4gKiBFYWNoIHN0b3JlZCBvYmplY3QgY2FuIG9ubHkgYmUgZmV0Y2hlZCBvbmNlIGFuZCBpcyBub3RcbiAqIGF2YWlsYWJsZSBmb3IgdGhlIHNlY29uZCB0aW1lLiBFYWNoIHN0b3JlZCBvYmplY3QgbXVzdCBiZVxuICogZmV0Y2hlZCwgc2luY2Ugb3RoZXJ3aXNlIGl0IHdpbGwgcmVtYWluIHN0b3JlZCBmb3JldmVyIGFuZFxuICogY29uc3VtZSBtZW1vcnkuXG4gKlxuICogU3RvcmVkIG9iamVjdCBpbmRlY2VzIGFyZSBzaW1wbHkgdGhlIG51bWJlcnMsIHdoaWNoIGFyZSBob3dldmVyXG4gKiByZWxlYXNlZCBhbG9uZyB3aXRoIHRoZSBvYmplY3RzLCBhbmQgYXJlIGxhdGVyIHJldXNlZCBhZ2FpbiAoaW5cbiAqIG9yZGVyIHRvIHBvc3Rwb25lIHRoZSBvdmVyZmxvdywgd2hpY2ggc2hvdWxkIG5vdCBsaWtlbHkgaGFwcGVuLFxuICogYnV0IGFueXdheSkuXG4gKi9cbmNsYXNzIFJlZmVyZW5jZVN0b3JlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fc3RvcmUgPSB7fTsgLy8gc3RvcmVkIG9iamVjdFxuICAgIHRoaXMuX2luZGljZXMgPSBbMF07IC8vIHNtYWxsZXN0IGF2YWlsYWJsZSBpbmRpY2VzXG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLl9idXN5SGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5fcmVhZHlIYW5kbGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogY2FsbCBoYW5kbGVyIHdoZW4gdGhlIHN0b3JlIGlzIGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSB7RlVOQ1RJT059IGlkIG9mIGEgaGFuZGxlclxuICAgKi9cbiAgb25SZWFkeShyZWFkeUhhbmRsZXIpIHtcbiAgICB0aGlzLl9yZWFkeUhhbmRsZXIgPSByZWFkeUhhbmRsZXIgfHwgZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxsIGhhbmRsZXIgd2hlbiB0aGUgc3RvcmUgaXMgbm90IGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSB7RlVOQ1RJT059IGlkIG9mIGEgaGFuZGxlclxuICAgKi9cbiAgb25CdXN5KGJ1c3lIYW5kbGVyKSB7XG4gICAgdGhpcy5fYnVzeUhhbmRsZXIgPSBidXN5SGFuZGxlciB8fCBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBzdG9yZVxuICAgKlxuICAgKi9cbiAgZ2V0U3RhY2soKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3N0b3JlKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIF9nZW5JZCgpIGdlbmVyYXRlcyB0aGUgbmV3IHJlZmVyZW5jZSBpZFxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBzbWFsbGVzdCBhdmFpbGFibGUgaWQgYW5kIHJlc2VydmVzIGl0XG4gICAqL1xuICBfZ2VuSWQoKSB7XG4gICAgdmFyIGlkO1xuICAgIGlmICh0aGlzLl9pbmRpY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWQgPSB0aGlzLl9pbmRpY2VzWzBdKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gdGhpcy5faW5kaWNlcy5zaGlmdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gcmVmZXJlbmNlIGlkIHNvIHRoYXQgaXQgd2lsbCBiZSBhdmFpbGFibGUgYnlcbiAgICogYW5vdGhlciBvYmplY3Qgc3RvcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCB0byByZWxlYXNlXG4gICAqL1xuICBfcmVsZWFzZUlkKGlkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaWQgPCB0aGlzLl9pbmRpY2VzW2ldKSB7XG4gICAgICAgIHRoaXMuX2luZGljZXMuc3BsaWNlKGksIDAsIGlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2xlYW5pbmctdXAgdGhlIHNlcXVlbmNlIHRhaWxcbiAgICBmb3IgKGkgPSB0aGlzLl9pbmRpY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy5faW5kaWNlc1tpXSAtIDEgPT09IHRoaXMuX2luZGljZXNbaSAtIDFdKSB7XG4gICAgICAgIHRoaXMuX2luZGljZXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiBvYmplY3QgYW5kIHJldHVybnMgdGhlIHJlZmVybmNlIGlkIGluc3RlYWRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0byBzdG9yZVxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSByZWZlcmVuY2UgaWQgb2YgdGhlIHN0b3JlZCBvYmplY3RcbiAgICovXG4gIHB1dChvYmopIHtcbiAgICBpZiAodGhpcy5fYnVzeUhhbmRsZXIgJiYgT2JqZWN0LmtleXModGhpcy5fc3RvcmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fYnVzeUhhbmRsZXIoKTtcbiAgICB9XG4gICAgdmFyIGlkID0gdGhpcy5fZ2VuSWQoKTtcbiAgICB0aGlzLl9zdG9yZVtpZF0gPSBvYmo7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBwcmV2aW91c2x5IHN0b3JlZCBvYmplY3QgYW5kIHJlbGVhc2VzIGl0cyByZWZlcmVuY2VcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIG9mIGFuIG9iamVjdCB0byByZXRyaWV2ZVxuICAgKi9cbiAgZmV0Y2goaWQpIHtcbiAgICB2YXIgb2JqID0gdGhpcy5fc3RvcmVbaWRdO1xuICAgIGlmIChvYmogJiYgIW9iai5fX3JlbW90ZV9tZXRob2QpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtpZF07XG4gICAgICB0aGlzLl9yZWxlYXNlSWQoaWQpO1xuICAgICAgaWYgKHRoaXMuX3JlYWR5SGFuZGxlciAmJiBPYmplY3Qua2V5cyh0aGlzLl9zdG9yZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5SGFuZGxlcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqICYmIG9iai5fX3Byb21pc2VfcGFpcikge1xuICAgICAgdGhpcy5mZXRjaChvYmouX19wcm9taXNlX3BhaXIpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQU9BO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBVUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBUkE7QUFrQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdDBCQTtBQXcwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTlHQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/rpc.js\n");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: randId, dtypeToTypedArray, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randId\", function() { return randId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"urlJoin\", function() { return urlJoin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\nconst dtypeToTypedArray = {\n  int8: \"Int8Array\",\n  int16: \"Int16Array\",\n  int32: \"Int32Array\",\n  uint8: \"Uint8Array\",\n  uint16: \"Uint16Array\",\n  uint32: \"Uint32Array\",\n  float32: \"Float32Array\",\n  float64: \"Float64Array\",\n  array: \"Array\"\n};\nconst typedArrayToDtype = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\"\n};\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url\n    };\n\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n\n    const messageChannel = new MessageChannel();\n\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  if (!Array.isArray(requirements)) {\n    requirementsm.code.requirements = [requirements];\n  }\n\n  if (requirements && requirements.length > 0) {\n    for (let req of requirements) {\n      //remove prefix\n      if (req.startsWith(\"js:\")) req = req.slice(3);\n      if (req.startsWith(\"css:\")) req = req.slice(4);\n      if (req.startsWith(\"cache:\")) req = req.slice(6);\n      if (!req.startsWith(\"http\")) continue;\n      await cacheUrlInServiceWorker(req).catch(e => {\n        console.error(e);\n      });\n    }\n  }\n}\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n  // register service worker for offline access\n  if (\"serviceWorker\" in navigator) {\n    baseUrl = baseUrl || \"/\";\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\n      // Registration was successful\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n    }, function (err) {\n      // registration failed :(\n      console.log(\"ServiceWorker registration failed: \", err);\n    });\n    targetOrigin = targetOrigin || \"*\";\n    cacheCallback = cacheCallback || cacheRequirements;\n\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\n      throw new Error(\"config.cache_requirements must be a function\");\n    }\n\n    window.addEventListener(\"message\", function (e) {\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n        const m = e.data;\n\n        if (m.type === \"cacheRequirements\") {\n          cacheCallback(m.requirements);\n        }\n      }\n    });\n  }\n} //#Source https://bit.ly/2neWfJ2\n\nfunction urlJoin(...args) {\n  return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n\n    this._event_handlers[event].push(handler);\n  }\n\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWpveVJQQy8uL3NyYy91dGlscy5qcz8wMjVlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiByYW5kSWQoKSB7XG4gIHJldHVybiAoXG4gICAgTWF0aC5yYW5kb20oKVxuICAgICAgLnRvU3RyaW5nKDM2KVxuICAgICAgLnN1YnN0cigyLCAxMCkgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICApO1xufVxuXG5leHBvcnQgY29uc3QgZHR5cGVUb1R5cGVkQXJyYXkgPSB7XG4gIGludDg6IFwiSW50OEFycmF5XCIsXG4gIGludDE2OiBcIkludDE2QXJyYXlcIixcbiAgaW50MzI6IFwiSW50MzJBcnJheVwiLFxuICB1aW50ODogXCJVaW50OEFycmF5XCIsXG4gIHVpbnQxNjogXCJVaW50MTZBcnJheVwiLFxuICB1aW50MzI6IFwiVWludDMyQXJyYXlcIixcbiAgZmxvYXQzMjogXCJGbG9hdDMyQXJyYXlcIixcbiAgZmxvYXQ2NDogXCJGbG9hdDY0QXJyYXlcIixcbiAgYXJyYXk6IFwiQXJyYXlcIlxufTtcbmV4cG9ydCBjb25zdCB0eXBlZEFycmF5VG9EdHlwZSA9IHtcbiAgSW50OEFycmF5OiBcImludDhcIixcbiAgSW50MTZBcnJheTogXCJpbnQxNlwiLFxuICBJbnQzMkFycmF5OiBcImludDMyXCIsXG4gIFVpbnQ4QXJyYXk6IFwidWludDhcIixcbiAgVWludDE2QXJyYXk6IFwidWludDE2XCIsXG4gIFVpbnQzMkFycmF5OiBcInVpbnQzMlwiLFxuICBGbG9hdDMyQXJyYXk6IFwiZmxvYXQzMlwiLFxuICBGbG9hdDY0QXJyYXk6IFwiZmxvYXQ2NFwiLFxuICBBcnJheTogXCJhcnJheVwiXG59O1xuXG5mdW5jdGlvbiBjYWNoZVVybEluU2VydmljZVdvcmtlcih1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICBjb21tYW5kOiBcImFkZFwiLFxuICAgICAgdXJsOiB1cmxcbiAgICB9O1xuICAgIGlmICghbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgfHwgIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKSB7XG4gICAgICByZWplY3QoXCJTZXJ2aWNlIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lcnJvcikge1xuICAgICAgICByZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlci5wb3N0TWVzc2FnZShtZXNzYWdlLCBbXG4gICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQyXG4gICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KFwiU2VydmljZSB3b3JrZXIgY29udHJvbGxlciBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWNoZVJlcXVpcmVtZW50cyhyZXF1aXJlbWVudHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlcXVpcmVtZW50cykpIHtcbiAgICByZXF1aXJlbWVudHNtLmNvZGUucmVxdWlyZW1lbnRzID0gW3JlcXVpcmVtZW50c107XG4gIH1cbiAgaWYgKHJlcXVpcmVtZW50cyAmJiByZXF1aXJlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAobGV0IHJlcSBvZiByZXF1aXJlbWVudHMpIHtcbiAgICAgIC8vcmVtb3ZlIHByZWZpeFxuICAgICAgaWYgKHJlcS5zdGFydHNXaXRoKFwianM6XCIpKSByZXEgPSByZXEuc2xpY2UoMyk7XG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXCJjc3M6XCIpKSByZXEgPSByZXEuc2xpY2UoNCk7XG4gICAgICBpZiAocmVxLnN0YXJ0c1dpdGgoXCJjYWNoZTpcIikpIHJlcSA9IHJlcS5zbGljZSg2KTtcbiAgICAgIGlmICghcmVxLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSBjb250aW51ZTtcblxuICAgICAgYXdhaXQgY2FjaGVVcmxJblNlcnZpY2VXb3JrZXIocmVxKS5jYXRjaChlID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTZXJ2aWNlV29ya2VyKGJhc2VVcmwsIHRhcmdldE9yaWdpbiwgY2FjaGVDYWxsYmFjaykge1xuICAvLyByZWdpc3RlciBzZXJ2aWNlIHdvcmtlciBmb3Igb2ZmbGluZSBhY2Nlc3NcbiAgaWYgKFwic2VydmljZVdvcmtlclwiIGluIG5hdmlnYXRvcikge1xuICAgIGJhc2VVcmwgPSBiYXNlVXJsIHx8IFwiL1wiO1xuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKGJhc2VVcmwgKyBcInBsdWdpbi1zZXJ2aWNlLXdvcmtlci5qc1wiKS50aGVuKFxuICAgICAgZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIC8vIFJlZ2lzdHJhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwgd2l0aCBzY29wZTogXCIsXG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnNjb3BlXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIHJlZ2lzdHJhdGlvbiBmYWlsZWQgOihcbiAgICAgICAgY29uc29sZS5sb2coXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQ6IFwiLCBlcnIpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGFyZ2V0T3JpZ2luID0gdGFyZ2V0T3JpZ2luIHx8IFwiKlwiO1xuICAgIGNhY2hlQ2FsbGJhY2sgPSBjYWNoZUNhbGxiYWNrIHx8IGNhY2hlUmVxdWlyZW1lbnRzO1xuICAgIGlmIChjYWNoZUNhbGxiYWNrICYmIHR5cGVvZiBjYWNoZUNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmZpZy5jYWNoZV9yZXF1aXJlbWVudHMgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRhcmdldE9yaWdpbiA9PT0gXCIqXCIgfHwgZS5vcmlnaW4gPT09IHRhcmdldE9yaWdpbikge1xuICAgICAgICBjb25zdCBtID0gZS5kYXRhO1xuICAgICAgICBpZiAobS50eXBlID09PSBcImNhY2hlUmVxdWlyZW1lbnRzXCIpIHtcbiAgICAgICAgICBjYWNoZUNhbGxiYWNrKG0ucmVxdWlyZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8vI1NvdXJjZSBodHRwczovL2JpdC5seS8ybmVXZkoyXG5leHBvcnQgZnVuY3Rpb24gdXJsSm9pbiguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzXG4gICAgLmpvaW4oXCIvXCIpXG4gICAgLnJlcGxhY2UoL1tcXC9dKy9nLCBcIi9cIilcbiAgICAucmVwbGFjZSgvXiguKyk6XFwvLywgXCIkMTovL1wiKVxuICAgIC5yZXBsYWNlKC9eZmlsZTovLCBcImZpbGU6L1wiKVxuICAgIC5yZXBsYWNlKC9cXC8oXFw/fCZ8I1teIV0pL2csIFwiJDFcIilcbiAgICAucmVwbGFjZSgvXFw/L2csIFwiJlwiKVxuICAgIC5yZXBsYWNlKFwiJlwiLCBcIj9cIik7XG59XG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlRW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGRlYnVnKSB7XG4gICAgdGhpcy5fZXZlbnRfaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLl9vbmNlX2hhbmRsZXJzID0ge307XG4gICAgdGhpcy5fZGVidWcgPSBkZWJ1ZztcbiAgfVxuICBlbWl0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImVtaXQgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIG9uKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0pIHtcbiAgICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgfVxuICBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaGFuZGxlci5fX19ldmVudF9ydW5fb25jZSA9IHRydWU7XG4gICAgdGhpcy5vbihldmVudCwgaGFuZGxlcik7XG4gIH1cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKCFldmVudCAmJiAhaGFuZGxlcikge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudHMgaGFuZGxlcnNcbiAgICAgIHRoaXMuX2V2ZW50X2hhbmRsZXJzID0ge307XG4gICAgfSBlbHNlIGlmIChldmVudCAmJiAhaGFuZGxlcikge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBoYW5sZGVycyBmb3IgdGhlIGV2ZW50XG4gICAgICBpZiAodGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdKSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGEgc3BlY2lmaWMgaGFuZGxlclxuICAgICAgaWYgKHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0uaW5kZXhPZihoYW5kbGVyKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9maXJlKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50X2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fZXZlbnRfaGFuZGxlcnNbZXZlbnRdW2ldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoYW5kbGVyLl9fX2V2ZW50X3J1bl9vbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudF9oYW5kbGVyc1tldmVudF0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidW5oYW5kbGVkIGV2ZW50XCIsIGV2ZW50LCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpEQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils.js\n");

/***/ })

/******/ });
});