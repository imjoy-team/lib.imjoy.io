!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("imjoyRPC",[],t):"object"==typeof exports?exports.imjoyRPC=t():e.imjoyRPC=t()}(window,(function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=7)}([function(e,t,n){"use strict";function r(){return Math.random().toString(36).substr(2,10)+(new Date).getTime()}n.d(t,"c",(function(){return r})),n.d(t,"b",(function(){return i})),n.d(t,"e",(function(){return o})),n.d(t,"d",(function(){return a})),n.d(t,"a",(function(){return _}));const i={int8:"Int8Array",int16:"Int16Array",int32:"Int32Array",uint8:"Uint8Array",uint16:"Uint16Array",uint32:"Uint32Array",float32:"Float32Array",float64:"Float64Array",array:"Array"},o={Int8Array:"int8",Int16Array:"int16",Int32Array:"int32",Uint8Array:"uint8",Uint16Array:"uint16",Uint32Array:"uint32",Float32Array:"float32",Float64Array:"float64",Array:"array"};function c(e){return new Promise((function(t,n){const r={command:"add",url:e};if(!navigator.serviceWorker||!navigator.serviceWorker.register)return void n("Service worker is not supported.");const i=new MessageChannel;i.port1.onmessage=function(e){e.data&&e.data.error?n(e.data.error):t(e.data&&e.data.result)},navigator.serviceWorker&&navigator.serviceWorker.controller?navigator.serviceWorker.controller.postMessage(r,[i.port2]):n("Service worker controller is not available")}))}async function s(e){if(Array.isArray(e)||(requirementsm.code.requirements=[e]),e&&e.length>0)for(let t of e)t.startsWith("js:")&&(t=t.slice(3)),t.startsWith("css:")&&(t=t.slice(4)),t.startsWith("cache:")&&(t=t.slice(6)),t.startsWith("http")&&await c(t).catch(e=>{console.error(e)})}function a(e,t,n){if("serviceWorker"in navigator){if(e=e||"/",navigator.serviceWorker.register(e+"plugin-service-worker.js").then((function(e){console.log("ServiceWorker registration successful with scope: ",e.scope)}),(function(e){console.log("ServiceWorker registration failed: ",e)})),t=t||"*",(n=n||s)&&"function"!=typeof n)throw new Error("config.cache_requirements must be a function");window.addEventListener("message",(function(e){if("*"===t||e.origin===t){const t=e.data;"cacheRequirements"===t.type&&n(t.requirements)}}))}}class _{constructor(e){this._event_handlers={},this._once_handlers={},this._debug=e}emit(){throw new Error("emit is not implemented")}on(e,t){this._event_handlers[e]||(this._event_handlers[e]=[]),this._event_handlers[e].push(t)}once(e,t){t.___event_run_once=!0,this.on(e,t)}off(e,t){if(e||t){if(e&&!t)this._event_handlers[e]&&(this._event_handlers[e]=[]);else if(this._event_handlers[e]){const n=this._event_handlers[e].indexOf(t);n>=0&&this._event_handlers[e].splice(n,1)}}else this._event_handlers={}}_fire(e,t){if(this._event_handlers[e])for(var n=this._event_handlers[e].length;n--;){const r=this._event_handlers[e][n];try{r(t)}catch(e){console.error(e)}finally{r.___event_run_once&&this._event_handlers[e].splice(n,1)}}else this._debug&&console.warn("unhandled event",e,t)}}},function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return API_VERSION})),__webpack_require__.d(__webpack_exports__,"b",(function(){return RPC}));var _utils_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(0);const API_VERSION="0.2.3",ArrayBufferView=Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array)).constructor;function _appendBuffer(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}function indexObject(e,t){if(!t)throw new Error("undefined index");return"string"==typeof t?indexObject(e,t.split(".")):0===t.length?e:indexObject(e[t[0]],t.slice(1))}class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.a{constructor(e,t,n){super(t&&t.debug),this._connection=e,this.config=t||{},this._codecs=n||{},this._object_store={},this._method_weakmap=new WeakMap,this._object_weakmap=new WeakMap,this._local_api=null;const r=this.config.name;this._connection.execute=this._connection.execute||function(){throw new Error(`connection.execute not implemented (in "${r}")`)},this._store=new ReferenceStore,this._method_refs=new ReferenceStore,this._method_refs.onReady(()=>{this._fire("remoteIdle")}),this._method_refs.onBusy(()=>{this._fire("remoteBusy")}),this._setupMessageHanlders()}init(){this._connection.emit({type:"initialized",config:this.config,peer_id:this._connection.peer_id})}getRemoteCallStack(){return this._method_refs.getStack()}getRemote(){return this._remote_interface}setInterface(e,t){if(t=t||{},this.config.name=t.name||this.config.name,this.config.description=t.description||this.config.description,this.config.forwarding_functions)for(let t of this.config.forwarding_functions){const n=this._remote_interface;n[t]&&(e.constructor===Object?e[t]||(e[t]=(...e)=>{n[t](...e)}):e.constructor.constructor===Function&&(e.constructor.prototype[t]||(e.constructor.prototype[t]=(...e)=>{n[t](...e)})))}this._local_api=e,this._fire("interfaceAvailable")}sendInterface(){if(!this._local_api)throw new Error("interface is not set.");this._encode(this._local_api,!0).then(e=>{this._connection.emit({type:"setInterface",api:e})})}_disposeObject(e){if(!this._object_store[e])throw new Error(`Object (id=${e}) not found.`);delete this._object_store[e]}disposeObject(e){return new Promise((t,n)=>{if(!this._object_weakmap.has(e))throw new Error("Invalid object");{const r=this._object_weakmap.get(e);this._connection.once("disposed",e=>{e.error?n(new Error(e.error)):t()}),this._connection.emit({type:"disposeObject",object_id:r})}})}_setupMessageHanlders(){this._connection.on("init",this.init),this._connection.on("execute",e=>{Promise.resolve(this._connection.execute(e.code)).then(()=>{this._connection.emit({type:"executed"})}).catch(e=>{console.error(e),this._connection.emit({type:"executed",error:String(e)})})}),this._connection.on("method",async e=>{let t,n,r,i,o,c;try{e.promise&&([t,n]=await this._unwrap(e.promise,!1));const s=this._object_store[e.object_id];if(r=indexObject(s,e.name),e.name.includes(".")){const t=e.name.split(".");i=indexObject(s,t.slice(0,t.length-1).join("."))}else i=s;o=await this._unwrap(e.args,!0),e.promise?(c=r.apply(i,o),c instanceof Promise||r.constructor&&"AsyncFunction"===r.constructor.name?c.then(t).catch(n):t(c)):r.apply(i,o)}catch(e){console.error(this.config.name,e),n&&n(e)}}),this._connection.on("callback",async e=>{let t,n,r,i,o;try{if(e.promise&&([t,n]=await this._unwrap(e.promise,!1)),e.promise){if(r=this._store.fetch(e.id),i=await this._unwrap(e.args,!0),!r)throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");o=r.apply(null,i),o instanceof Promise||r.constructor&&"AsyncFunction"===r.constructor.name?o.then(t).catch(n):t(o)}else{if(r=this._store.fetch(e.id),i=await this._unwrap(e.args,!0),!r)throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");r.apply(null,i)}}catch(e){console.error(this.config.name,e),n&&n(e)}}),this._connection.on("disposeObject",e=>{try{this._disposeObject(e.object_id),this._connection.emit({type:"disposed"})}catch(e){console.error(e),this._connection.emit({type:"disposed",error:String(e)})}}),this._connection.on("setInterface",e=>{this._setRemoteInterface(e.api)}),this._connection.on("getInterface",()=>{this._fire("getInterface"),this._local_api?this.sendInterface():this.once("interfaceAvailable",()=>{this.sendInterface()})}),this._connection.on("interfaceSetAsRemote",()=>{this._fire("interfaceSetAsRemote")}),this._connection.on("disconnect",()=>{this._fire("beforeDisconnect"),this._connection.disconnect(),this._fire("disconnected")})}requestRemote(){this._connection.emit({type:"getInterface"})}_ndarray(e,t,n){const r=_utils_js__WEBPACK_IMPORTED_MODULE_0__.e[e.constructor.name];if(n&&n!==r)throw"dtype doesn't match the type of the array: "+r+" != "+n;return t=t||[e.length],{_rtype:"ndarray",_rvalue:e.buffer,_rshape:t,_rdtype:r}}_setRemoteInterface(e){this._decode(e).then(e=>{this._remote_interface=e,this._fire("remoteReady"),this._reportRemoteSet()})}_genRemoteMethod(e,t,n){const r=this,i=function(){return new Promise(async(i,o)=>{let c=null;try{c=r._method_refs.put(n?n+"/"+t:t);const s=function(){return null!==c&&r._method_refs.fetch(c),i.apply(this,arguments)},a=function(){return null!==c&&r._method_refs.fetch(c),o.apply(this,arguments)},_=await r._wrap([s,a]);s.__promise_pair=_[1]._rvalue,a.__promise_pair=_[0]._rvalue;let d=Array.prototype.slice.call(arguments);d="register"===t||"export"===t||"on"===t?await r._wrap(d,!0):await r._wrap(d);const l=d.__transferables__;l&&delete d.__transferables__,r._connection.emit({type:"method",target_id:e,name:t,object_id:n,args:d,promise:_},l)}catch(e){c&&r._method_refs.fetch(c),o(`Failed to exectue remote method (interface: ${n||r.id}, method: ${t}), error: ${e}`)}})};return i.__remote_method=!0,i}_reportRemoteSet(){this._connection.emit({type:"interfaceSetAsRemote"})}async _encode(e,t,n){const r=typeof e;if("number"===r||"string"===r||"boolean"===r||null==e||e instanceof ArrayBuffer)return e;let i;if("function"==typeof e){if(t){if(!n)throw new Error("objectId is not specified.");i={_rtype:"interface",_rtarget_id:this._connection.peer_id,_rintf:n,_rvalue:t},this._method_weakmap.set(e,i)}else if(this._method_weakmap.has(e))i=this._method_weakmap.get(e);else{const t=this._store.put(e);i={_rtype:"callback",_rtarget_id:this._connection.peer_id,_rname:e.constructor&&e.constructor.name||t,_rvalue:t}}return i}if(e.constructor instanceof Object&&e._rtype){if(e._rintf){const r=e._rtype;delete e._rtype,i=await this._encode(e,t,n),i._rtype=r}else i=e;return i}const o=[],c=e._transfer,s=Array.isArray(e);for(let r of Object.keys(this._codecs)){const o=this._codecs[r];if(o.encoder&&e instanceof o.type){let r=await Promise.resolve(o.encoder(e));if(r&&!r._rtype&&(r._rtype=o.name),r&&r._rintf){const e=r._rtype;delete r._rtype,r=await this._encode(r,t,n),r._rtype=e}return i=r,i}}if("undefined"!=typeof tf&&tf.Tensor&&e instanceof tf.Tensor){const t=e.dataSync();(e._transfer||c)&&(o.push(t.buffer),delete e._transfer),i={_rtype:"ndarray",_rvalue:t.buffer,_rshape:e.shape,_rdtype:e.dtype}}else if("undefined"!=typeof nj&&nj.NdArray&&e instanceof nj.NdArray){const t=_utils_js__WEBPACK_IMPORTED_MODULE_0__.e[e.selection.data.constructor.name];(e._transfer||c)&&(o.push(e.selection.data.buffer),delete e._transfer),i={_rtype:"ndarray",_rvalue:e.selection.data.buffer,_rshape:e.shape,_rdtype:t}}else if(e instanceof Error)console.error(e),i={_rtype:"error",_rvalue:e.toString()};else if("undefined"!=typeof File&&e instanceof File)i={_rtype:"file",_rvalue:e,_rpath:e._path||e.webkitRelativePath};else if(e!==Object(e)||e instanceof Boolean||e instanceof String||e instanceof Date||e instanceof RegExp||e instanceof ImageData||"undefined"!=typeof FileList&&e instanceof FileList)i=e;else if("undefined"!=typeof File&&e instanceof File)i={_rtype:"file",_rname:e.name,_rmime:e.type,_rvalue:e,_rpath:e._path||e.webkitRelativePath};else if(e instanceof Blob)i={_rtype:"blob",_rvalue:e};else if(e instanceof ArrayBufferView){(e._transfer||c)&&(o.push(e.buffer),delete e._transfer);const t=_utils_js__WEBPACK_IMPORTED_MODULE_0__.e[e.constructor.name];i={_rtype:"typedarray",_rvalue:e.buffer,_rdtype:t}}else if(e instanceof DataView)(e._transfer||c)&&(o.push(e.buffer),delete e._transfer),i={_rtype:"memoryview",_rvalue:e.buffer};else if(e instanceof Set)i={_rtype:"set",_rvalue:await this._encode(Array.from(e),t)};else if(e instanceof Map)i={_rtype:"orderedmap",_rvalue:await this._encode(Array.from(e),t)};else if(e.constructor instanceof Object||Array.isArray(e)){let r;if(i=s?[]:{},e.constructor===Object||Array.isArray(e))r=Object.keys(e);else{if(e.constructor===Function)throw new Error("Please instantiate the class before exportting it.");if(e.constructor.constructor!==Function)throw Error("Unsupported interface type");r=Object.getOwnPropertyNames(Object.getPrototypeOf(e)).concat(Object.keys(e)),t=!0}let o=!1;if(e._rintf||t){n||(n=Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__.c)(),this._object_store[n]=e);for(let c of r)"constructor"!==c&&(c.startsWith("_")||(i[c]=await this._encode(e[c],"string"==typeof t?t+"."+c:c,n),"function"==typeof e[c]&&(o=!0)));o&&(i._rintf=n),e.on&&"function"==typeof e.on&&e.on("close",()=>{delete this._object_store[n]})}else for(let t of r)["hasOwnProperty","constructor"].includes(t)||(i[t]=await this._encode(e[t]))}else{if("object"!=typeof e)throw"imjoy-rpc: Unsupported data type:"+e;{const t=Object.getOwnPropertyNames(Object.getPrototypeOf(e)).concat(Object.keys(e)),n=Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__.c)();for(let n of t)["hasOwnProperty","constructor"].includes(n)||(i[n]=await this._encode(e[n],n,i));i._rintf=n}}if(o.length>0&&(i.__transferables__=o),!i)throw new Error("Failed to encode object");return i}async _decode(aObject,withPromise){if(!aObject)return aObject;let bObject;if(aObject._rtype)if(this._codecs[aObject._rtype]&&this._codecs[aObject._rtype].decoder){if(aObject._rintf){const e=aObject._rtype;delete aObject._rtype,aObject=await this._decode(aObject,withPromise),aObject._rtype=e}bObject=await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject))}else if("callback"===aObject._rtype)bObject=this._genRemoteCallback(aObject._rtarget_id,aObject._rvalue,withPromise);else if("interface"===aObject._rtype)bObject=this._genRemoteMethod(aObject._rtarget_id,aObject._rvalue,aObject._rintf);else if("ndarray"===aObject._rtype)if("undefined"!=typeof nj&&nj.array)Array.isArray(aObject._rvalue)&&(aObject._rvalue=aObject._rvalue.reduce(_appendBuffer)),bObject=nj.array(new Uint8(aObject._rvalue),aObject._rdtype).reshape(aObject._rshape);else if("undefined"!=typeof tf&&tf.Tensor){Array.isArray(aObject._rvalue)&&(aObject._rvalue=aObject._rvalue.reduce(_appendBuffer));const arraytype=eval(_utils_js__WEBPACK_IMPORTED_MODULE_0__.b[aObject._rdtype]);bObject=tf.tensor(new arraytype(aObject._rvalue),aObject._rshape,aObject._rdtype)}else bObject=aObject;else if("error"===aObject._rtype)bObject=new Error(aObject._rvalue);else if("file"===aObject._rtype)aObject._rvalue instanceof File?(bObject=aObject._rvalue,bObject._path=aObject._rpath):(bObject=new File([aObject._rvalue],aObject._rname,{type:aObject._rmime}),bObject._path=aObject._rpath);else if("typedarray"===aObject._rtype){const arraytype=eval(_utils_js__WEBPACK_IMPORTED_MODULE_0__.b[aObject._rdtype]);if(!arraytype)throw new Error("unsupported dtype: "+aObject._rdtype);bObject=new arraytype(aObject._rvalue)}else if("memoryview"===aObject._rtype)bObject=new DataView(aObject._rvalue);else if("blob"===aObject._rtype)bObject=aObject._rvalue instanceof Blob?aObject._rvalue:new Blob([aObject._rvalue],{type:aObject._rmime});else if("orderedmap"===aObject._rtype)bObject=new Map(await this._decode(aObject._rvalue,withPromise));else if("set"===aObject._rtype)bObject=new Set(await this._decode(aObject._rvalue,withPromise));else if(aObject._rintf){const e=aObject._rtype;delete aObject._rtype,bObject=await this._decode(aObject,withPromise),bObject._rtype=e}else bObject=aObject;else if(aObject.constructor===Object||Array.isArray(aObject)){const e=Array.isArray(aObject);bObject=e?[]:{};for(let t of Object.keys(aObject))if(e||aObject.hasOwnProperty(t)){const e=aObject[t];bObject[t]=await this._decode(e,withPromise)}}else bObject=aObject;if(void 0===bObject)throw new Error("Failed to decode object");return aObject._rintf&&this._object_weakmap.set(bObject,aObject._rintf),bObject}async _wrap(e,t){return await this._encode(e,t)}async _unwrap(e,t){return await this._decode(e,t)}_genRemoteCallback(e,t,n){const r=this;let i;return n?(i=function(){return new Promise(async(n,i)=>{const o=await r._wrap(Array.prototype.slice.call(arguments)),c=o.__transferables__;c&&delete o.__transferables__;const s=await r._wrap([n,i]);n.__promise_pair=s[1]._rvalue,i.__promise_pair=s[0]._rvalue;try{r._connection.emit({type:"callback",target_id:e,id:t,args:o,promise:s},c)}catch(e){i(`Failed to exectue remote callback ( id: ${t}).`)}})},i):(i=async function(){const n=await r._wrap(Array.prototype.slice.call(arguments)),i=n.__transferables__;return i&&delete n.__transferables__,r._connection.emit({type:"callback",target_id:e,id:t,args:n},i)},i)}disconnect(){this._connection.emit({type:"disconnect"}),setTimeout(()=>{this._connection.disconnect()},2e3)}}class ReferenceStore{constructor(){this._store={},this._indices=[0],this._readyHandler=function(){},this._busyHandler=function(){},this._readyHandler()}onReady(e){this._readyHandler=e||function(){}}onBusy(e){this._busyHandler=e||function(){}}getStack(){return Object.keys(this._store).length}_genId(){let e;return e=1===this._indices.length?this._indices[0]++:this._indices.shift(),e}_releaseId(e){for(let t=0;t<this._indices.length;t++)if(e<this._indices[t]){this._indices.splice(t,0,e);break}for(let e=this._indices.length-1;e>=0&&this._indices[e]-1===this._indices[e-1];e--)this._indices.pop()}put(e){this._busyHandler&&0===Object.keys(this._store).length&&this._busyHandler();const t=this._genId();return this._store[t]=e,t}fetch(e){const t=this._store[e];return t&&!t.__remote_method&&(delete this._store[e],this._releaseId(e),this._readyHandler&&0===Object.keys(this._store).length&&this._readyHandler()),t&&t.__promise_pair&&this.fetch(t.__promise_pair),t}}},function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return Connection})),__webpack_require__.d(__webpack_exports__,"b",(function(){return setupIframe}));var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(3),_rpc_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(1),_utils_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(0);function _htmlToElement(e){var t=document.createElement("template");return e=e.trim(),t.innerHTML=e,t.content.firstChild}var _importScript=function(e){return new Promise((t,n)=>{var r=document.createElement("script");r.src=e,r.type="text/javascript",r.onload=t,r.onreadystatechange=function(){"loaded"!==this.readyState&&"complete"!==this.readyState||t()},r.onerror=n,document.head.appendChild(r)})};async function importScripts(){for(var e=Array.prototype.slice.call(arguments),t=e.length,n=0;n<t;n++)await _importScript(e[n])}class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__.a{constructor(e){super(e&&e.debug),this.config=e||{},this.peer_id=Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__.c)()}connect(){this.config.target_origin=this.config.target_origin||"*",window.addEventListener("message",this),this.emit({type:"initialized",config:this.config,origin:window.location.origin,peer_id:this.peer_id}),this._fire("connected")}handleEvent(e){"message"!==e.type||"*"!==this.config.target_origin&&e.origin!==this.config.target_origin||(e.data.peer_id===this.peer_id?this._fire(e.data.type,e.data):this.config.debug&&console.log(`connection peer id mismatch ${e.data.peer_id} !== ${this.peer_id}`))}disconnect(){this._fire("beforeDisconnect"),window.removeEventListener("message",this),this._fire("disconnected")}emit(e){let t;e.__transferables__&&(t=e.__transferables__,delete e.__transferables__),parent.postMessage(e,this.config.target_origin,t)}async execute(code){try{if("requirements"===code.type){if(code.requirements&&(Array.isArray(code.requirements)||"string"==typeof code.requirements))try{var link_node;if(code.requirements="string"==typeof code.requirements?[code.requirements]:code.requirements,!Array.isArray(code.requirements))throw"unsupported requirements definition";for(var i=0;i<code.requirements.length;i++)code.requirements[i].toLowerCase().endsWith(".css")||code.requirements[i].startsWith("css:")?(code.requirements[i].startsWith("css:")&&(code.requirements[i]=code.requirements[i].slice(4)),link_node=document.createElement("link"),link_node.rel="stylesheet",link_node.href=code.requirements[i],document.head.appendChild(link_node)):code.requirements[i].toLowerCase().endsWith(".js")||code.requirements[i].startsWith("js:")?(code.requirements[i].startsWith("js:")&&(code.requirements[i]=code.requirements[i].slice(3)),await importScripts(code.requirements[i])):code.requirements[i].startsWith("http")?await importScripts(code.requirements[i]):code.requirements[i].startsWith("cache:")||console.log("Unprocessed requirements url: "+code.requirements[i])}catch(e){throw"failed to import required scripts: "+code.requirements.toString()}}else if("script"===code.type)if(code.src){var script_node=document.createElement("script");script_node.setAttribute("type",code.attrs.type),script_node.setAttribute("src",code.src),document.head.appendChild(script_node)}else if(!code.content||code.attrs.type&&"text/javascript"!==code.attrs.type){var node=document.createElement("script");node.setAttribute("type",code.attrs.type),node.appendChild(document.createTextNode(code.content)),document.body.appendChild(node)}else eval(code.content);else if("style"===code.type){const e=document.createElement("style");code.src&&(e.src=code.src),e.innerHTML=code.content,document.head.appendChild(e)}else if("link"===code.type){const e=document.createElement("link");code.rel&&(e.rel=code.rel),code.href&&(e.href=code.href),code.attrs&&code.attrs.type&&(e.type=code.attrs.type),document.head.appendChild(e)}else{if("html"!==code.type)throw"unsupported code type.";document.body.appendChild(_htmlToElement(code.content))}parent.postMessage({type:"executed"},this.config.target_origin)}catch(e){console.error("failed to execute scripts: ",code,e),parent.postMessage({type:"executed",error:e.stack||String(e)},this.config.target_origin)}}}function setupIframe(e){(e=e||{}).dedicated_thread=!1,e.lang="javascript",e.api_version=_rpc_js__WEBPACK_IMPORTED_MODULE_1__.a;const t=new Connection(e);Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__.a)(t,e),t.connect()}},function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n(1);function i(e,t){t=t||{};const n={},i=new r.b(e,t,n);i.on("getInterface",(function(){s()})),i.on("remoteReady",(function(){const e=i.getRemote()||{};if(e.export)throw new Error("`export` is a reserved function name");if(e.onload)throw new Error("`onload` is a reserved function name");if(e.dispose)throw new Error("`dispose` is a reserved function name");e.registerCodec=function(e){if(!e.name||!e.encoder&&!e.decoder)throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");if(e.type)for(let t of Object.keys(n))n[t].type!==e.type&&t!==e.name||(delete n[t],console.warn("Remove duplicated codec: "+t));n[e.name]=e},e.disposeObject=function(e){i.disposeObject(e)},e.export=function(e,t){i.setInterface(e,t)},e.onLoad=function(e){e=a(e),o?e():c.push(e)},e.dispose=function(e){i.disconnect()},"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?(self.api=e,self.postMessage({type:"imjoy_remote_api_ready"})):window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready",{detail:e}))}));let o=!1;const c=[],s=function(){if(!o){let e;for(o=!0;e=c.pop();)e()}},a=function(e){const t=typeof e;if("function"!==t){throw new Error("A function may only be subsribed to the event, "+t+" was provided instead")}return e};return i}},function(e){e.exports=JSON.parse('{"a":"0.2.26"}')},function(e,t,n){e.exports=function(){return n(8)('!function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=3)}([function(e,t,r){"use strict";function n(){return Math.random().toString(36).substr(2,10)+(new Date).getTime()}r.d(t,"c",(function(){return n})),r.d(t,"b",(function(){return i})),r.d(t,"d",(function(){return o})),r.d(t,"a",(function(){return s}));const i={int8:"Int8Array",int16:"Int16Array",int32:"Int32Array",uint8:"Uint8Array",uint16:"Uint16Array",uint32:"Uint32Array",float32:"Float32Array",float64:"Float64Array",array:"Array"},o={Int8Array:"int8",Int16Array:"int16",Int32Array:"int32",Uint8Array:"uint8",Uint16Array:"uint16",Uint32Array:"uint32",Float32Array:"float32",Float64Array:"float64",Array:"array"};class s{constructor(e){this._event_handlers={},this._once_handlers={},this._debug=e}emit(){throw new Error("emit is not implemented")}on(e,t){this._event_handlers[e]||(this._event_handlers[e]=[]),this._event_handlers[e].push(t)}once(e,t){t.___event_run_once=!0,this.on(e,t)}off(e,t){if(e||t){if(e&&!t)this._event_handlers[e]&&(this._event_handlers[e]=[]);else if(this._event_handlers[e]){const r=this._event_handlers[e].indexOf(t);r>=0&&this._event_handlers[e].splice(r,1)}}else this._event_handlers={}}_fire(e,t){if(this._event_handlers[e])for(var r=this._event_handlers[e].length;r--;){const n=this._event_handlers[e][r];try{n(t)}catch(e){console.error(e)}finally{n.___event_run_once&&this._event_handlers[e].splice(r,1)}}else this._debug&&console.warn("unhandled event",e,t)}}},function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return API_VERSION})),__webpack_require__.d(__webpack_exports__,"b",(function(){return RPC}));var _utils_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(0);const API_VERSION="0.2.3",ArrayBufferView=Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array)).constructor;function _appendBuffer(e,t){const r=new Uint8Array(e.byteLength+t.byteLength);return r.set(new Uint8Array(e),0),r.set(new Uint8Array(t),e.byteLength),r.buffer}function indexObject(e,t){if(!t)throw new Error("undefined index");return"string"==typeof t?indexObject(e,t.split(".")):0===t.length?e:indexObject(e[t[0]],t.slice(1))}class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.a{constructor(e,t,r){super(t&&t.debug),this._connection=e,this.config=t||{},this._codecs=r||{},this._object_store={},this._method_weakmap=new WeakMap,this._object_weakmap=new WeakMap,this._local_api=null;const n=this.config.name;this._connection.execute=this._connection.execute||function(){throw new Error(`connection.execute not implemented (in "${n}")`)},this._store=new ReferenceStore,this._method_refs=new ReferenceStore,this._method_refs.onReady(()=>{this._fire("remoteIdle")}),this._method_refs.onBusy(()=>{this._fire("remoteBusy")}),this._setupMessageHanlders()}init(){this._connection.emit({type:"initialized",config:this.config,peer_id:this._connection.peer_id})}getRemoteCallStack(){return this._method_refs.getStack()}getRemote(){return this._remote_interface}setInterface(e,t){if(t=t||{},this.config.name=t.name||this.config.name,this.config.description=t.description||this.config.description,this.config.forwarding_functions)for(let t of this.config.forwarding_functions){const r=this._remote_interface;r[t]&&(e.constructor===Object?e[t]||(e[t]=(...e)=>{r[t](...e)}):e.constructor.constructor===Function&&(e.constructor.prototype[t]||(e.constructor.prototype[t]=(...e)=>{r[t](...e)})))}this._local_api=e,this._fire("interfaceAvailable")}sendInterface(){if(!this._local_api)throw new Error("interface is not set.");this._encode(this._local_api,!0).then(e=>{this._connection.emit({type:"setInterface",api:e})})}_disposeObject(e){if(!this._object_store[e])throw new Error(`Object (id=${e}) not found.`);delete this._object_store[e]}disposeObject(e){return new Promise((t,r)=>{if(!this._object_weakmap.has(e))throw new Error("Invalid object");{const n=this._object_weakmap.get(e);this._connection.once("disposed",e=>{e.error?r(new Error(e.error)):t()}),this._connection.emit({type:"disposeObject",object_id:n})}})}_setupMessageHanlders(){this._connection.on("init",this.init),this._connection.on("execute",e=>{Promise.resolve(this._connection.execute(e.code)).then(()=>{this._connection.emit({type:"executed"})}).catch(e=>{console.error(e),this._connection.emit({type:"executed",error:String(e)})})}),this._connection.on("method",async e=>{let t,r,n,i,o,s;try{e.promise&&([t,r]=await this._unwrap(e.promise,!1));const c=this._object_store[e.object_id];if(n=indexObject(c,e.name),e.name.includes(".")){const t=e.name.split(".");i=indexObject(c,t.slice(0,t.length-1).join("."))}else i=c;o=await this._unwrap(e.args,!0),e.promise?(s=n.apply(i,o),s instanceof Promise||n.constructor&&"AsyncFunction"===n.constructor.name?s.then(t).catch(r):t(s)):n.apply(i,o)}catch(e){console.error(this.config.name,e),r&&r(e)}}),this._connection.on("callback",async e=>{let t,r,n,i,o;try{if(e.promise&&([t,r]=await this._unwrap(e.promise,!1)),e.promise){if(n=this._store.fetch(e.id),i=await this._unwrap(e.args,!0),!n)throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");o=n.apply(null,i),o instanceof Promise||n.constructor&&"AsyncFunction"===n.constructor.name?o.then(t).catch(r):t(o)}else{if(n=this._store.fetch(e.id),i=await this._unwrap(e.args,!0),!n)throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");n.apply(null,i)}}catch(e){console.error(this.config.name,e),r&&r(e)}}),this._connection.on("disposeObject",e=>{try{this._disposeObject(e.object_id),this._connection.emit({type:"disposed"})}catch(e){console.error(e),this._connection.emit({type:"disposed",error:String(e)})}}),this._connection.on("setInterface",e=>{this._setRemoteInterface(e.api)}),this._connection.on("getInterface",()=>{this._fire("getInterface"),this._local_api?this.sendInterface():this.once("interfaceAvailable",()=>{this.sendInterface()})}),this._connection.on("interfaceSetAsRemote",()=>{this._fire("interfaceSetAsRemote")}),this._connection.on("disconnect",()=>{this._fire("beforeDisconnect"),this._connection.disconnect(),this._fire("disconnected")})}requestRemote(){this._connection.emit({type:"getInterface"})}_ndarray(e,t,r){const n=_utils_js__WEBPACK_IMPORTED_MODULE_0__.d[e.constructor.name];if(r&&r!==n)throw"dtype doesn\'t match the type of the array: "+n+" != "+r;return t=t||[e.length],{_rtype:"ndarray",_rvalue:e.buffer,_rshape:t,_rdtype:n}}_setRemoteInterface(e){this._decode(e).then(e=>{this._remote_interface=e,this._fire("remoteReady"),this._reportRemoteSet()})}_genRemoteMethod(e,t,r){const n=this,i=function(){return new Promise(async(i,o)=>{let s=null;try{s=n._method_refs.put(r?r+"/"+t:t);const c=function(){return null!==s&&n._method_refs.fetch(s),i.apply(this,arguments)},a=function(){return null!==s&&n._method_refs.fetch(s),o.apply(this,arguments)},_=await n._wrap([c,a]);c.__promise_pair=_[1]._rvalue,a.__promise_pair=_[0]._rvalue;let f=Array.prototype.slice.call(arguments);f="register"===t||"export"===t||"on"===t?await n._wrap(f,!0):await n._wrap(f);const l=f.__transferables__;l&&delete f.__transferables__,n._connection.emit({type:"method",target_id:e,name:t,object_id:r,args:f,promise:_},l)}catch(e){s&&n._method_refs.fetch(s),o(`Failed to exectue remote method (interface: ${r||n.id}, method: ${t}), error: ${e}`)}})};return i.__remote_method=!0,i}_reportRemoteSet(){this._connection.emit({type:"interfaceSetAsRemote"})}async _encode(e,t,r){const n=typeof e;if("number"===n||"string"===n||"boolean"===n||null==e||e instanceof ArrayBuffer)return e;let i;if("function"==typeof e){if(t){if(!r)throw new Error("objectId is not specified.");i={_rtype:"interface",_rtarget_id:this._connection.peer_id,_rintf:r,_rvalue:t},this._method_weakmap.set(e,i)}else if(this._method_weakmap.has(e))i=this._method_weakmap.get(e);else{const t=this._store.put(e);i={_rtype:"callback",_rtarget_id:this._connection.peer_id,_rname:e.constructor&&e.constructor.name||t,_rvalue:t}}return i}if(e.constructor instanceof Object&&e._rtype){if(e._rintf){const n=e._rtype;delete e._rtype,i=await this._encode(e,t,r),i._rtype=n}else i=e;return i}const o=[],s=e._transfer,c=Array.isArray(e);for(let n of Object.keys(this._codecs)){const o=this._codecs[n];if(o.encoder&&e instanceof o.type){let n=await Promise.resolve(o.encoder(e));if(n&&!n._rtype&&(n._rtype=o.name),n&&n._rintf){const e=n._rtype;delete n._rtype,n=await this._encode(n,t,r),n._rtype=e}return i=n,i}}if("undefined"!=typeof tf&&tf.Tensor&&e instanceof tf.Tensor){const t=e.dataSync();(e._transfer||s)&&(o.push(t.buffer),delete e._transfer),i={_rtype:"ndarray",_rvalue:t.buffer,_rshape:e.shape,_rdtype:e.dtype}}else if("undefined"!=typeof nj&&nj.NdArray&&e instanceof nj.NdArray){const t=_utils_js__WEBPACK_IMPORTED_MODULE_0__.d[e.selection.data.constructor.name];(e._transfer||s)&&(o.push(e.selection.data.buffer),delete e._transfer),i={_rtype:"ndarray",_rvalue:e.selection.data.buffer,_rshape:e.shape,_rdtype:t}}else if(e instanceof Error)console.error(e),i={_rtype:"error",_rvalue:e.toString()};else if("undefined"!=typeof File&&e instanceof File)i={_rtype:"file",_rvalue:e,_rpath:e._path||e.webkitRelativePath};else if(e!==Object(e)||e instanceof Boolean||e instanceof String||e instanceof Date||e instanceof RegExp||e instanceof ImageData||"undefined"!=typeof FileList&&e instanceof FileList)i=e;else if("undefined"!=typeof File&&e instanceof File)i={_rtype:"file",_rname:e.name,_rmime:e.type,_rvalue:e,_rpath:e._path||e.webkitRelativePath};else if(e instanceof Blob)i={_rtype:"blob",_rvalue:e};else if(e instanceof ArrayBufferView){(e._transfer||s)&&(o.push(e.buffer),delete e._transfer);const t=_utils_js__WEBPACK_IMPORTED_MODULE_0__.d[e.constructor.name];i={_rtype:"typedarray",_rvalue:e.buffer,_rdtype:t}}else if(e instanceof DataView)(e._transfer||s)&&(o.push(e.buffer),delete e._transfer),i={_rtype:"memoryview",_rvalue:e.buffer};else if(e instanceof Set)i={_rtype:"set",_rvalue:await this._encode(Array.from(e),t)};else if(e instanceof Map)i={_rtype:"orderedmap",_rvalue:await this._encode(Array.from(e),t)};else if(e.constructor instanceof Object||Array.isArray(e)){let n;if(i=c?[]:{},e.constructor===Object||Array.isArray(e))n=Object.keys(e);else{if(e.constructor===Function)throw new Error("Please instantiate the class before exportting it.");if(e.constructor.constructor!==Function)throw Error("Unsupported interface type");n=Object.getOwnPropertyNames(Object.getPrototypeOf(e)).concat(Object.keys(e)),t=!0}let o=!1;if(e._rintf||t){r||(r=Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__.c)(),this._object_store[r]=e);for(let s of n)"constructor"!==s&&(s.startsWith("_")||(i[s]=await this._encode(e[s],"string"==typeof t?t+"."+s:s,r),"function"==typeof e[s]&&(o=!0)));o&&(i._rintf=r),e.on&&"function"==typeof e.on&&e.on("close",()=>{delete this._object_store[r]})}else for(let t of n)["hasOwnProperty","constructor"].includes(t)||(i[t]=await this._encode(e[t]))}else{if("object"!=typeof e)throw"imjoy-rpc: Unsupported data type:"+e;{const t=Object.getOwnPropertyNames(Object.getPrototypeOf(e)).concat(Object.keys(e)),r=Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__.c)();for(let r of t)["hasOwnProperty","constructor"].includes(r)||(i[r]=await this._encode(e[r],r,i));i._rintf=r}}if(o.length>0&&(i.__transferables__=o),!i)throw new Error("Failed to encode object");return i}async _decode(aObject,withPromise){if(!aObject)return aObject;let bObject;if(aObject._rtype)if(this._codecs[aObject._rtype]&&this._codecs[aObject._rtype].decoder){if(aObject._rintf){const e=aObject._rtype;delete aObject._rtype,aObject=await this._decode(aObject,withPromise),aObject._rtype=e}bObject=await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject))}else if("callback"===aObject._rtype)bObject=this._genRemoteCallback(aObject._rtarget_id,aObject._rvalue,withPromise);else if("interface"===aObject._rtype)bObject=this._genRemoteMethod(aObject._rtarget_id,aObject._rvalue,aObject._rintf);else if("ndarray"===aObject._rtype)if("undefined"!=typeof nj&&nj.array)Array.isArray(aObject._rvalue)&&(aObject._rvalue=aObject._rvalue.reduce(_appendBuffer)),bObject=nj.array(new Uint8(aObject._rvalue),aObject._rdtype).reshape(aObject._rshape);else if("undefined"!=typeof tf&&tf.Tensor){Array.isArray(aObject._rvalue)&&(aObject._rvalue=aObject._rvalue.reduce(_appendBuffer));const arraytype=eval(_utils_js__WEBPACK_IMPORTED_MODULE_0__.b[aObject._rdtype]);bObject=tf.tensor(new arraytype(aObject._rvalue),aObject._rshape,aObject._rdtype)}else bObject=aObject;else if("error"===aObject._rtype)bObject=new Error(aObject._rvalue);else if("file"===aObject._rtype)aObject._rvalue instanceof File?(bObject=aObject._rvalue,bObject._path=aObject._rpath):(bObject=new File([aObject._rvalue],aObject._rname,{type:aObject._rmime}),bObject._path=aObject._rpath);else if("typedarray"===aObject._rtype){const arraytype=eval(_utils_js__WEBPACK_IMPORTED_MODULE_0__.b[aObject._rdtype]);if(!arraytype)throw new Error("unsupported dtype: "+aObject._rdtype);bObject=new arraytype(aObject._rvalue)}else if("memoryview"===aObject._rtype)bObject=new DataView(aObject._rvalue);else if("blob"===aObject._rtype)bObject=aObject._rvalue instanceof Blob?aObject._rvalue:new Blob([aObject._rvalue],{type:aObject._rmime});else if("orderedmap"===aObject._rtype)bObject=new Map(await this._decode(aObject._rvalue,withPromise));else if("set"===aObject._rtype)bObject=new Set(await this._decode(aObject._rvalue,withPromise));else if(aObject._rintf){const e=aObject._rtype;delete aObject._rtype,bObject=await this._decode(aObject,withPromise),bObject._rtype=e}else bObject=aObject;else if(aObject.constructor===Object||Array.isArray(aObject)){const e=Array.isArray(aObject);bObject=e?[]:{};for(let t of Object.keys(aObject))if(e||aObject.hasOwnProperty(t)){const e=aObject[t];bObject[t]=await this._decode(e,withPromise)}}else bObject=aObject;if(void 0===bObject)throw new Error("Failed to decode object");return aObject._rintf&&this._object_weakmap.set(bObject,aObject._rintf),bObject}async _wrap(e,t){return await this._encode(e,t)}async _unwrap(e,t){return await this._decode(e,t)}_genRemoteCallback(e,t,r){const n=this;let i;return r?(i=function(){return new Promise(async(r,i)=>{const o=await n._wrap(Array.prototype.slice.call(arguments)),s=o.__transferables__;s&&delete o.__transferables__;const c=await n._wrap([r,i]);r.__promise_pair=c[1]._rvalue,i.__promise_pair=c[0]._rvalue;try{n._connection.emit({type:"callback",target_id:e,id:t,args:o,promise:c},s)}catch(e){i(`Failed to exectue remote callback ( id: ${t}).`)}})},i):(i=async function(){const r=await n._wrap(Array.prototype.slice.call(arguments)),i=r.__transferables__;return i&&delete r.__transferables__,n._connection.emit({type:"callback",target_id:e,id:t,args:r},i)},i)}disconnect(){this._connection.emit({type:"disconnect"}),setTimeout(()=>{this._connection.disconnect()},2e3)}}class ReferenceStore{constructor(){this._store={},this._indices=[0],this._readyHandler=function(){},this._busyHandler=function(){},this._readyHandler()}onReady(e){this._readyHandler=e||function(){}}onBusy(e){this._busyHandler=e||function(){}}getStack(){return Object.keys(this._store).length}_genId(){let e;return e=1===this._indices.length?this._indices[0]++:this._indices.shift(),e}_releaseId(e){for(let t=0;t<this._indices.length;t++)if(e<this._indices[t]){this._indices.splice(t,0,e);break}for(let e=this._indices.length-1;e>=0&&this._indices[e]-1===this._indices[e-1];e--)this._indices.pop()}put(e){this._busyHandler&&0===Object.keys(this._store).length&&this._busyHandler();const t=this._genId();return this._store[t]=e,t}fetch(e){const t=this._store[e];return t&&!t.__remote_method&&(delete this._store[e],this._releaseId(e),this._readyHandler&&0===Object.keys(this._store).length&&this._readyHandler()),t&&t.__promise_pair&&this.fetch(t.__promise_pair),t}}},function(e,t,r){"use strict";r.d(t,"a",(function(){return i}));var n=r(1);function i(e,t){t=t||{};const r={},i=new n.b(e,t,r);i.on("getInterface",(function(){c()})),i.on("remoteReady",(function(){const e=i.getRemote()||{};if(e.export)throw new Error("`export` is a reserved function name");if(e.onload)throw new Error("`onload` is a reserved function name");if(e.dispose)throw new Error("`dispose` is a reserved function name");e.registerCodec=function(e){if(!e.name||!e.encoder&&!e.decoder)throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");if(e.type)for(let t of Object.keys(r))r[t].type!==e.type&&t!==e.name||(delete r[t],console.warn("Remove duplicated codec: "+t));r[e.name]=e},e.disposeObject=function(e){i.disposeObject(e)},e.export=function(e,t){i.setInterface(e,t)},e.onLoad=function(e){e=a(e),o?e():s.push(e)},e.dispose=function(e){i.disconnect()},"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?(self.api=e,self.postMessage({type:"imjoy_remote_api_ready"})):window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready",{detail:e}))}));let o=!1;const s=[],c=function(){if(!o){let e;for(o=!0;e=s.pop();)e()}},a=function(e){const t=typeof e;if("function"!==t){throw new Error("A function may only be subsribed to the event, "+t+" was provided instead")}return e};return i}},function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(2),_rpc_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(1),_utils_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(0);!function(){if(!("undefined"!=typeof WorkerGlobalScope&&self&&self instanceof WorkerGlobalScope))throw new Error("This script can only loaded in a webworker");class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__.a{constructor(e){super(e&&e.debug),this.config=e||{}}connect(){self.addEventListener("message",e=>{this._fire(e.data.type,e.data)}),this.emit({type:"initialized",config:this.config})}disconnect(){this._fire("beforeDisconnect"),self.close(),this._fire("disconnected")}emit(e){let t=void 0;e.__transferables__&&(t=e.__transferables__,delete e.__transferables__),self.postMessage(e,t)}async execute(code){if("requirements"===code.type)try{if(code.requirements&&(Array.isArray(code.requirements)||"string"==typeof code.requirements))try{Array.isArray(code.requirements)||(code.requirements=[code.requirements]);for(var i=0;i<code.requirements.length;i++){if(code.requirements[i].toLowerCase().endsWith(".css")||code.requirements[i].startsWith("css:"))throw"unable to import css in a webworker";code.requirements[i].toLowerCase().endsWith(".js")||code.requirements[i].startsWith("js:")?(code.requirements[i].startsWith("js:")&&(code.requirements[i]=code.requirements[i].slice(3)),importScripts(code.requirements[i])):code.requirements[i].startsWith("http")?importScripts(code.requirements[i]):code.requirements[i].startsWith("cache:")||console.log("Unprocessed requirements url: "+code.requirements[i])}}catch(e){throw"failed to import required scripts: "+code.requirements.toString()}}catch(e){throw e}else{if("script"!==code.type)throw"unsupported code type.";try{if(code.requirements&&(Array.isArray(code.requirements)||"string"==typeof code.requirements))try{if(Array.isArray(code.requirements))for(let e=0;e<code.requirements.length;e++)importScripts(code.requirements[e]);else importScripts(code.requirements)}catch(e){throw"failed to import required scripts: "+code.requirements.toString()}eval(code.content)}catch(e){throw console.error(e.message,e.stack),e}}"requirements"===code.type&&self.postMessage({type:"cacheRequirements",requirements:code.requirements})}}const config={type:"web-worker",dedicated_thread:!0,allow_execution:!0,lang:"javascript",api_version:_rpc_js__WEBPACK_IMPORTED_MODULE_1__.a},conn=new Connection(config);conn.on("connectRPC",e=>{Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__.a)(conn,Object.assign(e.config,config))}),conn.connect(),self.postMessage({type:"worker-ready"})}()}]);\n//# sourceMappingURL=plugin.webworker.js.map',null)}},function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return setupWebPython}));var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(3),_rpc_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(1),_pluginIframe__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(2);function _htmlToElement(e){var t=document.createElement("template");return e=e.trim(),t.innerHTML=e,t.content.firstChild}const _importScript=function(e){return new Promise((t,n)=>{var r=document.createElement("script");r.src=e,r.onload=t,r.onreadystatechange=function(){"loaded"!==this.readyState&&"complete"!==this.readyState||t()},r.onerror=n,document.head.appendChild(r)})};async function importScripts(){for(var e=Array.prototype.slice.call(arguments),t=e.length,n=0;n<t;n++)await _importScript(e[n])}window.TimeoutPromise=function(e){return new Promise((function(t,n){window.setTimeout((function(){t(e)}),e)}))},window.RequestAnimationFramePromise=function(){return new Promise((function(e,t){window.requestAnimationFrame((function(t){e(t)}))}))};const startup_script='\nfrom js import RequestAnimationFramePromise\nfrom functools import partial \nfrom inspect import isawaitable\n\nclass PromiseException(RuntimeError):\n    pass\n\nclass WebLoop:\n    def __init__(self):\n        self.coros = []\n\n    def call_soon(self, coro, resolve=None, reject=None):\n        self.step(coro, resolve, reject)\n\n    def step(self, coro, resolve, reject, arg=None):\n        try:\n            x = coro.send(arg) \n            x = x.then(partial(self.step, coro, resolve, reject))\n            x.catch(partial(self.fail,coro, resolve, reject))\n        except StopIteration as result:\n            if callable(resolve):\n                resolve(result.value)\n        except Exception as e:\n            if callable(reject):\n                reject(e)\n\n    def fail(self, coro, resolve, reject, arg=None):\n        try:\n            if callable(reject):\n                reject(PromiseException(arg))\n                return\n            coro.throw(PromiseException(arg))\n        except StopIteration:\n            pass\n    \n    def request_animation_frame(self):\n        if not hasattr(self, "raf_event"):\n            self.raf_event = RAFEvent()\n        return self.raf_event\n\n\nclass RAFEvent:\n    def __init__(self):\n        self.awaiters = []\n        self.promise = None\n    def __await__(self):\n        if self.promise is None:\n            self.promise = RequestAnimationFramePromise()\n        x = yield self.promise\n        self.promise = None\n        return x\n',init_imjoy_script='\nfrom js import api, Object\nimport sys\nfrom functools import partial \nfrom types import ModuleType\nimport copy\n\ntry:\n    import numpy as np\n    NUMPY = np\nexcept:\n    NUMPY = False\nimport io\nfrom collections import OrderedDict\n\n_codecs = {}\n_object_store = {}\ndef _encode(a_object, as_interface=False, object_id=None):\n    """Encode object."""\n    if isinstance(a_object, (int, float, bool, str, bytes)) or a_object is None:\n        return a_object\n\n    if callable(a_object):\n        return a_object\n\n    if isinstance(a_object, tuple):\n        a_object = list(a_object)\n\n    if isinstance(a_object, dotdict):\n        a_object = dict(a_object)\n\n    # skip if already encoded\n    if isinstance(a_object, dict) and "_rtype" in a_object:\n        # make sure the interface functions are encoded\n        if "_rintf" in a_object:\n            temp = a_object["_rtype"]\n            del a_object["_rtype"]\n            b_object = _encode(a_object, as_interface, object_id)\n            b_object._rtype = temp\n        else:\n            b_object = a_object\n        return b_object\n\n    isarray = isinstance(a_object, list)\n    b_object = None\n\n    encoded_obj = None\n    for tp in _codecs:\n        codec = _codecs[tp]\n        if codec.encoder and isinstance(a_object, codec.type):\n            # TODO: what if multiple encoders found\n            encoded_obj = codec.encoder(a_object)\n            if isinstance(encoded_obj, dict) and "_rtype" not in encoded_obj:\n                encoded_obj["_rtype"] = codec.name\n            # encode the functions in the interface object\n            if isinstance(encoded_obj, dict) and "_rintf" in encoded_obj:\n                temp = encoded_obj["_rtype"]\n                del encoded_obj["_rtype"]\n                encoded_obj = _encode(encoded_obj, True)\n                encoded_obj["_rtype"] = temp\n            b_object = encoded_obj\n            return b_object\n\n    if NUMPY and isinstance(a_object, (NUMPY.ndarray, NUMPY.generic)):\n        v_bytes = a_object.tobytes()\n        b_object = {\n            "_rtype": "ndarray",\n            "_rvalue": v_bytes,\n            "_rshape": a_object.shape,\n            "_rdtype": str(a_object.dtype),\n        }\n\n    elif isinstance(a_object, Exception):\n        b_object = {"_rtype": "error", "_rvalue": str(a_object)}\n    elif isinstance(a_object, memoryview):\n        b_object = {"_rtype": "memoryview", "_rvalue": a_object.tobytes()}\n    elif isinstance(\n        a_object, (io.IOBase, io.TextIOBase, io.BufferedIOBase, io.RawIOBase)\n    ):\n        b_object = {\n            "_rtype": "blob",\n            "_rvalue": a_object.read(),\n            "_rmime": "application/octet-stream",\n        }\n    # NOTE: "typedarray" is not used\n    elif isinstance(a_object, OrderedDict):\n        b_object = {\n            "_rtype": "orderedmap",\n            "_rvalue": _encode(list(a_object), as_interface),\n        }\n    elif isinstance(a_object, set):\n        b_object = {\n            "_rtype": "set",\n            "_rvalue": _encode(list(a_object), as_interface),\n        }\n    elif hasattr(a_object, "_rintf") and a_object._rintf == True:\n        b_object = _encode(a_object, True)\n    elif isinstance(a_object, (list, dict)) or inspect.isclass(type(a_object)):\n        b_object = [] if isarray else {}\n        if not isinstance(a_object, (list, dict)) and inspect.isclass(\n            type(a_object)\n        ):\n            a_object_norm = {\n                a: getattr(a_object, a)\n                for a in dir(a_object)\n                if not a.startswith("_")\n            }\n            # always encode class instance as interface\n            as_interface = True\n        else:\n            a_object_norm = a_object\n\n        keys = range(len(a_object_norm)) if isarray else a_object_norm.keys()\n        # encode interfaces\n        if (not isarray and a_object_norm.get("_rintf")) or as_interface:\n            if object_id is None:\n                object_id = str(uuid.uuid4())\n                _object_store[object_id] = a_object\n\n            has_function = False\n            for key in keys:\n                if isinstance(key, str) and key.startswith("_"):\n                    continue\n                encoded = _encode(\n                    a_object_norm[key],\n                    as_interface + "." + str(key)\n                    if isinstance(as_interface, str)\n                    else key,\n                    object_id,\n                )\n                if callable(a_object_norm[key]):\n                    has_function = True\n                if isarray:\n                    b_object.append(encoded)\n                else:\n                    b_object[key] = encoded\n            # TODO: how to despose list object? create a wrapper for list?\n            if not isarray and has_function:\n                b_object["_rintf"] = object_id\n            # remove interface when closed\n            if "on" in a_object_norm and callable(a_object_norm["on"]):\n\n                def remove_interface():\n                    del _object_store[object_id]\n\n                a_object_norm["on"]("close", remove_interface)\n        else:\n            for key in keys:\n                if isarray:\n                    b_object.append(_encode(a_object_norm[key]))\n                else:\n                    b_object[key] = _encode(a_object_norm[key])\n    else:\n        raise Exception("imjoy-rpc: Unsupported data type:" + str(aObject))\n    return b_object\n\ndef _decode(a_object, with_promise=False):\n    """Decode object."""\n    if a_object is None:\n        return a_object\n    if isinstance(a_object, dict) and "_rtype" in a_object:\n        b_object = None\n        if (\n            _codecs.get(a_object["_rtype"])\n            and _codecs[a_object["_rtype"]].decoder\n        ):\n            if "_rintf" in a_object:\n                temp = a_object["_rtype"]\n                del a_object["_rtype"]\n                a_object = _decode(a_object, with_promise)\n                a_object["_rtype"] = temp\n            b_object = _codecs[a_object["_rtype"]].decoder(a_object)\n        elif a_object["_rtype"] == "callback":\n            raise Exception("Unsupported object decoding: callback")\n        elif a_object["_rtype"] == "interface":\n            raise Exception("Unsupported object decoding: interface")\n        elif a_object["_rtype"] == "ndarray":\n            # create build array/tensor if used in the plugin\n            try:\n                if isinstance(a_object["_rvalue"], (list, tuple)):\n                    a_object["_rvalue"] = reduce(\n                        (lambda x, y: x + y), a_object["_rvalue"]\n                    )\n                elif not isinstance(a_object["_rvalue"], bytes):\n                    raise Exception(\n                        "Unsupported data type: " + str(type(a_object["_rvalue"]))\n                    )\n                if NUMPY:\n                    b_object = NUMPY.frombuffer(\n                        a_object["_rvalue"], dtype=a_object["_rdtype"]\n                    ).reshape(tuple(a_object["_rshape"]))\n\n                else:\n                    b_object = a_object\n                    logger.warn("numpy is not available, failed to decode ndarray")\n\n            except Exception as exc:\n                logger.debug("Error in converting: %s", exc)\n                b_object = a_object\n                raise exc\n        elif a_object["_rtype"] == "memoryview":\n            b_object = memoryview(a_object["_rvalue"])\n        elif a_object["_rtype"] == "blob":\n            if isinstance(a_object["_rvalue"], str):\n                b_object = io.StringIO(a_object["_rvalue"])\n            elif isinstance(a_object["_rvalue"], bytes):\n                b_object = io.BytesIO(a_object["_rvalue"])\n            else:\n                raise Exception(\n                    "Unsupported blob value type: " + str(type(a_object["_rvalue"]))\n                )\n        elif a_object["_rtype"] == "typedarray":\n            if NUMPY:\n                b_object = NUMPY.frombuffer(\n                    a_object["_rvalue"], dtype=a_object["_rdtype"]\n                )\n            else:\n                b_object = a_object["_rvalue"]\n        elif a_object["_rtype"] == "orderedmap":\n            b_object = OrderedDict(_decode(a_object["_rvalue"], with_promise))\n        elif a_object["_rtype"] == "set":\n            b_object = set(_decode(a_object["_rvalue"], with_promise))\n        elif a_object["_rtype"] == "error":\n            b_object = Exception(a_object["_rvalue"])\n        else:\n            # make sure all the interface functions are decoded\n            if "_rintf" in a_object:\n                temp = a_object["_rtype"]\n                del a_object["_rtype"]\n                a_object = _decode(a_object, with_promise)\n                a_object["_rtype"] = temp\n            b_object = a_object\n    elif isinstance(a_object, (dict, list, tuple)):\n        if isinstance(a_object, tuple):\n            a_object = list(a_object)\n        isarray = isinstance(a_object, list)\n        b_object = [] if isarray else dotdict()\n        keys = range(len(a_object)) if isarray else a_object.keys()\n        for key in keys:\n            val = a_object[key]\n            if isarray:\n                b_object.append(_decode(val, with_promise))\n            else:\n                b_object[key] = _decode(val, with_promise)\n    else:\n        b_object = a_object\n\n    # object id, used for dispose the object\n    if isinstance(a_object, dict) and a_object.get("_rintf"):\n        # make the dict hashable\n        if isinstance(b_object, dict) and not isinstance(b_object, dotdict):\n            b_object = dotdict(b_object)\n        # _object_weakmap[b_object] = a_object.get("_rintf")\n    return b_object\n\n\nclass dotdict(dict):  # pylint: disable=invalid-name\n    """Access dictionary attributes with dot.notation."""\n\n    __getattr__ = dict.get\n    __setattr__ = dict.__setitem__\n    __delattr__ = dict.__delitem__\n\n    def __hash__(self):\n        # TODO: is there any performance impact?\n        return hash(tuple(sorted(self.items())))\n\n    def __deepcopy__(self, memo=None):\n        """Make a deep copy."""\n        return dotdict(copy.deepcopy(dict(self), memo=memo))\n\n\nclass WrappedPromise:\n    def __init__(self, promise):\n        self.promise = promise\n        try:\n            self.then = promise.then\n            self.catch = promise.catch\n            self.finally_ = promise.finally_\n        except:\n            self.then = lambda f: f(None)\n            self.catch = lambda f: f(None)\n            self.finally_ = lambda f: f(None)\n\n    def __await__(self):\n        x = yield self.promise\n        return x\n\nwrapped_api = dotdict()\nfor k in Object.keys(api):\n    func = getattr(api, k)\n    if callable(func) and k not in [\'export\', \'registerCodec\']:\n        def remote_method(func, *args, **kwargs):\n            args = list(args)\n            # wrap keywords to a dictionary and pass to the last argument\n            if kwargs:\n                args = args + [kwargs]\n            args = _encode(args)\n            return WrappedPromise(func(*args))\n        # this has to be partial, otherwise it crashes\n        wrapped_api[k] = partial(remote_method, func)\n    else:\n        wrapped_api[k] = func\n\ndef unwrap_func_args(func):\n    def wrapped_function(*args):\n        return func(*_decode(args))\n    return wrapped_function\n    \nm = ModuleType("imjoy")\nsys.modules[m.__name__] = m\nm.__file__ = m.__name__ + ".py"\nm.api = wrapped_api\n';let _export_plugin_api=null;const execute_python_code=function(e){try{_export_plugin_api||(_export_plugin_api=window.api.export,window.api.export=function(e){window.pyodide.runPython(startup_script);const t=window.pyodide.pyimport("WebLoop"),n=window.pyodide.pyimport("isawaitable"),r=window.pyodide.pyimport("unwrap_func_args"),i=window.pyodide.pyimport("callable"),o=t();if("object"==typeof e){const t={};for(let c in e)if(!c.startsWith("_")&&i(e[c])){const i=r(e[c]);t[c]=function(){return new Promise((e,t)=>{try{const r=i(...Array.prototype.slice.call(arguments));n(r)?o.call_soon(r,e,t):e(r)}catch(e){t(e)}})}}_export_plugin_api(t)}else{if("function"!=typeof e)throw"unsupported api export";{const t={},c=window.pyodide.pyimport("getattr"),s=window.pyodide.pyimport("hasattr");for(let a of Object.getOwnPropertyNames(e))if(!a.startsWith("_")&&s(e,a)&&i(c(e,a))){const i=r(c(e,a));t[a]=function(){return new Promise((e,t)=>{try{const r=i(...Array.prototype.slice.call(arguments));n(r)?o.call_soon(r,e,t):e(r)}catch(e){t(e)}})}}_export_plugin_api(t)}}}),window.pyodide.runPython(init_imjoy_script),window.pyodide.runPython(e.content)}catch(e){throw e}};function setupPyodide(){return new Promise((e,t)=>{window.languagePluginUrl="https://static.imjoy.io/pyodide/",importScripts("https://static.imjoy.io/pyodide/pyodide.js").then(()=>{window.iodide={output:{element:function(e){const t=document.createElement(e);return(document.getElementById("output")||document.body).appendChild(t),t}}},window.languagePluginLoader.then(()=>{console.log(window.pyodide.runPython("import sys\nsys.version")),e()}).catch(t)})})}class Connection extends _pluginIframe__WEBPACK_IMPORTED_MODULE_2__.a{constructor(e){super(e)}async execute(code){if("requirements"===code.type){if(code.requirements){if(code.requirements="string"==typeof code.requirements?[code.requirements]:code.requirements,!Array.isArray(code.requirements))throw"unsupported requirements definition";{const e=[];for(var i=0;i<code.requirements.length;i++)code.requirements[i].toLowerCase().endsWith(".css")||code.requirements[i].startsWith("css:")?(code.requirements[i].startsWith("css:")&&(code.requirements[i]=code.requirements[i].slice(4)),link_node=document.createElement("link"),link_node.rel="stylesheet",link_node.href=code.requirements[i],document.head.appendChild(link_node)):code.requirements[i].startsWith("js:")?(code.requirements[i].startsWith("js:")&&(code.requirements[i]=code.requirements[i].slice(3)),await importScripts(code.requirements[i])):code.requirements[i].startsWith("cache:")||(code.requirements[i].toLowerCase().endsWith(".js")||code.requirements[i].startsWith("package:")?(code.requirements[i].startsWith("package:")&&(code.requirements[i]=code.requirements[i].slice(8)),e.push(code.requirements[i])):code.requirements[i].startsWith("http:")||code.requirements[i].startsWith("https:")?console.log("Unprocessed requirements url: "+code.requirements[i]):e.push(code.requirements[i]));await window.pyodide.loadPackage(e)}}}else if("script"===code.type)if(code.src){var script_node=document.createElement("script");script_node.setAttribute("type",code.attrs.type),script_node.setAttribute("src",code.src),document.head.appendChild(script_node)}else if(code.content&&"python"===code.lang)execute_python_code(code);else if(code.content&&"javascript"===code.lang)try{eval(code.content)}catch(e){throw console.error(e.message,e.stack),e}else{const e=document.createElement("script");e.setAttribute("type",code.attrs.type),e.appendChild(document.createTextNode(code.content)),document.body.appendChild(e)}else if("style"===code.type){const e=document.createElement("style");code.src&&(e.src=code.src),e.innerHTML=code.content,document.head.appendChild(e)}else if("link"===code.type){const e=document.createElement("link");code.rel&&(e.rel=code.rel),code.href&&(e.href=code.href),code.attrs&&code.attrs.type&&(e.type=code.attrs.type),document.head.appendChild(e)}else{if("html"!==code.type)throw"unsupported code type.";document.body.appendChild(_htmlToElement(code.content))}}}function setupWebPython(e){(e=e||{}).debug=!0,e.dedicated_thread=!1,e.lang="python",e.api_version=_rpc_js__WEBPACK_IMPORTED_MODULE_1__.a;const t=new Connection(e);setupPyodide().then(()=>{Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__.a)(t,e),t.connect()})}},function(e,t,n){"use strict";n.r(t),n.d(t,"waitForInitialization",(function(){return l})),n.d(t,"setupRPC",(function(){return p}));var r=n(5),i=n.n(r),o=n(2),c=n(6),s=n(0),a=n(1);n.d(t,"RPC",(function(){return a.b})),n.d(t,"API_VERSION",(function(){return a.a}));var _=n(4);function d(){try{return window.self!==window.top}catch(e){return!0}}function l(e){if(!d())throw new Error("waitForInitialization (imjoy-rpc) should only run inside an iframe.");const t=(e=e||{}).target_origin||"*";if(e.credential_required&&"function"!=typeof e.verify_credential)throw new Error("Please also provide the `verify_credential` function with `credential_required`.");if(e.credential_required&&"*"===t)throw new Error("`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.");const n=Object(s.c)(),r=i=>{if("message"===i.type&&("*"===t||i.origin===t)){if("initialize"!==i.data.type)throw new Error(`unrecognized message: ${i.data}`);{window.removeEventListener("message",r),i.data.peer_id!==n&&console.warn(`${i.data.config&&i.data.config.name}: connection peer id mismatch ${i.data.peer_id} !== ${n}`);const o=i.data.config;"*"!==t&&(o.target_origin=t),e.credential_required?e.verify_credential(o.credential).then(e=>{if(!e||!e.auth||e.error)throw new Error("Failed to verify the credentail:"+(e&&e.error));o.auth=e.auth,p(o).then(()=>{console.log("ImJoy RPC loaded successfully!")})}):p(o).then(()=>{console.log("ImJoy RPC loaded successfully!")})}}};window.addEventListener("message",r),parent.postMessage({type:"imjoyRPCReady",config:e,peer_id:n},"*")}function p(e){if(!(e=e||{}).name)throw new Error("Please specify a name for your app.");return e.version=e.version||"0.1.0",e.description=e.description||`[TODO: add description for ${e.name} ]`,e.type=e.type||"rpc-window",e.id=e.id||Object(s.c)(),e.allow_execution=e.allow_execution||!1,e.enable_service_worker&&Object(s.d)(e.base_url,e.target_origin,e.cache_requirements),e.cache_requirements&&delete e.cache_requirements,e=Object.keys(e).reduce((t,n)=>("function"!=typeof e[n]&&(t[n]=e[n]),t),{}),new Promise((t,n)=>{if(d()){if("web-worker"===e.type)try{!function(e){if(!e.allow_execution)throw new Error("web-worker plugin can only work with allow_execution=true");const t=new i.a,n=setTimeout((function(){t.terminate(),console.warn("Plugin failed to start as a web-worker, running in an iframe instead."),Object(o.b)(e)}),2e3),r=Object(s.c)();t.addEventListener("message",(function(i){let o=void 0;const c=i.data;if("worker-ready"===c.type)return t.postMessage({type:"connectRPC",config:e}),void clearTimeout(n);"initialized"===c.type?(c.config=Object.assign({},e,c.config),c.origin=window.location.origin,c.peer_id=r):"imjoy_remote_api_ready"===c.type?window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready",{detail:null})):"cacheRequirements"===c.type&&"function"==typeof cache_requirements?cache_requirements(c.requirements):"disconnect"===c.type?t.terminate():c.__transferables__&&(o=c.__transferables__,delete c.__transferables__),parent.postMessage(c,e.target_origin||"*",o)})),window.addEventListener("message",(function(n){let i=void 0;const o=n.data;o.__transferables__&&(i=o.__transferables__,delete o.__transferables__),o.peer_id===r?t.postMessage(o,i):e.debug&&console.log(`connection peer id mismatch ${o.peer_id} !== ${r}`)}))}(e)}catch(t){Object(o.b)(e)}else"web-python"===e.type||"web-python-window"===e.type?Object(c.a)(e):["rpc-window","rpc-worker","iframe","window"].includes(e.type)?Object(o.b)(e):(console.error("Unsupported plugin type: "+e.type),n("Unsupported plugin type: "+e.type));try{const n=r=>{const i=r.detail;e.expose_api_globally&&(window.api=i),t(i),window.removeEventListener("imjoy_remote_api_ready",n)};window.addEventListener("imjoy_remote_api_ready",n)}catch(e){n(e)}}else n(new Error("imjoy-rpc should only run inside an iframe."))})}n.d(t,"VERSION",(function(){return _.a}))},function(e,t,n){"use strict";var r=window.URL||window.webkitURL;e.exports=function(e,t){try{try{var n;try{(n=new(window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder)).append(e),n=n.getBlob()}catch(t){n=new Blob([e])}return new Worker(r.createObjectURL(n))}catch(t){return new Worker("data:application/javascript,"+encodeURIComponent(e))}}catch(e){if(!t)throw Error("Inline worker is not supported");return new Worker(t)}}}])}));
//# sourceMappingURL=imjoy-rpc.min.js.map