{"version":3,"sources":["webpack://imjoyRPC/webpack/bootstrap","webpack://imjoyRPC/./src/utils.js","webpack://imjoyRPC/./src/rpc.js","webpack://imjoyRPC/./src/pluginCore.js","webpack://imjoyRPC/./src/plugin.webworker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","randId","Math","random","toString","substr","typedArrayToDtype","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Array","API_VERSION","ArrayBufferView","getPrototypeOf","constructor","_appendBuffer","buffer1","buffer2","tmp","byteLength","set","buffer","RPC","connection","config","this","_connection","_interface","_plugin_interfaces","_remote","_remoteUpdateHandler","_getInterfaceHandler","_interfaceSetAsRemoteHandler","_disconnectHandler","_store","ReferenceStore","_method_refs","me","onMessage","data","_processMessage","onRemoteUpdate","handler","onRemoteReady","onReady","onRemoteBusy","onBusy","getRemoteCallStack","getStack","onGetInterface","getRemote","setInterface","forwarding_functions","func_name","args","Function","sendInterface","Promise","resolve","names","Error","keys","startsWith","push","type","data2","k","functions","getOwnPropertyNames","concat","length","name_","send","api","reject","method","result","_method_context","__this__","pid","promise","_unwrap","console","error","indexOf","split","apply","then","catch","e","fetch","num","_setRemote","disconnect","requestRemote","_ndarray","typedArray","shape","dtype","_dtype","__jailed_type__","__value__","__shape__","__dtype__","_genRemoteMethod","_reportRemoteSet","plugin_id","remoteMethod","id","put","wrapped_resolve","arguments","wrapped_reject","__jailed_pairs__","slice","transferables","_wrap","__transferables__","__remote_method","_encode_interface","aObject","bObject","v","encoded_interface","__plugin_id__","isArray","on","_encode","as_interface","_transfer","isarray","__as_interface__","_rpcEncode","encoded_obj","__rpc_dtype__","interfaceFuncName","tf","Tensor","v_buffer","dataSync","nj","NdArray","selection","File","__relative_path__","relativePath","webkitRelativePath","Boolean","String","Date","RegExp","Blob","ImageData","FileList","ArrayBuffer","_decode","callbackId","withPromise","_rpcDecode","_genRemoteCallback","array","reduce","reshape","tensor","argNum","setTimeout","onDisconnect","_indices","_readyHandler","_busyHandler","readyHandler","busyHandler","_genId","shift","_releaseId","splice","pop","obj","_id","find","connectRPC","application","rpc","launchConnected","remote","export","onload","dispose","onLoad","whenConnected","WorkerGlobalScope","self","postMessage","window","dispatchEvent","CustomEvent","detail","connected","connectedHandlers","checkHandler","execute","code","requirements","toLowerCase","endsWith","importScripts","log","eval","content","message","stack","conn","close","h","_messageHandler","dedicated_thread","allow_execution","lang","api_version","addEventListener"],"mappings":"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","file":"imjoy-rpc-min-webworker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","export function randId() {\n  return Math.random()\n    .toString(36)\n    .substr(2, 10);\n}\n\nexport const dtypeToTypedArray = {\n  int8: \"Int8Array\",\n  int16: \"Int16Array\",\n  int32: \"Int32Array\",\n  uint8: \"Uint8Array\",\n  uint16: \"Uint16Array\",\n  uint32: \"Uint32Array\",\n  float32: \"Float32Array\",\n  float64: \"Float64Array\",\n  array: \"Array\"\n};\nexport const typedArrayToDtype = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\"\n};\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function(resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url\n    };\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n    const messageChannel = new MessageChannel();\n    messageChannel.port1.onmessage = function(event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [\n        messageChannel.port2\n      ]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nexport async function cacheRequirements(requirements) {\n  if (requirements && requirements.length > 0) {\n    for (let req of requirements) {\n      //remove prefix\n      if (req.startsWith(\"js:\")) req = req.slice(3);\n      if (req.startsWith(\"css:\")) req = req.slice(4);\n      if (req.startsWith(\"cache:\")) req = req.slice(6);\n      if (!req.startsWith(\"http\")) continue;\n\n      await cacheUrlInServiceWorker(req).catch(e => {\n        console.error(e);\n      });\n    }\n  }\n}\n\nexport function setupServiceWorker(targetOrigin, cacheCallback) {\n  // register service worker for offline access\n  if (\"serviceWorker\" in navigator) {\n    window.addEventListener(\"load\", function() {\n      navigator.serviceWorker.register(\"/plugin-service-worker.js\").then(\n        function(registration) {\n          // Registration was successful\n          console.log(\n            \"ServiceWorker registration successful with scope: \",\n            registration.scope\n          );\n        },\n        function(err) {\n          // registration failed :(\n          console.log(\"ServiceWorker registration failed: \", err);\n        }\n      );\n      targetOrigin = targetOrigin || \"*\";\n      cacheCallback = cacheCallback || cacheRequirements;\n      if (cacheCallback && typeof cacheCallback !== \"function\") {\n        throw new Error(\"config.cache_requirements must be a function\");\n      }\n      window.addEventListener(\"message\", function(e) {\n        if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n          const m = e.data;\n          if (m.type === \"cacheRequirements\") {\n            cacheCallback(m.requirements);\n          }\n        }\n      });\n    });\n  }\n}\n\n//#Source https://bit.ly/2neWfJ2\nexport function urlJoin(...args) {\n  return args\n    .join(\"/\")\n    .replace(/[\\/]+/g, \"/\")\n    .replace(/^(.+):\\//, \"$1://\")\n    .replace(/^file:/, \"file:/\")\n    .replace(/\\/(\\?|&|#[^!])/g, \"$1\")\n    .replace(/\\?/g, \"&\")\n    .replace(\"&\", \"?\");\n}\n","/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\nimport { randId, typedArrayToDtype } from \"./utils.js\";\n\nexport const API_VERSION = \"0.2.0\";\n\nconst ArrayBufferView = Object.getPrototypeOf(\n  Object.getPrototypeOf(new Uint8Array())\n).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction getKeyByValue(object, value) {\n  return Object.keys(object).find(key => object[key] === value);\n}\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\nexport class RPC {\n  constructor(connection, config) {\n    this._connection = connection;\n    this.config = config || {};\n    this._interface = {};\n    this._plugin_interfaces = {};\n    this._remote = null;\n    this._remoteUpdateHandler = function() {};\n    this._getInterfaceHandler = function() {};\n    this._interfaceSetAsRemoteHandler = null;\n    this._disconnectHandler = function() {};\n    this._store = new ReferenceStore();\n    this._method_refs = new ReferenceStore();\n    this._connection = connection;\n    let me = this;\n    this._connection.onMessage(function(data) {\n      me._processMessage(data);\n    });\n  }\n\n  /**\n   * Set a handler to be called when the remote site updates its\n   * interface\n   *\n   * @param {Function} handler\n   */\n  onRemoteUpdate(handler) {\n    this._remoteUpdateHandler = handler;\n  }\n\n  /**\n   * Set a handler to be called when received a responce from the\n   * remote site reporting that the previously provided interface\n   * has been successfully set as remote for that site\n   *\n   * @param {Function} handler\n   */\n\n  onRemoteReady(handler) {\n    this._method_refs.onReady(handler);\n  }\n\n  onRemoteBusy(handler) {\n    this._method_refs.onBusy(handler);\n  }\n\n  getRemoteCallStack() {\n    return this._method_refs.getStack();\n  }\n  /**\n   * Set a handler to be called when the remote site requests to\n   * (re)send the interface. Used to detect an initialzation\n   * completion without sending additional request, since in fact\n   * 'getInterface' request is only sent by application at the last\n   * step of the plugin initialization\n   *\n   * @param {Function} handler\n   */\n  onGetInterface(handler) {\n    this._getInterfaceHandler = handler;\n  }\n\n  /**\n   * @returns {Object} set of remote interface methods\n   */\n  getRemote() {\n    return this._remote;\n  }\n\n  /**\n   * Sets the interface of this site making it available to the\n   * remote site by sending a message with a set of methods names\n   *\n   * @param {Object} _interface to set\n   */\n  setInterface(_interface) {\n    if (this.config.forwarding_functions) {\n      for (let func_name of this.config.forwarding_functions) {\n        if (this._remote[func_name]) {\n          if (_interface.constructor === Object) {\n            if (!_interface[func_name]) {\n              _interface[func_name] = (...args) => {\n                this._remote[func_name](...args);\n              };\n            }\n          } else if (_interface.constructor.constructor === Function) {\n            if (!_interface.constructor.prototype[func_name]) {\n              _interface.constructor.prototype[func_name] = (...args) => {\n                this._remote[func_name](...args);\n              };\n            }\n          }\n        }\n      }\n    }\n    this._interface = _interface;\n  }\n\n  /**\n   * Sends the actual interface to the remote site upon it was\n   * updated or by a special request of the remote site\n   */\n  sendInterface() {\n    return new Promise(resolve => {\n      var names = [];\n      if (!this._interface) {\n        throw new Error(\"interface is not set.\");\n      }\n      if (this._interface.constructor === Object) {\n        for (var name of Object.keys(this._interface)) {\n          if (name.startsWith(\"_\")) continue;\n          if (typeof this._interface[name] === \"function\") {\n            names.push({ name: name, data: null, type: \"function\" });\n          } else {\n            var data = this._interface[name];\n            if (data !== null && typeof data === \"object\") {\n              var data2 = {};\n              for (var k of Object.keys(data)) {\n                if (typeof data[k] === \"function\") {\n                  data2[k] = \"rpc_method::\" + k;\n                } else {\n                  data2[k] = data[k];\n                }\n              }\n              names.push({ name: name, data: data2, type: \"object\" });\n            } else if (Object(data) !== data) {\n              names.push({ name: name, data: data, type: \"data\" });\n            }\n          }\n        }\n      }\n      // a class\n      else if (this._interface.constructor === Function) {\n        throw new Error(\"Please instantiate the class before exportting it.\");\n      }\n      // instance of a class\n      else if (this._interface.constructor.constructor === Function) {\n        var functions = Object.getOwnPropertyNames(\n          Object.getPrototypeOf(this._interface)\n        ).concat(Object.keys(this._interface));\n        for (var i = 0; i < functions.length; i++) {\n          var name_ = functions[i];\n          if (name_.startsWith(\"_\") || name_ === \"constructor\") continue;\n          if (typeof this._interface[name_] === \"function\") {\n            names.push({ name: name_, data: null });\n          }\n        }\n      } else {\n        throw Error(\"Unsupported interface type\");\n      }\n      this._interfaceSetAsRemoteHandler = resolve;\n      this._connection.send({ type: \"setInterface\", api: names });\n    });\n  }\n\n  /**\n   * Handles a message from the remote site\n   */\n  // var callback_reg = new RegExp(\"onupdate|run$\")\n  _processMessage(data) {\n    var resolve, reject, method, args, result;\n    switch (data.type) {\n      case \"method\":\n        var _interface = this._interface;\n        var _method_context = _interface.__this__ || _interface;\n        if (data.pid) {\n          _interface = this._plugin_interfaces[data.pid];\n          if (!_interface) {\n            if (data.promise) {\n              [resolve, reject] = this._unwrap(data.promise, false);\n              reject(\n                `plugin api function is not avaialbe in \"${data.pid}\", the plugin maybe terminated.`\n              );\n            } else {\n              console.error(\n                `plugin api function is not avaialbe in ${data.pid}, the plugin maybe terminated.`\n              );\n            }\n            return;\n          }\n        }\n        if (data.name.indexOf(\".\") !== -1) {\n          var names = data.name.split(\".\");\n          method = _interface[names[0]][names[1]];\n        } else {\n          method = _interface[data.name];\n        }\n        args = this._unwrap(data.args, true);\n        if (data.promise) {\n          [resolve, reject] = this._unwrap(data.promise, false);\n          try {\n            result = method.apply(_method_context, args);\n            if (\n              result instanceof Promise ||\n              (method.constructor &&\n                method.constructor.name === \"AsyncFunction\")\n            ) {\n              result.then(resolve).catch(reject);\n            } else {\n              resolve(result);\n            }\n          } catch (e) {\n            console.error(e, method);\n            reject(e);\n          }\n        } else {\n          try {\n            method.apply(_method_context, args);\n          } catch (e) {\n            console.error(e, method, args);\n          }\n        }\n\n        break;\n      case \"callback\":\n        if (data.promise) {\n          [resolve, reject] = this._unwrap(data.promise, false);\n          try {\n            method = this._store.fetch(data.num);\n            args = this._unwrap(data.args, true);\n            if (!method) {\n              throw \"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\";\n            }\n            result = method.apply(null, args);\n            if (\n              result instanceof Promise ||\n              (method.constructor &&\n                method.constructor.name === \"AsyncFunction\")\n            ) {\n              result.then(resolve).catch(reject);\n            } else {\n              resolve(result);\n            }\n          } catch (e) {\n            console.error(e, method);\n            reject(e);\n          }\n        } else {\n          try {\n            method = this._store.fetch(data.num);\n            args = this._unwrap(data.args, true);\n            if (!method) {\n              throw \"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\";\n            }\n            method.apply(null, args);\n          } catch (e) {\n            console.error(e, method, args);\n          }\n        }\n        break;\n      case \"setInterface\":\n        this._setRemote(data.api);\n        break;\n      case \"getInterface\":\n        this.sendInterface();\n        this._getInterfaceHandler();\n        break;\n      case \"interfaceSetAsRemote\":\n        if (typeof this._interfaceSetAsRemoteHandler === \"function\") {\n          this._interfaceSetAsRemoteHandler();\n          this._interfaceSetAsRemoteHandler === null;\n        }\n        break;\n      case \"disconnect\":\n        this._disconnectHandler();\n        this._connection.disconnect();\n        break;\n    }\n  }\n\n  /**\n   * Sends a requests to the remote site asking it to provide its\n   * current interface\n   */\n  requestRemote() {\n    this._connection.send({ type: \"getInterface\" });\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    var _dtype = typedArrayToDtype[typedArray.constructor.name];\n    if (dtype && dtype !== _dtype) {\n      throw \"dtype doesn't match the type of the array: \" +\n        _dtype +\n        \" != \" +\n        dtype;\n    }\n    shape = shape || [typedArray.length];\n    return {\n      __jailed_type__: \"ndarray\",\n      __value__: typedArray,\n      __shape__: shape,\n      __dtype__: _dtype\n    };\n  }\n\n  /**\n   * Sets the new remote interface provided by the other site\n   *\n   * @param {Array} names list of function names\n   */\n  _setRemote(api) {\n    this._remote = {};\n    var i, name, data, type;\n    for (i = 0; i < api.length; i++) {\n      name = api[i].name;\n      data = api[i].data;\n      type = api[i].type;\n      if (type === \"data\") {\n        this._remote[name] = data;\n      } else if (data) {\n        if (typeof data === \"object\") {\n          var data2 = {};\n          for (var key in data) {\n            if (data.hasOwnProperty(key)) {\n              if (data[key] === \"rpc_method::\" + key) {\n                data2[key] = this._genRemoteMethod(name + \".\" + key);\n              } else {\n                data2[key] = data[key];\n              }\n            }\n          }\n          this._remote[name] = data2;\n        } else {\n          this._remote[name] = data;\n        }\n      } else {\n        this._remote[name] = this._genRemoteMethod(name);\n      }\n    }\n\n    this._remoteUpdateHandler();\n    this._reportRemoteSet();\n  }\n\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * method. When the generated function is called, it will send the\n   * corresponding message to the remote site asking it to execute\n   * the particular method of its interface\n   *\n   * @param {String} name of the remote method\n   *\n   * @returns {Function} wrapped remote method\n   */\n  _genRemoteMethod(name, plugin_id) {\n    var me = this;\n    var remoteMethod = function() {\n      return new Promise((resolve, reject) => {\n        let id = null;\n        try {\n          id = me._method_refs.put(plugin_id ? plugin_id + \"/\" + name : name);\n          var wrapped_resolve = function() {\n            if (id !== null) me._method_refs.fetch(id);\n            return resolve.apply(this, arguments);\n          };\n          var wrapped_reject = function() {\n            if (id !== null) me._method_refs.fetch(id);\n            return reject.apply(this, arguments);\n          };\n\n          wrapped_resolve.__jailed_pairs__ = wrapped_reject;\n          wrapped_reject.__jailed_pairs__ = wrapped_resolve;\n\n          var args = Array.prototype.slice.call(arguments);\n          if (name === \"register\" || name === \"export\" || name === \"on\") {\n            args = me._wrap(args, true);\n          } else {\n            args = me._wrap(args);\n          }\n          var transferables = args.args.__transferables__;\n          if (transferables) delete args.args.__transferables__;\n          me._connection.send(\n            {\n              type: \"method\",\n              name: name,\n              pid: plugin_id,\n              args: args,\n              promise: me._wrap([wrapped_resolve, wrapped_reject])\n            },\n            transferables\n          );\n        } catch (e) {\n          if (id) me._method_refs.fetch(id);\n          reject(\n            `Failed to exectue remote method (plugin: ${plugin_id ||\n              me.id}, method: ${name}), error: ${e}`\n          );\n        }\n      });\n    };\n    remoteMethod.__remote_method = true;\n    return remoteMethod;\n  }\n\n  /**\n   * Sends a responce reporting that interface just provided by the\n   * remote site was successfully set by this site as remote\n   */\n  _reportRemoteSet() {\n    this._connection.send({ type: \"interfaceSetAsRemote\" });\n  }\n\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n\n  _encode_interface(aObject, bObject) {\n    var v, k;\n    const encoded_interface = {};\n    aObject[\"__id__\"] = aObject[\"__id__\"] || randId();\n    for (k in aObject) {\n      if (k === \"hasOwnProperty\") continue;\n      if (aObject.hasOwnProperty(k)) {\n        if (k.startsWith(\"_\")) {\n          continue;\n        }\n        v = aObject[k];\n\n        if (typeof v === \"function\") {\n          bObject[k] = {\n            __jailed_type__: \"plugin_interface\",\n            __plugin_id__: aObject[\"__id__\"],\n            __value__: k,\n            num: null\n          };\n          encoded_interface[k] = v;\n        } else if (Object(v) !== v) {\n          bObject[k] = { __jailed_type__: \"argument\", __value__: v };\n          encoded_interface[k] = v;\n        } else if (typeof v === \"object\") {\n          bObject[k] = Array.isArray(v) ? [] : {};\n          this._encode_interface(v, bObject[k]);\n        }\n      }\n    }\n    this._plugin_interfaces[aObject[\"__id__\"]] = encoded_interface;\n\n    if (aObject.on) {\n      aObject.on(\"close\", () => {\n        delete this._plugin_interfaces[aObject[\"__id__\"]];\n      });\n    }\n  }\n\n  _encode(aObject, as_interface) {\n    var transferables = [];\n    if (!aObject) {\n      return aObject;\n    }\n    var _transfer = aObject._transfer;\n    var bObject, v, k;\n    var isarray = Array.isArray(aObject);\n    bObject = isarray ? [] : {};\n    //skip if already encoded\n    if (\n      typeof aObject === \"object\" &&\n      aObject.__jailed_type__ &&\n      aObject.__value__\n    ) {\n      return aObject;\n    }\n\n    //encode interfaces\n    if (\n      typeof aObject === \"object\" &&\n      !Array.isArray(aObject) &&\n      (aObject.__as_interface__ || as_interface)\n    ) {\n      this._encode_interface(aObject, bObject);\n      return bObject;\n    }\n\n    if (as_interface) {\n      aObject[\"__id__\"] = aObject[\"__id__\"] || randId();\n      this._plugin_interfaces[aObject[\"__id__\"]] =\n        this._plugin_interfaces[aObject[\"__id__\"]] || {};\n    }\n    for (k in aObject) {\n      if (k === \"hasOwnProperty\") continue;\n      if (isarray || aObject.hasOwnProperty(k)) {\n        v = aObject[k];\n        if (typeof this._interface._rpcEncode === \"function\") {\n          const encoded_obj = this._interface._rpcEncode(v);\n          if (encoded_obj && encoded_obj.__rpc_dtype__) {\n            bObject[k] = {\n              __jailed_type__: \"custom_encoding\",\n              __value__: encoded_obj\n            };\n            continue;\n          }\n          // if the returned object does not contain __jailed_type__, assuming the object has been transformed\n          else {\n            v = encoded_obj;\n          }\n        }\n        if (typeof v === \"function\") {\n          if (as_interface) {\n            const encoded_interface = this._plugin_interfaces[\n              aObject[\"__id__\"]\n            ];\n            bObject[k] = {\n              __jailed_type__: \"plugin_interface\",\n              __plugin_id__: aObject[\"__id__\"],\n              __value__: k,\n              num: null\n            };\n            encoded_interface[k] = v;\n            continue;\n          }\n          let interfaceFuncName = null;\n          for (var name in this._interface) {\n            if (this._interface.hasOwnProperty(name)) {\n              if (name.startsWith(\"_\")) continue;\n              if (this._interface[name] === v) {\n                interfaceFuncName = name;\n                break;\n              }\n            }\n          }\n          // search for prototypes\n          var functions = Object.getOwnPropertyNames(\n            Object.getPrototypeOf(this._interface)\n          );\n          for (var i = 0; i < functions.length; i++) {\n            var name_ = functions[i];\n            if (name_.startsWith(\"_\")) continue;\n            if (this._interface[name_] === v) {\n              interfaceFuncName = name_;\n              break;\n            }\n          }\n          if (!interfaceFuncName) {\n            var id = this._store.put(v);\n            bObject[k] = {\n              __jailed_type__: \"callback\",\n              __value__: (v.constructor && v.constructor.name) || id,\n              num: id\n            };\n          } else {\n            bObject[k] = {\n              __jailed_type__: \"interface\",\n              __value__: interfaceFuncName,\n              num: null\n            };\n          }\n        } else if (\n          /*global tf*/\n          typeof tf !== \"undefined\" &&\n          tf.Tensor &&\n          v instanceof tf.Tensor\n        ) {\n          const v_buffer = v.dataSync();\n          if (v._transfer || _transfer) {\n            transferables.push(v_buffer.buffer);\n            delete v._transfer;\n          }\n          bObject[k] = {\n            __jailed_type__: \"ndarray\",\n            __value__: v_buffer,\n            __shape__: v.shape,\n            __dtype__: v.dtype\n          };\n        } else if (\n          /*global nj*/\n          typeof nj !== \"undefined\" &&\n          nj.NdArray &&\n          v instanceof nj.NdArray\n        ) {\n          var dtype = typedArrayToDtype[v.selection.data.constructor.name];\n          if (v._transfer || _transfer) {\n            transferables.push(v.selection.data.buffer);\n            delete v._transfer;\n          }\n          bObject[k] = {\n            __jailed_type__: \"ndarray\",\n            __value__: v.selection.data,\n            __shape__: v.shape,\n            __dtype__: dtype\n          };\n        } else if (v instanceof Error) {\n          console.error(v);\n          bObject[k] = { __jailed_type__: \"error\", __value__: v.toString() };\n        } else if (typeof File !== \"undefined\" && v instanceof File) {\n          bObject[k] = {\n            __jailed_type__: \"file\",\n            __value__: v,\n            __relative_path__: v.relativePath || v.webkitRelativePath\n          };\n        }\n        // send objects supported by structure clone algorithm\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n        else if (\n          v !== Object(v) ||\n          v instanceof Boolean ||\n          v instanceof String ||\n          v instanceof Date ||\n          v instanceof RegExp ||\n          v instanceof Blob ||\n          v instanceof ImageData ||\n          (typeof FileList !== \"undefined\" && v instanceof FileList)\n        ) {\n          bObject[k] = { __jailed_type__: \"argument\", __value__: v };\n        } else if (v instanceof ArrayBuffer) {\n          if (v._transfer || _transfer) {\n            transferables.push(v);\n            delete v._transfer;\n          }\n          bObject[k] = { __jailed_type__: \"argument\", __value__: v };\n        } else if (v instanceof ArrayBufferView) {\n          if (v._transfer || _transfer) {\n            transferables.push(v.buffer);\n            delete v._transfer;\n          }\n          bObject[k] = { __jailed_type__: \"argument\", __value__: v };\n        }\n        // TODO: support also Map and Set\n        // TODO: avoid object such as DynamicPlugin instance.\n        else if (v.__as_interface__) {\n          bObject[k] = this._encode(v, true);\n        } else if (typeof v === \"object\" || Array.isArray(v)) {\n          bObject[k] = this._encode(v, as_interface);\n          // move transferables to the top level object\n          if (bObject[k].__transferables__) {\n            for (var t = 0; t < bObject[k].__transferables__.length; t++) {\n              transferables.push(bObject[k].__transferables__[t]);\n            }\n            delete bObject[k].__transferables__;\n          }\n        } else if (typeof v === \"object\" && v.constructor) {\n          throw \"Unsupported data type for transferring between the plugin and the main app: \" +\n            k +\n            \" : \" +\n            v.constructor.name;\n        } else {\n          throw \"Unsupported data type for transferring between the plugin and the main app: \" +\n            k +\n            \",\" +\n            v;\n        }\n      }\n    }\n    if (transferables.length > 0) {\n      bObject.__transferables__ = transferables;\n    }\n    return bObject;\n  }\n\n  _decode(aObject, callbackId, withPromise) {\n    if (!aObject) {\n      return aObject;\n    }\n    var bObject, v, k;\n\n    if (\n      aObject.hasOwnProperty(\"__jailed_type__\") &&\n      aObject.hasOwnProperty(\"__value__\")\n    ) {\n      if (aObject.__jailed_type__.startsWith(\"custom_encoding\")) {\n        if (typeof this._interface._rpcDecode === \"function\") {\n          const decodedObj = this._interface._rpcDecode(aObject.__value__);\n          bObject = decodedObj;\n        } else {\n          bObject = aObject;\n        }\n      } else if (aObject.__jailed_type__ === \"callback\") {\n        bObject = this._genRemoteCallback(callbackId, aObject.num, withPromise);\n      } else if (aObject.__jailed_type__ === \"interface\") {\n        bObject =\n          this._remote[aObject.__value__] ||\n          this._genRemoteMethod(aObject.__value__);\n      } else if (aObject.__jailed_type__ === \"plugin_interface\") {\n        bObject = this._genRemoteMethod(\n          aObject.__value__,\n          aObject.__plugin_id__\n        );\n      } else if (aObject.__jailed_type__ === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (this.id === \"__plugin__\" && typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject.__value__)) {\n            aObject.__value__ = aObject.__value__.reduce(_appendBuffer);\n          }\n          bObject = nj\n            .array(aObject.__value__, aObject.__dtype__)\n            .reshape(aObject.__shape__);\n        } else if (\n          this.id === \"__plugin__\" &&\n          typeof tf !== \"undefined\" &&\n          tf.Tensor\n        ) {\n          if (Array.isArray(aObject.__value__)) {\n            aObject.__value__ = aObject.__value__.reduce(_appendBuffer);\n          }\n          bObject = tf.tensor(\n            aObject.__value__,\n            aObject.__shape__,\n            aObject.__dtype__\n          );\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject.__jailed_type__ === \"error\") {\n        bObject = new Error(aObject.__value__);\n      } else if (aObject.__jailed_type__ === \"file\") {\n        bObject = aObject.__value__;\n        //patch relativePath\n        bObject.relativePath = aObject.__relative_path__;\n      } else if (aObject.__jailed_type__ === \"argument\") {\n        bObject = aObject.__value__;\n      }\n      return bObject;\n    } else {\n      var isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n      for (k in aObject) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          v = aObject[k];\n          if (typeof v === \"object\" || Array.isArray(v)) {\n            bObject[k] = this._decode(v, callbackId, withPromise);\n          }\n        }\n      }\n      return bObject;\n    }\n  }\n\n  _wrap(args, as_interface) {\n    var wrapped = this._encode(args, as_interface);\n    var result = { args: wrapped };\n    return result;\n  }\n\n  /**\n   * Unwraps the set of arguments delivered from the remote site,\n   * replaces all callback identifiers with a function which will\n   * initiate sending that callback identifier back to other site\n   *\n   * @param {Object} args to unwrap\n   *\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Array} unwrapped args\n   */\n  _unwrap(args, withPromise) {\n    // var called = false;\n\n    // wraps each callback so that the only one could be called\n    // var once(cb) {\n    //     return function() {\n    //         if (!called) {\n    //             called = true;\n    //             return cb.apply(this, arguments);\n    //         } else {\n    //             var msg =\n    //               'A callback from this set has already been executed';\n    //             throw new Error(msg);\n    //         }\n    //     };\n    // }\n    var result = this._decode(args.args, args.callbackId, withPromise);\n    return result;\n  }\n\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * callback. When the generated function is called, it will send\n   * the corresponding message to the remote site asking it to\n   * execute the particular callback previously saved during a call\n   * by the remote site a method from the interface of this site\n   *\n   * @param {Number} id of the remote callback to execute\n   * @param {Number} argNum argument index of the callback\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Function} wrapped remote callback\n   */\n  _genRemoteCallback(id, argNum, withPromise) {\n    var me = this;\n    var remoteCallback;\n    if (withPromise) {\n      remoteCallback = function() {\n        return new Promise((resolve, reject) => {\n          var args = me._wrap(Array.prototype.slice.call(arguments));\n          var transferables = args.args.__transferables__;\n          if (transferables) delete args.args.__transferables__;\n          resolve.__jailed_pairs__ = reject;\n          reject.__jailed_pairs__ = resolve;\n          try {\n            me._connection.send(\n              {\n                type: \"callback\",\n                id: id,\n                num: argNum,\n                args: args,\n                // pid :  me.id,\n                promise: me._wrap([resolve, reject])\n              },\n              transferables\n            );\n          } catch (e) {\n            reject(\n              `Failed to exectue remote callback (id: ${id}, argNum: ${argNum}).`\n            );\n          }\n        });\n      };\n      return remoteCallback;\n    } else {\n      remoteCallback = function() {\n        var args = me._wrap(Array.prototype.slice.call(arguments));\n        var transferables = args.args.__transferables__;\n        if (transferables) delete args.args.__transferables__;\n        return me._connection.send(\n          {\n            type: \"callback\",\n            id: id,\n            num: argNum,\n            args: args\n            // pid :  me.id\n          },\n          transferables\n        );\n      };\n      return remoteCallback;\n    }\n  }\n\n  /**\n   * Sends the notification message and breaks the connection\n   */\n  disconnect() {\n    this._connection.send({ type: \"disconnect\" });\n    setTimeout(this._connection.disconnect, 2000);\n  }\n\n  /**\n   * Set a handler to be called when received a disconnect message\n   * from the remote site\n   *\n   * @param {Function} handler\n   */\n  onDisconnect(handler) {\n    this._disconnectHandler = handler;\n  }\n}\n\n/**\n * ReferenceStore is a special object which stores other objects\n * and provides the references (number) instead. This reference\n * may then be sent over a json-based communication channel (IPC\n * to another Node.js process or a message to the Worker). Other\n * site may then provide the reference in the responce message\n * implying the given object should be activated.\n *\n * Primary usage for the ReferenceStore is a storage for the\n * callbacks, which therefore makes it possible to initiate a\n * callback execution by the opposite site (which normally cannot\n * directly execute functions over the communication channel).\n *\n * Each stored object can only be fetched once and is not\n * available for the second time. Each stored object must be\n * fetched, since otherwise it will remain stored forever and\n * consume memory.\n *\n * Stored object indeces are simply the numbers, which are however\n * released along with the objects, and are later reused again (in\n * order to postpone the overflow, which should not likely happen,\n * but anyway).\n */\nclass ReferenceStore {\n  constructor() {\n    this._store = {}; // stored object\n    this._indices = [0]; // smallest available indices\n    this._readyHandler = function() {};\n    this._busyHandler = function() {};\n    this._readyHandler();\n  }\n\n  /**\n   * call handler when the store is empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n  onReady(readyHandler) {\n    this._readyHandler = readyHandler || function() {};\n  }\n\n  /**\n   * call handler when the store is not empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n  onBusy(busyHandler) {\n    this._busyHandler = busyHandler || function() {};\n  }\n\n  /**\n   * get the length of the store\n   *\n   */\n  getStack() {\n    return Object.keys(this._store).length;\n  }\n\n  /**\n   * @function _genId() generates the new reference id\n   *\n   * @returns {Number} smallest available id and reserves it\n   */\n  _genId() {\n    var id;\n    if (this._indices.length === 1) {\n      id = this._indices[0]++;\n    } else {\n      id = this._indices.shift();\n    }\n\n    return id;\n  }\n\n  /**\n   * Releases the given reference id so that it will be available by\n   * another object stored\n   *\n   * @param {Number} id to release\n   */\n  _releaseId(id) {\n    for (var i = 0; i < this._indices.length; i++) {\n      if (id < this._indices[i]) {\n        this._indices.splice(i, 0, id);\n        break;\n      }\n    }\n\n    // cleaning-up the sequence tail\n    for (i = this._indices.length - 1; i >= 0; i--) {\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\n        this._indices.pop();\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Stores the given object and returns the refernce id instead\n   *\n   * @param {Object} obj to store\n   *\n   * @returns {Number} reference id of the stored object\n   */\n  put(obj) {\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\n      this._busyHandler();\n    }\n    var id = this._genId();\n    this._store[id] = obj;\n    return id;\n  }\n\n  /**\n   * Retrieves previously stored object and releases its reference\n   *\n   * @param {Number} id of an object to retrieve\n   */\n  fetch(id) {\n    var obj = this._store[id];\n    if (obj && !obj.__remote_method) {\n      delete this._store[id];\n      this._releaseId(id);\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\n        this._readyHandler();\n      }\n    }\n    if (obj && obj.__jailed_pairs__) {\n      const _id = getKeyByValue(this._store, obj.__jailed_pairs__);\n      this.fetch(_id);\n    }\n    return obj;\n  }\n\n  /**\n   * Retrieves previously stored object\n   *\n   * @param {Number} id of an object to retrieve\n   */\n  // retrieve(id) {\n  //     var obj = this._store[id];\n  //     return obj;\n  // }\n}\n","/**\n * Core plugin script loaded into the plugin process/thread.\n *\n * Initializes the plugin-site API global methods.\n */\nimport { RPC } from \"./rpc.js\";\n\nexport function connectRPC(connection, config) {\n  const application = {};\n  config = config || {};\n\n  const rpc = new RPC(connection, config);\n  rpc.onGetInterface(function() {\n    launchConnected();\n  });\n\n  rpc.onRemoteUpdate(function() {\n    application.remote = rpc.getRemote();\n    if (!application.remote) return;\n    const api = application.remote || {};\n    if (api.export) {\n      console.error(\"WARNING: overwriting function 'export'.\");\n    }\n    if (api.onload) {\n      console.error(\"WARNING: overwriting function 'onload'.\");\n    }\n    if (api.dispose) {\n      console.error(\"WARNING: overwriting function 'dispose'.\");\n    }\n    api.export = application.setInterface;\n    api.onLoad = application.whenConnected;\n    api.dispose = application.disconnect;\n    if (\n      typeof WorkerGlobalScope !== \"undefined\" &&\n      self instanceof WorkerGlobalScope\n    ) {\n      self.api = api;\n      self.postMessage({\n        type: \"imjoy_remote_api_ready\"\n      });\n    } else if (typeof window) {\n      window.dispatchEvent(\n        new CustomEvent(\"imjoy_remote_api_ready\", { detail: api })\n      );\n    }\n  });\n\n  var connected = false;\n  var connectedHandlers = [];\n\n  var launchConnected = function() {\n    if (!connected) {\n      connected = true;\n\n      var handler;\n      while ((handler = connectedHandlers.pop())) {\n        handler();\n      }\n    }\n  };\n\n  var checkHandler = function(handler) {\n    var type = typeof handler;\n    if (type !== \"function\") {\n      var msg =\n        \"A function may only be subsribed to the event, \" +\n        type +\n        \" was provided instead\";\n      throw new Error(msg);\n    }\n\n    return handler;\n  };\n\n  /**\n   * Sets a function executed after the connection to the\n   * application is estaplished, and the initial interface-exchange\n   * messaging is completed\n   *\n   * @param {Function} handler to be called upon initialization\n   */\n  application.whenConnected = function(handler) {\n    handler = checkHandler(handler);\n    if (connected) {\n      handler();\n    } else {\n      connectedHandlers.push(handler);\n    }\n  };\n\n  /**\n   * Sets the plugin interface available to the application\n   *\n   * @param {Object} _interface to set\n   */\n  application.setInterface = function(_interface) {\n    rpc.setInterface(_interface);\n  };\n\n  /**\n   * Disconnects the plugin from the application (sending\n   * notification message) and destroys itself\n   */\n  application.disconnect = function(_interface) {\n    rpc.disconnect();\n  };\n}\n","/**\n * Contains the routines loaded by the plugin Worker under web-browser.\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\nimport { connectRPC } from \"./pluginCore.js\";\nimport { API_VERSION } from \"./rpc.js\";\n\n(function() {\n  // make sure this runs inside a webworker\n  if (\n    typeof WorkerGlobalScope === \"undefined\" ||\n    !self ||\n    !(self instanceof WorkerGlobalScope)\n  ) {\n    throw new Error(\"This script can only loaded in a webworker\");\n  }\n  /**\n   * Executes the given code in a jailed environment. For web\n   * implementation, we're already jailed in the iframe and the\n   * worker, so simply eval()\n   *\n   * @param {String} code code to execute\n   */\n  var execute = function(code) {\n    try {\n      if (code.type === \"requirements\") {\n        try {\n          if (\n            code.requirements &&\n            (Array.isArray(code.requirements) ||\n              typeof code.requirements === \"string\")\n          ) {\n            try {\n              if (!Array.isArray(code.requirements)) {\n                code.requirements = [code.requirements];\n              }\n              for (var i = 0; i < code.requirements.length; i++) {\n                if (\n                  code.requirements[i].toLowerCase().endsWith(\".css\") ||\n                  code.requirements[i].startsWith(\"css:\")\n                ) {\n                  throw \"unable to import css in a webworker\";\n                } else if (\n                  code.requirements[i].toLowerCase().endsWith(\".js\") ||\n                  code.requirements[i].startsWith(\"js:\")\n                ) {\n                  if (code.requirements[i].startsWith(\"js:\")) {\n                    code.requirements[i] = code.requirements[i].slice(3);\n                  }\n                  importScripts(code.requirements[i]);\n                } else if (code.requirements[i].startsWith(\"http\")) {\n                  importScripts(code.requirements[i]);\n                } else if (code.requirements[i].startsWith(\"cache:\")) {\n                  //ignore cache\n                } else {\n                  console.log(\n                    \"Unprocessed requirements url: \" + code.requirements[i]\n                  );\n                }\n              }\n            } catch (e) {\n              throw \"failed to import required scripts: \" +\n                code.requirements.toString();\n            }\n          }\n        } catch (e) {\n          throw e;\n        }\n      } else if (code.type === \"script\") {\n        try {\n          if (\n            code.requirements &&\n            (Array.isArray(code.requirements) ||\n              typeof code.requirements === \"string\")\n          ) {\n            try {\n              if (Array.isArray(code.requirements)) {\n                for (let i = 0; i < code.requirements.length; i++) {\n                  importScripts(code.requirements[i]);\n                }\n              } else {\n                importScripts(code.requirements);\n              }\n            } catch (e) {\n              throw \"failed to import required scripts: \" +\n                code.requirements.toString();\n            }\n          }\n          eval(code.content);\n        } catch (e) {\n          console.error(e.message, e.stack);\n          throw e;\n        }\n      } else {\n        throw \"unsupported code type.\";\n      }\n      self.postMessage({ type: \"executeSuccess\" });\n    } catch (e) {\n      console.error(\"failed to execute scripts: \", code, e);\n      self.postMessage({ type: \"executeFailure\", error: e.stack || String(e) });\n    }\n  };\n\n  /**\n   * Connection object provided to the RPC constructor,\n   * plugin site implementation for the web-based environment.\n   * Global will be then cleared to prevent exposure into the\n   * Worker, so we put this local connection object into a closure\n   */\n  const conn = {\n    disconnect: function() {\n      self.close();\n    },\n    send: function(data, transferables) {\n      data.__transferables__ = transferables;\n      self.postMessage(data, transferables);\n    },\n    onMessage: function(h) {\n      conn._messageHandler = h;\n    },\n    _messageHandler: function() {},\n    onDisconnect: function() {}\n  };\n\n  const config = {\n    type: \"web-worker\",\n    dedicated_thread: true,\n    allow_execution: true,\n    lang: \"javascript\",\n    api_version: API_VERSION\n  };\n\n  /**\n   * Event lisener for the plugin message\n   */\n  self.addEventListener(\"message\", function(e) {\n    const m = e.data;\n    switch (m && m.type) {\n      case \"getConfig\":\n        self.postMessage({\n          type: \"config\",\n          config: config\n        });\n        break;\n      case \"execute\":\n        execute(m.code);\n        if (m.code.type === \"requirements\") {\n          if (!Array.isArray(m.code.requirements)) {\n            m.code.requirements = [m.code.requirements];\n          }\n          self.postMessage({\n            type: \"cacheRequirements\",\n            requirements: m.code.requirements\n          });\n        }\n        break;\n      // for webworker only\n      case \"connectRPC\":\n        connectRPC(conn, m.config);\n        break;\n      default:\n        conn._messageHandler(m);\n    }\n  });\n  self.postMessage({\n    type: \"initialized\",\n    config: config\n  });\n})();\n"],"sourceRoot":""}